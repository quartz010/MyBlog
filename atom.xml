<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>R4y&#39;s Blog</title>
  
  <subtitle>个人回收站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.diglp.xyz/"/>
  <updated>2019-03-19T15:08:20.000Z</updated>
  <id>https://blog.diglp.xyz/</id>
  
  <author>
    <name>R4yd</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OpenFaaS 的部署</title>
    <link href="https://blog.diglp.xyz/2019/03/19/OP_OpenFaaS/"/>
    <id>https://blog.diglp.xyz/2019/03/19/OP_OpenFaaS/</id>
    <published>2019-03-18T16:00:00.000Z</published>
    <updated>2019-03-19T15:08:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>## </p><h2 id="前面的话"><a href="#前面的话" class="headerlink" title="前面的话"></a>前面的话</h2><p>本来说项目完结的转身离去，不过这样的一个平台带来的 <strong>从未体验过的全新感觉</strong> 实在是震惊呢。这一片再开新坑，来部署一个 <strong>serverless</strong> 思想的 OpenFaaS平台</p><blockquote><p>FaaS = Function as a Service</p></blockquote><p>这篇操作主要参考文章：</p><blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmFsZXhlbGxpcy5pby95b3VyLXNlcnZlcmxlc3MtcmFzcGJlcnJ5LXBpLWNsdXN0ZXIv" title="https://blog.alexellis.io/your-serverless-raspberry-pi-cluster/">Your Serverless Raspberry Pi cluster with Docker<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9saW51eC5jbi9hcnRpY2xlLTkwMDctMS5odG1s" title="https://linux.cn/article-9007-1.html">使用 Docker 构建你的 Serverless 树莓派集群<i class="fa fa-external-link"></i></span>（上文译版）</li><li><span class="exturl" data-url="aHR0cHM6Ly9qaW1teXNvbmcuaW8vcG9zdHMvb3BlbmZhYXMtcXVpY2stc3RhcnQv" title="https://jimmysong.io/posts/openfaas-quick-start/">OpenFaaS快速入门指南<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9qaW1teXNvbmcuaW8vcG9zdHMvd2hhdC1pcy1zZXJ2ZXJsZXNzLw==" title="https://jimmysong.io/posts/what-is-serverless/">什么是Serverless（无服务器）架构？<i class="fa fa-external-link"></i></span></li></ul></blockquote><p>部署过程使用一键安装脚本，感觉有点点惭愧，不过体验功能才是重点。不重复造轮子问题不大。这篇打算主要写，这个 OpenFaaS 的架构的组成，以及后面的基础使用。</p><h2 id="关于-OpenFaaS"><a href="#关于-OpenFaaS" class="headerlink" title="关于 OpenFaaS"></a>关于 OpenFaaS</h2><h3 id="什么是OpenFaaS"><a href="#什么是OpenFaaS" class="headerlink" title="什么是OpenFaaS"></a>什么是OpenFaaS</h3><p>和我们熟知的 <strong>IaaS，PaaS，SaaS</strong> 类似，这里指的是云的三大层次。如果不是很清楚可以看这个 ：</p><blockquote><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTcvMDcvaWFhcy1wYWFzLXNhYXMuaHRtbA==" title="http://www.ruanyifeng.com/blog/2017/07/iaas-paas-saas.html">IaaS，PaaS，SaaS 的区别 - ruanyf<i class="fa fa-external-link"></i></span></li></ul><p>今天大多数公司在开发应用程序并将其部署在服务器上的时候，无论是选择公有云还是私有的数据中心，都需要提前了解究竟需要多少台服务器、多大容量的存储和数据库的功能等。并需要部署运行应用程序和依赖的软件到基础设施之上。假设我们不想在这些细节上花费精力，是否有一种简单的架构模型能够满足我们这种想法？</p></blockquote><p>函数及服务，在这里是Serverless的一种实现，这里的 Serverless 可以简单的理解为，服务器的服务应用都被<strong>打包成了一个个独立的容器</strong>。这种情况下可以很容易的进行全自动的横向扩容。</p><blockquote><p>传统的服务器端软件不同是经应用程序部署到拥有操作系统的虚拟机或者容器中，一般需要长时间驻留在操作系统中运行，而FaaS是直接将程序部署上到平台上即可，当有事件到来时触发执行，执行完了就可以卸载掉。</p></blockquote><hr><p>就可以使用 类似于 <code>http://bgb0:8080/function/nslookup</code> 这样的URL来对容器服务产生一个请求，而不用再考虑后端的各种的体系和流程。</p><h2 id="OpenFaaS部署"><a href="#OpenFaaS部署" class="headerlink" title="OpenFaaS部署"></a>OpenFaaS部署</h2><h3 id="FaaS-服务部署"><a href="#FaaS-服务部署" class="headerlink" title="FaaS 服务部署"></a>FaaS 服务部署</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这里使用现有的项目一键部署</span></span><br><span class="line">git clone https://github.com/alexellis/faas/</span><br><span class="line">cd faas</span><br><span class="line">./deploy_stack.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 客户端安装 fssa-cli 用于构建</span></span><br><span class="line">curl -sSL cli.openfaas.com | sudo sh</span><br></pre></td></tr></table></figure><p>对于 OpenFaaS 的部署，上面有给出的一键部署的的脚本，在x86和Arm上都可以进行快速的部署。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@vm0:~# docker stack services func</span><br><span class="line">ID                  NAME                MODE                REPLICAS            IMAGE                                 PORTS</span><br><span class="line">joj44r8vpaf4        func_faas-swarm     replicated          1/1                 openfaas/faas-swarm:0.6.1-armhf       </span><br><span class="line">mjnrabl3d8sj        func_nats           replicated          1/1                 nats-streaming:0.11.2                 </span><br><span class="line">mo8klvy4id9n        func_queue-worker   replicated          1/1                 openfaas/queue-worker:0.6.0-armhf     </span><br><span class="line">phqan7977dgi        func_alertmanager   replicated          1/1                 functions/alertmanager:0.15.0-armhf   </span><br><span class="line">sjbxputi1xe8        func_prometheus     replicated          1/1                 functions/prometheus:2.7.0-armhf      *:9090-&gt;9090/tcp</span><br><span class="line">z6pc60t4b684        func_gateway        replicated          1/1                 openfaas/gateway:0.11.0-armhf         *:8080-&gt;8080/tcp</span><br></pre></td></tr></table></figure><p>在部署完成之后，可以看到有这些服务组成了这个 Stack</p><ul><li>func_gateway    管理 Function 的前端页面</li><li>func_prometheus    数据统计，以及告警的平台，用于检测服务状态来来实现系统扩容。</li></ul><h3 id="Grafana-监控部署"><a href="#Grafana-监控部署" class="headerlink" title="Grafana 监控部署"></a>Grafana 监控部署</h3><p>这里使用了prometheus作为数据收集和数据源和Grafana很好的兼容。直接可以作为Dashboard 的数据源。这里已经有了 FaaS 的模板的Json配置文件：</p><blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ncmFmYW5hLmNvbS9kYXNoYm9hcmRzLzM1MjY=" title="https://grafana.com/dashboards/3526">https://grafana.com/dashboards/3526<i class="fa fa-external-link"></i></span></li></ul></blockquote><p>在对Dashboard导入后，有统计调用频率，函数副本数，调用次数，调用比例。</p><h2 id="OpenFaaS-HelloWorld"><a href="#OpenFaaS-HelloWorld" class="headerlink" title="OpenFaaS.HelloWorld()"></a>OpenFaaS.HelloWorld()</h2><p>由于是 ARM 的平台，所以导致可以直接拿来使用的镜像不是很多。其自带的 <strong>nodeinfo</strong> 和 <strong>nslookup</strong> 。这里如果要实现一个hello world 需要自己去构建函数镜像。直接使用 <code>faas-cli</code> 先生成模板。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">faas-cli new --lang python hello-python</span><br></pre></td></tr></table></figure><p>然后回自动的构建一个python 的函数容器的模板：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">root@bgb0:~/functions# tree . -L 2</span><br><span class="line">.</span><br><span class="line">|-- hello-python</span><br><span class="line">|   |-- handler.py# 修改</span><br><span class="line">|   `-- requirements.txt</span><br><span class="line">|-- hello-python.yml# 修改</span><br><span class="line">|-- pass</span><br><span class="line">`-- template</span><br><span class="line">    |-- csharp</span><br><span class="line">    |-- csharp-armhf</span><br><span class="line">    |-- dockerfile</span><br><span class="line">    |-- go</span><br><span class="line">    |-- go-armhf</span><br><span class="line">    |-- java8</span><br><span class="line">    |-- node</span><br><span class="line">    |-- node-arm64</span><br><span class="line">    |-- node-armhf</span><br><span class="line">    |-- php7</span><br><span class="line">    |-- python</span><br><span class="line">    |-- python-armhf# 拷贝到上级</span><br><span class="line">    |-- python3</span><br><span class="line">    |-- python3-armhf</span><br><span class="line">    `-- ruby</span><br></pre></td></tr></table></figure><p>然后开始写接口，这里直接编辑 <code>handler.py</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(req)</span>:</span></span><br><span class="line">    <span class="string">"""handle a request to the function</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        req (str): request body</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">"Hello! This is a test: "</span> + req)</span><br><span class="line">    <span class="keyword">return</span> req</span><br></pre></td></tr></table></figure><p>修改之后，执行构建命令，有二十几个step。。。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">faas-cli build -f ./hello-python.yml</span><br></pre></td></tr></table></figure><blockquote><p>If you’re trying thing out on a single host, then you don’t need to push your images to a registry, they’ll just be used from the local Docker library.</p></blockquote><p>为了让其他的容器拉到镜像，这里需要 push 镜像上去。</p><h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2><p>今天变成 <code>高盐度低湿度常见水产品</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;## &lt;/p&gt;
&lt;h2 id=&quot;前面的话&quot;&gt;&lt;a href=&quot;#前面的话&quot; class=&quot;headerlink&quot; title=&quot;前面的话&quot;&gt;&lt;/a&gt;前面的话&lt;/h2&gt;&lt;p&gt;本来说项目完结的转身离去，不过这样的一个平台带来的 &lt;strong&gt;从未体验过的全新感觉&lt;/stron
      
    
    </summary>
    
      <category term="OP之路" scheme="https://blog.diglp.xyz/categories/OP%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Docker" scheme="https://blog.diglp.xyz/tags/Docker/"/>
    
      <category term="Swarm" scheme="https://blog.diglp.xyz/tags/Swarm/"/>
    
      <category term="kubernetes" scheme="https://blog.diglp.xyz/tags/kubernetes/"/>
    
      <category term="OpenFaaS" scheme="https://blog.diglp.xyz/tags/OpenFaaS/"/>
    
  </entry>
  
  <entry>
    <title>Docker的集群监控</title>
    <link href="https://blog.diglp.xyz/2019/03/17/OP_Cluster_Monitor/"/>
    <id>https://blog.diglp.xyz/2019/03/17/OP_Cluster_Monitor/</id>
    <published>2019-03-16T16:00:00.000Z</published>
    <updated>2019-03-18T12:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前面的话"><a href="#前面的话" class="headerlink" title="前面的话"></a>前面的话</h2><p>再一次被 Docker 所带来的革命性的变量所震撼。<strong>Build，ship and run</strong>。</p><p>想着给之前的搭建的集群加一个监控系统，主机性能监控，和服务日志监控(ES + Kibana + filebeat)。当然很有可能只是幻想了。因为单机性能实在是太过羸弱。 </p><p>正巧看到了网上的方案使用的是 ：</p><blockquote><p>cAdvisor(数据收集)+InfluxDB(数据存储)+Grafana(数据可视化)</p></blockquote><p>这样的方案。这里的主要参考文章链接：</p><blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JvdGxlZy9zd2FybS1tb25pdG9yaW5n" title="https://github.com/botleg/swarm-monitoring">Docker Swarm Monitoring<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RrZmFqc2xkZnNkZnNkL2FydGljbGUvZGV0YWlscy83OTk3NzY5Mw==" title="https://blog.csdn.net/dkfajsldfsdfsd/article/details/79977693">docker swarm集群监控方案cAdvisor+InfluxDB+Grafana实战<i class="fa fa-external-link"></i></span></li></ul></blockquote><h2 id="服务部署"><a href="#服务部署" class="headerlink" title="服务部署"></a>服务部署</h2><p>有了前面的折腾的经验，这里就到了一路绿灯的状态了。毕竟较之前有了更多的理解。这里直接使用 compose 进行结构化的部署：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.2'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  influx:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">influxdb</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="attr">      - influx:</span><span class="string">/var/lib/influxdb</span></span><br><span class="line"><span class="attr">    deploy:</span></span><br><span class="line"><span class="attr">      replicas:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">      placement:</span></span><br><span class="line"><span class="attr">        constraints:</span></span><br><span class="line">        <span class="comment"># 这里指定部署的角色，数据库放在manager上面</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">node.role</span> <span class="string">==</span> <span class="string">manager</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">  grafana:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">grafana/grafana</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line">    <span class="comment"># 端口映射</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">:3000:3000</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="attr">      - grafana:</span><span class="string">/var/lib/grafana</span></span><br><span class="line"><span class="attr">    depends_on:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">influx</span></span><br><span class="line"><span class="attr">    deploy:</span></span><br><span class="line"><span class="attr">      replicas:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">      placement:</span></span><br><span class="line"><span class="attr">        constraints:</span></span><br><span class="line">        <span class="comment"># 这里也是指定部署角色</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">node.role</span> <span class="string">==</span> <span class="string">manager</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">  cadvisor:</span></span><br><span class="line">  <span class="comment"># 这里需要使用 cadvisor 的ARM 的版本</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">budry/cadvisor-arm</span></span><br><span class="line">    <span class="comment"># 这里指定hostname 为节点名</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">'<span class="template-variable">&#123;&#123;.Node.Hostname&#125;&#125;</span>'</span></span><br><span class="line">    <span class="comment"># 配置参数（待会前面的frp可以学习一下）</span></span><br><span class="line"><span class="attr">    command:</span> <span class="bullet">-logtostderr</span> <span class="bullet">-docker_only</span> <span class="bullet">-storage_driver=influxdb</span> <span class="bullet">-storage_driver_db=cadvisor</span> <span class="bullet">-storage_driver_host=influx:8086</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line">    <span class="comment"># 这里需要对一些目录进行挂载，特别是 sys 以便获得系统信息</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/:/rootfs:ro</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/var/run:/var/run:rw</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/sys:/sys:ro</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/var/lib/docker/:/var/lib/docker:ro</span></span><br><span class="line"><span class="attr">    depends_on:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">influx</span></span><br><span class="line"><span class="attr">    deploy:</span></span><br><span class="line"><span class="attr">      mode:</span> <span class="string">global</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">  influx:</span></span><br><span class="line"><span class="attr">    driver:</span> <span class="string">local</span></span><br><span class="line"><span class="attr">  grafana:</span></span><br><span class="line"><span class="attr">    driver:</span> <span class="string">local</span></span><br></pre></td></tr></table></figure><p>上传 <code>yml</code> 文件，直接在 manager 节点进行部署：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull braingamer/cadvisor-arm</span><br><span class="line">docker pull grafana/grafana</span><br><span class="line">docker stack deploy -c monitor.yml monitor</span><br></pre></td></tr></table></figure><p>其实 这里会自动的拉镜像。(Docker 在大陆连通性不好)所以这里可能对部分镜像需要梯子。如果不出意外，理应是一路绿灯。</p><hr><p>上面的部署过程完成之后，后面需要在 InfluxDB 里面建立一个 cAdvisor 的库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec `docker ps | grep -i influx | awk '&#123;print $1&#125;'` influx -execute 'CREATE DATABASE cadvisor'</span><br></pre></td></tr></table></figure><p>容器内执行的命令。cAdviosr 的配置已经在部署的yml指定：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">command:</span> <span class="bullet">-logtostderr</span> <span class="bullet">-docker_only</span> <span class="bullet">-storage_driver=influxdb</span> <span class="bullet">-storage_driver_db=cadvisor</span> <span class="bullet">-storage_driver_host=influx:8086</span></span><br></pre></td></tr></table></figure><p>后面就是在 Grafana 里面对视图进行配置了，（默认账号密码：admin），在项目里面有示例的 dashboard的配置，这里直接 Copy-paste 就好</p><blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JvdGxlZy9zd2FybS1tb25pdG9yaW5n" title="https://github.com/botleg/swarm-monitoring">swarm-monitoring<i class="fa fa-external-link"></i></span>/<strong><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JvdGxlZy9zd2FybS1tb25pdG9yaW5nL2Jsb2IvbWFzdGVyL2Rhc2hib2FyZC5qc29u" title="https://github.com/botleg/swarm-monitoring/blob/master/dashboard.json">dashboard.json<i class="fa fa-external-link"></i></span></strong></li></ul></blockquote><hr><p>这里有个坑，需要修改这个配置文件里面的数据源。由 <code>influx</code> 改为 <code>InfluxDB</code>。</p><hr><p>这里的数据源直接可以修改为 <code>http://influx:8086</code> 便可以直接进行连接。</p><p>至此配置完成，直接访问 主机的3000 端口即可，看见高大上的 Grafana的界面了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@vm0:~# docker service ls</span><br><span class="line">ID                  NAME                MODE                REPLICAS            IMAGE                        PORTS</span><br><span class="line">0m4tl8b6huw9        monitor_cadvisor    global              5/5                 budry/cadvisor-arm:latest    </span><br><span class="line">ixftiydc1v8k        monitor_grafana     replicated          1/1                 grafana/grafana:latest       *:3000-&gt;3000/tcp</span><br><span class="line">78f3ryphvjc6        monitor_influx      replicated          1/1                 influxdb:latest</span><br></pre></td></tr></table></figure><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><p>Docker 的项目和工程至此就结束了，后面开始 Golang 的学习了，加油呢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前面的话&quot;&gt;&lt;a href=&quot;#前面的话&quot; class=&quot;headerlink&quot; title=&quot;前面的话&quot;&gt;&lt;/a&gt;前面的话&lt;/h2&gt;&lt;p&gt;再一次被 Docker 所带来的革命性的变量所震撼。&lt;strong&gt;Build，ship and run&lt;/strong&gt;。
      
    
    </summary>
    
      <category term="OP之路" scheme="https://blog.diglp.xyz/categories/OP%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="monitor" scheme="https://blog.diglp.xyz/tags/monitor/"/>
    
      <category term="Docker" scheme="https://blog.diglp.xyz/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>收工-关于Swarm的总结</title>
    <link href="https://blog.diglp.xyz/2019/03/14/OP_Swarm_Sumup/"/>
    <id>https://blog.diglp.xyz/2019/03/14/OP_Swarm_Sumup/</id>
    <published>2019-03-13T16:00:00.000Z</published>
    <updated>2019-03-18T05:08:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前面的话"><a href="#前面的话" class="headerlink" title="前面的话"></a>前面的话</h2><p>这篇算是这段时间的对 Docker 的集群项目的一个总结，想写点什么不过发现前面都零零星星写的差不多了，所以这篇就水水的把期间遇到的有指导性的文章进行一次收集吧。</p><blockquote><p>发现了没，浏览器的标签不是收敛的。</p></blockquote><h2 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h2><p>这里收集了一些优秀且有参考意义的文章，总是舍不得关掉的那种。</p><blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZnVuZGVidWcvcC82ODIzODk3Lmh0bWw=" title="https://www.cnblogs.com/fundebug/p/6823897.html">生产环境中使用Docker Swarm的一些建议 – Fundebug博客 <i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20va2V2aW5ncmFjZS9wLzY4NzAzNTkuaHRtbA==" title="https://www.cnblogs.com/kevingrace/p/6870359.html">Docker管理工具-Swarm部署记录<i class="fa fa-external-link"></i></span> 很棒的一個博客站，長期學習</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucGJldGEubWUvZG9ja2VyLXZvbHVtZS1taWdyYXRlLw==" title="https://www.pbeta.me/docker-volume-migrate/">Docker volume 跨服务器迁移 – way to go<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucGJldGEubWUva2lsbC14bXJpZy8=" title="https://www.pbeta.me/kill-xmrig/">服务器清除 xmrig 后门程序记录 – way to go<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucGJldGEubWUvZG9ja2VyLWxubXAv" title="https://www.pbeta.me/docker-lnmp/">Docker 搭建 Nginx+MySQL+ PHP (LNMP)基础环境 – way to go<i class="fa fa-external-link"></i></span> 很棒的文章，干货实用。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5haWRhbnN1LmNvbS8yMDE3L2RvY2tlci1jb250YWluZXJzLXNlcnZpY2VzLw==" title="http://www.aidansu.com/2017/docker-containers-services/">Docker 镜像、容器与服务<i class="fa fa-external-link"></i></span> 一個實例，簡潔明瞭的構建自己的一個鏡像</li></ul><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYm9va3N0YWNrLmNuL2Jvb2tzL2RvY2tlci1zd2FybS1ndWlkZXM=" title="https://www.bookstack.cn/books/docker-swarm-guides">Docker Swarm 深入浅出<i class="fa fa-external-link"></i></span>  很好的一本書</li><li><span class="exturl" data-url="aHR0cHM6Ly95ZWFzeS5naXRib29rcy5pby9kb2NrZXJfcHJhY3RpY2Uv" title="https://yeasy.gitbooks.io/docker_practice/">Docker — 从入门到实践<i class="fa fa-external-link"></i></span> </li></ul><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLm1hbGx1eC5tZS8yMDE3LzAzLzE5L2NvbnN1bC8=" title="https://blog.mallux.me/2017/03/19/consul/">Consul 与 Registrator <i class="fa fa-external-link"></i></span>怕自己弄丢的好文章</li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLm1hbGx1eC5tZS8yMDE3LzAzLzExL21mcy8=" title="https://blog.mallux.me/2017/03/11/mfs/">02 - Moosefs 分布式文件系统<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLm1hbGx1eC5tZS8yMDE3LzAyLzIyL3RyYWVmaWsv" title="https://blog.mallux.me/2017/02/22/traefik/">Traefik 微服务代理<i class="fa fa-external-link"></i></span></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前面的话&quot;&gt;&lt;a href=&quot;#前面的话&quot; class=&quot;headerlink&quot; title=&quot;前面的话&quot;&gt;&lt;/a&gt;前面的话&lt;/h2&gt;&lt;p&gt;这篇算是这段时间的对 Docker 的集群项目的一个总结，想写点什么不过发现前面都零零星星写的差不多了，所以这篇就水水的把期
      
    
    </summary>
    
      <category term="OP之路" scheme="https://blog.diglp.xyz/categories/OP%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Docker" scheme="https://blog.diglp.xyz/tags/Docker/"/>
    
      <category term="Swarm" scheme="https://blog.diglp.xyz/tags/Swarm/"/>
    
  </entry>
  
  <entry>
    <title>从Service到Stack</title>
    <link href="https://blog.diglp.xyz/2019/03/14/OP_Swarm_Stack/"/>
    <id>https://blog.diglp.xyz/2019/03/14/OP_Swarm_Stack/</id>
    <published>2019-03-13T16:00:00.000Z</published>
    <updated>2019-03-16T06:29:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>本来想着集群稳定呢，结果早上六点docker 的网络就突然挂了。默认网关除了问题，ping 外网不可达。导致远程主机域名无法解析，<code>8.8.4.4:53</code> 不可达，整体服务不可用。</p><p>这篇，接着上面的内容，实现 frp 和 Nignx 的服务的Stack 化。前面遇到的问题，后面在找个整体的时间进行解决吧。</p><h2 id="架构描述-以及-Compose实现"><a href="#架构描述-以及-Compose实现" class="headerlink" title="架构描述 以及 Compose实现"></a>架构描述 以及 Compose实现</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>这里主要是使用 frp 和 Nginx ，前者用于穿透，后者进行页面的反代。所以这里的就是两层的服务。应该还有一级提供负载均衡的server，不过Swarm 的本身已经提供了 VIP 以及负载均衡的功能。 </p><h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker-Compose"></a>Docker-Compose</h3><p>docker-compose 是用来做docker 的多容器控制，可以通过一个描述文件，来对服务，或者容器，进行整体的搭建，大大简化了操作流程以及可维护和可拓展性。这里的内容参考了网上的例子，进行了简单的修改。实现了前面所描述的架构。</p><p>具体的 <code>.yml</code> 文件如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.2"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  nginx:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"80"</span><span class="comment"># 对外暴露端口</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="attr">      - nginx_conf:</span><span class="string">/etc/nginx</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">backend</span></span><br><span class="line"><span class="attr">    deploy:</span></span><br><span class="line"><span class="attr">      replicas:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">      update_config:</span></span><br><span class="line"><span class="attr">        parallelism:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">        delay:</span> <span class="number">10</span><span class="string">s</span></span><br><span class="line"><span class="attr">      restart_policy:</span></span><br><span class="line"><span class="attr">        condition:</span> <span class="string">on-failure</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">  frp:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">xddxdd/frpc:arm32v7</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">backend</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="attr">     - frpc_ini:</span><span class="string">/frp</span></span><br><span class="line"><span class="attr">    deploy:</span></span><br><span class="line"><span class="attr">      replicas:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">      update_config:</span></span><br><span class="line"><span class="attr">        parallelism:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">        delay:</span> <span class="number">10</span><span class="string">s</span></span><br><span class="line"><span class="attr">      restart_policy:</span></span><br><span class="line"><span class="attr">        condition:</span> <span class="string">on-failure</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">  backend:</span></span><br><span class="line"><span class="comment"># 这里是应该建立的卷</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">  nginx_conf:</span> </span><br><span class="line"><span class="attr">    driver_opts:</span></span><br><span class="line"><span class="attr">      type:</span> <span class="string">"nfs4"</span></span><br><span class="line"><span class="attr">      o:</span> <span class="string">"addr=192.168.1.130,nolock,soft,rw"</span></span><br><span class="line"><span class="attr">      device:</span> <span class="string">":/srv/nfs/nginx/conf"</span></span><br><span class="line"><span class="attr">  frpc_ini:</span> </span><br><span class="line"><span class="attr">    driver_opts:</span>  </span><br><span class="line"><span class="attr">      type:</span> <span class="string">"nfs4"</span></span><br><span class="line"><span class="attr">      o:</span> <span class="string">"addr=192.168.1.130,nolock,soft,rw"</span></span><br><span class="line"><span class="attr">      device:</span> <span class="string">":/srv/nfs/frpc"</span></span><br></pre></td></tr></table></figure><p>一个好消息：在这种配置的情况下比较奇迹的是可以进行 <strong>NFS 的自动挂载</strong>了。解决了前面一个很大的问题。也不清楚是之前的BUG 还是什么情况。</p><blockquote><p>Compose下面使用nfs : <span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDUyODI2MDgvaG93LXRvLWRpcmVjdGx5LW1vdW50LW5mcy1zaGFyZS12b2x1bWUtaW4tY29udGFpbmVyLXVzaW5nLWRvY2tlci1jb21wb3NlLXYz" title="https://stackoverflow.com/questions/45282608/how-to-directly-mount-nfs-share-volume-in-container-using-docker-compose-v3">How to directly mount NFS share/volume in container using docker compose v3<i class="fa fa-external-link"></i></span></p></blockquote><hr><p>这里<strong>有一个坑</strong>。在Portainer 上面直接进行 Stack 部署的话，会有报错，说是平台不支持，但是的确是拉的arm的。报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">State Messagepending task scheduling</span><br><span class="line">Error messageno suitable node (unsupported platform on 3 nodes; 1 node not available for new tasks)</span><br></pre></td></tr></table></figure><p>查证之后，得到以下的回答</p><blockquote><p>参考链接 =  <span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDg5NjIzOTkvbm8tc3VpdGFibGUtbm9kZS11bmFibGUtdG8tZGVwbG95LWltYWdlLXVzaW5nLWRvY2tlci1zZXJ2aWNl" title="https://stackoverflow.com/questions/48962399/no-suitable-node-unable-to-deploy-image-using-docker-service">no suitable node - unable to deploy image using docker service<i class="fa fa-external-link"></i></span></p></blockquote><p>在命令行里进行创建，带一个 <code>--resolve-image never</code> 的参数，这样可以解决报错：<strong>镜像平台不支持的问题</strong> 但前提是，镜像的架构必须相同。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack deploy --compose-file str.yml --resolve-image never home</span><br></pre></td></tr></table></figure><p>这里有一个 Issue ,在进行 nfs 的挂载部分,可能会出现  ,<code>chmod</code> 的permission deny,试着以下命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+x /srv/nfs -R</span><br></pre></td></tr></table></figure><h2 id="项目细节"><a href="#项目细节" class="headerlink" title="项目细节"></a>项目细节</h2><p>这里需要解决的问题，就是网络的问题。在前面的方法里面是直接把端口暴露在了 HOST 上面，这样占用主机资源显然是不符合<strong>容器化的思想</strong>。这里就使用Docker 的强大的网络功能，来实现一个真正的服务。swarm 的服务网络其自动带有了 负载均衡 以及 <strong>VIP</strong>。所以，这里实现目标就是 FRP 到 VIP的映射</p><h3 id="Stack的内部网络"><a href="#Stack的内部网络" class="headerlink" title="Stack的内部网络"></a>Stack的内部网络</h3><p>Swarm 的自建 Layout 网络默认的是VIP模式，可以inspect服务得到服务所在网络的VIP。这个服务，跑了 Nginx 镜像的多个副本。这些副本共用一个 VIP。实现了负载均衡以及高可用，当单容器挂了之后，自动的进行 IP 的漂移。</p><p>获取 service 的VIP 如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker service  inspect nginxs</span><br><span class="line"></span><br><span class="line">"Endpoint": &#123;</span><br><span class="line">"Spec": &#123;</span><br><span class="line">"Mode": "vip"</span><br><span class="line">&#125;,</span><br><span class="line">"VirtualIPs": [</span><br><span class="line">        &#123;</span><br><span class="line">            "NetworkID": "ktsw8uaob2n0ppsh93p5upils",</span><br><span class="line">            "Addr": "10.0.14.9/24"</span><br><span class="line">        &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于前面已经配置了，这个 Stack ，两个服务是在同一个子网（backend）中。所以 ，frp服务是和nginx 的网络是联通的。所以可以直接访问 其VIP。由于，好像使用stack了NFS 的问题自动解决了。这里直接修改主机上的配置文件即可。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@bgb0:/tmp# cat /srv/nfs/frpc/frpc.ini </span><br><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = ****.****.xyz </span><br><span class="line"><span class="attr">server_port</span> = ****</span><br><span class="line"><span class="attr">token</span> = myfrptest</span><br><span class="line"><span class="section">[web_swarm]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">10.0</span>.<span class="number">14.9</span># 这里是 Nginx服务的VIP</span><br><span class="line"><span class="attr">local_port</span> = <span class="number">443</span></span><br><span class="line"><span class="attr">remote_port</span> = ****</span><br></pre></td></tr></table></figure><p>之后，更新该服务，重新加载配置。发现外网服务可达，已实现目标功能。开心</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC82MGJjY2JkYjZhZjk=" title="https://www.jianshu.com/p/60bccbdb6af9">Docker Swarm 入门：Service Network 管理<i class="fa fa-external-link"></i></span> 通过这篇，对网络有了基本了解 （小姐姐好看）</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9kYmE5MzQyMDcxZDg=" title="https://www.jianshu.com/p/dba9342071d8">Docker Swarm 服务发现和负载均衡原理<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5odWlsb2cuY29tLz9wPTEwMzg=" title="http://www.huilog.com/?p=1038">docker swarm 集群及多主机overlay网络测试<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLjUxY3RvLmNvbS9nYW5iaW5nLzIwOTEyOTI=" title="https://blog.51cto.com/ganbing/2091292">“三剑客”之Swarm应用数据持久化管理（volume 、bind 、 nfs）<i class="fa fa-external-link"></i></span></li></ul></blockquote><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><p>构思基本已经实现了，一个基于容器技术的服务部署。后面，想着对系统的整体的日志监控，依旧使用前面的ELK。完成之后，算是项目收工，后面开始Golang了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;本来想着集群稳定呢，结果早上六点docker 的网络就突然挂了。默认网关除了问题，ping 外网不可达。导致远程主机域名无法解析，&lt;code&gt;8.8
      
    
    </summary>
    
      <category term="OP之路" scheme="https://blog.diglp.xyz/categories/OP%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Docker" scheme="https://blog.diglp.xyz/tags/Docker/"/>
    
      <category term="Swarm" scheme="https://blog.diglp.xyz/tags/Swarm/"/>
    
      <category term="Nginx" scheme="https://blog.diglp.xyz/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 的 Swarm 化</title>
    <link href="https://blog.diglp.xyz/2019/03/13/OP_Swarm_nginx/"/>
    <id>https://blog.diglp.xyz/2019/03/13/OP_Swarm_nginx/</id>
    <published>2019-03-12T16:00:00.000Z</published>
    <updated>2019-03-16T06:25:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>这个题目可能显得比较不严谨，但是也想不到什么好的名字。这篇主要就是实现，在一个 Swarm 集群里面的 Nginx 的服务部署。且实现可以很快的进行 文件变更以及配置变更的统一提交。</p><p>这里至于之前的对于Swarm 的服务功能的测试不同了，更加偏向应用。再往后一部分，<strong>将会使用stack</strong> 来实现一个真正可用的服务架构。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>使用Swarm 很容易的实现了一个服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">--replicas 2 \# 两个副本（一共）</span><br><span class="line">--network ngx_net \ # 虚拟网络</span><br><span class="line">--name my-test \# 服务名</span><br><span class="line">-p 80:80 nginx# 端口映射（本地到容器）</span><br></pre></td></tr></table></figure><p>但是实际上要对这些服务进行以下内容的变更，就需要挂载<strong>外部卷</strong>了。</p><h3 id="外部卷的挂载"><a href="#外部卷的挂载" class="headerlink" title="外部卷的挂载"></a>外部卷的挂载</h3><p>在创建服务的时候，可以使用以下，命令进行 一个数据卷的创建，以及挂载。而且在服务被创建的时候，这些容器会被拷贝到多个节点上去，命令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个挂载卷</span><br><span class="line">docker volume create --name myvolume</span><br><span class="line"># 在容器内挂载卷</span><br><span class="line">docker service create \</span><br><span class="line">--replicas 2 \</span><br><span class="line">--network ngx_net \</span><br><span class="line">--mount type=volume,src=myvolume,dst=/wangshibo \</span><br><span class="line">--name test-nginx nginx</span><br></pre></td></tr></table></figure><p>但是问题来了，如果部署完成之后，对配置文件进行变更，这文件并不会同步到每个节点上。这里打算使用 NFS 进行部署</p><h3 id="NFS-的部署"><a href="#NFS-的部署" class="headerlink" title="NFS 的部署"></a>NFS 的部署</h3><p>为了实现多节点的配置文件的同步，以及数据卷的统一管理，这里就直接使用NFS</p><p>使用 apt 直接进行服务的安装 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install nfs-common # 这个在所有节点进行安装</span><br><span class="line">apt-get install nfs-kernel-server# 这里是NFS的服务，安装在服务节点上</span><br></pre></td></tr></table></figure><p>配置共享目录 <code>/etc/exports</code> ，添加新行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/srv/nfs/  bgb1(rw,sync)  bgb2(rw,sync)  bgb3(rw,sync)</span><br></pre></td></tr></table></figure><p>重启服务端的nfs服务，并且尝试挂载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> service nfs-kernel-server start</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> b 主机上进行挂载</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> mount bgb0:/srv/nfs /mnt/</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> chmod a+x /srv/nfs -R</span></span><br></pre></td></tr></table></figure><hr><p>测试完成，NFS 部署完成。</p><h3 id="NFS-共享卷挂载"><a href="#NFS-共享卷挂载" class="headerlink" title="NFS 共享卷挂载"></a>NFS 共享卷挂载</h3><p>为了实现多个节点之间的文件共享。<strong>这里遇到了很坑的问题，不知道是自己的理解问题还是BUG什么，具体症状是 NFS卷 不进行自动的挂载</strong>。</p><p>新建一个NFS的卷，下面命令进行参数修改即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker volume create --driver local \</span><br><span class="line">--opt type=nfs4 \</span><br><span class="line">--opt o=addr=&lt;NFS-Server&gt;,rw \</span><br><span class="line">--opt device=:&lt;Shared-Path&gt; \</span><br><span class="line">share</span><br></pre></td></tr></table></figure><hr><p>由于上面的问题折腾了很久的时间，只好暂时使用手动进行挂载，后面再进行逐步的研究。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mount bgb0:/srv/nfs /var/lib/docker/volumes/share/_data</span><br><span class="line"><span class="meta">#</span><span class="bash"> 用作页面 /usr/share/nginx/html/</span></span><br><span class="line">mount bgb0:/srv/nfs/nginx/html /var/lib/docker/volumes/Nginx_html/_data</span><br><span class="line"><span class="meta">#</span><span class="bash"> 用作配置 /etc/nginx/</span></span><br><span class="line">mount bgb0:/srv/nfs/nginx/conf /var/lib/docker/volumes/Nginx_conf/_data</span><br></pre></td></tr></table></figure><p>和第一部分的创建服务一样，这里直接使用Portainer来进行创建各个节点的卷，<strong>然后手动执行上面的命令，进行NFS的挂载，没有美感</strong></p><p>（应该又是一个 BUG ，在创建服务的时候初始配置，如果直接使用了当前的卷，其默认的的是新建新的卷。而不是对原有的卷来进行拷贝，这点待会可能去提个 Issue 。）<strong>需要在服务创建之后，后面进行第二次的挂载，才能正确的挂载 nginx_html 这个卷</strong></p><p>当全部进行手动挂载之后，所有的配置文件都可可以从NFS主机处获取。实现配置的统一管理</p><hr><p>记得映射 <strong>80 和 443</strong> 完成主机功能配置。</p><h3 id="Nginx-配置"><a href="#Nginx-配置" class="headerlink" title="Nginx 配置"></a>Nginx 配置</h3><p>当前面的基于 NFS 的共享配置完成之后，可以直接对之前的配置进行平行迁移即可，（copy-paste）。</p><p>完成配置文件的迁移之后，可以直接在终端里面进行平滑升级。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service update WebTest</span><br></pre></td></tr></table></figure><h3 id="frpc-的部署"><a href="#frpc-的部署" class="headerlink" title="frpc 的部署"></a>frpc 的部署</h3><p>这里这里可以直接在 DockerHub上面找到相应的镜像，前面还以为没有，打算自己写 Dockerfile的，现在既然遇上了就直接使用了。</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9yL3hkZHhkZC9mcnBjL3RhZ3M=" title="https://hub.docker.com/r/xddxdd/frpc/tags">xddxdd/frpc<i class="fa fa-external-link"></i></span> 这个是 frpc 的image ，里面刚好有 armv7 的版本 。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">entry point/usr/bin/frpc</span><br><span class="line">working Dir/frp</span><br></pre></td></tr></table></figure><p>这里，直接 bind 绑定 host 的目录，到容器内部</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--mount type=bind,src=/conf,dst=/frp</span><br></pre></td></tr></table></figure><p>主机目录配置文件 <code>frpc.ini</code> ，其配内容如下</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = *******</span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">token</span> = *******</span><br><span class="line"></span><br><span class="line"><span class="section">[web_swarm]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">192.168</span>.***.***</span><br><span class="line"><span class="attr">local_port</span> = <span class="number">443</span></span><br><span class="line"><span class="attr">remote_port</span> = ******</span><br></pre></td></tr></table></figure><p>之后直接对容器进行重启即可。</p><h3 id="后"><a href="#后" class="headerlink" title="后"></a>后</h3><p>这里是在云服务器上使用 Nginx 做一个 upstream ， 具体的细节前面有讲 不在赘述。至此功能测试完毕。</p><h2 id="续"><a href="#续" class="headerlink" title="续"></a>续</h2><p>后面将会使用 Stack 和 network 功能， 实现结构的整体部署。还得解决 NFS 的不自动挂载的问题</p><blockquote><p>是不是每个人年轻的时候都有这样一段日子，鸿鹄志高却难遂，迷茫地过着，昏昏噩噩地耗，最终不是妥协泯然众人，就是找不到出口被生活围困。这时候家人朋友，看在眼里，哪怕不说，心里想的也是“小镇青年何必心怀远方”这样的想法吧。（J·M·库切《青春》）</p></blockquote><p>### </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;这个题目可能显得比较不严谨，但是也想不到什么好的名字。这篇主要就是实现，在一个 Swarm 集群里面的 Nginx 的服务部署。且实现可以很快的进行
      
    
    </summary>
    
      <category term="OP之路" scheme="https://blog.diglp.xyz/categories/OP%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Docker" scheme="https://blog.diglp.xyz/tags/Docker/"/>
    
      <category term="Swarm" scheme="https://blog.diglp.xyz/tags/Swarm/"/>
    
      <category term="Nginx" scheme="https://blog.diglp.xyz/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Swarm的服务</title>
    <link href="https://blog.diglp.xyz/2019/03/12/OP_Swarm_%E9%9B%86%E7%BE%A4%E4%BD%BF%E7%94%A8/"/>
    <id>https://blog.diglp.xyz/2019/03/12/OP_Swarm_集群使用/</id>
    <published>2019-03-11T16:00:00.000Z</published>
    <updated>2019-03-12T14:22:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前面的话"><a href="#前面的话" class="headerlink" title="前面的话"></a>前面的话</h2><p>上一篇简单快速的进行swarm集群的部署，这可以开始使用了。这里试着部署一个 Nginx 的服务，并且一步步实现前面的高可用的服务架构。</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9fL25naW54" title="https://hub.docker.com/_/nginx">Nginx image 地址<i class="fa fa-external-link"></i></span></p></blockquote><p>这里推荐一个博客：</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20va2V2aW5ncmFjZS8=" title="https://www.cnblogs.com/kevingrace/">散尽浮华 - 安寻安放，不卑不亢；重剑无锋，大巧不工！<i class="fa fa-external-link"></i></span></p></blockquote><p>里面很多很多的干活，实用型的文章</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><p>多个容器的统一为服务</p></li><li><p>多个服务的统一为栈</p></li><li><p>服务内自动有VIP机制，VIP 为各个节点的IP</p></li><li><blockquote><p>docker service其实不仅仅是批量启动服务这么简单，而是在集群中定义了一种状态。Cluster会持续检测服务的健康状态并维护集群的高可用性。</p></blockquote></li></ul><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>Swarm 作为 Docker 的原生功能，其主要的工具有以下：</p><ul><li>docker swarm 用于集群管理</li><li>docker service 用于服务创建</li><li>docker node 用于节点管理</li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="部署服务"><a href="#部署服务" class="headerlink" title="部署服务"></a>部署服务</h3><p>这里简单的基于 Swarm 部署一个 Nginx 的服务。（其实这里本来应该有详细的说明的，留在下篇吧）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d overlay ngx_net</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看docker网络</span></span><br><span class="line">docker network ls</span><br><span class="line"></span><br><span class="line">docker service create \</span><br><span class="line">--replicas 2 \# 两个副本（一共）</span><br><span class="line">--network ngx_net \ # 虚拟网络</span><br><span class="line">--name my-test \# 服务名</span><br><span class="line">-p 80:80 nginx# 端口映射（本地到容器）</span><br><span class="line"></span><br><span class="line">docker service ps# 查看运行的所有的服务</span><br><span class="line"></span><br><span class="line">docker ps# 查看节点的运行的容器</span><br></pre></td></tr></table></figure><h3 id="服务扩缩容"><a href="#服务扩缩容" class="headerlink" title="服务扩缩容"></a>服务扩缩容</h3><p>Swarm 的一大亮点，就是可以很灵活的进行服务的扩缩容。可以很方便的调整服务的对应的容器的数量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker service scale my-test=1</span><br><span class="line">docker service scale my-test=5</span><br></pre></td></tr></table></figure><h3 id="数据的持久化"><a href="#数据的持久化" class="headerlink" title="数据的持久化"></a>数据的持久化</h3><p>容器和镜像的区别在与其可读性，镜像可以理解为只读的容器。为了数据的持久化，数据应该挂在在硬盘之上，而不是容器智能，否则容器销毁，数据将会消失。</p><p>这里主要有两种办法：</p><ul><li>bind        这里是直接绑定硬盘上的目录和容器内的目录。</li><li>volumes    在主机上建立相应的目录，可以进行统一的管理。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个挂载卷</span></span><br><span class="line">docker volume create --name myvolume</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在容器内挂载卷</span></span><br><span class="line">docker service create \</span><br><span class="line">--replicas 2 \</span><br><span class="line">--network ngx_net \</span><br><span class="line">--mount type=volume,src=myvolume,dst=/wangshibo \</span><br><span class="line">--name test-nginx nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里在容器内执行shell，可以看到文件已经同步</span></span><br><span class="line">docker exec -ti 3618e3d1b966 /bin/bash</span><br></pre></td></tr></table></figure><hr><p>这里再折腾的时候，遇到了很大的问题，后面看到发现是swarm 的特性。当服务有多个副本的时候，在创建的时候，的确会在manager界面对目录进行拷贝。但是，后续再对manager上的文件进行修改，这些修改将不会被同步到各个节点上。需要一个个的进行修改很是麻烦，后面可以试着使用 <strong>NFS</strong> 实现多个镜像的配置文件的统一。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20va2V2aW5ncmFjZS9wLzY4NzAzNTkuaHRtbA==" title="https://www.cnblogs.com/kevingrace/p/6870359.html">Docker管理工具-Swarm部署记录<i class="fa fa-external-link"></i></span></li></ul></blockquote><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><blockquote><p>当你发现自己的才华撑不起野心时，就请安静下来学习吧</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前面的话&quot;&gt;&lt;a href=&quot;#前面的话&quot; class=&quot;headerlink&quot; title=&quot;前面的话&quot;&gt;&lt;/a&gt;前面的话&lt;/h2&gt;&lt;p&gt;上一篇简单快速的进行swarm集群的部署，这可以开始使用了。这里试着部署一个 Nginx 的服务，并且一步步实现前面的高可用
      
    
    </summary>
    
      <category term="OP之路" scheme="https://blog.diglp.xyz/categories/OP%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Docker" scheme="https://blog.diglp.xyz/tags/Docker/"/>
    
      <category term="Swarm" scheme="https://blog.diglp.xyz/tags/Swarm/"/>
    
  </entry>
  
  <entry>
    <title>Docker集群搭建</title>
    <link href="https://blog.diglp.xyz/2019/03/05/OP_Docker_Swarm/"/>
    <id>https://blog.diglp.xyz/2019/03/05/OP_Docker_Swarm/</id>
    <published>2019-03-04T16:00:00.000Z</published>
    <updated>2019-03-16T01:58:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速部署"><a href="#快速部署" class="headerlink" title="快速部署"></a>快速部署</h2><h3 id="Docker-的安装"><a href="#Docker-的安装" class="headerlink" title="Docker 的安装"></a>Docker 的安装</h3><p>Docker 的安装，这里直接使用官方提供的一键安装的脚本。一路绿灯</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://get.docker.com/ | sh</span><br><span class="line"></span><br><span class="line">curl -sSL https://get.daocloud.io/docker | sh</span><br></pre></td></tr></table></figure><h3 id="创建Swarm集群"><a href="#创建Swarm集群" class="headerlink" title="创建Swarm集群"></a>创建Swarm集群</h3><p>直接使用 Docker 的 <code>swarm</code> 来进行集群的创建。直接通过help可以查看相关的参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 初始化 Swarm 集群</span><br><span class="line">docker swarm init --advertise-addr 192.168.xxx.xxx# 这里是主机的地址 注意保持静态 IP</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 得到 Worker 的join-token</span><br><span class="line">docker swarm join-token worker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 输入join之后直接加入集群</span><br><span class="line">docker node ls</span><br><span class="line">ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION</span><br><span class="line">6km4644t62w3h3g7iujceerl1 *   bgb1         Ready               Active              Leader              18.06.3-ce</span><br><span class="line">kwi9t231ulc2dry75zzg52580     bgb2         Ready               Active                                  18.06.3-ce</span><br></pre></td></tr></table></figure><h3 id="Portainer-服务部署"><a href="#Portainer-服务部署" class="headerlink" title="Portainer 服务部署"></a>Portainer 服务部署</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>拉镜像</span><br><span class="line">docker pull portainer/portainer</span><br><span class="line"><span class="meta">#</span> 创建挂载卷</span><br><span class="line">docker volume create portainer_data</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 创建挂载目录,不然后面挂载会报错</span><br><span class="line">mkdir -p /opt/portainer</span><br><span class="line"></span><br><span class="line">docker service create \</span><br><span class="line">--name portainer \</span><br><span class="line">--publish 9000:9000 \</span><br><span class="line">--replicas=1 \</span><br><span class="line">--constraint 'node.role == manager' \</span><br><span class="line">--mount type=bind,src=//var/run/docker.sock,dst=/var/run/docker.sock \</span><br><span class="line">--mount type=bind,src=//opt/portainer,dst=/data \</span><br><span class="line">portainer/portainer \</span><br><span class="line">-H unix:///var/run/docker.sock</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 列出所有的服务</span><br><span class="line">docker service ls</span><br><span class="line">ID                  NAME                MODE                REPLICAS            IMAGE                        PORTS</span><br><span class="line">plmkdifqivcs        mAgent_agent        global              4/4                 portainer/agent:latest</span><br></pre></td></tr></table></figure><hr><p>这里注意的是，这里的部署是服务部署，而不是单个容器的部署。</p><p>容器的部署是针对与单个节点的。在上面的部署方式也可以使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9000:9000 --name portainer --restart always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer</span><br></pre></td></tr></table></figure><p>这里的问题是，这个命令只是在单主机的 Node 上对该镜像进行了部署。如果进行服务的访问，<strong>只能通过该主机的Hostname</strong> 进行访问。</p><p>但是一旦进行了一个服务的部署，那么所有的节点IP，都会做一个统一的映射，继而都可以对该服务进行访问。（这里选择的网络接口是 Ingress ，直接和主机网络共享，并且在服务的子网内，这些容器是自动进行负载均衡的。全自动的！</p><p>至此，整个 <strong>Swarm</strong> 集群搭建完成，并且使用了轻量级的容器管理系统 <strong>Portainer</strong> 。</p><h2 id="笔记s"><a href="#笔记s" class="headerlink" title="笔记s"></a>笔记s</h2><p>这里，自己折腾了一下简单的部署，实际的应用后面还有很长很长的路要走。这个section记录一下途中遇上的坑：</p><ul><li>Manager节点需要配置静态 IP ，因为 advertise 的地址是固定的，否则会发现IP改变之后节点全部 Down 掉。</li><li>在跑 Portainer 的注意检查其挂载的目录是否真实存在，否则报错。（bind，和mount）</li><li>Agent 的部署好像很吃内存。</li><li>脚本安装Docker 的时候，被CDN坑，没办法</li></ul><h2 id="资料："><a href="#资料：" class="headerlink" title="资料："></a>资料：</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYm9va3N0YWNrLmNuL3JlYWQvZG9ja2VyLXN3YXJtLWd1aWRlcy9SRUFETUUubWQ=" title="https://www.bookstack.cn/read/docker-swarm-guides/README.md">Docker Swarm 深入浅出<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vc3RvcmFnZS9iaW5kLW1vdW50cy8=" title="https://docs.docker.com/storage/bind-mounts/">Use bind mounts<i class="fa fa-external-link"></i></span></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;快速部署&quot;&gt;&lt;a href=&quot;#快速部署&quot; class=&quot;headerlink&quot; title=&quot;快速部署&quot;&gt;&lt;/a&gt;快速部署&lt;/h2&gt;&lt;h3 id=&quot;Docker-的安装&quot;&gt;&lt;a href=&quot;#Docker-的安装&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="OP之路" scheme="https://blog.diglp.xyz/categories/OP%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Docker" scheme="https://blog.diglp.xyz/tags/Docker/"/>
    
      <category term="Swarm" scheme="https://blog.diglp.xyz/tags/Swarm/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 访问量统计接口</title>
    <link href="https://blog.diglp.xyz/2019/03/03/OP_Nginx%E8%AE%BF%E9%97%AE%E9%87%8F%E7%BB%9F%E8%AE%A1%E6%8E%A5%E5%8F%A3/"/>
    <id>https://blog.diglp.xyz/2019/03/03/OP_Nginx访问量统计接口/</id>
    <published>2019-03-02T16:00:00.000Z</published>
    <updated>2019-03-04T11:57:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>这个post来自于之前偶遇的一个页面上的组件：</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9yc3NodWIuYXBwLw==" title="https://rsshub.app/">Welcome to RSSHub!<i class="fa fa-external-link"></i></span> 万物皆可订阅的RRSHUB</p></blockquote><p>上面的那个Debug 的统计，就是显得十分的帅气了，想着自己也搞一个？</p><h2 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h2><p>当然,这里也没什么数据库的，直接是用shell出来的，根据日志的格式来进行解析，参考页面：</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC81MzdhMGJkZGRhOTQ=" title="https://www.jianshu.com/p/537a0bddda94">统计Nginx访问量 - 简书<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC84MDBlMTY4ZTI0NjM=" title="https://www.jianshu.com/p/800e168e2463">nginx cache查看缓存命中率<i class="fa fa-external-link"></i></span></p></blockquote><hr><p>这些操作都是基于 Nginx 日志进行操作的，这里列举一条：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">111.59.124.138 - - [25/Feb/2019:15:31:26 +0800] &quot;GET / HTTP/2.0&quot; 200 12628 &quot;-&quot; &quot;Mozilla/5.    0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.10    9 Safari/537.36&quot; &quot;-&quot;</span><br></pre></td></tr></table></figure><p>使用awk对参数进行提取，默认以空格进行分割。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">awk '&#123;print $1&#125;'  /var/log/nginx/access.log|sort | uniq -c |wc -l</span><br><span class="line"></span><br><span class="line">awk '&#123;print $7&#125;' /var/log/nginx/access.log|wc -l</span><br><span class="line"></span><br><span class="line">awk '&#123;print $7&#125;' /var/log/nginx/access.log|sort | uniq -c |sort -n -k 1 -r|head 10</span><br><span class="line"></span><br><span class="line">awk '&#123;print $1&#125;' /var/log/nginx/access.log|sort | uniq -c |sort -n -k 1 -r|head 10</span><br></pre></td></tr></table></figure><blockquote><p>UV 和 PV：<strong>UV（Unique visitor）</strong> 24小时内的单个自然人， <strong>PV（Page View）</strong> 页面点击量。 </p></blockquote><hr><p>这里学好 <code>awk</code> 和 <code>sed</code> 和 <code>xargs</code> 后面我要开专题。 通过 Shell 的天然的特性。就可以得到响应的内容。</p><h2 id="CGI脚本"><a href="#CGI脚本" class="headerlink" title="CGI脚本"></a>CGI脚本</h2><p>得到统计提取的脚本之后，这里直接进行通过wsgi实现接口。供前端调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cgi</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Content-Type: application/json"</span>)</span><br><span class="line">print(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">query = &#123;</span><br><span class="line">    <span class="string">'uv'</span>:<span class="string">"awk '&#123;print $1&#125;'  /var/log/nginx/xxxx.xxx.cf.log|sort | uniq -c |wc -l"</span>,</span><br><span class="line">    <span class="string">'pv'</span>:<span class="string">"awk '&#123;print $7&#125;' /var/log/nginx/xxxx.xxx.cf.log|wc -l"</span>,</span><br><span class="line">    <span class="string">'hoturl'</span>:<span class="string">"awk '&#123;print $7&#125;' /var/log/nginx/xxxx.xxx.cf.log|sort | uniq -c |sort -n -k 1 -r|head"</span>,</span><br><span class="line">    <span class="string">'hotip'</span>:<span class="string">"awk '&#123;print $1&#125;' /var/log/nginx/xxxx.xxx.cf.log|sort | uniq -c |sort -n -k 1 -r|head"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp = dict(zip(query, map(<span class="keyword">lambda</span> x: os.popen(x).read(), query.values())))</span><br><span class="line">result = json.dumps(resp)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><hr><p>前端使用 <code>AJAX</code> 进行请求，拉取数据，进行基本处理即可，这里的问题存在：<code>CC攻击</code> 的问题，这里直接使用 Shell 调用，如果接口被压测，可能占用大量的 IO资源。所以优化方案是 数据入库。</p><h2 id="前端处理"><a href="#前端处理" class="headerlink" title="前端处理"></a>前端处理</h2><p>前端通过 <code>AJAX</code> 对接口动态调用，拉取数据。之后进行处理和动态刷新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    $.get(<span class="string">'/get_dbg/'</span>).done(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">            $(<span class="string">'#PV'</span>).text(<span class="string">'站点PV:  '</span>+ data.pv)</span><br><span class="line">            $(<span class="string">'#UV'</span>).text(<span class="string">'站点UV:  '</span>+ data.uv)</span><br><span class="line">            $(<span class="string">'#hotip'</span>).html(<span class="string">'&lt;br&gt;'</span> + data.hotip.replace(<span class="regexp">/\n/g</span>, <span class="string">'&lt;br&gt;'</span>))</span><br><span class="line">            $(<span class="string">'#hoturl'</span>).html(<span class="string">'&lt;br&gt;'</span> + data.hoturl.replace(<span class="regexp">/\n/g</span>, <span class="string">'&lt;br&gt;'</span>))</span><br><span class="line">        &#125;)；</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>这里进行全局的 <code>\n</code> 替换，使内容换行。对页面进行刷新即可。</p><h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2><p>这里做了 nginx 的日志的统计，进行对部分服务质量的反馈。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;这个post来自于之前偶遇的一个页面上的组件：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=
      
    
    </summary>
    
      <category term="OP之路" scheme="https://blog.diglp.xyz/categories/OP%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Nginx" scheme="https://blog.diglp.xyz/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Keepalive 实现 HA</title>
    <link href="https://blog.diglp.xyz/2019/03/01/OP_KeepAlive%E5%AE%9E%E7%8E%B0HA/"/>
    <id>https://blog.diglp.xyz/2019/03/01/OP_KeepAlive实现HA/</id>
    <published>2019-02-28T16:00:00.000Z</published>
    <updated>2019-03-04T11:57:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p><code>HA(High Availability)</code> 高可用，是衡量一个系统的重要指标。所以双机热备，成为一个好的和通用的选择。前面的的方案直接使用了nginx 的Upstream，来实现了 <strong>双机</strong> 的过程。<br>虽然是可以实现在单节点down掉之后系统依旧可用，不过显得不是那么专业。这里就使用 KeepAlive 来实现系统的 <strong>双机过程</strong>。</p><hr><blockquote><ol><li>nginx进程基于Master+Slave(worker)多进程模型，自身具有非常稳定的子进程管理功能。在Master进程分配模式下，Master进程永远不进行业务处理，只是进行任务分发，从而达到Master进程的存活高可靠性，Slave(worker)进程所有的业务信号都 由主进程发出，Slave(worker)进程所有的超时任务都会被Master中止，属于非阻塞式任务模型。</li><li>Keepalived是Linux下面实现VRRP备份路由的高可靠性运行件。基于Keepalived设计的服务模式能够真正做到主服务器和备份服务器故障时IP瞬间无缝交接。二者结合，可以构架出比较稳定的软件LB方案。</li></ol><p>引用自 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20va2V2aW5ncmFjZS9wLzYxMzgxODUuaHRtbA==" title="https://www.cnblogs.com/kevingrace/p/6138185.html">Nginx+keepalived 双机热备（主从模式）<i class="fa fa-external-link"></i></span></p></blockquote><hr><h2 id="Keepalive-基本概念"><a href="#Keepalive-基本概念" class="headerlink" title="Keepalive 基本概念"></a>Keepalive 基本概念</h2><p>KeepAlived 使用了 <code>VRRP</code> 来避免IP的单点故障。VRRP全称 Virtual Router Redundancy Protocol，即 虚拟路由冗余协议。简单的说，在一个子网IP，后面其实对应了 N 台主机。这些主机再构成一个路由器组。这个单独的虚拟ip，复杂对数据包的转发。这里也就有了传说中的 <strong>VIP （virtual IP）</strong>。</p><p>简单的一句话来讲：多个IP被放在一个路由组，虚拟成一个 IP。</p><p>这里有主机和从机。当主机不可用时候，回自主更新路由对应的MAC（设备）。</p><h2 id="Keepailve-简易配置"><a href="#Keepailve-简易配置" class="headerlink" title="Keepailve 简易配置"></a>Keepailve 简易配置</h2><p>这里直接在两台主机上安装 <code>keepalive</code> ，在 <code>/etc/keepalive/keepalive.conf</code> 里面进行配置。 这里也直接贴配置了，因为是直接 Copy的。。。</p><blockquote><p>示例配置在项目官网可见：<span class="exturl" data-url="aHR0cDovL3d3dy5rZWVwYWxpdmVkLm9yZy9tYW5wYWdlLmh0bWw=" title="http://www.keepalived.org/manpage.html">http://www.keepalived.org/manpage.html<i class="fa fa-external-link"></i></span></p></blockquote><p>主机配置如下，定义了节点名称，网络接口，认证方式以及 <strong>VIP</strong>：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">global_defs</span> &#123;  </span><br><span class="line">    <span class="attribute">router_id</span> NodeA<span class="comment"># 不同节点的不同命名  </span></span><br><span class="line">    router_id NodeB <span class="comment">#################</span></span><br><span class="line">&#125;  </span><br><span class="line">vrrp_instance VI_1 &#123;  </span><br><span class="line">    <span class="attribute">state</span> MASTER    <span class="comment">#设置为主服务器  </span></span><br><span class="line">    state BACKUP    <span class="comment">#设置为备服务器 ###############</span></span><br><span class="line">        </span><br><span class="line">    interface eth0  <span class="comment">#监测网络接口  </span></span><br><span class="line">    virtual_router_id <span class="number">51</span>  <span class="comment">#主、备必须一样  </span></span><br><span class="line">    </span><br><span class="line">    priority <span class="number">99</span>   <span class="comment">#(主、备机取不同的优先级，主机值较大，备份&gt;机值较小,值越大优先级越高)</span></span><br><span class="line">    </span><br><span class="line">    advert_int <span class="number">1</span>   <span class="comment">#VRRP Multicast广播周期秒数  </span></span><br><span class="line">    authentication &#123;  </span><br><span class="line">        <span class="attribute">auth_type</span> PASS  <span class="comment">#VRRP认证方式，主备必须一致  </span></span><br><span class="line">        auth_pass *****<span class="comment">#(密码)  </span></span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;  </span><br><span class="line">        192.168.1.200/24  #VRRP HA虚拟地址  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>上面直接给出了器可用的配置文件，主从之间的差距就是那么几行。之后使用 <code>service</code> 重启服务即可。</p><h3 id="效果验证"><a href="#效果验证" class="headerlink" title="效果验证"></a>效果验证</h3><p>在主机或者路由里可以看到 <code>arp -a</code> 里面，192.168.1.200 的这个IP的路由已经被注册了，而且后面的MAC正是我们的 <strong>Master</strong> 的MAC地址。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span>.<span class="number">1.1</span>           <span class="number">20</span>-<span class="number">76</span>-<span class="number">93</span>-<span class="number">46</span>-<span class="number">68</span>-e3     动态</span><br><span class="line">...</span><br><span class="line"><span class="number">192.168</span>.<span class="number">1.200</span>         <span class="number">2</span>c-<span class="number">4</span>d-<span class="number">54</span>-<span class="number">42</span>-<span class="number">9</span>b-<span class="number">0</span>a     动态</span><br><span class="line"><span class="comment">######################################################################</span></span><br><span class="line">➜  keepalived ifconfig </span><br><span class="line">eth0: flags=<span class="number">4163</span>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class="number">1500</span></span><br><span class="line">        inet <span class="number">192.168</span>.<span class="number">1.129</span>  netmask <span class="number">255.255</span>.<span class="number">255.0</span>  broadcast <span class="number">192.168</span>.<span class="number">1.255</span></span><br><span class="line">        inet6 fe80::cffe:<span class="number">4</span>eee:f129:de22  prefixlen <span class="number">64</span>  scopeid <span class="number">0</span>x20&lt;link&gt;</span><br><span class="line">        ether <span class="number">2</span>c:<span class="number">4</span>d:<span class="number">54</span>:<span class="number">42</span>:<span class="number">9</span>b:<span class="number">0</span>a  txqueuelen <span class="number">1000</span>  (Ethernet)</span><br><span class="line">        RX packets <span class="number">464842</span>  bytes <span class="number">188082136</span> (<span class="number">179.3</span> MiB)</span><br><span class="line">        RX errors <span class="number">0</span>  dropped <span class="number">0</span>  overruns <span class="number">0</span>  frame <span class="number">0</span></span><br><span class="line">        TX packets <span class="number">506574</span>  bytes <span class="number">162269596</span> (<span class="number">154.7</span> MiB)</span><br><span class="line">        TX errors <span class="number">0</span>  dropped <span class="number">0</span> overruns <span class="number">0</span>  carrier <span class="number">0</span>  collisions <span class="number">0</span></span><br><span class="line">        device interrupt <span class="number">43</span></span><br></pre></td></tr></table></figure><p>当<strong>拔掉 MASTER 主机的网线</strong>之后：可以看到地址绑定的MAC地址，飞速的就切换了。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span>.<span class="number">1.1</span>           <span class="number">20</span>-<span class="number">76</span>-<span class="number">93</span>-<span class="number">46</span>-<span class="number">68</span>-e3     动态</span><br><span class="line">...</span><br><span class="line"><span class="number">192.168</span>.<span class="number">1.200</span>         b8-<span class="number">27</span>-eb-eb-<span class="number">17</span>-<span class="number">72</span>     动态</span><br><span class="line"><span class="comment">#######################################################################</span></span><br></pre></td></tr></table></figure><p>至此可见，Keepalive 的热备效果实现了在一个 VIP 下的双机热备。在单主机下线情况下快速切换。</p><hr><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>当前的配置实际上并不合理，只有在主机掉线后才会进行主从切换。很多实话是某个服务（比如 Nginx）挂掉了导致的服务不可用。所以后面回就需要更高阶的使用，加上对服务进行检测的功能。</p><h2 id="Keepavlived-监控配置"><a href="#Keepavlived-监控配置" class="headerlink" title="Keepavlived 监控配置"></a>Keepavlived 监控配置</h2><p>入上面的提到的问题，在这种情况下，只适用于 <strong>MASTER</strong> 节点down掉的情况下，才会重新选取 Backup节点。然很多时候实际上是服务出了问题而不是主机（比如 Nginx 服务挂掉），那么在这种情况下就不能及时的切换到备机。</p><p>所以这里的配置就需要更进一步，来实现监控的过程。对于 Nignx 的web服务来讲，可以有以下的方式：</p><ul><li>监控 Nginx 进程</li><li>监控 Nginx 端口</li><li>监控 Nginx 的请求返回</li></ul><p>这三种方法，的可靠性也是依次提升的。</p><blockquote><p>这里参考文章：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20va2V2aW5ncmFjZS9wLzYxMzgxODUuaHRtbA==" title="https://www.cnblogs.com/kevingrace/p/6138185.html">Nginx+keepalived 双机热备（主从模式）<i class="fa fa-external-link"></i></span> </p><p>里面对细节讲的相当的详细</p></blockquote><hr><p>在配置文件里，可以使用 <code>vrrp_script</code> 域来自定义检测脚本。示例如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">vrrp_script</span> chk_http_port &#123;         </span><br><span class="line">    <span class="attribute">script</span> <span class="string">"/opt/chk_nginx.sh"</span><span class="comment"># 指定检测脚本</span></span><br><span class="line">    interval <span class="number">2</span>                      <span class="comment"># 检测间隔</span></span><br><span class="line">    weight -<span class="number">5</span>                       <span class="comment"># 故障时权重值 -5</span></span><br><span class="line">    fall <span class="number">2</span>                   <span class="comment"># 故障判断次数，连续两次算故障</span></span><br><span class="line">    rise <span class="number">1</span>                  <span class="comment"># 检测成功，一次算成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里要提示一下keepalived.conf中vrrp_script配置区的script一般有2种写法：<br>1）通过脚本执行的返回结果，<strong>改变优先级</strong>，keepalived继续发送通告消息，backup比较优先级再决定。这是直接监控Nginx进程的方式。<br>2）脚本里面检测到异常，<strong>直接关闭keepalived进程</strong>，backup机器接收不到advertisement会抢占IP。这是检查NginX端口的方式。</p></blockquote><hr><p>用于检测的 <strong>Nginx</strong> 进程的脚本如下，用Shell脚本对进程进行检测，统计进程数量，如果进程挂掉，就尝试重启进程，如果进程无法拉起，那么就直接停掉本机的 <code>keepalive</code> ，让 VIP 漂移到从机上。这里使用的就是第二种方法。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">counter=$(ps -C nginx --no-heading|wc -l)</span><br><span class="line">if [ "$&#123;counter&#125;" = "0" ]; then</span><br><span class="line">    /usr/local/nginx/sbin/nginx</span><br><span class="line">    sleep 2</span><br><span class="line">    counter=$(ps -C nginx --no-heading|wc -l)</span><br><span class="line">    if [ "$&#123;counter&#125;" = "0" ]; then</span><br><span class="line">        /etc/init.d/keepalived stop</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><hr><p>至此，基于进程监控的 Keepalive 已经实现。</p><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><p>这里用 Keepalive 实现了一个 VIP 下的双机热备，和实际业务需求更加接近了一点。当然真实架构不是这样的，这样导致了，从机的完全的空闲，其压测效果还不如两个机器分别在 upstream里面。后面将会使用 Docker集群进行统一管理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;&lt;code&gt;HA(High Availability)&lt;/code&gt; 高可用，是衡量一个系统的重要指标。所以双机热备，成为一个好的和通用的选择。前面
      
    
    </summary>
    
      <category term="OP之路" scheme="https://blog.diglp.xyz/categories/OP%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Nginx" scheme="https://blog.diglp.xyz/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Proxy 缓存 及 命中率统计</title>
    <link href="https://blog.diglp.xyz/2019/02/28/OP_%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98_%E5%91%BD%E4%B8%AD%E7%8E%87%E7%BB%9F%E8%AE%A1/"/>
    <id>https://blog.diglp.xyz/2019/02/28/OP_代理缓存_命中率统计/</id>
    <published>2019-02-27T16:00:00.000Z</published>
    <updated>2019-03-04T11:57:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>车能跑之后，就希望跑的快点对吧？所以就想办法开始对其性能进行优化。 这里就使用 CDN的思想，对代理的静态文件进行缓存，实现访问速度的提升。</p><p>所以这篇的主要目的，就是配置主机的 CDN 功能，实现对页面的静态文件缓存。</p><h2 id="proxy-cache-配置"><a href="#proxy-cache-配置" class="headerlink" title="proxy_cache 配置"></a>proxy_cache 配置</h2><p>由于Nginx里面默认是编译了 Cache 的功能， 所以可以很方便的通过配置，来实现功能。这里直接贴出conf的内容。这里需要指定缓存空间，以及缓存配置。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_cache_path</span> /tmp/ramdisk levels=<span class="number">1</span>:<span class="number">2</span> keys_zone=my_zone:<span class="number">64m</span> inactive=<span class="number">24h</span> max_size=<span class="number">64m</span>;</span><br><span class="line"><span class="attribute">proxy_cache_key</span> <span class="string">"<span class="variable">$scheme</span><span class="variable">$request_method</span><span class="variable">$host</span><span class="variable">$request_uri</span>"</span>;</span><br></pre></td></tr></table></figure><p>这里是在 HTTP 域里面进行的缓存空间的配置。</p><hr><p>下面，就是通过正则匹配来实现，不同静态资源的统一缓存。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*\.(gif|jpg|png|html|htm|css|js|ico|swf|pdf)$</span> &#123;</span><br><span class="line"><span class="comment"># 部分不需要走缓存</span></span><br><span class="line">    <span class="comment"># proxy_cache_bypass  $http_cache_control;</span></span><br><span class="line">    <span class="attribute">proxy_set_header</span>            Host <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_ignore_headers</span> Set-Cookie Cache-Control;   </span><br><span class="line">    <span class="attribute">proxy_set_header</span>            X-real-ip <span class="variable">$remote_addr</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>            X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">proxy_pass</span> https://frpcon;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#Use Proxy Cache</span></span><br><span class="line">    <span class="attribute">proxy_cache</span> my_zone;<span class="comment"># 缓存空间指定</span></span><br><span class="line">    <span class="attribute">proxy_cache_key</span> <span class="string">"<span class="variable">$host</span><span class="variable">$request_uri</span>"</span>; <span class="comment"># 键存储方式  </span></span><br><span class="line">    <span class="attribute">add_header</span> Cache <span class="string">"<span class="variable">$upstream_cache_status</span>"</span>; <span class="comment"># 返回头添加字段，说明命中状态</span></span><br><span class="line">    <span class="attribute">proxy_cache_valid</span>  <span class="number">200</span> <span class="number">304</span> <span class="number">301</span> <span class="number">302</span> <span class="number">8h</span>;<span class="comment"># 不同返回码的有效时间</span></span><br><span class="line">    <span class="attribute">proxy_cache_valid</span>  <span class="number">404</span> <span class="number">1m</span>;</span><br><span class="line">    <span class="attribute">proxy_cache_valid</span>  any <span class="number">2d</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> <span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMjY4MDQ1Mw==" title="https://segmentfault.com/a/1190000012680453">nginx proxy cache配置参数解读<i class="fa fa-external-link"></i></span> 这里是一篇 相关配置参数的说明</p></blockquote><hr><p>如上配置完成之后，reload server ，缓存功能理应启动。</p><h2 id="热数据思想"><a href="#热数据思想" class="headerlink" title="热数据思想"></a>热数据思想</h2><p>冷热数据分离的思想，常伴在身，虽然这里的请求量是微乎其微，不过还是建一个概念功能。Cache 的请求量一定是非常高的，所以才会被 cache。涉及到IO的时候，最快的设备可能就是我们的内存了。</p><p>所以这里直接使用<strong>内存盘</strong> 对数据来进行缓存，这样的化，大大的降低了物理磁盘的IO量，而且也大大提升了缓存性能。</p><hr><p>在linux下实现一个内存盘是相当的简单：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/ramdisk# 创建挂载点</span><br><span class="line">mount  -t tmpfs -o size=64m  myramdisk /tmp/ramdisk # 实现内存盘挂载</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###### 测速 #####</span></span></span><br><span class="line">➜  /tmp sudo dd if=/dev/zero of=/tmp/ramdisk/zero bs=4k count=100</span><br><span class="line">100+0 records in</span><br><span class="line">100+0 records out</span><br><span class="line">409600 bytes (410 kB) copied, 0.000243897 s, 1.7 GB/s</span><br></pre></td></tr></table></figure><p>这里顺便进行了测速，可见速度还是相当的满意的。至此内存盘的配置完毕。</p><hr><p>当然如果要实现自动挂载，需要在 <code>fstab</code> 里面进行配置.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myramdisk/tmp/ramdisktmpfsdefaults00</span><br></pre></td></tr></table></figure><p>至此配置完毕。</p><h2 id="命中率统计"><a href="#命中率统计" class="headerlink" title="命中率统计"></a>命中率统计</h2><h3 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h3><p>关于命中率的统计这里还是通过在日志里面实现的。和之前的一篇一样，通过 shell 脚本对日志进行提取得到我们需要的数据。</p><p>不过在这里，需要对日志个事进行设定，使其能提供我们需要的信息：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">log_format</span>  proxy <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line"><span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line"><span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span></span><br><span class="line"><span class="string">'"<span class="variable">$request_time</span>" "<span class="variable">$upstream_response_time</span>" "<span class="variable">$upstream_cache_status</span>" "<span class="variable">$upstream_addr</span>"'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attribute">access_log</span> xxxx proxy;<span class="comment"># 这里对格式进行指定。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在我们的HTTP域里面自定义日志类型</p><h3 id="统计脚本"><a href="#统计脚本" class="headerlink" title="统计脚本"></a>统计脚本</h3><p>学好 awk ，走遍天下都不怕。。。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '&#123;if($(NF-1)=="\"HIT\"") hit++&#125; END &#123;printf "%.4f%",hit/NR&#125;' /var/log/nginx/xxx.log</span><br></pre></td></tr></table></figure><p>这里，就很精巧的实现了对缓存命中率的统计。后面可以直接合并入之前的接口之中即可。</p><h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2><p>慢慢装起来一辆能跑快的车，还是不错的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;车能跑之后，就希望跑的快点对吧？所以就想办法开始对其性能进行优化。 这里就使用 CDN的思想，对代理的静态文件进行缓存，实现访问速度的提升。&lt;/p&gt;
      
    
    </summary>
    
      <category term="OP之路" scheme="https://blog.diglp.xyz/categories/OP%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Nginx" scheme="https://blog.diglp.xyz/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Supervisor 进程管理系统</title>
    <link href="https://blog.diglp.xyz/2019/02/23/OP_Supervisord/"/>
    <id>https://blog.diglp.xyz/2019/02/23/OP_Supervisord/</id>
    <published>2019-02-22T16:00:00.000Z</published>
    <updated>2019-03-04T11:57:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>一台机器东西跑多了，就开始各种混乱了。如果是标准安装的注册了service 的还可以比较容易的进行管理。然而很多组件是后面直接下载二进制文件的。这里一个 <code>nohup</code> ，那里一个。最后只能 ps 找出来。如没运行了，有时候甚至找不到了。自启动也是。</p><p>所以这里就是用 Supervisor  进行统一的进程管理，对添加的进程，的启停，自启等都能有很方便的管理。这篇就做个 basic 的部署使用说明。</p><h2 id="部署及配置"><a href="#部署及配置" class="headerlink" title="部署及配置"></a>部署及配置</h2><p>debian 和 redhat 的风格各自不同，debian直接通过 <code>apt-get</code> 安装即可。redhat 使用pip安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install supervisor</span><br></pre></td></tr></table></figure><p>以上完成，就实现了安装过程。</p><hr><p>一共有两个部分 <code>supervisorctl</code> 和 <code>supervisord</code>。根据其命名可以看出来，一个是控制端，另一个是守护进程。先启动守护进程，并注册开机启动。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable supervisor.service# redhat</span><br><span class="line">update-rc.d supervisor enable# debian</span><br></pre></td></tr></table></figure><p>之后把进程跑起来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ systemctl start supervisord.service               </span><br><span class="line">➜  ~ supervisorctl </span><br><span class="line"><span class="meta">supervisor&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure><p>至此,配置没有问题，部署完成。</p><h2 id="进程配置"><a href="#进程配置" class="headerlink" title="进程配置"></a>进程配置</h2><p>在 <code>/etc/supervisord.d</code> 里面通过 ini文件（conf）进行统一的注册。示例注册如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[program:frps]</span></span><br><span class="line"><span class="attr">command</span>=/***/frp/frps -c frps_full.ini --log_file frps.log</span><br><span class="line"><span class="attr">directory</span>=/***/</span><br><span class="line"><span class="attr">autostart</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">startsecs</span>=<span class="number">5</span></span><br><span class="line"><span class="attr">autorestart</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">startretries</span>=<span class="number">3</span></span><br><span class="line"><span class="attr">user</span>=root</span><br><span class="line"><span class="attr">redirect_stderr</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">stdout_logfile_maxbytes</span>=<span class="number">20</span>MB</span><br><span class="line"><span class="attr">stdout_logfile_backups</span>=<span class="number">5</span></span><br><span class="line"><span class="attr">stdout_logfile</span>=/data/logs/frps_stdout.log</span><br></pre></td></tr></table></figure><p>这样就完成了一个进程的注册。后面在 ctl 里面进行更新，和操作了，十分方便</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ supervisorctl </span><br><span class="line">frps                             RUNNING   pid 6607, uptime 6:14:01</span><br><span class="line">uwsgi                            RUNNING   pid 6606, uptime 6:14:01</span><br><span class="line"><span class="meta">supervisor&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure><p>至此，一个进程注册完成</p><h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2><p>这篇文章感觉水水的，不过，挺偏实用向，下面给出 supervisor 的官方手册</p><blockquote><p><span class="exturl" data-url="aHR0cDovL3N1cGVydmlzb3JkLm9yZy9pbmRleC5odG1s" title="http://supervisord.org/index.html">Supervisor: A Process Control System<i class="fa fa-external-link"></i></span></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;一台机器东西跑多了，就开始各种混乱了。如果是标准安装的注册了service 的还可以比较容易的进行管理。然而很多组件是后面直接下载二进制文件的。这里
      
    
    </summary>
    
      <category term="OP之路" scheme="https://blog.diglp.xyz/categories/OP%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Supervisor" scheme="https://blog.diglp.xyz/tags/Supervisor/"/>
    
  </entry>
  
  <entry>
    <title>另一次内网穿透(reverse proxy)</title>
    <link href="https://blog.diglp.xyz/2019/02/21/OP_%E5%8F%A6%E4%B8%80%E6%AC%A1%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F(reverse%20proxy)/"/>
    <id>https://blog.diglp.xyz/2019/02/21/OP_另一次内网穿透(reverse proxy)/</id>
    <published>2019-02-20T16:00:00.000Z</published>
    <updated>2019-03-04T11:57:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>很快这就是第二篇了，上篇信誓旦旦说的更好的方案，实际上，这里较比而已只是有了一点点改进XD</p><p>上一篇：<a href="https://blog.diglp.xyz/2019/02/20/OP_%E6%84%9A%E8%A0%A2%E7%9A%84%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%96%B9%E6%A1%88(tunnel">愚蠢的内网穿透方案(tunnel)</a>/) &lt;– 在此</p><p>其目标和目的是一样的，实现页面的内网穿透，以及内网主机的反代。</p><h2 id="方案以及可行性"><a href="#方案以及可行性" class="headerlink" title="方案以及可行性"></a>方案以及可行性</h2><h3 id="可行性"><a href="#可行性" class="headerlink" title="可行性"></a>可行性</h3><p>如上面所说，实际上分了两个部分，内网穿透，以及反向代理。这里实际上有点混淆了一个概念。反向代理实际上是内网穿透的一个实现过程。之于正向代理不同，反向代理是代理服务器在上次，有请求之后，会把请求转发都后排的客户端，所以这就是反向代理的过程。</p><p>那么内网穿透呢？内网穿透是在反向代理的功能上更多了一层。上面提到反向代理，在有连接的时候，会把它直接转发到后面的客户端。但是在穿透这个情况下，内网主机是<strong>无法被公网主机所访问</strong>，从而无法传递请求了。所以我们在反向代理的前提下，<strong>使用客户端向服务器发起TCP长连接</strong>，这样就打通了，公网主机到内网主机之间的通道。从而实现了内网的穿透。</p><blockquote><p>内网穿透 = 反向代理 + 正向连接</p></blockquote><hr><p>下面又是一个反向代理，这个和前面不一样，是七层代理（也就是应用层）HTTP 的七层代理。对Http的请求进行转发。这个转发和上面不同。转发的服务是运行在内网的主机上的。其作用是对公网穿透的主机请求进行到同一内网的主机的转发。</p><p>这里就是实现的是对HTTP的请求的转发。转发主机与lb主机是在同一个可以访问的网段内的。</p><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>之于上次的傻傻的方法所不同，这次使用现成的轮子了，内网穿透这里直接使用 <code>FRP</code> （Fast reverse proxy）实现，FRP是一个简单易用的内网穿透工具。在公网主机上进行配置。实现内网主机的透传连接。把你穿透到公网主机的开放端口。实现内网主机在公网上的端口访问。</p><p>内网主机使用 <code>Nginx</code> 对目标主机进行 反代，并且把web端口开放在 <code>FRP</code> 的转发上。</p><p>至此方案设计完毕</p><h2 id="部署过程"><a href="#部署过程" class="headerlink" title="部署过程"></a>部署过程</h2><h3 id="FRP的部署"><a href="#FRP的部署" class="headerlink" title="FRP的部署"></a>FRP的部署</h3><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhdGVkaWVyL2ZycC9ibG9iL21hc3Rlci9SRUFETUVfemgubWQ=" title="https://github.com/fatedier/frp/blob/master/README_zh.md">FRP项目Readme<i class="fa fa-external-link"></i></span>  这里面对工具的部署和使用做了详尽的说明，我们直接下载对应架构的 FRP 进行使用即可。其中的功能很多。这里我们只需要用到其中的 TCP 透传的功能。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/fatedier/frp.git</span><br></pre></td></tr></table></figure><p>之后直接 make ，就OK了，当然也是推荐使用现有的 Release的版本。</p><h3 id="Nginx-部署"><a href="#Nginx-部署" class="headerlink" title="Nginx 部署"></a>Nginx 部署</h3><p>Nginx 是在大多数的发行版里默认带有的组件，简单性能轻量。</p><h3 id="FRP配置-以及测试"><a href="#FRP配置-以及测试" class="headerlink" title="FRP配置 以及测试"></a>FRP配置 以及测试</h3><h4 id="FRP-配置"><a href="#FRP-配置" class="headerlink" title="FRP 配置"></a>FRP 配置</h4><p>这里只是用到了 FRP 的内穿功能，通过简单的配置文件实现：</p><p>服务端：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="attr">server_port</span> = *<span class="number">000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">token</span> = *******</span><br><span class="line"></span><br><span class="line"><span class="attr">allow_ports</span> = <span class="number">2000</span>-<span class="number">3000</span>,<span class="number">3001</span>,<span class="number">3003</span>,<span class="number">4000</span>-<span class="number">50000</span></span><br></pre></td></tr></table></figure><p>配置简单通俗易懂，配置监听端口，以及连接 token、</p><hr><p>客户端：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = ****.diglp.xyz</span><br><span class="line"><span class="attr">server_port</span> = *<span class="number">000</span></span><br><span class="line"><span class="attr">token</span> = *******</span><br><span class="line"><span class="section">[web]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">443</span></span><br><span class="line"><span class="attr">remote_port</span> = ****</span><br></pre></td></tr></table></figure><p>这里是客户端的配置文件，比较核心的配置在其指定本地端口以及远程端口的两行。指本地的localhost的443端口透传到远程主机的 <code>****</code> 端口。</p><h4 id="FRP-测试连接"><a href="#FRP-测试连接" class="headerlink" title="FRP 测试连接"></a>FRP 测试连接</h4><p>服务端部署，使用 Nohup 使其在后台运行，当然可以注册一个 supervisor。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ nohup ./frps -c frps_full.ini --log_file frps.log &amp;</span><br></pre></td></tr></table></figure><p>客户端连接，运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./frpc -c frpc_wan.ini &amp;</span><br></pre></td></tr></table></figure><hr><p>测试连接，这里使用 <code>nc -l</code> 对端口进行监听：</p><p>客户端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l 443</span><br></pre></td></tr></table></figure><p>服务端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET localhost:**80</span><br></pre></td></tr></table></figure><p>以此模拟一个 GET 请求。之后在客户端得到如下结果，说明透传成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@vm:~/qspace $ nc -l 443</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">User-Agent: curl/7.29.0</span><br><span class="line">Host: localhost:**80</span><br><span class="line">Accept: */*</span><br></pre></td></tr></table></figure><hr><p>或者：客户端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@vm:~/qspace $ sudo python -m SimpleHTTPServer 443</span><br><span class="line">Serving HTTP on 0.0.0.0 port 443 ...</span><br><span class="line">127.0.0.1 - - [20/Feb/2019 23:29:47] "GET / HTTP/1.1" 200 -</span><br></pre></td></tr></table></figure><p>服务端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  frp_0.23.2 curl -XGET localhost:**80</span><br><span class="line">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"&gt;&lt;html&gt;</span><br><span class="line">    &lt;title&gt;Directory listing for /&lt;/title&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h2&gt;Directory listing for /&lt;/h2&gt;</span><br><span class="line">        &lt;hr&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href="frp_0.24.1_linux_arm/"&gt;frp_0.24.1_linux_arm/&lt;/a&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href="frp_0.24.1_linux_arm.tar.gz"&gt;frp_0.24.1_linux_arm.tar.gz&lt;/a&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        &lt;hr&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>至此连接测试完成。FRP 功能测试正常。</p><h2 id="Nginx-配置以及测试"><a href="#Nginx-配置以及测试" class="headerlink" title="Nginx 配置以及测试"></a>Nginx 配置以及测试</h2><p>这里用到了 Nginx 的反代功能，在写正确的配置之时，后面也写自己在过程中的尝试和想法XD。</p><p>这里直接把配置贴上来了就</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;                                                                     </span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">443</span> ssl default_server;                             </span><br><span class="line">    <span class="attribute">server_name</span>  _;                                            </span><br><span class="line">    <span class="attribute">root</span>         /usr/share/nginx/html;                                     </span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span>     /etc/nginx/ssl/mine.diglp.xyz.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/nginx/ssl/mine.diglp.xyz.key;</span><br><span class="line">    <span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">1m</span>;                                        </span><br><span class="line">    <span class="attribute">ssl_session_timeout</span>  <span class="number">10m</span>;                                               </span><br><span class="line">    <span class="attribute">ssl_ciphers</span> HIGH:!aNULL:!MD5;                                           </span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;                                           </span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load configuration files for the default server block.                </span></span><br><span class="line">    <span class="attribute">location</span> = / &#123;                                                           </span><br><span class="line">    <span class="comment">#internal;                                                              </span></span><br><span class="line">    <span class="comment">#return 403;                                                           </span></span><br><span class="line">    empty_gif;                                                             </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">404</span> /<span class="number">404</span>.html;                                                  </span><br><span class="line">    <span class="attribute">location</span> = /40x.html &#123;                                                 </span><br><span class="line">    &#125;                                                                          </span><br><span class="line"></span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /50x.html;                                      </span><br><span class="line">    <span class="attribute">location</span> = /50x.html &#123;                                                 </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;                                                                     </span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">443</span> ssl;                             </span><br><span class="line">    <span class="attribute">server_name</span>  <span class="regexp">xxxk.*</span>**<span class="regexp">*.diglp.xyz</span>;                                            </span><br><span class="line">    <span class="attribute">root</span>         /usr/share/nginx/html;                                     </span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span>     /etc/nginx/ssl/mine.diglp.xyz.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/nginx/ssl/mine.diglp.xyz.key;</span><br><span class="line">    <span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">1m</span>;                                        </span><br><span class="line">    <span class="attribute">ssl_session_timeout</span>  <span class="number">10m</span>;                                               </span><br><span class="line">    <span class="attribute">ssl_ciphers</span> HIGH:!aNULL:!MD5;                                           </span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;                                           </span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://172.***.64.***;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;                                                                     </span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">443</span> ssl ;                             </span><br><span class="line">    <span class="attribute">server_name</span>  <span class="regexp">bkjw.*</span>**<span class="regexp">*.diglp.xyz</span>;                                            </span><br><span class="line">    <span class="attribute">root</span>         /usr/share/nginx/html;                                     </span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span>     /etc/nginx/ssl/mine.diglp.xyz.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/nginx/ssl/mine.diglp.xyz.key;</span><br><span class="line">    <span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">1m</span>;                                        </span><br><span class="line">    <span class="attribute">ssl_session_timeout</span>  <span class="number">10m</span>;                                               </span><br><span class="line">    <span class="attribute">ssl_ciphers</span> HIGH:!aNULL:!MD5;                                           </span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;                                           </span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://172.***.13.***;</span><br><span class="line">    &#125;                                                                         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这里的说明：</p><ul><li>由于域名没有备案，所以随随便便弄个自签证书，顶上去，先用着了。所以会显示不安全</li><li>配置文件从 模板 copy-paste 上来的，所以有些冗长</li><li>这里还撞上了名字服务的问题</li></ul><hr><p>配置完成后使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/sbin/nignx -s reload</span><br></pre></td></tr></table></figure><p>对其进行热重启就好了。理论上问题不大。</p><h2 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h2><p>这个架构十分的简单，也没有什么问题可言吧。好像是的，直接公网访问。即可</p><h2 id="可用性保证"><a href="#可用性保证" class="headerlink" title="可用性保证"></a>可用性保证</h2><p>由于条件问题，内网客户端并不能保证稳定以及可用性，为了可用性的保证，这里使用 云拨测，对目标 URL 进行定时请求，当有服务不可用时，及时的进行告警。</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9jb25zb2xlLmNsb3VkLnRlbmNlbnQuY29tL2NhdC9hdmFpbFRhc2tMaXN0" title="https://console.cloud.tencent.com/cat/availTaskList">腾讯云-云拨测<i class="fa fa-external-link"></i></span> 现在是免费使用 Recommend</p></blockquote><h2 id="过程问题笔记"><a href="#过程问题笔记" class="headerlink" title="过程问题笔记"></a>过程问题笔记</h2><p>这部分，没什么太大营养。。。</p><h3 id="rewrite"><a href="#rewrite" class="headerlink" title="rewrite"></a>rewrite</h3><p>其实，在这整个搭建的过程中，遇到了一个很大的问题。什么呢？就是通过名字对页面进行访问和区分。比如 <code>adb.com/1</code> 和 <code>abc.com/2</code> <strong>分别转发到不同的</strong>。乍一看是很好实现的，直接 rewrite 就好了比如这样：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span><span class="regexp"> ^~</span> /phpMyAdmin &#123;</span><br><span class="line">    <span class="attribute">root</span> /var/services/web;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span> /phpMyAdmin/disabled.html <span class="literal">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的确可以实现隐式的重定向，但是这里的核心问题，<strong>不是同源</strong>。所以这个方法直接 pass 掉了。</p><hr><h3 id="直接proxy-pass的问题"><a href="#直接proxy-pass的问题" class="headerlink" title="直接proxy_pass的问题"></a>直接proxy_pass的问题</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /bkjw/ &#123;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://172.*.13.*;</span><br><span class="line"><span class="comment">#proxy_pass http://bkjw.guet.edu.cn;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的配置看似是没有问题，但是在测试的时候，会发现非常非常多的 <code>404</code>。具体什么情况呢？因为页面的请求是相对与我们的路由路径 <code>/bkjw/</code> 来加载静态文件的。所以请求的路径是 <code>abc.com/bkjw/</code> 直接导致了静态文件的 <strong>404</strong>。</p><p>那么就想嘛，我把静态文件单独代就行了？所以有这样的：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*\.(gif|jpg|jpeg|png|bmp|swf|js|css|html)$</span></span><br><span class="line"><span class="regexp"></span>&#123;</span><br><span class="line"><span class="attribute">proxy_pass</span> http://172.*.13.*;</span><br><span class="line">    <span class="attribute">expires</span>      <span class="number">30d</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然这样也是不行的，有悖了初衷，还是占用了 <code>/</code>。</p><h3 id="Set-Cookie-和-referer-的脑洞"><a href="#Set-Cookie-和-referer-的脑洞" class="headerlink" title="Set-Cookie 和 referer 的脑洞"></a>Set-Cookie 和 referer 的脑洞</h3><p>那么归根结底，我们要确认的是这个静态文件的请求是从哪里来的。于是就想到了 referer。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line"><span class="attribute">if</span> (<span class="variable">$http_referer</span> <span class="regexp">~* '.*/bkjw/'</span> )&#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://172.#.13.#;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一试，还可以！打开了首页里面所有的东西都加载出来了。不过问题又出现了，在打开第二个页面的时候，<code>referer</code> 已经发生了变化，同样导致大量 404。</p><hr><p>这样，我就给用户一个标识，在请求资源的时候我就可以判断啦。这里就出现了 <code>set-cookie</code> 的方法。希望通过cookie的方式给用户一个标识符，说明其源站从哪里来。配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /bkjw/ &#123;</span><br><span class="line">    <span class="comment">#add_header Set-Cookie 'bussid=bkjw' ;</span></span><br><span class="line">    <span class="attribute">proxy_pass</span> http://172.16.13.22/;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">if ($cookie_&#123;bussid&#125; ~* 'bkjw' )&#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://172.#.13.#;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果发现，并没有什么用。F12 看了看，发现了奥秘，<strong>请求静态资源的时候是不进行Cookie传递的</strong>，一想也是，这样才安全嘛。</p><blockquote><p>这里回顾一个经典的 phishing 的手段，在邮件中插入一个外部图片，透过请求图片的请求头，获得已读回执，和基本的系统状态 </p></blockquote><hr><p>至此没有办法，只能使用 <code>server_name</code> 来对其进行区分，最终的配置如上上的示例所示。显得不是那么有美感了。</p><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><blockquote><p>人工智能的发展一旦上路了将会是飞速的，不要想着如何对付和人一样聪明的电脑，要么它永远不如你，要么它就把你远远的甩在身后。和你齐头并进只不过是一个瞬间而已。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;很快这就是第二篇了，上篇信誓旦旦说的更好的方案，实际上，这里较比而已只是有了一点点改进XD&lt;/p&gt;
&lt;p&gt;上一篇：&lt;a href=&quot;https://
      
    
    </summary>
    
      <category term="OP之路" scheme="https://blog.diglp.xyz/categories/OP%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Nginx" scheme="https://blog.diglp.xyz/tags/Nginx/"/>
    
      <category term="Frp" scheme="https://blog.diglp.xyz/tags/Frp/"/>
    
  </entry>
  
  <entry>
    <title>记一次内网穿透配置(tunnel)</title>
    <link href="https://blog.diglp.xyz/2019/02/20/OP_%E6%84%9A%E8%A0%A2%E7%9A%84%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%96%B9%E6%A1%88(tunnel)/"/>
    <id>https://blog.diglp.xyz/2019/02/20/OP_愚蠢的内网穿透方案(tunnel)/</id>
    <published>2019-02-19T16:00:00.000Z</published>
    <updated>2019-03-04T11:57:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个挺重要的网站,奈何只能内网访问, 想着把他外网映射出来…遂为之</p><hr><p>这篇文章应该是 2018/1/14时候就已经完成了，总是缺一点内容于是就没有post 出去。现在是时候了，因为完成同样的事情，现在有了第二个更好的解决方案，所以这这里 post 上去，做个对比。</p><p>这篇的方法十分的简单粗暴，使用了昂贵的资源，做了简单的事情，也是个反面教材。不过从底层的原理还是OK的。</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><h3 id="VPN-simple概念"><a href="#VPN-simple概念" class="headerlink" title="VPN simple概念"></a>VPN simple概念</h3><p>VPN 是 Virtual Private Network 的缩写, 翻译过来是虚拟专用网络.引用百科的话来讲:</p><blockquote><p>虚拟专用网络的功能是：在公用网络上建立专用网络，进行加密通讯。在企业网络中有广泛应用。VPN网关通过对数据包的加密和数据包目标地址的转换实现远程访问。</p></blockquote><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1518414600419&amp;di=f908309c6976739a03741121bb706d0b&amp;imgtype=0&amp;src=http%3A%2F%2Fs9.rr.itc.cn%2Fr%2FwapChange%2F20171_23_14%2Fa7zdid2847716173619.jpg" alt="VPN"></p><p>通俗的讲, 使用VPN 技术,可以将 在公有网络的 两台主机, 进行一个私有的隧道链接, 效果,就和我们自家用的路由器一样. 在一个 VPN 下的子网主机是可以互相访问的(规则允许的话)</p><p>VPN 再协议栈层级很低的地方，一般在 2或者3 层，也就是数据链路层或者网络层，这里的 端口转发涉及到端端在第四层。</p><h3 id="端口转发-Port-Tunnel-simple概念"><a href="#端口转发-Port-Tunnel-simple概念" class="headerlink" title="端口转发(Port-Tunnel) simple概念"></a>端口转发(Port-Tunnel) simple概念</h3><p>一样援引百科的定义</p><blockquote><p>端口转发（Port forwarding），有时被叫做隧道(tunnel)，端口转发是转发一个网络端口从一个网络节点到另一个网络节点的行为，其使一个外部用户从外部经过一个被激活的NAT路由器到达一个在私有内部IP地址（局域网内部）上的一个端口。</p></blockquote><p>很好理解的东西, 端口转发技术, 显然是用于端到端的通信. 端到端,在TCP/IP的协议栈中, 是包含了TCP和UDP 这两种数据传输方式, 所以可见所有的应用层的数据, 都可以使用端口转发(这也是 ss 和 http代理的区别).</p><p>在这里我们使用端口转发, 对Http请求进行直接转发.<br><img src="http://img4.imgtn.bdimg.com/it/u=745504115,462270053&amp;fm=27&amp;gp=0.jpg" alt="port"></p><h2 id="实施"><a href="#实施" class="headerlink" title="实施"></a>实施</h2><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>先使用外网VPN服务器, 让内网主机接入其子网, 而后通过两次的端口转发(port-tunnel), 达到内网服务器<br>现在分析具体情况, 我们的内网外部不可访问, 内网主机可以互相访问, 我们的内网主机可以访问外网. 所以我们我要实现的是</p><ul><li>先使得我们的主机可以外网访问, 所以首先连接外网, 这里就选择了VPN.内网主机,和公网主机组合成一个子网</li><li>内外网主机可以互相访问之后, 使用端口转发, 暴露公网主机的端口, 转发到我们的VPN子网的某个端口.实现外网访问我们内网的转发主机</li><li>实现了转发主机的外网访问之后, 我们再在转发主机上, 进行二次转发. 让流量,从虚拟子网, 转发到内网可以访问的目标主机的80 . </li><li>至此, 方案完成</li></ul><p><img src="https://i.loli.net/2018/02/12/5a810b0b4888d.png" alt="ARCH"></p><h3 id="具体实施"><a href="#具体实施" class="headerlink" title="具体实施"></a>具体实施</h3><p>这里使用 <code>OpenVPN</code> 在这里建立了VPN连接，为了方便管理和配置，（因为只是自己用），所以这里推荐使用 <code>openvpn-as</code> 是一个管理前端。免费版允许两台主机同时连接，自己使用实际上也是已经够了的。配置的过程这里年久失修，脑子里也没有了，难度系数一颗星。</p><p>在搭建完成之后，开始使用客户端进行连接，记得开放主机的安全组端口配置。连接之后，使用 <code>ifconfig</code> 应该会有个 Vlan的 interface 。这里就是我们的 VPN 子网。</p><hr><p>有了子网之后，先互 ping 确保联通。之后使用这里的主角 <code>rinetd</code> 。是一个十分轻量级的端口转发工具。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0.0.0 2333 172.16.64.*** 80</span><br></pre></td></tr></table></figure><p>启动脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pkill rinetd</span><br><span class="line">sudo rinetd -c /etc/rinetd.conf</span><br></pre></td></tr></table></figure><p>这样就实现了，在 <strong>2333</strong> 端口到目的主机的 80端口的内容转发，最终转发的就是我们的 HTTP 的请求。</p><hr><p>同样的，在我们的云服务器上一样需要这样的配置，把用户们输入的请求，转发到我们的 VPN 的子网之中，到内网转发主机的模板端口，来再进行下一次转发。在公网主机上我们一样使用上面类似的配置。只不过，是从 公网 转发到 VPN 子网，反向操作。</p><hr><p>综上，基本的链路已经实现和打通。还会有一点我问题。这样直接访问的话，得到的结果是 <strong>无法连接</strong>。 为什么？</p><p>因为，在默认的路由出了问题。</p><p>路由是什么？怎么用？ 看篇文章：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JlbnlpZm9yZXZlci9hcnRpY2xlL2RldGFpbHMvNzc4NTEwMTI=" title="https://blog.csdn.net/renyiforever/article/details/77851012">win7操作系统双网卡同时上内外网<i class="fa fa-external-link"></i></span></p><p>所以文oveli对路由进行指定：让这个 IP 走我们的 199.1 的网关。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo route add -host 172.16.64.236 gw 192.168.199.1</span><br></pre></td></tr></table></figure><p>至此，整个配置完成。（辣鸡方案）</p><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><p>这篇文章，是一年前的烂尾了，现在才post出来，是为了后面的更好的方案做对比。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个挺重要的网站,奈何只能内网访问, 想着把他外网映射出来…遂为之&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;这篇文章应该是 2018/1/14时候就已经完成了，总是缺一点内容于是就没有post 出去。现在是时候了，因为完成同样的事情，现在有了第二个更好的解决方案，所以这这里 post 上去
      
    
    </summary>
    
      <category term="OP之路" scheme="https://blog.diglp.xyz/categories/OP%E4%B9%8B%E8%B7%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>ELK 日志可视化平台 搭建</title>
    <link href="https://blog.diglp.xyz/2019/02/14/OP_ELK%20%E6%97%A5%E5%BF%97%E5%8F%AF%E8%A7%86%E5%8C%96%20%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/"/>
    <id>https://blog.diglp.xyz/2019/02/14/OP_ELK 日志可视化 搭建笔记/</id>
    <published>2019-02-13T16:00:00.000Z</published>
    <updated>2019-03-04T11:57:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="架构选型"><a href="#架构选型" class="headerlink" title="架构选型"></a>架构选型</h2><p>这里使用ELK 平台主要是实现了单主机的日至手机以及可视化，吞吐量比较小，所以直接进行单点部署。由以下几个组件组成：</p><ul><li>FileBeat</li><li>Elasticsearch</li><li>Kibana</li></ul><p>Filebeat 这里实现日志文件的手机以及格式化，并且通过管道直接存入ES</p><p>ES 作为主体，实现对索引条目进行保存</p><p>Kibana 实现了ELK系统的整体监控，通过 API与ES交互，实现数据可视化，以及设置。</p><ul><li>logstash</li></ul><p>logstash 作为一个对数据进行流处理的module，这里由于不需要对日志进行进一步处理，所以并没有使用此组件。<strong>关键是内存真的不够了，跑不起来了是真的Q</strong></p><h2 id="安装及部署"><a href="#安装及部署" class="headerlink" title="安装及部署"></a>安装及部署</h2><p>安装以及部署的过程实际上并不是十分复杂，在<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby8=" title="https://www.elastic.co/">ELK项目官网<i class="fa fa-external-link"></i></span>上实际上已经给出了相关的 <code>rpm包</code>，所以直接使用 rpm 进行安装即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- 1 root root  12M Jan 29 19:31 filebeat-6.6.0-x86_64.rpm</span><br><span class="line">-rw-r--r-- 1 root root 177M Jan 29 19:34 kibana-6.6.0-x86_64.rpm</span><br><span class="line">-rw-r--r-- 1 root root 163M Jan 29 19:35 logstash-6.6.0.rpm</span><br><span class="line">rpm -ivh xxx.rpm</span><br></pre></td></tr></table></figure><hr><p>这里涉及到的一个 point 是<code>systemV init</code> 还是 <code>systemd</code> 下面给出一篇相关文章，(IBM Developer 还真是个好地方。)</p><blockquote><p> <span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi9saW51eC8xNDA3X2xpdW1pbmdfaW5pdDMvaW5kZXguaHRtbA==" title="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init3/index.html">浅析 Linux 初始化 init 系统，第 3 部分<i class="fa fa-external-link"></i></span></p></blockquote><p>这里提到的是Linux里最重要的启动进程，作为<strong>第一个用户态进程</strong> 其PID为1 <code>ps 1</code> 可以看到进程的运行。他负责在内核启动之后，完成余下的引导过程，比如加载加载服务，启动Shell/图形化界面等等。在 CentOS 7 之后，使用 Systemd 风格取代了原来的 init的风格。（使得启动速度有的提升）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ps 1</span><br><span class="line">  PID TTY      STAT   TIME COMMAND</span><br><span class="line">    1 ?        Ss     2:50 /usr/lib/systemd/systemd --switched-root --system --deserialize 21</span><br></pre></td></tr></table></figure><p>可以看到，这里的 ps1 已经是 systemd 了。</p><p>所以这里又涉及到了，Ubuntu 和 CentOS 的一大差别，自己也是用了才发现，之前Ubuntu的服务启动与管理使用 <code>service</code> 命令，并且在 <code>/etc/inittab</code> 里面可以对初始化进行一系列的配置。在Cent里面写着一句话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">总之在目前的环境中，使用 `systemctl` 命令对服务进行控制。</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">➜  ~ systemctl status elasticsearch.service</span><br><span class="line">● elasticsearch.service - Elasticsearch</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/elasticsearch.service; disabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Tue 2019-02-05 02:39:39 CST; 1 weeks 1 days ago</span><br><span class="line">     Docs: http://www.elastic.co</span><br><span class="line"> Main PID: 27965 (java)</span><br><span class="line">   CGroup: /system.slice/elasticsearch.service</span><br><span class="line">           ├─27965 /bin/java -Xms256m -Xmx256m -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly -Des.networkaddress.cache.ttl=6...</span><br><span class="line">           └─28026 /usr/share/elasticsearch/modules/x-pack-ml/platform/linux-x86_64/bin/controller</span><br></pre></td></tr></table></figure><hr><p>之后修改各自的配置文件，使得其端口对应，一般就可以跑起来了。</p><p>为了安全起见，这里使用 Nginx 做了一个 Web 的认证，对路由进行一个转发。</p><h2 id="环境调整"><a href="#环境调整" class="headerlink" title="环境调整"></a>环境调整</h2><h3 id="ES的JVM-的堆大小调整-（heap）"><a href="#ES的JVM-的堆大小调整-（heap）" class="headerlink" title="ES的JVM 的堆大小调整 （heap）"></a>ES的JVM 的堆大小调整 （heap）</h3><p>启ES的时候，直接报错 <code>unable to alloca</code> ，一想应该是内存太小了导致的问题。查看配置文件 <code>/etc/elasticsearch/jvm.options</code> 并且进行参数调整</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-Xms256m# 这里缺省为 1g</span><br><span class="line">-Xmx256m</span><br></pre></td></tr></table></figure><p>由于本机的RAM也只有 <strong>1G</strong> 还得跑其他的奇怪的东西，所以这里只能非常的乞丐设置。分出一点宝贵内存。</p><h3 id="虚拟内存-Swap-的设置"><a href="#虚拟内存-Swap-的设置" class="headerlink" title="虚拟内存 Swap 的设置"></a>虚拟内存 Swap 的设置</h3><p>由于VM的机能，所以1G的内存显然是不够用的。只能改变参数。使得<code>JVM</code>分配的内存只有 256M。且，启用虚拟内存，即swap。</p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW5sZXNvZnR3YXJlL2FydGljbGUvZGV0YWlscy84NzQxODcz" title="https://blog.csdn.net/tianlesoftware/article/details/8741873">Linux SWAP 交换分区配置说明 - CSDN<i class="fa fa-external-link"></i></span></p><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/zero of=/swap-file bs=1M count=1024# 新建白文件 1G</span><br><span class="line">mkswap /swap-file# 格式化</span><br><span class="line">swapon /swap-file# 启用swap</span><br></pre></td></tr></table></figure><p>为了使swap自动挂载使用 <code>/etc/fstab</code> 里面进行配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UUID=653bbeb5-4abb-4295-b110-5847e073140dswapswapdefaults00</span><br><span class="line">/swap-file swap    swap    defaults00</span><br></pre></td></tr></table></figure><hr><p>顺便调整了 <code>swappiness</code> 使得机器更加积极的使用 虚拟内存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ sysctl vm/swappiness=60</span><br></pre></td></tr></table></figure><h3 id="设置副本数-0"><a href="#设置副本数-0" class="headerlink" title="设置副本数 0"></a>设置副本数 0</h3><p>由于只是单点，且性能受限，这里发现的问题es的节点状态一直是 <code>yellow</code>。归根发现就是性能问题，所以这里进行配置，<strong>设置其分片副本为 0</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -H "Content-Type: application/json" -XPUT 'http://localhost:9202/_settings' -d '</span><br><span class="line">&#123;</span><br><span class="line">    "index" : &#123;</span><br><span class="line">        "number_of_replicas" : 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><p><strong>Happy Valentine’s Day</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;架构选型&quot;&gt;&lt;a href=&quot;#架构选型&quot; class=&quot;headerlink&quot; title=&quot;架构选型&quot;&gt;&lt;/a&gt;架构选型&lt;/h2&gt;&lt;p&gt;这里使用ELK 平台主要是实现了单主机的日至手机以及可视化，吞吐量比较小，所以直接进行单点部署。由以下几个组件组成：&lt;/p&gt;
      
    
    </summary>
    
      <category term="OP之路" scheme="https://blog.diglp.xyz/categories/OP%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="ELK" scheme="https://blog.diglp.xyz/tags/ELK/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 折腾笔记（SSL配置以及路由重写）</title>
    <link href="https://blog.diglp.xyz/2019/02/08/OP_Nginx%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0%EF%BC%88SSL%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E8%B7%AF%E7%94%B1%E9%87%8D%E5%86%99%EF%BC%89/"/>
    <id>https://blog.diglp.xyz/2019/02/08/OP_Nginx折腾笔记（SSL配置以及路由重写）/</id>
    <published>2019-02-07T16:00:00.000Z</published>
    <updated>2019-03-04T11:57:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前面的话"><a href="#前面的话" class="headerlink" title="前面的话"></a>前面的话</h2><p>需求分析，由于 搭好了日志平台，本想着把Blog迁移到主机上，最后想想，算了</p><p>这里的博客的域名，本来是通过 在解析配置里面使用了一个 <code>CNAME</code>到 <a href="quartz010.github.io">quartz010.github.io</a> 实现一次访问，这里对架构进行一次调整。原 <code>blog</code>的二级先解析到服务器，留下日志之后，进行一次隐式跳转，实现一次访问。不过，这样会受限于服务器的带宽。但是也算是接入了日志平台。所以这里需要使用 Nginx  实现重定向。</p><hr><p>其二，域名不备案，web一起来，就被工信部给 ban 了。可是备案太麻烦了，真的是懒。所以这里跑 HTTPS ，做一个短期的检测绕过。因为 HTTPS 其报文内容是加密的，所以流量只要不是很大，应该也不至于单独去做侧信道的分析。所以这里顺便给部署全站的  HTTPS 访问暂时的撑着。</p><h2 id="显式重定向-和-隐式重定向"><a href="#显式重定向-和-隐式重定向" class="headerlink" title="显式重定向 和 隐式重定向"></a>显式重定向 和 隐式重定向</h2><p>这里的一点调整在于 Github page 的命名</p><p>当repo 命名为 <code>quartz010.github.io</code> 可以直接通过 其进行访问，如果其他命名的话，需要进行 quartz010.github.io/xxx 进行访问，所以修改之后导致了其找不到静态文件。导致样式消失以及一大堆404 的问题。</p><p>这里给出 基本配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">listen</span>       [::]:<span class="number">80</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="attribute">server_name</span> blog1.diglp.xyz;</span><br><span class="line">   </span><br><span class="line">   <span class="comment"># Load configuration files for the default server block.</span></span><br><span class="line">   <span class="attribute">include</span> /etc/nginx/default.d/<span class="regexp">*.conf</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="attribute">location</span> / &#123;</span><br><span class="line">   <span class="comment">#rewrite  ^/(.*)$  /$1 break;</span></span><br><span class="line">   <span class="attribute">proxy_pass</span> https://quartz010.github.io;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment"># rewrite "^/(.*)$" https://quartz010.github.io/$1 last;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的重点在 Location 的这一段：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line"><span class="comment">#1# rewrite  ^/(.*)$  /$1 break;# 隐式重定向</span></span><br><span class="line"><span class="comment">#2# proxy_pass https://quartz010.github.io;# 显式重定向</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的重定向方式有两种，不过严格意义上讲，通过<code>proxy_pass</code>实现的只能叫做反向代理。不过这里用到了实现 Url不改变的重定向，也权且这样叫吧。 后面讲路由重写，这里先看这个正则表达式 <code>^/(.*)$</code> 代表以 <code>/</code> 开头中间匹配 <code>.*</code> (也就是任意个单字符)，之后再进行结尾。综上是匹配所有的路由。</p><h2 id="路由重写"><a href="#路由重写" class="headerlink" title="路由重写"></a>路由重写</h2><p>路由的重写，这里算得上是很重要的一个模块了。一般 Nginx 默认编译需要 加上 Pcre 的正则的库，其基本语法如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">rewrite</span> 规则 定向路径 重写类型;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>规则：用于匹配的 URL 或者是正则表达式。</li><li>重定向之后的链接，可以带参数</li><li><p>重写类型：</p><ul><li>last ：表示完成rewrite，浏览器地址栏URL地址不变</li><li>break：本条规则匹配完成后，终止匹配，不再匹配后面的规则，浏览器地址栏URL地址不变</li><li>redirect：返回302临时重定向，浏览器地址会显示跳转后的URL地址</li><li>permanent：返回301永久重定向，浏览器地址栏会显示跳转后的URL地址</li></ul></li><li><p><strong>作用域:</strong> <em>server, location, if</em></p></li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span>  https://<span class="variable">$host</span><span class="variable">$1</span> <span class="literal">permanent</span></span><br></pre></td></tr></table></figure><p>这里的重写类型是可选项，也可以不进行指定。这里值得注意的是，last 和 break 类型的区别。last 可以理解为，对url改变之后，继续对url进行重写匹配，知道最后没有相关规则时候便停止。break 在完成本次的重写之后，就不进行后继的匹配重写。eg</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">rewrite</span> /<span class="number">111</span>/ /<span class="number">555</span>/ <span class="literal">last</span>;</span><br><span class="line">        <span class="attribute">rewrite</span> /<span class="number">222</span>/ /<span class="number">555</span>/ <span class="literal">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /<span class="number">555</span>/ &#123;</span><br><span class="line">        internal;</span><br><span class="line">        empty_gif;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这样的配置下。得到的结果是 访问 <code>/111/</code> 的时候，直接返回了403的页面。而访问 <code>/222/</code> 的时候，得到了404的返回。不过，值得注意的是， <code>111</code> 返回了 403 的内容，但是实际上的 URL 并没有发生改变。即：</p><p><strong>xxx/111/ 的 URL 实际上是返回了 /555/ 的内容</strong>  </p><h2 id="SSL-配置"><a href="#SSL-配置" class="headerlink" title="SSL 配置"></a>SSL 配置</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>SSL 在http的具体应用就是 HTTPS （<strong>HTTP over TLS</strong>）。</p><blockquote><p>HTTPS的主要思想是在不安全的网络上创建一安全信道，并可在使用适当的加密包和<em>服务器证书可被验证且可被信任时</em>，对<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUFCJThBJUU4JTgxJUJE" title="https://zh.wikipedia.org/wiki/%E7%AB%8A%E8%81%BD">窃听<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUI4JUFEJUU5JTk3JUI0JUU0JUJBJUJBJUU2JTk0JUJCJUU1JTg3JUJC" title="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB">中间人攻击<i class="fa fa-external-link"></i></span>提供合理的防护。</p></blockquote><p>一样回到PKI（Public Key Instruction）的体系里面，其中一个重要的概念就是 HTTPS 的证书。</p><p>在普通的点对点加密里面，另个客户端可以直接进行秘钥的商定。</p><p>但是在 BS 里面，服务器将面临多个客户端的请求，如果使用自签发证书，会出现证书可能会被伪造。可能会有其他的客户端使用伪造的证书进行HTTPS通信。</p><p>常见的应用在于使用 <strong>SSLstrip</strong> 进行证书伪造攻击，以实现把HTTPS流量降级到HTTP。</p><p>为了<strong>避免</strong>这样的情况出现，这里就出现了 CA机构（Certificate Authority）用于进行一个可信的第三方证书保管。证书由可信第三方提供，不是直接从服务器获得，所以保护了证书被伪造的可能。</p><h3 id="证书配置"><a href="#证书配置" class="headerlink" title="证书配置"></a>证书配置</h3><p>直接在云服务商的website上面申请域名证书，这里申请的是针对 <a href="">mine.diglp.xyz</a> 的单域名证书。可以免费申请。不过 CA 机构是 <strong>TrustAsia</strong> 据说这个真的不值得Trust。。。这就另说了。</p><p>这里了解一下文件分布：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">|-- Apache</span><br><span class="line">|   |-- 1_root_bundle.crt</span><br><span class="line">|   |-- 2_mine.diglp.xyz.crt</span><br><span class="line">|   `-- 3_mine.diglp.xyz.key</span><br><span class="line">|-- IIS</span><br><span class="line">|   `-- mine.diglp.xyz.pfx</span><br><span class="line">|-- Nginx</span><br><span class="line">|   |-- 1_mine.diglp.xyz_bundle.crt</span><br><span class="line">|   `-- 2_mine.diglp.xyz.key</span><br><span class="line">`-- Tomcat</span><br><span class="line">    `-- mine.diglp.xyz.jks</span><br></pre></td></tr></table></figure><p>tree 一下目录，可见已经根据不同的Server给分成了不同的类型。内容都是一样，进行了一定程度的合并和拆分而已</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ssl_certificate</span> <span class="string">"/xxx/1_mine.diglp.xyz_bundle.crt"</span>;                    </span><br><span class="line"><span class="attribute">ssl_certificate_key</span> <span class="string">"/xxx/2_mine.diglp.xyz.key"</span>;           </span><br><span class="line"><span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">1m</span>;                                             </span><br><span class="line"><span class="attribute">ssl_session_timeout</span>  <span class="number">10m</span>;                                                    </span><br><span class="line"><span class="attribute">ssl_ciphers</span> HIGH:!aNULL:!MD5;                                                </span><br><span class="line"><span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br></pre></td></tr></table></figure><p>这样就很轻松的完成了Https的配置。</p><h2 id="全站使用-HTTPS-的实现"><a href="#全站使用-HTTPS-的实现" class="headerlink" title="全站使用 HTTPS 的实现"></a>全站使用 HTTPS 的实现</h2><p>这里很巧妙的使用了重定向，实现了全站的HTTPS。通过对HTTP流量进行重定向实现</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">80</span> default_server;</span><br><span class="line">    <span class="comment">#listen [::]:80;</span></span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$host</span>:9943<span class="variable">$request_uri</span>;</span><br><span class="line">    <span class="comment">#rewrite ^(.*)$  https://$host$1 permanent;</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这里对所有的请求，直接重定向到HTTPS。很是巧妙</p><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><p>很多事，很多事，面对审判吧。</p><p>用的就记录下来</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前面的话&quot;&gt;&lt;a href=&quot;#前面的话&quot; class=&quot;headerlink&quot; title=&quot;前面的话&quot;&gt;&lt;/a&gt;前面的话&lt;/h2&gt;&lt;p&gt;需求分析，由于 搭好了日志平台，本想着把Blog迁移到主机上，最后想想，算了&lt;/p&gt;
&lt;p&gt;这里的博客的域名，本来是通过 在
      
    
    </summary>
    
      <category term="OP之路" scheme="https://blog.diglp.xyz/categories/OP%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Nginx" scheme="https://blog.diglp.xyz/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 折腾笔记 （路由配置以及认证）</title>
    <link href="https://blog.diglp.xyz/2019/02/07/OP_Nginx%20%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0%20%EF%BC%88%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E8%AE%A4%E8%AF%81%EF%BC%89/"/>
    <id>https://blog.diglp.xyz/2019/02/07/OP_Nginx 折腾笔记 （路由配置以及认证）/</id>
    <published>2019-02-06T16:00:00.000Z</published>
    <updated>2019-03-04T11:57:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前面的话"><a href="#前面的话" class="headerlink" title="前面的话"></a>前面的话</h2><blockquote><p>2008年，第一款安卓手机诞生，HTC G1。智能手机的十年，像是人类的一个世纪</p><p>在十年前的时候，互联网哪里有普及呢？</p><p>十年之后，世界又将怎样？</p><p>每种技能的经济价值是很快会下降的</p></blockquote><hr><p>又是拖延症爆炸的时间，这篇博文开了都自己墨迹了这么久，竟然几天之后才开始继续写，没救了。</p><p>这篇主要就是写，Nignx 的路由匹配，和一些基本的认证操作。</p><h2 id="Nginx-的认证配置"><a href="#Nginx-的认证配置" class="headerlink" title="Nginx 的认证配置"></a>Nginx 的认证配置</h2><p>这里使用 Nginx 的基础的身份认证功能，来实现对页面访问的授权访问。采用 <code>htpasswd</code> 来实现了鉴权。这个是 apache 的资自带的工具，这里也可以使用 <code>OpenSSL</code>来生成密码文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c "echo -n 'admin:' &gt;&gt; /etc/nginx/.htpasswd"</span><br><span class="line">sudo sh -c "openssl passwd -apr1 &gt;&gt; /etc/nginx/.htpasswd"</span><br></pre></td></tr></table></figure><hr><p>在 Nginx 的conf 文件中，在指定的路由路径的配置下面使用如下的配置语句：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">auth_basic</span> <span class="string">"Authorized users only"</span>;<span class="comment"># 验证提示框</span></span><br><span class="line"><span class="attribute">auth_basic_user_file</span> /home/.htpasswd;<span class="comment"># 鉴权密码文件</span></span><br></pre></td></tr></table></figure><p>在最终的 Nginx 配置里的实例配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span><span class="regexp"> ^~/asd/</span> &#123;</span><br><span class="line"><span class="attribute">auth_basic</span> <span class="string">"Is You?"</span>;</span><br><span class="line">    <span class="attribute">auth_basic_user_file</span> /etc/nginx/.htpasswd_k;    </span><br><span class="line">   </span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://localhost:5601/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在对目的路由进行请求的时候，会被要求用户鉴权。</p><p>至此，配置完成</p><h2 id="Nginx-路由配置"><a href="#Nginx-路由配置" class="headerlink" title="Nginx 路由配置"></a>Nginx 路由配置</h2><p><code>location</code> 在 Nginx 里面是相当常见的，用于对路由路径的匹配。</p><p>通配符在这里是一个重点，</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">location [=|~|~*|^~] /uri/ &#123; … &#125;</span><br><span class="line">location modifier uri &#123;...&#125;</span><br></pre></td></tr></table></figure><h3 id="匹配类型"><a href="#匹配类型" class="headerlink" title="匹配类型"></a>匹配类型</h3><table><thead><tr><th>匹配类型</th><th>描述</th></tr></thead><tbody><tr><td>=</td><td>完全匹配 斜杠都不能多</td></tr><tr><td>~</td><td>大小写敏感 pattern 是正则表达式</td></tr><tr><td>(None)</td><td>匹配相似的部分pattern 部分相似即匹配</td></tr><tr><td>~*</td><td>大小写不敏感 pattern 是正则表达式</td></tr><tr><td>^~</td><td>和 None 类似，但是一旦匹配，即停止匹配</td></tr><tr><td>@</td><td>只能被内部访问 同 internal？</td></tr></tbody></table><h3 id="匹配示例"><a href="#匹配示例" class="headerlink" title="匹配示例"></a>匹配示例</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span><span class="regexp"> ^~</span> /us/ &#123;</span><br><span class="line"><span class="attribute">auth_basic</span> <span class="string">"Is You?"</span>;</span><br><span class="line">    <span class="attribute">auth_basic_user_file</span> /etc/nginx/.htpasswd;</span><br><span class="line">    <span class="attribute">alias</span> /usr/share/nginx/html/us/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用 <code>^~</code> 修饰符指定了是部分匹配的，但是使用了 <code>/xxx/</code> 的结构基本上也是实现了完全匹配。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line"><span class="attribute">proxy_pass</span>   http://127.0.0.1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大小写匹配的正则表达式，匹配以 <code>.php</code> 结尾的项目，转发到 fastcgi。<code>\.</code> 是转义的 <code>.</code></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~* .(gif|jpg|jpeg)$</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前面的话&quot;&gt;&lt;a href=&quot;#前面的话&quot; class=&quot;headerlink&quot; title=&quot;前面的话&quot;&gt;&lt;/a&gt;前面的话&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;2008年，第一款安卓手机诞生，HTC G1。智能手机的十年，像是人类的一个世纪&lt;/p&gt;
&lt;p&gt;在
      
    
    </summary>
    
      <category term="OP之路" scheme="https://blog.diglp.xyz/categories/OP%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Nginx" scheme="https://blog.diglp.xyz/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>写给小安的WEB入坑指南</title>
    <link href="https://blog.diglp.xyz/2019/01/30/web_%E5%86%99%E7%BB%99%E5%B0%8F%E5%AE%89%E7%9A%84WEB%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    <id>https://blog.diglp.xyz/2019/01/30/web_写给小安的WEB入坑指南/</id>
    <published>2019-01-29T16:00:00.000Z</published>
    <updated>2019-03-04T11:57:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是web"><a href="#什么是web" class="headerlink" title="什么是web"></a>什么是web</h2><blockquote><p>web（World Wide Web）即全球广域网，也称为万维网，它是一种基于超文本和HTTP的、全球性的、动态交互的、跨平台的分布式图形信息系统。</p></blockquote><p>这里引用自百科，这这里就粗浅的理解为我们的网站吧。</p><h2 id="前端和后端"><a href="#前端和后端" class="headerlink" title="前端和后端"></a>前端和后端</h2><p>WEB的结构是 <code>B/S</code>模式（Browser/Server，浏览器/服务器模式），这种模式区别于 <code>C/S</code> （Client/Server）模式。</p><p>（想想CS模式，常见的是我们的桌面软件（QQ，etc）），所以 BS 的特点就是<strong>功能在服务器的高度集中</strong>，使用浏览器就可以和所需的不同服务进行交互。</p><hr><p>前端后端，是我们在web方面听到的较多的词汇，其实际上的功能是什么呢？</p><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p><strong>提词：</strong></p><ul><li>HTML （How to meet lady）（页面的主体，可以理解为ppt的内容）</li><li>CSS        （决定ppt内容的样子，方的圆的）</li><li>JavaScript    （赋予了页面动态的效果）</li><li>BootStrap    （用于设计界面的一个框架）</li><li>JQuery        （用于更好的动态功能的组件）</li><li>…</li></ul><p>好，上面的名词看晕了，那么现在就来看看什么是前端。</p><p>简单切不严谨的说，用户通过浏览器直接接触到的东西就是前端。那么怎么讲呢？简单！按一下 <code>F12</code>就看见了熙熙攘攘的代码堆起来了。</p><hr><p>鼠标在元素选项卡(Element)，选中 Html 中的不同标签，发现其是在页面中是一一对应的。所以说，页面的内容和我们 HTML 中的标签是一一对应的（不严谨），这样就可以得出结论，HTML 是页面的骨架对吧，构建出了整个页面的<strong>基本内容</strong>。</p><blockquote><p>HTML 就是PPT的内容，实现了基本的页面内容</p></blockquote><hr><p>接下来，就是介绍 JavaScript 的时候了，JS 这个名号听着厉害，实际上一直在浏览器上跑着呢。这里继续 <code>F12</code> 在里面找到 <strong>控制台(Console)</strong>，在里面输入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">'love ann!'</span>);</span><br><span class="line">confirm(<span class="string">'Would U like be With me?'</span>);</span><br></pre></td></tr></table></figure><p>(如果看到这里，可以去跑一下晚上的神秘代码！)</p><p>所以 JS 的功能呢，就是可以赋予网页动态的灵魂（类比给 ppt 加上了动画），这样就可以实现很多炫酷的效果。这些代码在浏览器里偷偷运行着。</p><p>或者试试这个？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.map($(<span class="string">'div'</span>), <span class="function"><span class="keyword">function</span>(<span class="params">e,t,n</span>)</span>&#123;$(e).css(&#123;<span class="string">"background"</span>: <span class="string">"red"</span>&#125;);&#125;)</span><br></pre></td></tr></table></figure><p>红彤彤的，是不是一下子就过年了？？？</p><blockquote><p>JS 就是 PPT 里面的动画，实现了动态效果，比如点击消失</p></blockquote><hr><p>CSS （Cascading Style Sheets） 层叠样式表，是不是有些时候页面加载出来很奇怪？ 比如一堆内容堆在了屏幕的坐标，刷新几次就好了？ 这里就是这个CSS没有加载出来。</p><p>简单的说呢？ 这个东西是来配置一个<strong>页面元素</strong> 长什么样子的，怎么说呢？我们还是看上面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.map($(<span class="string">'div'</span>), <span class="function"><span class="keyword">function</span>(<span class="params">e,t,n</span>)</span>&#123;$(e).css(&#123;<span class="string">"background"</span>: <span class="string">"red"</span>&#125;);&#125;)</span><br></pre></td></tr></table></figure><p>虽然有点晕晕的，不过我们看里面的部分 <code>css({&quot;background&quot;: &quot;red&quot;})</code> 是不是瞬间熟悉了，这里其实完成的就是对元素的样式进行了调整，把背景设置成了红彤彤。</p><hr><p>好的，前端我说完了 XD</p><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p><strong>提词：</strong></p><ul><li><p>Web服务器 Nginx Apache</p></li><li><p>数据库 Mysql， MongoDB，Redis …</p></li><li><p>PHP，Python，Java …</p></li><li><p>ThinkPHP，Django，Spring …</p></li><li><p>这里的词就有些模式了吧？ 慢慢来</p></li></ul><p>现在我们到了，后端了。这个又怎么说？一句话，用户摸不到的地方就是后端。怎么理解呢？</p><p>看我们平时登陆一些服务的时候，这个过程一定熟悉。我们的账户就保存在 后端的 数据库之中，每每我们登陆的时候，把账号密码发送给目标服务器，服务器帮我验证，你的密码和注册的时候是不是一样的，从而判断是不是你。（不可能放在前端对吧？否则 你 F12 就看见密码了，吼吼吼）</p><hr><p>先从 WEB服务器来讲吧，这到底是个啥呢？ </p><p>我们的Html文件，在本地磁盘上，我们直接双击打开，看已经打开了一个网页了对吧？</p><p>那么 WEB服务器 的功能，<strong>就是帮你找东西</strong>。比如我要访问这个链接</p><p><a href="https://blog.diglp.xyz/2019/01/20/Nginx%20log/index.html">https://blog.diglp.xyz/2019/01/20/Nginx%20log/index.html</a></p><p>分段来看：</p><ul><li><a href="https://blog.diglp.xyz">https://blog.diglp.xyz</a>                    这里就是访问了服务器对吧</li><li>/2019/01/20/Nginx%20log/index.html      这里呢？就是在服务器里面找东西了</li></ul><p>想想昨天的 <code>pwd</code> 是不是就好理解了？</p><hr><p>数据库，这里其实听名字就知道啦，存数据的地方。我们可以使用 <code>SQL</code> （Structured Query Language）语言，对数据进行查询。</p><p>MongoDB 是一种新式数据库，基于文件的  NoSQL， 突破了结构化的限制 是  <strong>NoSQL</strong> （Not Only）</p><p>Redis 实现在内存中实现数据存储，数据更快，一般用于请求量极大的数据，保持高命中率。</p><hr><p>编程语言，和编程框架，这里放在一起啦。上面的每一种语言 都可以轻松实现一个 hello world。</p><ul><li>PHP 本身是一种编程语言，是和 python 一个层级，.py 需要 python runtime 。.php 需要 php 的 runtime。两个东西都可以很简单的使用 <code>python x.py</code> 和 <code>php x.php</code> 的运行起来</li><li>当 python 使用 flask/Django 开始 web 开发的时候了。和 PHP 的 web 框架 (ThinkPHP) 作用在一个层级了。<strong>不准确的讲</strong>每次访问，都会启动一个进程，对这个脚本内的内容进行运行， 这里的运行是在服务器端的。对我的的请求进行解析，比如 url 的路由路径， 请求方式等进行响应。</li><li>这时候仍然是在服务器端， 进行数据库的增删查改。 把操作 (得到的数据，传递到前端) <code>index.php?category=x</code></li><li>前端进行数据获取，由 js 脚本，实现静态 html 的显示刷新</li></ul><p>XD 这里我从之前的地方 Copy了，饿了！</p><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="function"><span class="keyword">function</span>(<span class="params">p,a,c,k,e,d</span>)</span>&#123;e=<span class="function"><span class="keyword">function</span>(<span class="params">c</span>)</span>&#123;<span class="keyword">return</span>(c&lt;a?<span class="string">""</span>:e(<span class="built_in">parseInt</span>(c/a)))+((c=c%a)&gt;<span class="number">35</span>?<span class="built_in">String</span>.fromCharCode(c+<span class="number">29</span>):c.toString(<span class="number">36</span>))&#125;;<span class="keyword">if</span>(!<span class="string">''</span>.replace(<span class="regexp">/^/</span>,<span class="built_in">String</span>))&#123;<span class="keyword">while</span>(c--)d[e(c)]=k[c]||e(c);k=[<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">return</span> d[e]&#125;];e=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span><span class="string">'\\w+'</span>&#125;;c=<span class="number">1</span>;&#125;;<span class="keyword">while</span>(c--)<span class="keyword">if</span>(k[c])p=p.replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\\b'</span>+e(c)+<span class="string">'\\b'</span>,<span class="string">'g'</span>),k[c]);<span class="keyword">return</span> p;&#125;(<span class="string">'7["\\6\\8\\a\\9\\2"](\'\\1\\1\\5\\4\\3\\h\\g\\i\\k\\j\\c\\b\\0\\0\\d\\f\\e\');'</span>,<span class="number">21</span>,<span class="number">21</span>,<span class="string">'u661f|u563b|x74|u505a|uff01|u6bdb|x61|window|x6c|x72|x65|uff08|x7e|u773c|uff09|u2728|u5973|u6211|u670b|u5427|u53cb'</span>.split(<span class="string">'|'</span>),<span class="number">0</span>,&#123;&#125;))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是web&quot;&gt;&lt;a href=&quot;#什么是web&quot; class=&quot;headerlink&quot; title=&quot;什么是web&quot;&gt;&lt;/a&gt;什么是web&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;web（World Wide Web）即全球广域网，也称为万维网，它是一种基于超文
      
    
    </summary>
    
      <category term="WEB" scheme="https://blog.diglp.xyz/categories/WEB/"/>
    
    
      <category term="web" scheme="https://blog.diglp.xyz/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 折腾笔记（LB 和 Tunnel）</title>
    <link href="https://blog.diglp.xyz/2019/01/20/OP_Nginx%20%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0%EF%BC%88LB%20%E5%92%8C%20Tunnel%EF%BC%89/"/>
    <id>https://blog.diglp.xyz/2019/01/20/OP_Nginx 折腾笔记（LB 和 Tunnel）/</id>
    <published>2019-01-19T16:00:00.000Z</published>
    <updated>2019-03-04T11:57:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前面的话"><a href="#前面的话" class="headerlink" title="前面的话"></a>前面的话</h2><p>突然又是折腾了一波nginx，其中一点点的配置和过程在这里记录一下。</p><p>下午又把 《社交网络》这部片看了一遍，又是一种熟悉的热血沸腾的感觉。</p><p>思考自己仿佛也是在同样的年龄，但是，为什么却是那种的遥不可及的的感觉，</p><p>也许这个就是文化吧。一定去西海岸！</p><blockquote><p> drop the The, just Facebook</p></blockquote><hr><ol><li><p>这世道，绅士做不了。海盗才是王。</p></li><li><p>签任何协议之前至少看3遍以上。 </p></li><li>出卖你的往往是你最好的朋友</li></ol><h2 id="之前的场景"><a href="#之前的场景" class="headerlink" title="之前的场景"></a>之前的场景</h2><p>内网不通，怎么打洞，使得外网可以访问。内网打洞。</p><p>原始方案，两次端口转发，加上 VPN。这样实现协议栈倒是没有加其他的东西，都团原生的。</p><p>后面 想想，使用 <code>frp</code> 或者 <code>ngrok</code>  直接实现内网的转发，到还是一个更好的方法了。之前的只是赞成做了个理论性的尝试，没想到，ei？还真是能用。</p><hr><p>方案的两次转发，主要在于，不同网段之间的转发。</p><ol><li>由服务器 外网的网段， 转发到 VPN 的子网网段的内网主机 IP</li><li>在内网主机上，由VPN的子网网段，转发到内网网卡</li><li>并且设置内网的网卡路由走内网网关</li></ol><hr><h2 id="Nginx-Port-forwarding-and-Load-Balance"><a href="#Nginx-Port-forwarding-and-Load-Balance" class="headerlink" title="Nginx Port forwarding and Load Balance"></a>Nginx Port forwarding and Load Balance</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">stream</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> <span class="number">127.0.0.1:7000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件很容易的实现了 <strong>80到7000端口</strong> 的转发，</p><p>下面的配置很容易实现转发的 <strong>LB</strong> 这里就会有很好的用处</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">stream</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> frp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">upstream</span> frp&#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.1:7000</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.1:8000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>这里一个point 是 <strong>七层均衡</strong> 还是 <strong>四层均衡</strong>。这里的层指的是在协议栈中的层级 ，OSI 的七层结构，其中的七层均衡指的就是在应用层实现的（HTTP），四层就是在传输层（tcp）。</p><p>这里的配置段是存在于 stream 的不是在 Http中。</p><hr><p>这里本来有个突然很荒谬的想法：能不能使用 server_name 用来对不同的 <strong>referer</strong> 进行都不同端口的转发。</p><p>（事实上，当然可以通过虚拟主机，在同一个端口上，通过 server_name 字段来解析到不同的端口，配置如下）</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> baidu&#123; </span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8081</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="attribute">upstream</span> google &#123; </span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8082</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123; </span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>; </span><br><span class="line">    <span class="attribute">server_name</span> www.baidu.cn baidu.cn;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>   Host             <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>   X-Real-IP        <span class="variable">$remote_addr</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>   X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    <span class="attribute">location</span> / &#123; </span><br><span class="line">        <span class="attribute">proxy_pass</span> http://baidu; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123; </span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>; </span><br><span class="line">    <span class="attribute">server_name</span> www.google.cn google.cn;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>   Host             <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>   X-Real-IP        <span class="variable">$remote_addr</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>   X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://google; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以，实现在同一端口的来自已不同站点的请求，分配到各自不同的 server。</p><hr><p>当时就想，能不能 我的 Frp 连接也可以实现这样的域名绑定呢？当时有点懵，显然回答是不行的。</p><p>回到<strong>Domain Name</strong> 的解析原理，最终是在 Dns server 解析成为真实的 IP 。在进行 HTTP 的forward 的时候，其源站实际上是包含在 HTTP 的请求包里面的，所以，Nginx 可以对其不同的源站解析的不同的端口。</p><p>那么这里回到前面 的情况，如果是使用了nginx 来对一个 tcp 连接进行分发。可能实现吗？</p><p>不可能，因为，根本无法获得源站的地址呀。这里就是问题所在了。</p><h2 id="关于-Nginx-LB-的配置"><a href="#关于-Nginx-LB-的配置" class="headerlink" title="关于 Nginx LB 的配置"></a>关于 Nginx LB 的配置</h2><p>这里就顺便，巩固一下 LB 的相关配置：</p><h3 id="Nginx-的-LB-类型"><a href="#Nginx-的-LB-类型" class="headerlink" title="Nginx 的 LB 类型"></a>Nginx 的 LB 类型</h3><p><strong>nginx 的 upstream目前支持 4 种方式的分配</strong> 引用自（<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbWljcm90aWdlci9wLzc2MjM4NTguaHRtbO+8iQ==" title="https://www.cnblogs.com/microtiger/p/7623858.html）">https://www.cnblogs.com/microtiger/p/7623858.html）<i class="fa fa-external-link"></i></span></p><ol><li>轮询（默认） </li></ol><p>　　每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，<strong>能自动剔除</strong>。 </p><ol><li>weight </li></ol><p>　　指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 </p><ol><li>ip_hash </li></ol><p>　　每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。  </p><ol><li>fair（第三方） </li></ol><p>　　按后端服务器的响应时间来分配请求，响应时间短的优先分配。  <strong>这个感觉不错，后面可以试试</strong></p><ol><li>url_hash（第三方）</li></ol><hr><p>ip_hash是容易理解的，但是因为仅仅能用ip这个因子来分配后端，因此ip_hash是有缺陷的，不能在一些情况下使用：</p><p>nginx不是最前端的服务器。ip_hash要求nginx一定是最前端的服务器，否则nginx得不到正确ip，就不能根据ip作hash。譬如使用的是squid为最前端，那么nginx取ip时只能得到squid的服务器ip地址，用这个地址来作分流是肯定错乱的。</p><p>这里就最好使用 Url_hash 的方式，根据 不同的 Url 进行分流。</p><hr><p>不过这里又有了一个严重的问题 ：<strong>Session 和 Cookie</strong>，这里直接贴出文章。本来想总结一下 ， 已经有写好的了，自己也学习一下</p><blockquote><p> <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc2hpeWFuZ3h0L2FydGljbGVzLzEzMDU1MDYuaHRtbA==" title="https://www.cnblogs.com/shiyangxt/articles/1305506.html">cookie 和session 的区别详解<i class="fa fa-external-link"></i></span></p></blockquote><p>cookie 和session 的区别：</p><ol><li><p><strong>cookie数据存放在客户的浏览器上，session数据放在服务器上</strong></p></li><li><p>cookie不是很安全，<strong>别人可以分析存放在本地的COOKIE</strong>并进行COOKIE欺骗考虑到安全应当使用session。</p><p>httpOnly ：JS 无法读取到 cookie</p></li><li><p>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。</p></li><li><p>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p><p><strong>这里比较好玩， 可以将 Cookie 设置为 大于 4096 的kv，这样的话，将会直接导致 客户端的 Deny</strong></p></li><li><p>所以个人建议：</p><p>将登陆信息等重要信息存放为SESSION （存在 Session 注入的问题？）<br>其他信息如果需要保留，可以放在COOKIE中</p></li></ol><h2 id="知识树"><a href="#知识树" class="headerlink" title="知识树"></a>知识树</h2><p>这个比较好玩， 以后每次类似的 blog 的时候就加上 吧，做个自己的思路方向的记录：</p><ul><li>nginx 的 LB<ul><li>通过 域名 的TCP 转发可行性</li><li>nginx 的 LB 的种类<ul><li>IP_hash 的问题</li><li>URL_hash 的 session问题<ul><li>session和Cookie<ul><li>httpOnly</li></ul></li></ul></li></ul></li></ul></li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前面的话&quot;&gt;&lt;a href=&quot;#前面的话&quot; class=&quot;headerlink&quot; title=&quot;前面的话&quot;&gt;&lt;/a&gt;前面的话&lt;/h2&gt;&lt;p&gt;突然又是折腾了一波nginx，其中一点点的配置和过程在这里记录一下。&lt;/p&gt;
&lt;p&gt;下午又把 《社交网络》这部片看了一遍，又
      
    
    </summary>
    
      <category term="OP之路" scheme="https://blog.diglp.xyz/categories/OP%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Nginx" scheme="https://blog.diglp.xyz/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Docker 初步</title>
    <link href="https://blog.diglp.xyz/2019/01/08/OP_Docker_proj/"/>
    <id>https://blog.diglp.xyz/2019/01/08/OP_Docker_proj/</id>
    <published>2019-01-07T16:00:00.000Z</published>
    <updated>2019-03-04T11:57:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>这篇，是一个Docker 的实战篇，使用Docker实现一个文件上传的web页面。ps：本来是要实现上传后自动编译并且允许返回结果的。因为各种原因就烂尾了，就这样吧先。</p><p>因为这篇，是比较基础的操作，很多东西还是有悖了Docker的 <strong>Build，ship，and run</strong> 的思想。这里还需要进行手动，所以显得比较有悖初衷。不过做一个过程的记录还是可以的。</p><hr><p>后面就打算实现一个标标准准的Docker 的工程，体现出 <strong>微服务</strong> 的思想。</p><blockquote><p>Docker 的一个容器理应是只跑一个进程（服务）的。</p></blockquote><h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><p>先从Dockerhub上拉镜像，这里需要 Nginx 和 Uwsgi，这里选取了<span class="exturl" data-url="aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9yL3RpYW5nb2xvL3V3c2dpLW5naW54" title="https://hub.docker.com/r/tiangolo/uwsgi-nginx">tiangolo/uwsgi-nginx<i class="fa fa-external-link"></i></span> 这个镜像。 </p><p>在启动镜像的时候使用交互模式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd -p 80:80 --name test2 docker.io/tiangolo/uwsgi-nginx:latest /bin/sh</span><br></pre></td></tr></table></figure><p>这个时候，Dockerfile 里面的CMD命令将会被重载为后面的 <code>/bin/sh</code></p><p>在交互模式下，attach 了容器之后，可以使用 <code>ctrl+p，ctrl+q</code> 组合键进行 detach</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker attach bf00008eee04</span><br><span class="line">docker attach test2</span><br></pre></td></tr></table></figure><hr><p>创建挂载卷容器，在对应的环境 编译 uwsgi， 之后可以之间拷贝到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -tdi -v /tmp/tttmm/:/tmp/mm --name share docker.io/tiangolo/uwsgi-nginx:latest /bin/bash</span><br></pre></td></tr></table></figure><p>这里使用 bash 好用得多。另外这里附上 uwsgi 的CGI版本的一键编译的script：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://uwsgi.it/install | bash -s cgi /tmp/uwsgi</span><br></pre></td></tr></table></figure><hr><h2 id="CGI-部署"><a href="#CGI-部署" class="headerlink" title="CGI 部署"></a>CGI 部署</h2><p>跑一个综合的容器， 有端口映射以及卷挂载功能：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -tdi -p 80:80 -v /tmp/tttmm/:/tmp/mm --name share docker.io/tiangolo/uwsgi-nginx:latest /bin/bash</span><br></pre></td></tr></table></figure><p>由于 镜像自带的uwsgi 的版本是app的，其没有编译 CGI 功能。所以在这里需要进行替换。之间在容器内使用上述命令进行编译。对 <code>/usr/local/bin/uwsgi</code> 进行替换，对配置文件进行修改</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[uwsgi]</span></span><br><span class="line"><span class="attr">socket</span> = /tmp/uwsgi.sock</span><br><span class="line"><span class="attr">chown-socket</span> = nginx:nginx</span><br><span class="line"><span class="attr">chmod-socket</span> = <span class="number">664</span></span><br><span class="line"><span class="attr">hook-master-start</span> = unix_signal:<span class="number">15</span> gracefully_kill_them_allroot@<span class="number">251</span>a2c8dc0b2:/usr/local/bin#</span><br></pre></td></tr></table></figure><p>这里是用户自定义的：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[uwsgi]</span></span><br><span class="line"><span class="attr">plugins</span> = cgi</span><br><span class="line"><span class="attr">cgi</span> = /app</span><br><span class="line"><span class="attr">cgi-allowed-ext</span> = .py</span><br><span class="line"><span class="attr">cgi-helper</span> = .py=python</span><br></pre></td></tr></table></figure><p>指定CGI根目录，以及对应的后缀文件的解析器。后面再修改Nginx配置即可。</p><hr><p>编写实例 CGI 脚本。使用其标准输出作为页面内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"Content-Type: text/html"</span>)</span><br><span class="line">print(<span class="string">""</span>)</span><br><span class="line">print(<span class="string">"&lt;html&gt;"</span>)</span><br><span class="line">print(<span class="string">"&lt;h2&gt;First CGI server Base on Docker&lt;/h2&gt;"</span>)</span><br><span class="line">print(<span class="string">"&lt;p&gt;Hello ann&lt;/p&gt;"</span>)</span><br><span class="line">print(<span class="string">"&lt;p&gt;cause you are my world XD&lt;/p&gt;"</span>)</span><br><span class="line">print(<span class="string">"&lt;/html&gt;"</span>)</span><br></pre></td></tr></table></figure><hr><p>至此，启动 <code>/usr/bin/supervisord</code> 便可以启动相关进程</p><blockquote><p>Supervisor (<span class="exturl" data-url="aHR0cDovL3N1cGVydmlzb3JkLm9yZy8=" title="http://supervisord.org/">http://supervisord.org<i class="fa fa-external-link"></i></span>) 是一个用 Python 写的进程管理工具，可以很方便的用来启动、重启、关闭进程（不仅仅是 Python 进程）。除了对单个进程的控制，还可以同时启动、关闭多个进程，比如很不幸的服务器出问题导致所有应用程序都被杀死，此时可以用 supervisor 同时启动所有应用程序而不是一个一个地敲命令启动。</p></blockquote><p>在客户端使用 浏览器请求便可以得到返回结果</p><hr><h2 id="Post-文件以及编译执行"><a href="#Post-文件以及编译执行" class="headerlink" title="Post 文件以及编译执行"></a>Post 文件以及编译执行</h2><p>前面实现了一个简单的CGI, 后面开始完善整个功能，实现文件的POST 上传以及在线的编译。</p><p>先需要对 Nginx 配置进行修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root /app/html;# 这里是页面的目录</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /cgi-bin &#123;</span><br><span class="line">        root /app/cgi-bin;# cgi 的目录</span><br><span class="line">        include uwsgi_params;</span><br><span class="line">uwsgi_modifier1 9;</span><br><span class="line">        uwsgi_pass unix:///tmp/uwsgi.sock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启 Nginx 的服务，使其配置生效，测试 页面 以及 CGI 脚本。</p><p>这里先构建文件的上传入口，简易的上传 页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>update<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>UploadPoint<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"upload-form"</span> <span class="attr">action</span>=<span class="string">"/cgi-bin/upload.py"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span> &gt;</span></span><br><span class="line">        　　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"upload"</span> <span class="attr">name</span>=<span class="string">"upload"</span> /&gt;</span> <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">        　　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Upload"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以及后端的实现文件保存以及编译的功能</p><p>下面是CGI代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> cgi, cgitb </span><br><span class="line"></span><br><span class="line">form = cgi.FieldStorage() </span><br><span class="line">fileitem = form[<span class="string">'upload'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> fileitem.filename:</span><br><span class="line">    print(<span class="string">"Content-type:text/html"</span>)</span><br><span class="line">    print()</span><br><span class="line">    print(<span class="string">"&lt;html&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;head&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;meta charset=\"utf-8\"&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;title&gt;succeed&lt;/title&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;/head&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;body&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;h2&gt; 输入的内容是：%s&lt;/h2&gt;"</span>)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'tmpfile/'</span> + fileitem.filename, <span class="string">'wb+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(fileitem.file.read())</span><br><span class="line">        print(<span class="string">'&lt;p&gt;文件已保存&lt;/p&gt;'</span>)</span><br><span class="line">    print(<span class="string">"&lt;/body&gt;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    text_content = <span class="string">"没有内容"</span></span><br><span class="line">    print(<span class="string">"Content-type:text/html"</span>)</span><br><span class="line">    print()</span><br><span class="line">    print(<span class="string">"&lt;html&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;head&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;meta charset=\"utf-8\"&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;title&gt;failed&lt;/title&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;/head&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;body&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;h2&gt; 输入的内容是：%s&lt;/h2&gt;"</span> % text_content)</span><br><span class="line">    print(<span class="string">"&lt;/body&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;/html&gt;"</span>)</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly91d3NnaS1kb2NzLXpoLnJlYWR0aGVkb2NzLmlvL3poX0NOL2xhdGVzdC9DR0kuaHRtbA==" title="https://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/CGI.html">在uWSGI上运行CGI脚本<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xpeWFuZ2xpYW5nLm1lL3Bvc3RzLzIwMTUvMDYvdXNpbmctc3VwZXJ2aXNvci8=" title="http://liyangliang.me/posts/2015/06/using-supervisor/">使用 supervisor 管理进程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9yL3RpYW5nb2xvL3V3c2dpLW5naW54" title="https://hub.docker.com/r/tiangolo/uwsgi-nginx">镜像地址 tiangolo/uwsgi-nginx<i class="fa fa-external-link"></i></span></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;这篇，是一个Docker 的实战篇，使用Docker实现一个文件上传的web页面。ps：本来是要实现上传后自动编译并且允许返回结果的。因为各种原因就
      
    
    </summary>
    
      <category term="OP之路" scheme="https://blog.diglp.xyz/categories/OP%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Docker" scheme="https://blog.diglp.xyz/tags/Docker/"/>
    
      <category term="CGI" scheme="https://blog.diglp.xyz/tags/CGI/"/>
    
  </entry>
  
  <entry>
    <title>读本好书 《Docker 进阶与实践》</title>
    <link href="https://blog.diglp.xyz/2018/12/31/Book_Docker%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>https://blog.diglp.xyz/2018/12/31/Book_Docker进阶与实践/</id>
    <published>2018-12-30T16:00:00.000Z</published>
    <updated>2019-03-04T11:57:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>书名：Docker 进阶与实践</li><li>作者：华为Docker实践小组</li><li>ISBN：9787111523390</li></ul><hr><p>这本书作为一个 对 Docker 的系统的学习和了解，由理论到实践，讲解了Docker 技术，以及其应用。</p><p>粗浅阅读，作为对Docker 了解，准备一个简单的project。（在线编译器？）</p><h2 id="Docker-简介"><a href="#Docker-简介" class="headerlink" title="Docker 简介"></a>Docker 简介</h2><p>其核心的思想是 ： <strong>Build Ship and Run</strong>。 </p><p>在磁盘占用，性能以及效率都在传统的虚拟化技术上有了明显的提高。</p><ul><li><p>Docker 之于传统的虚拟化技术是没有 Hypervisor 层。</p></li><li><p>Docker 使用了层级镜像的应用，可以实现存储空间的复用。</p></li></ul><hr><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ul><li><p>Docker 客户端</p><p>使用 command 发起请求，或者使用 RESTful API 进行请求</p></li><li><p>Docker deamon</p><p>整个Docker 的核芯引擎，可以理解为 Docker Server。</p></li><li><p>Docker 容器</p><p>容器是一个核心内容，很好的诠释了集装箱的概念，可以实现一个标准隔离执行环境。</p><p>迁移和部署的时候，不用关心容器里面是装了什么，也不需要了解是怎么配置。整个就是一个一切完整的集装箱。 </p></li><li><p>Docker 镜像</p><p>可以理解为 容器是镜像的实例， 镜像是容器的模板。</p></li><li><p>Registry</p><p>可以理解为镜像站点，可以直接使用 pull 从其拉去镜像。</p></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在内核编译的阶段，需要开启 <code>Cgroup</code> 以及 <code>Namespace</code>的编译选项。</p><h3 id="Docker-的基本使用"><a href="#Docker-的基本使用" class="headerlink" title="Docker 的基本使用"></a>Docker 的基本使用</h3><p>直接键入docker 会得到其提示页面， 使用 <code>docker COMMAND --help</code>可以直接显示相关的帮助页面</p><h2 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h2><p>在社区的合作下形成了Cgroup 以及 namespace 。</p><ul><li>Mount Namespace</li><li>UTS Namespace</li><li>IPC Namespace</li><li>PID Namespace</li><li>Net Namespace</li><li>User Namespace</li></ul><hr><p>Cgroup :</p><ul><li>cpuset</li><li>CPU</li><li>memory</li><li>device</li><li>freezer</li><li>blkio</li></ul><hr><h3 id="容器组成"><a href="#容器组成" class="headerlink" title="容器组成"></a>容器组成</h3><p>容器技术通过 Cgroup 和 Namespace 为核心技术。在其基础上由了根文件系统，以及容器引擎。书中有以下公式：</p><blockquote><p><code>容器 = cgroup + namespace + rootfs + 容器引擎(用户态工具)</code></p></blockquote><ul><li>Cgroup: 资源控制</li><li>Namespace: 访问隔离</li><li>rootfs： 文件系统隔离</li><li>容器引擎: 生命周期控制</li></ul><h3 id="容器的创建"><a href="#容器的创建" class="headerlink" title="容器的创建"></a>容器的创建</h3><p>书中的这里使用了三段伪代码，来说明一个容器的构成，这里说下自己的理解。</p><ol><li><p>通过系统的clone调用，来传入各个的Namespace的Clone flag，对其命名空间进行拷贝 ，之后得到一个新的进程，这个进程就会拥有一个属于自己的 clone 的Namespace。</p></li><li><p><code>echo $pid &gt; /sys/fs/cgroup/cpu/tesks</code> 建立的进程的PID 写入了各个 Cgroup的子系统之中，受到相应的Cgroup的子系统控制。</p></li><li>通过 系统调用，使得进程可以进入一个 新的 rootfs ，之后使用 <code>exec(&quot;/bin/bash&quot;)</code> 来启动一个 shell。</li></ol><p>这样就完成了一个容器的创建</p><hr><h3 id="Cgroup"><a href="#Cgroup" class="headerlink" title="Cgroup"></a>Cgroup</h3><p><strong>Cgroup 的目的就是实现了对与系统资源的<code>QoS</code></strong></p><p>在CG 之前，通过 sched_setaffinity 设定一个进程的CPU 亲和性（nginx中的配置）。</p><blockquote><p><code>$$</code> 表示当前进程的PID</p></blockquote><p>用户可以甚至可以新建自己的 Cgroup的规则，系统默认的规则在 <code>/sys/fs/cgroup</code> 下面进行配置</p><p>对进程配置生效，只需要将pid 写入以下文件 ： <code>/sys/fs/cgroup/pids</code>  这样是整个的 Cgroup 规则对当前进程生效。</p><p>或者，可以直接配置独立项目里面的 xxx.procs 。</p><p>blkio子系统        可以对块设备的I/O带宽进行限制。</p><p>devices子系统     可以对设备的权限进行控制 <code>a *.* rmw</code> 代表所有设备可被访问 <code>c 1:3 r</code> 控制 主设备号:子设备号设备 只读</p><h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><p>将内核的全局资源做封装，每一个NS 都有其独立的资源拷贝。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll /proc/$$/ns</span><br></pre></td></tr></table></figure><p>查看当前的进程的namespace。</p><p>可以很容易的使用 系统调用建立一个独立的namespace的进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> <span class="built_in">stack</span>[STACK_SIZE];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* <span class="keyword">const</span> child_args[] = &#123;<span class="string">"/bin/bash"</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">child</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  execv(<span class="string">"/bin/bash"</span>, child_args);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  pid = clone(child, <span class="built_in">stack</span>+STACK_SIZE, SIGCHLD|CLONE_NEWUTS, <span class="literal">NULL</span>);<span class="comment">// 这里配置克隆命名空间的操作</span></span><br><span class="line">  waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接 GCC 编译， 在返回的SHELL 里，对hostname 进行修改 ，logout 之后，原shell中的hostname并没有被改变。</p><p>如前面提到的，namespace 有几个种类，</p><table><thead><tr><th>type</th><th>desc</th></tr></thead><tbody><tr><td>UTS</td><td>struct utsname ，uname 系统调用里面的结构体</td></tr><tr><td>IPC</td><td>进程间通信的隔离，如消息队列？ ipcmk</td></tr><tr><td>PID</td><td>PID 之间的隔离，（ps从procfs里读取），实际上的操作是隔离的，如kill</td></tr><tr><td>Mount</td><td>挂载点隔离</td></tr><tr><td>Network</td><td>网络接口隔离</td></tr><tr><td>User</td><td>用户以及用户权限隔离</td></tr></tbody></table><h2 id="Docker-的镜像"><a href="#Docker-的镜像" class="headerlink" title="Docker 的镜像"></a>Docker 的镜像</h2><p>image是启动容器的只读模板，是容器启动需要的rootfs。下面是一些 词汇：</p><table><thead><tr><th>word</th><th>meaning</th></tr></thead><tbody><tr><td>doker hub</td><td>可以理解为一个镜像站</td></tr><tr><td>Namespace</td><td>类似 Github 中的命名空间，代表一个种类，用户或组织</td></tr><tr><td>Repository</td><td>一个 Git 仓库，可以有多个镜像</td></tr><tr><td>Tag</td><td>类似Git 的tag，区别于不同的版本</td></tr><tr><td>Layer</td><td>类似于Git的 <strong>commit</strong> ，一个长的 Hash 串</td></tr><tr><td>Image ID</td><td>镜像的唯一标识，可以等同 repo:tag</td></tr></tbody></table><p>后面的部分简述了，<strong>build，ship and run </strong> 的操作。</p><hr><p>Docker 的image的组织结构，颗粒理解为积木堆叠的形式。书中对其源文件做了探索：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull busybox# 拉取镜像</span><br><span class="line">docker history busybox# 查看镜像的历史版本</span><br><span class="line">docker inspect busybox:latest</span><br></pre></td></tr></table></figure><hr><h3 id="Docker-image-的技术亮点"><a href="#Docker-image-的技术亮点" class="headerlink" title="Docker image 的技术亮点"></a>Docker image 的技术亮点</h3><ul><li><p>联合挂载</p><p>可以把多个目录同时挂载到同一个目录。</p></li><li><p>写时复制</p><p>在和系统调用的 <code>fork</code>类似，在创建子进程的时候，并不进行新的一个内存区的复制，而是在修改了共享的内的时候触发了一次缺页的中断，这时候进行一次页分配。这时候才会有真正的写。</p></li></ul><h2 id="仓库进阶"><a href="#仓库进阶" class="headerlink" title="仓库进阶"></a>仓库进阶</h2><p>git 的思想， 可以很容易的进行 <code>pull/push</code></p><h2 id="容器间的网络"><a href="#容器间的网络" class="headerlink" title="容器间的网络"></a>容器间的网络</h2><p>这里是在实践过程中比较重要的一部分。过程较为复杂，这里记录一些 kword <code>Weave</code>，<code>Flannel</code>，这些是现有的Docker 的网络解决方案</p><ul><li>Weave</li><li>Flannel</li><li>SocketPlane</li></ul><h2 id="容器卷管理"><a href="#容器卷管理" class="headerlink" title="容器卷管理"></a>容器卷管理</h2><p>在执行 <code>run/create</code> 使用 <code>-v</code> 来添加数据卷 volume，当然也可以将主机上的卷挂载到 容器中来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -v /var/vol --name mytest busybox# 添加新的卷</span><br><span class="line">docker run -d -v /var/vol:/home/test --name mytest busybox# 挂载主机卷</span><br></pre></td></tr></table></figure><p>可以创建一个共有的存储容器，在其他的实例上使用 <code>--vloume-from</code> 来共享卷</p><hr><p>问题：数据卷的悬挂问题</p><p>在删除容器的时候，需要显式的指明所挂载的卷，分配卷的空间才会被删除，如果不指定，就会出现数据卷的悬挂（dangling），浪费大量空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rm mytest</span><br><span class="line">docker rm mytest -v /var/vol</span><br></pre></td></tr></table></figure><h2 id="Docker-API"><a href="#Docker-API" class="headerlink" title="Docker API"></a>Docker API</h2><p>Docker 的API 设计 满足 <strong>RESTful(Representational State Transfer)</strong> 表达性状态转移。其API 设计：清晰，简单，低耦合，无状态，面向资源。</p><p>Docker 提供了API接口，使得其拓展性得到极大的提高。有提供三类API：</p><ul><li>Docker Remote API    比如 docker run 这种服务控制的命令</li><li>Docker Registry API    可以用来控制镜像存储</li><li>Docker Hub API        与Docker 的关系不大</li></ul><hr><p>示例请求，Docker 在启动的时候，会默认开启API，并且监听本地的unix 套接字，默认值为 <code>unix:///var/run/docker.sock</code>，可以直接向套接字写内容从而实现了API的调用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里直接向套接字写了HTTP的请求，server 会直接返回了当前的所有的镜像的状态。</p><hr><p>当然，Docker 也会监听 <code>localhost:5678</code> 作为API 的请求端口，（之前有用过一个 GUI 的Docker的管理工具，其核心就是通过API与服务进行交互）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET localhost:5678/image/debian/history| python -m json.tool# 等同：</span><br><span class="line">docker history debian</span><br></pre></td></tr></table></figure><hr><p>Docker API 的监听在其启动的时候进行配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -d -H unix:///var/run/docker.sock -H tcp://localhost:32768</span><br></pre></td></tr></table></figure><hr><h3 id="API的应用场景"><a href="#API的应用场景" class="headerlink" title="API的应用场景"></a>API的应用场景</h3><p>书中在这里以神奇的背景展开了一个使用案例：</p><ul><li>一个python 写的httpserver</li><li>打包成一个 Docker 镜像<ul><li>Dockerfile 和其依赖的文件打压缩包</li><li>使用远程的Docker 主机对镜像进行构建】</li></ul></li><li>发布镜像到Registry pash</li><li>其他主机 Pull 到本地</li><li>本地运行容器实例并验证</li><li>至此完成一个docker 的helloworld。</li></ul><p>这里对这个场景进行简单的描述，后面将会有操作的实例。</p><h2 id="Docker-的安全"><a href="#Docker-的安全" class="headerlink" title="Docker 的安全"></a>Docker 的安全</h2><p>由于 Docker 和物理主机是公用同一个内核，因此受攻击的面将会特别的广，<strong>而且一旦容器内的程序导致了内核的panic，物理机的内核也将 Painc</strong></p><p>共用内核使用Cgroup和Namespace 实现了容器隔离和资源限制的目的。Namespace 目前不是十分完善。<strong>所以导致了虚拟容器中的逃逸问题</strong>，（比如 PS 使用的 procfs ，就可以看到物理机的所有的 ps）这个是特性导致，所以很难完美的处理。现在应用的安全策略：</p><ol><li>Cgroup    进行资源限制</li><li>ulimit    资源限制</li><li>容器组网    安全</li><li>容器+全虚拟化    公有云，安全需求很高的解决方案</li><li>监控    <code>docker ps -a</code> 监控容器状态</li><li>文件级防护    对文件的权限进行严格的控制</li><li>capability</li><li>SELinux    严格的DAC ，资助访问控制</li><li>AppArmor</li><li>Seccomp</li><li>grsecurity    内核的 patch 大大提高安全性</li></ol><h3 id="安全示例"><a href="#安全示例" class="headerlink" title="安全示例"></a>安全示例</h3><h4 id="主机逃逸"><a href="#主机逃逸" class="headerlink" title="主机逃逸"></a>主机逃逸</h4><p><strong>shocker攻击</strong> 通过 <code>open_by_handle_at</code> 和 <code>name_to_handle_at</code> 这两个系统调用实现。先在容器内打开一个文件描述符，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">"/.dockerinit"</span>, O_RDONLY);</span><br></pre></td></tr></table></figure><p>之后使用 <code>open_by_handle_at</code> 获取文件的句柄。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd = open_by_handle_at(bfd, (struct file_handle *)ih, O_RDONLY);</span><br><span class="line">dir = fdopendir(fd)</span><br></pre></td></tr></table></figure><p>并且在这里得到其打开的所有目录？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">de = readdir(dir);</span><br></pre></td></tr></table></figure><p>得到其目录的结构体，之后进行对比与 <code>/etc/shadow</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strncmp</span>(de-&gt;d_name, path, <span class="built_in">strlen</span>(de-&gt;d_name));</span><br></pre></td></tr></table></figure><p>找到了包含 shadow 的de目录之后，开始穷举句柄：</p><hr><p>后面略过部分的内容。讲解了Libcontainer 的一些技术原理。</p><h2 id="Docker-实践篇"><a href="#Docker-实践篇" class="headerlink" title="Docker 实践篇"></a>Docker 实践篇</h2><h3 id="Dockerfile-的hello-world"><a href="#Dockerfile-的hello-world" class="headerlink" title="Dockerfile 的hello world"></a>Dockerfile 的hello world</h3><p>Dockerfile 用来制作镜像，像是一个蓝图一样，</p><ul><li>以 # 为注释</li><li>每一行一个命令</li><li>四部分组成<ul><li>基础镜像信息</li><li>维护者信息</li><li>镜像操作指令</li><li>容器启动指令</li></ul></li></ul><p>书中给了一个 Nginx 的基础镜像的配置，这里进行cpoy：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">MAINTAINER</span> admin xxx</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"[软件源]"</span> &gt;&gt; /etc/apt/source.list<span class="comment"># 添加软件源</span></span></span><br><span class="line"><span class="bash">RUN apt-get update &amp;&amp; apt-get install -y nginx </span></span><br><span class="line"><span class="bash">RUN <span class="built_in">echo</span> <span class="string">"\ndeamon off"</span> &gt;&gt; /etc/nginx/nginx.conf<span class="comment"># 写配置前台运行</span></span></span><br><span class="line"><span class="bash">CMD /usr/sbin/nginx<span class="comment"># 启动服务</span></span></span><br></pre></td></tr></table></figure><hr><table><thead><tr><th>KeyWord</th><th>DESC</th></tr></thead><tbody><tr><td>FROM <image></image></td><td>继承自哪个镜像</td></tr><tr><td>MAINTAINER <name></name></td><td>指定维护者信息</td></tr><tr><td>RUN <command></td><td>执行SHELL指令，类似 <code>sh -c</code></td></tr><tr><td>EXPOSE</td><td>暴露容器端口</td></tr><tr><td>CMD</td><td>启动容器时执行的命令，<strong>只能有一条</strong></td></tr><tr><td>VOLUME</td><td>创建挂载点</td></tr><tr><td>ENV <key> <value></value></key></td><td>定义环境变量</td></tr><tr><td>ADD <src> <dest></dest></src></td><td>复制指定src(URL，tar，相对路径)的指定文件到目的卷</td></tr><tr><td>COPY \<src> \<dset></dset></src></td><td>复制本地主机的文件到容器的目</td></tr></tbody></table><hr><h3 id="Docker-镜像-的制作与启动"><a href="#Docker-镜像-的制作与启动" class="headerlink" title="Docker 镜像 的制作与启动"></a>Docker 镜像 的制作与启动</h3><p>书中给出了一个DockerFile 的示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> busybox</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> date;sleep 100;date</span></span><br><span class="line"><span class="bash">RUN <span class="built_in">echo</span> <span class="string">"abc"</span> &gt; /mytest</span></span><br><span class="line"><span class="bash">RUN date;sleep 100; date</span></span><br><span class="line"><span class="bash">CMD /bin/bash</span></span><br></pre></td></tr></table></figure><p>RUN 命令都是在容器内部执行的，最后的CMD为最后返回的内容。</p><p>在书中是以一个 Tomcat 的例子来演示的。这里主要设计到了镜像的拉去，以及 卷的 静态挂载，SSL 证书的生成。之后贼了容器内部，把 证书保存在 指定的目录，并且修改一下 server 的配置。</p><p>完成所有的配置之后，直接进行一次 commit。之后 跑容器实例即可。</p><p><strong>源码导入</strong> 使用静态导入以及动态导入两种方式。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> tomecat:https</span><br><span class="line"><span class="keyword">MAINTAINER</span> xxx</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./websrc /usr/<span class="built_in">local</span>/tomecat/webapps/myproj</span></span><br></pre></td></tr></table></figure><p><strong>动态挂载</strong> 把本地的数据卷挂载在容器中，现在船舰一个挂载点，把文件动态挂载到容器中。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> tomcat:http</span><br><span class="line"><span class="keyword">MAINTAINER</span> xxx </span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /usr/<span class="built_in">local</span>/tomcat/webapps/myproj</span></span><br><span class="line"><span class="bash">VOLUME /usr/<span class="built_in">local</span>/tomcat/webapps/myproj</span></span><br></pre></td></tr></table></figure><p>在启动容器的时候指定参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti -v $(pwd)/websrc:/usr/local/tomcat/webapps/myproj</span><br></pre></td></tr></table></figure><hr><h3 id="Docker-的架构"><a href="#Docker-的架构" class="headerlink" title="Docker 的架构"></a>Docker 的架构</h3><p>微服务之核心就在于此,把服务的多个部分以容器的形式，分散在各处。比如实现一个 web服务架构，除了上面的web服务器之外，还有后端的数据库，或者是 一些其他的模块。</p><p><strong>Docker-compose</strong>  提供了一个Docker 的工程的管理，可以实现对多个容器的构成一个项目的整合。</p><h2 id="Docker-的集群管理"><a href="#Docker-的集群管理" class="headerlink" title="Docker 的集群管理"></a>Docker 的集群管理</h2><p>在生产环境的使用的时候，当然是需要进行统一管理的。这里在书中就引入了几个工具：</p><h3 id="Compose"><a href="#Compose" class="headerlink" title="Compose"></a>Compose</h3><blockquote><p>一个应用往往有多个组件构成，Docker 的最佳实践是一个容器运行一个进程</p></blockquote><p>所以为了实现容器之间的同意管理，以及协作工作，这里就有了 Compose 。</p><h3 id="Machine"><a href="#Machine" class="headerlink" title="Machine"></a>Machine</h3><p>简化Docker 安装的工具</p><h3 id="Swarm"><a href="#Swarm" class="headerlink" title="Swarm"></a>Swarm</h3><p>集群管理工具，实现把多个Docker主机组成的系统，整合为统一的虚拟Docker 主机。</p><blockquote><p>swap,plug and play</p></blockquote><hr><p><strong>K8S</strong></p><h2 id="FAQ（Frequently-asked-questions-）"><a href="#FAQ（Frequently-asked-questions-）" class="headerlink" title="FAQ（Frequently asked questions ）"></a>FAQ（<em>Frequently asked questions</em> ）</h2><p>书后面的 FAQ，这里挑选部分摘录：</p><ul><li>Docker 容器中管理多个进程<ul><li>使用 <code>supervisord,runit</code>等进行进程的统一管理，保持管理进程工作即可</li></ul></li><li>ATTACH 到容器之后怎么退出<ul><li>操作和 <code>screen</code> 有些类似使用 <code>ctrl+P，ctrl+Q</code> 进行退出，容器继续进行，如果使用 <code>ctrl+c</code> 可能导致进程结束从而容器退出</li></ul></li></ul><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><p>通过这本书，对Docker 的认识，和使用更上了一个台阶，后面准备实现一个 基于Docker 的在线编译执行的东西。</p><p>基础构想是 使用 Nginx 跑 Python的CGI，post 源码，之后编译执行，再返回前端，把这个打包成镜像</p><p>下一步就是把服务拆开，单容器单进程，把 nginx 和 uwsgi 拆分开来，使用多容器合作。</p><p>后面看看 Docker 的源码吧。</p><p>书后推荐书籍：    </p><ul><li>Docker 技术入门与实践    9787111488521</li><li>Docker 源码分析            9787111510727</li><li>Linux 内核设计与实现        </li><li>Linux 内核精髓</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;书
      
    
    </summary>
    
      <category term="读本好书吧" scheme="https://blog.diglp.xyz/categories/%E8%AF%BB%E6%9C%AC%E5%A5%BD%E4%B9%A6%E5%90%A7/"/>
    
    
      <category term="读书笔记" scheme="https://blog.diglp.xyz/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="信息安全" scheme="https://blog.diglp.xyz/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
</feed>
